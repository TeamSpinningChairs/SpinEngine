#include "Precompiled.h"
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	Any::Any() :
		StoredType(nullptr)
	{
		ZilchErrorIfNotStarted(Any);

		// Memset the area to empty, so any handles or primitives we store won't get messed up by exceptions
		memset(this->Data, 0, sizeof(this->Data));
	}

	//***************************************************************************
	Any::Any(Type* type)
	{
		ZilchErrorIfNotStarted(Any);

		// Get how big the copyable size of the object is (size of a handle, or the entire value size)
		size_t copyableSize = type->GetCopyableSize();

		// Allocate room to store this type (may store locally and not actually allocate)
		byte* destination = this->AllocateData(copyableSize);

		// Store the type and default construct the data into us
		this->StoredType = type;
		type->GenericDefaultConstruct(destination);
	}

	//***************************************************************************
	Any::Any(const byte* data, Type* type)
	{
		ZilchErrorIfNotStarted(Any);

		// Get how big the copyable size of the object is (size of a handle, or the entire value size)
		size_t copyableSize = type->GetCopyableSize();

		// Allocate room to store this type (may store locally and not actually allocate)
		byte* destination = this->AllocateData(copyableSize);

		// Store the type and copy construct the data into us
		this->StoredType = type;
		type->GenericCopyConstruct(destination, data);
	}

	//***************************************************************************
	Any::Any(const Any& other)
	{
		// Change the stored type to their same type
		this->StoredType = other.StoredType;

		// If we're copying from an any that actually contains data...
		if (this->StoredType != nullptr)
		{
			// Get how big the copyable size of the object is (size of a handle, or the entire value size)
			size_t copyableSize = this->StoredType->GetCopyableSize();

			// Allocate room to store this type (may store locally and not actually allocate)
			byte* destination = this->AllocateData(copyableSize);

			// Copy the right hand data into our data
			this->StoredType->GenericCopyConstruct(destination, other.GetData());
		}
		else
		{
			// Memset the area to empty, so any handles or primitives we store won't get messed up by exceptions
			memset(this->Data, 0, sizeof(this->Data));
		}
	}

	//***************************************************************************
	Any::~Any()
	{
		// Clear the any, even though it's a bit redundant (could be optimized)
		this->Clear();
	}

	//***************************************************************************
	byte* Any::AllocateData(size_t size)
	{
		// We assume that the size of the object will fit within our data section
		byte* result = this->Data;

		// If the type is bigger then we can store... (note than storing an 'any' inside an 'any' will always hit this case!)
		if (size > sizeof(this->Data))
		{
			// Allocate memory to store the data
			result = new byte[size];

			// Store a pointer to our allocation inside the data field
			*((byte**)this->Data) = result;
		}

		// Return data that will be large enough to store the object
		return result;
	}

	//***************************************************************************
	const byte* Any::GetData() const
	{
		// Get the size of the handle, delegate, or entire value type (copyable size)
		size_t copyableSize = this->StoredType->GetCopyableSize();

		// If the type is bigger then we can store... (note than storing an 'any' inside an 'any' will always hit this case!)
		if (copyableSize > sizeof(this->Data))
		{
			// The size of the object was large, which meant we must be storing it by pointer instead
			return *((byte**)this->Data);
		}

		// Otherwise, it was small enough so we just stored it in our fixed data field
		return this->Data;
	}

	//***************************************************************************
	void Any::Clear()
	{
		// If we're storing anything...
		if (this->StoredType != nullptr)
		{
			// Get the size of the handle, delegate, or entire value type (copyable size)
			size_t copyableSize = this->StoredType->GetCopyableSize();

			// Memory that we need to free
			byte* toBeDeleted = nullptr;

			// Where we store the memory that needs to be destructed (via GenericDestruct)
			byte* data = this->Data;

			// If the type is bigger then we can store... (note than storing an 'any' inside an 'any' will always hit this case!)
			if (copyableSize > sizeof(this->Data))
			{
				// The size of the object was large, which meant we must be storing it by pointer instead
				data = *((byte**)this->Data);

				// Since we're clearing, we also want to free the data
				toBeDeleted = data;
			}

			// Generically destruct the data we store first
			this->StoredType->GenericDestruct(data);

			// Delete the memory (could be null!)
			delete[] toBeDeleted;

			// Memset the area to empty, so any handles or primitives we store won't get messed up by exceptions
			memset(this->Data, 0, sizeof(this->Data));

			// Clear the stored type
			this->StoredType = nullptr;
		}
	}

	//***************************************************************************
	Any& Any::operator=(const Any& other)
	{
		// Avoid self assignment
		if (this == &other)
			return *this;

		// Clear ourself out, which destructs any data we were storing
		this->Clear();

		// Change the stored type to their same type
		this->StoredType = other.StoredType;

		// If we're copying from an any that actually contains data...
		if (this->StoredType != nullptr)
		{
			// Get how big the copyable size of the object is (size of a handle, or the entire value size)
			size_t copyableSize = this->StoredType->GetCopyableSize();

			// Allocate room to store this type (may store locally and not actually allocate)
			byte* destination = this->AllocateData(copyableSize);

			// Copy the right hand data into our data
			this->StoredType->GenericCopyConstruct(destination, other.GetData());
		}

		// Return ourself for chaining... which I don't like ;)
		return *this;
	}

	//***************************************************************************
	bool Any::operator==(const Any& rhs) const
	{
		// The types must compare the same for the values to be the same
		// Remember that the types stored are the MOST derived type in terms of inheritance
		// Example:
		// var derviedClass = new Cat();
		// var baseClass : Animal = derviedClass;
		// var any : Any = baseClass;
		// The 'StoredType' in Any will be 'Cat', not 'Animal' (most derived)
		if (this->StoredType != rhs.StoredType)
			return false;

		// If the types are both null, return true (we already know they are the same based on the above check)
		if (this->StoredType == nullptr)
			return true;

		// Generically compare the type with each other (we know they are the same type!)
		return this->StoredType->GenericEquals(this->GetData(), rhs.GetData());
	}

	//***************************************************************************
	bool Any::operator!=(const Any& rhs) const
	{
		// Just invert the comparison
		return !((*this) == rhs);
	}

	//***************************************************************************
	int Any::Hash() const
	{
		// The hash of an empty any is always 0
		if (this->StoredType == nullptr)
			return 0;

		// Generically hash our stored value
		return this->StoredType->GenericHash(this->GetData());
	}

	//***************************************************************************
	String Any::ToString() const
	{
		// Return an empty string if we store nothing
		static String EmptyString("<empty>");
		if (this->StoredType == nullptr)
			return EmptyString;

		// Generically stringify our stored value
		return this->StoredType->GenericToString(this->GetData());
	}

	//***************************************************************************
	void Any::AssignFrom(const byte* data, Type* type)
	{
		ErrorIf(type == nullptr, "Cannot assign the 'Any' to a null type, use Clear instead");

		// Avoid self assignment
		if (this->GetData() == data)
			return;

		// Clear ourself out, which destructs any data we were storing
		this->Clear();

		// Get the copyable size (size of the handle, deleget, or value type, etc)
		size_t copyableSize = type->GetCopyableSize();

		// Allocate room to store this type (may store locally and not actually allocate)
		byte* destination = this->AllocateData(copyableSize);

		// Copy the right hand data into our data
		type->GenericCopyConstruct(destination, data);

		// Change the stored type to their same type
		this->StoredType = type;
	}

	//***************************************************************************
	void Any::DefaultConstruct(Type* type)
	{
		ErrorIf(type == nullptr, "Cannot assign the 'Any' to a null type, use Clear instead");

		// Destruct any memory we are currently holding
		this->Clear();

		// Change the stored type to their same type
		this->StoredType = type;

		// Get the copyable size (size of the handle, deleget, or value type, etc)
		size_t copyableSize = type->GetCopyableSize();

		// Allocate room to store this type (may store locally and not actually allocate)
		byte* destination = this->AllocateData(copyableSize);

		// Default construct the value into our data
		// Typically makes handles null, delegates null, and value types cleared to 0
		this->StoredType->GenericDefaultConstruct(destination);
	}

	//***************************************************************************
	void Any::CopyStoredValueTo(byte* to) const
	{
		ErrorIf(this->StoredType == nullptr, "The any does not contain a type!");

		// Get the size of the handle, delegate, or entire value type (copyable size)
		size_t copyableSize = this->StoredType->GetCopyableSize();

		// Where we store the memory that needs to be copied from
		const byte* data = this->GetData();

		// Generically copy the stored value
		this->StoredType->GenericCopyConstruct(to, data);
	}

	//***************************************************************************
	template <>
	Any CopyToAnyOrActualType<Any>(byte* data, Type* dataType)
	{
		// If no data was provided, then default construct the type into the any
		if (data == nullptr)
			return Any(dataType);

		// Construct the any from the given data
		return Any(data, dataType);
	}

	//***************************************************************************
	template <>
	void CopyFromAnyOrActualType<Any>(const Any& any, byte* to)
	{
		// Generically copy the contained type to the destination
		any.CopyStoredValueTo(to);
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	// Unfortunately because there's some sort of bug in the MSVC linker, we have to make a bunch of non-inlined comparison functions
	ZilchNoInline bool LinkerEquals(Boolean         a, Boolean          b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Boolean2Param   a, Boolean2Param    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Boolean3Param   a, Boolean3Param    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Boolean4Param   a, Boolean4Param    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Integer         a, Integer          b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Integer2Param   a, Integer2Param    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Integer3Param   a, Integer3Param    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Integer4Param   a, Integer4Param    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Real            a, Real             b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Real2Param      a, Real2Param       b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Real3Param      a, Real3Param       b) { return a == b; }
	ZilchNoInline bool LinkerEquals(Real4Param      a, Real4Param       b) { return a == b; }
	ZilchNoInline bool LinkerEquals(QuaternionParam a, QuaternionParam  b) { return a == b; }
	ZilchNoInline bool LinkerEquals(DoubleInteger   a, DoubleInteger    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(DoubleReal      a, DoubleReal       b) { return a == b; }
	ZilchNoInline bool LinkerEquals(const Handle&   a, const Handle&    b) { return a == b; }
	ZilchNoInline bool LinkerEquals(const Delegate& a, const Delegate&  b) { return a == b; }
	ZilchNoInline bool LinkerEquals(const Any&      a, const Any&       b) { return a == b; }

	//***************************************************************************
	// For every instantiated array, it may want to look up information about what it contains
	class ArrayUserData
	{
	public:
		ArrayUserData() :
			ContainedType(nullptr),
			RangeType(nullptr),
			SelfType(nullptr)
		{
		}

		Type* ContainedType;
		BoundType* RangeType;
		BoundType* SelfType;
	};

	//***************************************************************************
	// Forward declaration of the range template
	template <typename T>
	class ArrayRangeTemplate;

	//***************************************************************************
	// The template layout we use for arrays
	// As an optimization, the array can be instantiated for some known data types
	// For all other unknown types (such as structs created in Zilch) we use the 'Any' type
	template <typename T>
	class ArrayTemplate
	{
	public:
		// Constructor
		ArrayTemplate() :
			ModifyId(0)
		{
		}

		// Our array is actually just an array of Any types
		// but for arrays of primitive/built in types, it will be optimized
		Array<T> NativeArray;

		// Get the number of elements in the array
		Integer GetCount()
		{
			return (Integer)this->NativeArray.size();
		}

		// Increment ModifyId invalidating all active ranges
		void Modified()
		{
			++this->ModifyId;
		}

		// A special counter that we use to denote whenever the container has been modified
		Integer ModifyId;

		//***************************************************************************
		static String ArrayToString(const BoundType* type, const byte* data)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = type->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Create a string builder to generate the array entries
			StringBuilder builder;
			builder.Append(Grammar::GetKeywordOrSymbol(Grammar::BeginInitializer));

			// Grab the generic data as our own self template
			ArrayTemplate* self = (ArrayTemplate*)data;

			// Loop through all entries in the array
			for (size_t i = 0; i < self->NativeArray.size(); ++i)
			{
				// Get a pointer to to the value at the given index (as a byte*)
				byte* valuePointer = (byte*)&self->NativeArray[i];

				// Convert that value to a string generically
				String valueString = userData.ContainedType->GenericToString(valuePointer);

				// Append the stringified value to the builder
				builder.Append(valueString);

				// If we're not the last element, add a comma (argument separator) and a space
				bool isNotLastItem = (self->NativeArray.size() - 1 != i);
				if (isNotLastItem)
				{
					builder.Append(Grammar::GetKeywordOrSymbol(Grammar::ArgumentSeparator));
					builder.Append(" ");
				}
			}

			builder.Append(Grammar::GetKeywordOrSymbol(Grammar::EndInitializer));

			String result = builder.ToString();
			return result;
		}

		//***************************************************************************
		// Store 'Any' value as return value
		static void ArrayCopyReturnValue(Call& call, const T& value)
		{
			// Get a pointer to the return value data (on the stack)
			byte* returnValue = call.GetReturnUnchecked();
			call.DisableReturnChecks();

			// Generically copy the contained type to the return value
			CopyFromAnyOrActualType<T>(value, returnValue);
		}

		//***************************************************************************
		static T ArrayReadValue(Call& call, ArrayTemplate* self, Integer parameter)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Get the value
			byte* valueData = call.GetParameterUnchecked(parameter);

			// Grab the data out generically (if this is an Any type, we handle that properly)
			return CopyToAnyOrActualType<T>(valueData, userData.ContainedType);
		}

		//***************************************************************************
		static void ArrayGet(Call& call, ExceptionReport& report)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Read the array index
			Integer index = call.Get<Integer>(0);

			// Check the array index
			if (index < 0 || index >= self->GetCount())
			{
				call.GetState()->ThrowException(report, "Array index was out of bounds");
				return;
			}

			// Return the value
			ArrayCopyReturnValue(call, self->NativeArray[index]);
		}

		//***************************************************************************
		static void ArraySet(Call& call, ExceptionReport& report)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Read the array index
			Integer index = call.Get<Integer>(0);

			// Check the array index
			if (index < 0 || index >= self->GetCount())
			{
				call.GetState()->ThrowException(report, "Array index was out of bounds");
				return;
			}

			// Place in array
			self->NativeArray[index] = ArrayReadValue(call, self, 1);
			self->Modified();
		}

		//***************************************************************************
		static void ArrayAdd(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Place in array
			self->NativeArray.push_back(ArrayReadValue(call, self, 0));
			self->Modified();
		}

		//***************************************************************************
		static void ArrayInsert(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Read the array index
			Integer index = call.Get<Integer>(0);

			// Check the array index
			if (index < 0 || index >= self->GetCount())
			{
				call.GetState()->ThrowException(report, "Array index was out of bounds");
				return;
			}

			// Place in array
			self->NativeArray.insertAt(index, ArrayReadValue(call, self, 1));
			self->Modified();
		}

		//***************************************************************************
		static void ArrayPop(Call& call, ExceptionReport& report)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Check that the array has elements
			if (self->GetCount() == 0)
			{
				call.GetState()->ThrowException(report, "Cannot pop from an empty array");
				return;
			}

			// This function returns the popped value so copy it to return value before removal
			ArrayCopyReturnValue(call, self->NativeArray.back());

			//  Remove the element
			self->NativeArray.pop_back();
			self->Modified();
		}

		//***************************************************************************
		static void ArrayRemoveAt(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Get the index we're trying to remove at
			Integer index = call.Get<Integer>(0);

			// Check the array index
			if (index < 0 || index >= self->GetCount())
			{
				call.GetState()->ThrowException(report, "Array index was out of bounds");
				return;
			}

			// Erase the value
			self->NativeArray.eraseAt(index);
			self->Modified();
		}

		//***************************************************************************
		static void ArrayRemoveSwap(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Get the index we're trying to remove at
			Integer index = call.Get<Integer>(0);

			// Check the array index
			if (index < 0 || index >= self->GetCount())
			{
				call.GetState()->ThrowException(report, "Array index was out of bounds");
				return;
			}

			RemoveSwap(self->NativeArray, index);
			self->Modified();
		}

		//***************************************************************************
		static void ArrayClear(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			self->NativeArray.clear();
			self->Modified();
		}

		//***************************************************************************
		static void ArrayCopy(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Create the new array
			Handle arrayHandle = call.GetState()->AllocateDefaultConstructedHeapObject(userData.SelfType, report, HeapFlags::ReferenceCounted);

			// If we threw an exception, we need to early out and let the stack unroll
			if (report.HasThrownExceptions())
				return;

			// Get pointer to the new array
			ArrayTemplate* newArray = (ArrayTemplate*)arrayHandle.Dereference();

			// Copy array data
			newArray->NativeArray = self->NativeArray;

			// Write out the count
			call.SetHandle(Call::Return, arrayHandle);
		}

		//***************************************************************************
		static void ArrayCount(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Write out the count
			call.Set(Call::Return, self->GetCount());
		}

		//***************************************************************************
		static void ArrayCapacity(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Write out the capacity
			call.Set(Call::Return, (Integer)self->NativeArray.capacity());
		}

		//***************************************************************************
		static void ArrayReserve(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Get the first argument, capacity
			Integer capacity = call.Get<Integer>(0);

			// Reserve space on the array (setting to anything smaller than the current capacity is ignored)
			self->NativeArray.reserve(capacity);
		}

		//***************************************************************************
		static void ArrayResizeHelper(Call& call, ExceptionReport& report, byte* defaultValue)
		{
			// Get the user data, because we need to know the template types
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Get the new size of the array (first argument)
			Integer newSize = call.Get<Integer>(0);

			// If the user attempted to pass in a negative value...
			if (newSize < 0)
			{
				call.GetState()->ThrowException(report, "Cannot resize the array to a negative size");
				return;
			}

			// Reserve space on the array (setting to anything smaller than the current capacity is ignored)
			// Normally we'd like to just invoke 'resize', however because this is an array of any types,
			// each element needs to be default constructed to the contained value type
			if (newSize > self->GetCount())
			{
				// First start by reserving space
				self->NativeArray.reserve((size_t)newSize);

				// Loop until we've filled the array
				while (self->GetCount() < newSize)
				{
					// Add each element one by one and construct it to be the element type
					T& element = self->NativeArray.push_back();

					// If no default value was provided, use default construction (otherwise use the given default value)
					element = CopyToAnyOrActualType<T>(defaultValue, userData.ContainedType);
				}
			}
			else
			{
				// Just resize the array, this will auto destruct elements
				self->NativeArray.resize((size_t)newSize);
			}
		}

		//***************************************************************************
		static void ArrayResizeConstructorHelper(Call& call, ExceptionReport& report, byte* defaultValue)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Get ourselves (the array)
			byte* memory = call.GetHandle(Call::This).Dereference();

			// Construct the array
			ArrayTemplate* self = new (memory)ArrayTemplate();

			// Resize with no default value
			ArrayResizeHelper(call, report, defaultValue);
		}

		//***************************************************************************
		static void ArrayConstructorResize(Call& call, ExceptionReport& report)
		{
			// Construct the array and resize the number of elements, with no default value
			ArrayResizeConstructorHelper(call, report, nullptr);
		}

		//***************************************************************************
		static void ArrayConstructorResizeDefault(Call& call, ExceptionReport& report)
		{
			// The second argument should be the default value we'd like to initialize elements with
			byte* defaultValue = call.GetParameterUnchecked(1);

			// Construct the array and resize the number of elements, with no default value
			ArrayResizeConstructorHelper(call, report, defaultValue);
		}

		//***************************************************************************
		static void ArrayResize(Call& call, ExceptionReport& report)
		{
			// Resize with no default value
			ArrayResizeHelper(call, report, nullptr);
		}

		//***************************************************************************
		static void ArrayResizeDefault(Call& call, ExceptionReport& report)
		{
			// The second argument should be the default value we'd like to initialize elements with
			byte* defaultValue = call.GetParameterUnchecked(1);

			// Resize with the given default value
			ArrayResizeHelper(call, report, defaultValue);
		}

		//***************************************************************************
		static void ArrayLastIndex(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Write out the count
			call.Set(Call::Return, self->GetCount() - 1);
		}

		//***************************************************************************
		static void ArrayFindFirstIndex(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Read value to find
			T value = ArrayReadValue(call, self, 0);

			// Loop through the entire array to find the value
			for (size_t i = 0; i < self->NativeArray.size(); ++i)
			{
				// If we found the value....
				const T& temp = self->NativeArray[i];
				if (LinkerEquals(value, temp))
				{
					// Return the index at which we found the value
					return call.Set(Call::Return, (Integer)i);
				}
			}

			// We didn't find the first index, just return -1 to indicate it was not found
			call.Set(Call::Return, -1);
		}

		//***************************************************************************
		static void ArrayRemoveFirst(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Read the value to find
			T value = ArrayReadValue(call, self, 0);

			// Loop through all the values in the native array
			for (size_t i = 0; i < self->NativeArray.size(); ++i)
			{
				// If we found the value...
				const T& temp = self->NativeArray[i];
				if (LinkerEquals(value, temp))
				{
					// Erase the value at that index and mark the container as modified
					self->NativeArray.eraseAt(i);
					self->Modified();

					// Return that we removed a value
					return call.Set<Boolean>(Call::Return, true);
				}
			}

			// Return that we did not remove a value
			call.Set<Boolean>(Call::Return, false);
		}

		//***************************************************************************
		static void ArrayRemoveAll(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Read the value that we want to remove
			T testValue = ArrayReadValue(call, self, 0);

			// Remove all the elements if they are equal, and get how many were removed
			size_t removeCount = RemoveAll(self->NativeArray, Zero::EqualTo<T>(testValue));

			// Return the amount we removed
			call.Set<Integer>(Call::Return, (Integer)removeCount);
		}

		//***************************************************************************
		static void SetParameter(Call& call, size_t index, T& value)
		{
			byte* dest = call.GetParameterUnchecked(index);
			CopyFromAnyOrActualType(value, dest);
		}

		//***************************************************************************
		class DelegateCompare
		{
		public:
			DelegateCompare(ExecutableState* state, ExceptionReport& report, Delegate& comparer) :
				State(state),
				Report(&report),
				Comparer(&comparer)
			{
			}

			ExecutableState* State;
			ExceptionReport* Report;
			Delegate* Comparer;

			bool operator()(T& left, T& right)
			{
				// Ideally we would have exited out of the algorthm, but sort has no mechanism for that
				// Just check if an exception was set upon coming in here, if so ignore it
				if (this->Report->HasThrownExceptions())
					return false;

				// Call the delegate with the left and right values
				Zilch::Call call(*this->Comparer, this->State);
				SetParameter(call, 0, left);
				SetParameter(call, 1, right);
				call.DisableParameterChecks();
				call.Invoke(*this->Report);

				// If the recent invokation threw an exception, then it means no return value was placed on the stack
				if (this->Report->HasThrownExceptions())
					return false;

				return call.Get<bool>(Call::Return);
			}
		};

		//***************************************************************************
		static void ArraySortDelegate(Call& call, ExceptionReport& report)
		{
			Delegate& comparer = call.GetDelegate(0);
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();
			sort(self->NativeArray.all(), DelegateCompare(call.GetState(), report, comparer));
		}

		//***************************************************************************
		static void ArrayReturnIndexedRange(Call& call, ExceptionReport& report, ArrayTemplate* self, Integer start, Integer count)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Create the range type that we will return
			Handle rangeHandle = call.GetState()->AllocateDefaultConstructedHeapObject(userData.RangeType, report, HeapFlags::ReferenceCounted);

			// If we threw an exception, we need to early out and let the stack unroll
			if (report.HasThrownExceptions())
				return;

			// Get the range's data (should have been constructed!)
			ArrayRangeTemplate<T>* range = (ArrayRangeTemplate<T>*)rangeHandle.Dereference();

			// Setup the range to be returned
			range->Array = call.GetHandle(Call::This);
			range->Count = count;
			range->Start = start;
			range->Current = start;
			range->ModifyId = self->ModifyId;

			// Return the handle to the array range
			call.SetHandle(Call::Return, rangeHandle);
		}

		//***************************************************************************
		static void ArrayAll(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Range of all elements
			ArrayReturnIndexedRange(call, report, self, 0, self->GetCount());
		}

		//***************************************************************************
		static void ArrayRange(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the array)
			ArrayTemplate* self = (ArrayTemplate*)call.GetHandle(Call::This).Dereference();

			// Get the index we're trying to remove at
			Integer begin = call.Get<Integer>(0);
			Integer count = call.Get<Integer>(1);

			if (begin < 0 || begin >= self->GetCount())
			{
				call.GetState()->ThrowException(report, "Array range was out of bounds");
				return;
			}

			Integer end = begin + count;
			if (count < 0 || end > self->GetCount())
			{
				call.GetState()->ThrowException(report, "Array range was out of bounds");
				return;
			}

			// Range of all elements
			ArrayReturnIndexedRange(call, report, self, begin, count);
		}

	};

	// To iterate through arrays using 'foreach', we use the range type
	// Ranges are also much safer than iterators
	template <typename T>
	class ArrayRangeTemplate
	{
	public:

		// Constructor
		ArrayRangeTemplate() :
			Current(0),
			Start(0),
			Count(0),
			ModifyId(0)
		{
		}

		// Check if the range is empty
		Boolean IsEmpty()
		{
			return (this->Current - this->Start) == this->Count;
		}

		// Check if the range is not empty
		Boolean IsNotEmpty()
		{
			return this->IsEmpty() == false;
		}

		// A handle back to the source container that our data belongs to
		Handle Array;

		// The current index that we're iterating through
		Integer Current;

		// Where we started (so we can reset the range)
		Integer Start;

		// How many elements are in the range (so we know the end)
		Integer Count;

		// The id that the container had when we were created from it
		Integer ModifyId;

		//***************************************************************************
		static void ArrayRangeConstructor(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the range)
			Handle& selfHandle = call.GetHandle(Call::This);
			byte* selfData = selfHandle.Dereference();

			// Call our default constructor on the memory
			new (selfData)ArrayRangeTemplate();
		}

		//***************************************************************************
		static void ArrayRangeDestructor(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the range)
			ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

			// Directly invoke the destructor
			self->~ArrayRangeTemplate();
		}

		//***************************************************************************
		static void ArrayRangeReset(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the range)
			ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

			// Move the range back to the start
			self->Current = self->Start;
		}

		//***************************************************************************
		static void ArrayRangeMoveNext(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the range)
			ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

			// Check if the difference (how much we've gone forward) is past the count
			if (self->IsEmpty())
			{
				// Throw an exception since the range was empty and we called MoveNext
				call.GetState()->ThrowException(report, "The range reached the end, but then an attempt was made to make it iterate forward more");
				return;
			}
			else
			{
				// Move the range forward
				++self->Current;
			}
		}

		//***************************************************************************
		static void ArrayRangeIsEmpty(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the range)
			ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

			// Compute and return whether or not he range is empty
			Boolean isEmpty = self->IsEmpty();
			call.Set(Call::Return, isEmpty);
		}

		//***************************************************************************
		static void ArrayRangeIsNotEmpty(Call& call, ExceptionReport& report)
		{
			// Get ourselves (the range)
			ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

			// Compute and return whether or not he range is empty
			Boolean isNotEmpty = self->IsNotEmpty();
			call.Set(Call::Return, isNotEmpty);
		}

		//***************************************************************************
		static void ArrayRangeAll(Call& call, ExceptionReport& report)
		{
			// Grab our self handle and return it (we just return ourselves)
			Handle& selfHandle = call.GetHandle(Call::This);
			call.SetHandle(Call::Return, selfHandle);
		}

		//***************************************************************************
		static void ArrayRangeCurrent(Call& call, ExceptionReport& report)
		{
			// Read the element size from the current function's user-data
			ArrayUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<ArrayUserData>(0);

			// Get this object
			ArrayRangeTemplate* self = (ArrayRangeTemplate*)call.GetHandle(Call::This).Dereference();

			// Get the array that we look at
			ArrayTemplate<T>* array = (ArrayTemplate<T>*)self->Array.Dereference();

			// Check if the array was modified
			if (self->ModifyId != array->ModifyId)
			{
				// It was modified, so throw an exception and early out
				call.GetState()->ThrowException(report,
					"The collection was modified and therefore the range cannot be used");
				return;
			}

			// If we've already reached the end...
			if (self->IsEmpty())
			{
				// Throw an exception since the range was empty and we called Current
				call.GetState()->ThrowException(report, "The range reached the end and an attempt was made to get the current value");
				return;
			}
			else
			{
				// Get a pointer to the return value data (on the stack)
				byte* returnValue = call.GetReturnUnchecked();
				call.DisableReturnChecks();

				// Copy the value at the array to the return type (this properly deals with the Any type)
				CopyFromAnyOrActualType(array->NativeArray[self->Current], returnValue);
			}
		}
	};

	//***************************************************************************
	template <typename T>
	BoundType* InstantiateArray
		(
		LibraryBuilder& builder,
		StringParam baseName,
		StringParam fullyQualifiedName,
		const Array<Type*>& templateTypes,
		const void* userData
		)
	{
		// Error checking
		ErrorIf(templateTypes.size() != 1,
			"The Array template should only take one template argument");

		// Get the type we're instantiating
		Type* containedType = templateTypes.front();

		// We could have put core in our userdata, but no real need
		Core& core = Core::GetInstance();

		StringBuilder rangeName;
		rangeName.Append("ArrayRange[");
		rangeName.Append(containedType->ToString());
		rangeName.Append("]");

		String fullyQualifiedRangeName = rangeName.ToString();

		ZilchTodo("The range type must have a valid destructor the decrements the reference count on the 'array' handle");
		BoundType* rangeType = builder.AddBoundType(fullyQualifiedRangeName, TypeCopyMode::ReferenceType, sizeof(ArrayRangeTemplate<T>));

		// Create the array type instance (arrays and any other containers should be reference types!)
		BoundType* arrayType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(ArrayTemplate<T>));

		arrayType->ToStringFunction = ArrayTemplate<T>::ArrayToString;

		Function* f = nullptr;
		Property* p = nullptr;

		ArrayUserData arrayUserData;
		arrayUserData.ContainedType = containedType;
		arrayUserData.RangeType = rangeType;
		arrayUserData.SelfType = arrayType;
		arrayType->ComplexUserData.WriteObject(arrayUserData);

		ZilchBindCustomConstructor(builder, arrayType, ArrayTemplate<T>);
		ZilchBindCustomDestructor(builder, arrayType, ArrayTemplate<T>);

		f = builder.AddBoundConstructor(arrayType, ArrayTemplate<T>::ArrayConstructorResize, OneParameter(core.IntegerType, "size"));
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundConstructor(arrayType, ArrayTemplate<T>::ArrayConstructorResizeDefault, TwoParameters(core.IntegerType, "size", containedType, "defaultValue"));
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Get", ArrayTemplate<T>::ArrayGet, OneParameter(core.IntegerType, "index"), containedType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Set", ArrayTemplate<T>::ArraySet, TwoParameters(core.IntegerType, "index", containedType, "value"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Reserve", ArrayTemplate<T>::ArrayReserve, OneParameter(core.IntegerType, "capacity"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Resize", ArrayTemplate<T>::ArrayResize, OneParameter(core.IntegerType, "size"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Resize", ArrayTemplate<T>::ArrayResizeDefault, TwoParameters(core.IntegerType, "size", containedType, "defaultValue"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Add", ArrayTemplate<T>::ArrayAdd, OneParameter(containedType), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Push", ArrayTemplate<T>::ArrayAdd, OneParameter(containedType), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Pop", ArrayTemplate<T>::ArrayPop, ParameterArray(), containedType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Insert", ArrayTemplate<T>::ArrayInsert, TwoParameters(core.IntegerType, "index", containedType, "value"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "RemoveAt", ArrayTemplate<T>::ArrayRemoveAt, OneParameter(core.IntegerType, "index"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "RemoveFirst", ArrayTemplate<T>::ArrayRemoveFirst, OneParameter(containedType, "value"), core.BooleanType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "RemoveAll", ArrayTemplate<T>::ArrayRemoveAll, OneParameter(containedType, "value"), core.IntegerType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "RemoveSwap", ArrayTemplate<T>::ArrayRemoveSwap, OneParameter(core.IntegerType, "index"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Range", ArrayTemplate<T>::ArrayRange, TwoParameters(core.IntegerType, "start", core.IntegerType, "count"), rangeType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Copy", ArrayTemplate<T>::ArrayCopy, ParameterArray(), arrayType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "Clear", ArrayTemplate<T>::ArrayClear, ParameterArray(), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		f = builder.AddBoundFunction(arrayType, "FindFirstIndex", ArrayTemplate<T>::ArrayFindFirstIndex, OneParameter(containedType, "value"), core.IntegerType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		DelegateType* binaryCompare = builder.GetDelegateType(TwoParameters(containedType, "left", containedType, "right"), core.BooleanType);
		f = builder.AddBoundFunction(arrayType, "Sort", ArrayTemplate<T>::ArraySortDelegate, OneParameter(binaryCompare, "compare"), core.VoidType, FunctionOptions::None);
		f->ComplexUserData.WriteObject(arrayUserData);

		builder.AddBoundProperty(arrayType, "Count", core.IntegerType, nullptr, ArrayTemplate<T>::ArrayCount, MemberOptions::None);
		builder.AddBoundProperty(arrayType, "Capacity", core.IntegerType, nullptr, ArrayTemplate<T>::ArrayCapacity, MemberOptions::None);
		builder.AddBoundProperty(arrayType, "LastIndex", core.IntegerType, nullptr, ArrayTemplate<T>::ArrayLastIndex, MemberOptions::None);

		p = builder.AddBoundProperty(arrayType, "All", rangeType, nullptr, ArrayTemplate<T>::ArrayAll, MemberOptions::None);
		p->Get->ComplexUserData.WriteObject(arrayUserData);

		builder.AddBoundConstructor(rangeType, ArrayRangeTemplate<T>::ArrayRangeConstructor, ParameterArray());
		builder.AddBoundDestructor(rangeType, ArrayRangeTemplate<T>::ArrayRangeDestructor);

		builder.AddBoundFunction(rangeType, "MoveNext", ArrayRangeTemplate<T>::ArrayRangeMoveNext, ParameterArray(), core.VoidType, FunctionOptions::None);
		builder.AddBoundFunction(rangeType, "Reset", ArrayRangeTemplate<T>::ArrayRangeReset, ParameterArray(), core.VoidType, FunctionOptions::None);

		p = builder.AddBoundProperty(rangeType, "Current", containedType, nullptr, ArrayRangeTemplate<T>::ArrayRangeCurrent, MemberOptions::None);
		p->Get->ComplexUserData.WriteObject(arrayUserData);

		builder.AddBoundProperty(rangeType, "IsEmpty", core.BooleanType, nullptr, ArrayRangeTemplate<T>::ArrayRangeIsEmpty, MemberOptions::None);
		builder.AddBoundProperty(rangeType, "IsNotEmpty", core.BooleanType, nullptr, ArrayRangeTemplate<T>::ArrayRangeIsNotEmpty, MemberOptions::None);
		builder.AddBoundProperty(rangeType, "All", rangeType, nullptr, ArrayRangeTemplate<T>::ArrayRangeAll, MemberOptions::None);

		// Return the array type we instantiated
		return arrayType;
	}

	//***************************************************************************
	BoundType* InstantiateArray
		(
		LibraryBuilder& builder,
		StringParam baseName,
		StringParam fullyQualifiedName,
		const Array<Type*>& templateTypes,
		const void* userData
		)
	{
		// Get the type our array is containing
		Type* containedType = templateTypes.front();

		if (Type::IsHandleType(containedType))
		{
			return InstantiateArray<Handle>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsDelegateType(containedType))
		{
			return InstantiateArray<Delegate>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Boolean)))
		{
			return InstantiateArray<Boolean>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Boolean2)))
		{
			return InstantiateArray<Boolean2>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Boolean3)))
		{
			return InstantiateArray<Boolean3>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Boolean4)))
		{
			return InstantiateArray<Boolean4>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Integer)) || Type::IsEnumOrFlagsType(containedType))
		{
			return InstantiateArray<Integer>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Integer2)))
		{
			return InstantiateArray<Integer2>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Integer3)))
		{
			return InstantiateArray<Integer3>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Integer4)))
		{
			return InstantiateArray<Integer4>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Real)))
		{
			return InstantiateArray<Real>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Real2)))
		{
			return InstantiateArray<Real2>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Real3)))
		{
			return InstantiateArray<Real3>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Real4)))
		{
			return InstantiateArray<Real4>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(Quaternion)))
		{
			return InstantiateArray<Quaternion>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(DoubleInteger)))
		{
			return InstantiateArray<DoubleInteger>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else if (Type::IsSame(containedType, ZilchTypeId(DoubleReal)))
		{
			return InstantiateArray<DoubleReal>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
		else
		{
			return InstantiateArray<Any>(builder, baseName, fullyQualifiedName, templateTypes, userData);
		}
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	StaticLibrary::StaticLibrary(String name) :
		Name(name),
		Build(BuildState::NotBuilt),
		IsDependencyOrderComputed(false),
		IsBeingWalked(false)
	{
		// Create a library builder
		this->Builder = new LibraryBuilder(name);

		// Add ourselves to the static libraries list
		StaticLibraries::GetInstance().AddStaticLibrary(*this);
	}

	//***************************************************************************
	StaticLibrary::~StaticLibrary()
	{
		delete this->Builder;
	}

	//***************************************************************************
	BuildState::Enum StaticLibrary::GetBuildState()
	{
		return this->Build;
	}

	//***************************************************************************
	LibraryRef StaticLibrary::GetLibrary()
	{
		// If the library has not been built yet...
		if (this->Library == nullptr)
		{
			// Throw an error
			Error("The static library '%s' must be built before it can be accessed! "
				"To build all static libraries call Zilch::ZilchStartup() in main.", this->Name.c_str());
		}

		return this->Library;
	}

	//***************************************************************************
	LibraryBuilder* StaticLibrary::GetBuilder()
	{
		// If the library was already built (the builder is destroyed...)
		if (this->Builder == nullptr)
		{
			// Throw an error
			Error("The static library '%s' was already built, and therefore its builder cannot be accessed.",
				this->Library->Name.c_str());
			return nullptr;
		}

		return this->Builder;
	}

	//***************************************************************************
	int StaticLibrary::AddInitializer(StaticInitializeFn fn)
	{
		// Add the initializer to our list
		this->Initializers.push_back(fn);

		// Return any value (just used for running global functions)
		return 0;
	}

	//***************************************************************************
	void StaticLibrary::PreSetupBinding(LibraryBuilder& builder)
	{
		// The base class does nothing, this is just to allow users to do their own setup
	}

	//***************************************************************************
	void StaticLibrary::PostSetupBinding(LibraryBuilder& builder)
	{
		// The base class does nothing, this is just to allow users to do their own setup
	}

	//***************************************************************************
	void StaticLibrary::BuildLibrary()
	{
		// Let the library know it's in the process of building
		// This is generally used to provide clear error messages in ZilchTypeId
		this->Build = BuildState::Building;

		// If this was already done, show an error
		ReturnIf(this->Builder == nullptr, , "The static library '%s' can only be built once!", this->Library->Name.c_str());

		// Before we run initializers, let the user setup anything they want
		this->PreSetupBinding(*this->Builder);

		// Go through the entire list and invoke all initializers
		for (size_t i = 0; i < this->Initializers.size(); ++i)
		{
			// Invoke the initializer (nothing else to do but that!)
			this->Initializers[i](*this);
		}

		// Clear the initializers (just for safety and clarity)
		this->Initializers.clear();

		// Now that all static types have been initialized, let the user finish up
		this->PostSetupBinding(*this->Builder);

		// Create the library and store it for everyone to be able to access
		this->Library = this->Builder->CreateLibrary();

		// Destroy the library builder since it's no longer needed
		delete this->Builder;
		this->Builder = nullptr;

		// Let the library know it's done being built
		this->Build = BuildState::Built;
	}

	//***************************************************************************
	bool TypeBinding::VirtualTableCounter::StaticDebugIsVirtual = false;

	//***************************************************************************
	TypeBinding::VirtualTableCounter::VirtualTableCounter()
	{
		// Make sure both flags are set to false so that we don't trip the assert
		StaticDebugIsVirtual = false;
		this->InstanceDebugIsVirtual = false;
	}

	//***************************************************************************
	void TypeBinding::VirtualTableCounter::AssertIfNotVirtual()
	{
		// Perform the error checking
		ErrorIf(StaticDebugIsVirtual == false || this->InstanceDebugIsVirtual == false,
			"Method being tested was not virtual!");

		// Reset our state back, just incase we use this again
		StaticDebugIsVirtual = false;
		this->InstanceDebugIsVirtual = false;
	}

	//***************************************************************************
	BoundType* StaticLibrary::MakeType
		(
		StringParam         name,
		size_t              size,
		TypeCopyMode::Enum  copyMode,
		BoundType*          parent,
		size_t              nativeVirtualCount
		)
	{
		// Get the library builder
		LibraryBuilder& builder = *this->GetBuilder();

		// Create the type info with the provided information
		BoundType* newType = builder.AddBoundType(name, copyMode, size, nativeVirtualCount);
		newType->BaseType = parent;

		// Return the new type
		return newType;
	}

	//***************************************************************************
	StaticLibraries& StaticLibraries::GetInstance()
	{
		static StaticLibraries instance;
		return instance;
	}

	//***************************************************************************
	void StaticLibraries::AddStaticLibrary(StaticLibrary& library)
	{
		// Error checking
		ReturnIf(this->Build != BuildState::NotBuilt, ,
			"We cannot add more static libraries after they were all already built");

		// Check if we've already added that library builder...
		if (this->DuplicateLibraryFinder.contains(&library) == false)
		{
			// Add the builder to the list...
			this->LibrariesTobeBuilt.push_back(&library);

			// Add this to the duplicate libraries list
			this->DuplicateLibraryFinder.insert(&library);
		}
		else
		{
			Error("Attempting to add a static library twice!");
		}
	}

	//***************************************************************************
	void StaticLibraries::VisitDependencies(StaticLibrary* library, Array<StaticLibrary*>& dependencyOrder)
	{
		// Note: If the library we're walking was already walked, we've detected a cycle!
		if (library->IsBeingWalked)
		{
			Error("A cycle in static library dependencies was detected with %s", library->Name.c_str());
			library->IsDependencyOrderComputed = true;
			return;
		}

		// If this library has already been added (which does NOT mean it is currently being walked...)
		// There is no need to walk this dependency, since it and all it's dependencies have been walked
		if (library->IsDependencyOrderComputed)
			return;

		// Mark ourselves as being walked
		library->IsBeingWalked = true;

		// Walk through all dependency libraries
		// All libraries should at least have Core as a dependency, except of course Core itself
		Array<StaticLibrary*>::range dependencies;
		for (dependencies = library->Dependencies.all(); dependencies.empty() == false; dependencies.popFront())
		{
			// Before adding ourselves to the dependency order array,
			// we must visit our dependencies so they get added first
			StaticLibrary* dependency = dependencies.front();
			VisitDependencies(dependency, dependencyOrder);
		}

		// Finally, add ourselves to the dependency order (our dependencies should have been added already)
		dependencyOrder.push_back(library);

		// Mark this library as having its dependency order computed
		library->IsDependencyOrderComputed = true;

		// We're no longer being walked
		library->IsBeingWalked = false;
	}

	//***************************************************************************
	void StaticLibraries::BuildAll()
	{
		// Error checking
		ReturnIf(this->Build != BuildState::NotBuilt, ,
			"Attempted to build the static libraries again");

		// We're starting the build process
		this->Build = BuildState::Building;

		// The libraries that we need to build, in dependency order
		Array<StaticLibrary*> dependencyOrder;

		// Go through all static libraries and compute dependency order
		for (size_t i = 0; i < this->LibrariesTobeBuilt.size(); ++i)
		{
			// Grab the current static library
			StaticLibrary* staticLibrary = this->LibrariesTobeBuilt[i];

			// Compute the dependency order for this library and any dependencies
			VisitDependencies(staticLibrary, dependencyOrder);
		}

		// Now that we've ordered the libraries in a way that makes it so we'll build dependencies first...
		for (size_t i = 0; i < dependencyOrder.size(); ++i)
		{
			// Grab the current static library
			StaticLibrary* staticLibrary = dependencyOrder[i];

			// Build all the types and their bindings
			staticLibrary->BuildLibrary();
		}

		// Clear out the libraries we need to build
		this->LibrariesTobeBuilt.clear();

		// We finally built all the libraries
		this->Build = BuildState::Built;
	}

	//***************************************************************************
	BuildState::Enum StaticLibraries::GetBuildState()
	{
		return this->Build;
	}

	//***************************************************************************
	StaticLibraries::StaticLibraries() :
		Build(BuildState::NotBuilt)
	{
	}

	//***************************************************************************
	bool TypeBinding::IsA(BoundType* type, BoundType* base)
	{
		// Loop until the type chain becomes empty
		while (type != nullptr)
		{
			// If the base type is the same as the current type...
			if (base == type)
				return true;

			// Iterate to the next parent
			type = type->BaseType;
		}

		// Otherwise, the given type does not inherit from base
		return false;
	}

	//***************************************************************************
	bool TypeBinding::IndirectionIsA(IndirectionType* type, IndirectionType* base)
	{
		// The is-a relationship stands for indirect types (the types they point at)
		return IsA
			(
			type->ReferencedType,
			base->ReferencedType
			);
	}

	//***************************************************************************
	bool TypeBinding::GenericIsA(Type* type, Type* base)
	{
		// Get the first type as a bound type
		BoundType* boundType = DynamicCast<BoundType*>(type);

		// If the first type is a bound type...
		if (boundType != nullptr)
		{
			// Then hopefully the base is a bound type also
			BoundType* boundBase = DynamicCast<BoundType*>(base);

			// If it's not, then these types do not match
			if (boundBase == nullptr)
				return false;

			// Otherwise, check for the IsA relationship on two bound types
			return IsA(boundType, boundBase);
		}

		// The first type wasn't a bound type, but is it an indirect type?
		IndirectionType* indirectType = DynamicCast<IndirectionType*>(type);

		// If the first type is an indirect type...
		if (indirectType != nullptr)
		{
			// Then hopefully the base is an indirect type also
			IndirectionType* indirectBase = DynamicCast<IndirectionType*>(base);

			// If it's not, then these types do not match
			if (indirectBase == nullptr)
				return false;

			// Otherwise, check for the IsA relationship on two bound types
			return IndirectionIsA(indirectType, indirectBase);
		}

		// If we got here, then we don't know what type these are
		return Type::IsSame(type, base);
	}

	//***************************************************************************
	BoundType* TypeBinding::StaticTypeId<void>::Get()
	{
		return Core::GetInstance().VoidType;
	}

	//***************************************************************************
	BoundType* TypeBinding::StaticTypeId<nullptr_t>::Get()
	{
		return Core::GetInstance().NullType;
	}

	//***************************************************************************
	AnyType* TypeBinding::StaticTypeId<Any>::Get()
	{
		return Core::GetInstance().AnythingType;
	}

	//***************************************************************************
	ZilchDefineSimpleExternalType(Boolean, Core);
	ZilchDefineSimpleExternalType(Boolean2, Core);
	ZilchDefineSimpleExternalType(Boolean3, Core);
	ZilchDefineSimpleExternalType(Boolean4, Core);
	ZilchDefineSimpleExternalType(Integer, Core);
	ZilchDefineSimpleExternalType(Integer2, Core);
	ZilchDefineSimpleExternalType(Integer3, Core);
	ZilchDefineSimpleExternalType(Integer4, Core);
	ZilchDefineSimpleExternalType(Real, Core);
	ZilchDefineSimpleExternalType(Real2, Core);
	ZilchDefineSimpleExternalType(Real3, Core);
	ZilchDefineSimpleExternalType(Real4, Core);
	ZilchDefineSimpleExternalType(Quaternion, Core);
	ZilchDefineSimpleExternalType(String, Core);
	ZilchDefineSimpleExternalType(DoubleReal, Core);
	ZilchDefineSimpleExternalType(DoubleInteger, Core);

	// All the redirection types
	ZilchDefineSimpleRedirectType(char);
	ZilchDefineSimpleRedirectType(signed   char);
	ZilchDefineSimpleRedirectType(unsigned char);
	ZilchDefineSimpleRedirectType(signed   short);
	ZilchDefineSimpleRedirectType(unsigned short);
	ZilchDefineSimpleRedirectType(unsigned int);
	ZilchDefineSimpleRedirectType(signed   long);
	ZilchDefineSimpleRedirectType(unsigned long);
	ZilchDefineSimpleRedirectType(unsigned long long);
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	TypeParsedDelegate::TypeParsedDelegate() :
		Callback(nullptr),
		UserData(nullptr)
	{
	}

	//***************************************************************************
	InstantiateTemplateDelegate::InstantiateTemplateDelegate() :
		Callback(nullptr),
		UserData(nullptr)
	{
	}

	//***************************************************************************
	OpcodeStepDelegate::OpcodeStepDelegate() :
		Callback(nullptr),
		UserData(nullptr)
	{
	}

	//***************************************************************************
	FunctionStepDelegate::FunctionStepDelegate() :
		Callback(nullptr),
		UserData(nullptr)
	{
	}

	//***************************************************************************
	ExceptionDelegate::ExceptionDelegate() :
		Callback(nullptr),
		UserData(nullptr)
	{
	}

	//***************************************************************************
	FatalErrorDelegate::FatalErrorDelegate() :
		Callback(nullptr),
		UserData(nullptr)
	{
	}
}
/*
cdecoder.c - c source to a base64 decoding algorithm implementation

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

int base64_decode_value(char value_in)
{
	static const char decoding[] = { 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 };
	static const char decoding_size = sizeof(decoding);
	value_in -= 43;
	if (value_in < 0 || value_in >= decoding_size) return -1;
	return decoding[(int)value_in];
}

void base64_init_decodestate(base64_decodestate* state_in)
{
	state_in->step = step_a;
	state_in->plainchar = 0;
}

size_t base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in)
{
	const char* codechar = code_in;
	char* plainchar = plaintext_out;
	char fragment;

	*plainchar = state_in->plainchar;

	switch (state_in->step)
	{
		while (1)
		{
	case step_a:
		do {
			if (codechar == code_in + length_in)
			{
				state_in->step = step_a;
				state_in->plainchar = *plainchar;
				return plainchar - plaintext_out;
			}
			fragment = (char)base64_decode_value(*codechar++);
		} while (fragment < 0);
		*plainchar = (fragment & 0x03f) << 2;
	case step_b:
		do {
			if (codechar == code_in + length_in)
			{
				state_in->step = step_b;
				state_in->plainchar = *plainchar;
				return plainchar - plaintext_out;
			}
			fragment = (char)base64_decode_value(*codechar++);
		} while (fragment < 0);
		*plainchar++ |= (fragment & 0x030) >> 4;
		*plainchar = (fragment & 0x00f) << 4;
	case step_c:
		do {
			if (codechar == code_in + length_in)
			{
				state_in->step = step_c;
				state_in->plainchar = *plainchar;
				return plainchar - plaintext_out;
			}
			fragment = (char)base64_decode_value(*codechar++);
		} while (fragment < 0);
		*plainchar++ |= (fragment & 0x03c) >> 2;
		*plainchar = (fragment & 0x003) << 6;
	case step_d:
		do {
			if (codechar == code_in + length_in)
			{
				state_in->step = step_d;
				state_in->plainchar = *plainchar;
				return plainchar - plaintext_out;
			}
			fragment = (char)base64_decode_value(*codechar++);
		} while (fragment < 0);
		*plainchar++ |= (fragment & 0x03f);
		}
	}
	/* control should not reach here */
	return plainchar - plaintext_out;
}

/*
cencoder.c - c source to a base64 encoding algorithm implementation

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

/*
cencode.h - c header for a base64 encoding algorithm

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

#ifndef BASE64_CENCODE_H
#define BASE64_CENCODE_H

typedef enum
{
	step_A, step_B, step_C
} base64_encodestep;

typedef struct
{
	base64_encodestep step;
	char result;
	int stepcount;
} base64_encodestate;

int compute_base64_size(int length);

void base64_init_encodestate(base64_encodestate* state_in);

char base64_encode_value(char value_in);

size_t base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in);

size_t base64_encode_blockend(char* code_out, base64_encodestate* state_in);

#endif /* BASE64_CENCODE_H */

const int CHARS_PER_LINE = 72;

int compute_base64_size(int length)
{
	return (int)(ceil(length / 3.0f)) * 4;
}

void base64_init_encodestate(base64_encodestate* state_in)
{
	state_in->step = step_A;
	state_in->result = 0;
	state_in->stepcount = 0;
}

char base64_encode_value(char value_in)
{
	static const char* encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	if (value_in > 63) return '=';
	return encoding[(int)value_in];
}

size_t base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in)
{
	const char* plainchar = plaintext_in;
	const char* const plaintextend = plaintext_in + length_in;
	char* codechar = code_out;
	char result;
	char fragment;

	result = state_in->result;

	switch (state_in->step)
	{
		while (1)
		{
	case step_A:
		if (plainchar == plaintextend)
		{
			state_in->result = result;
			state_in->step = step_A;
			return codechar - code_out;
		}
		fragment = *plainchar++;
		result = (fragment & 0x0fc) >> 2;
		*codechar++ = base64_encode_value(result);
		result = (fragment & 0x003) << 4;
	case step_B:
		if (plainchar == plaintextend)
		{
			state_in->result = result;
			state_in->step = step_B;
			return codechar - code_out;
		}
		fragment = *plainchar++;
		result |= (fragment & 0x0f0) >> 4;
		*codechar++ = base64_encode_value(result);
		result = (fragment & 0x00f) << 2;
	case step_C:
		if (plainchar == plaintextend)
		{
			state_in->result = result;
			state_in->step = step_C;
			return codechar - code_out;
		}
		fragment = *plainchar++;
		result |= (fragment & 0x0c0) >> 6;
		*codechar++ = base64_encode_value(result);
		result = (fragment & 0x03f) >> 0;
		*codechar++ = base64_encode_value(result);

		++(state_in->stepcount);
		if (state_in->stepcount == CHARS_PER_LINE / 4)
		{
			*codechar++ = '\n';
			state_in->stepcount = 0;
		}
		}
	}
	/* control should not reach here */
	return codechar - code_out;
}

size_t base64_encode_blockend(char* code_out, base64_encodestate* state_in)
{
	char* codechar = code_out;

	switch (state_in->step)
	{
	case step_B:
		*codechar++ = base64_encode_value(state_in->result);
		*codechar++ = '=';
		*codechar++ = '=';
		break;
	case step_C:
		*codechar++ = base64_encode_value(state_in->result);
		*codechar++ = '=';
		break;
	case step_A:
		break;
	}

	return codechar - code_out;
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	CodeGenerator::CodeGenerator() :
		Builder(nullptr)
	{
		ZilchErrorIfNotStarted(CodeGenerator);

		// Walk all any type of expression (often, expressions are nested within each other)
		this->FunctionWalker.Register(&CodeGenerator::GenerateFunction);
		this->FunctionWalker.Register(&CodeGenerator::GeneratePreConstructorAndPushClassContext);
		this->FunctionWalker.Register(&CodeGenerator::GenerateEnumValueProperties);
		this->FunctionWalker.Register(&CodeGenerator::GenerateEventNameProperties);

		this->GeneratorWalker.Register(&CodeGenerator::ClassAndPreconstructorContext);
		this->GeneratorWalker.RegisterDerived<FunctionNode>(&CodeGenerator::FunctionContext);
		this->GeneratorWalker.RegisterDerived<ConstructorNode>(&CodeGenerator::FunctionContext);
		this->GeneratorWalker.RegisterDerived<DestructorNode>(&CodeGenerator::FunctionContext);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateInitializer);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateParameter);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateLocalVariable);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateDebugBreak);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateMemberVariablePreConstructor);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateTimeout);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateIfRoot);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateWhile);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateDoWhile);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateFor);
		this->GeneratorWalker.RegisterDerived<ForEachNode>(&CodeGenerator::GenerateFor);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateLoop);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateScope);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateBinaryOperation);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateUnaryOperation);
		this->GeneratorWalker.Register(&CodeGenerator::GeneratePropertyDelegateOperation);
		this->GeneratorWalker.RegisterDerived<MemberAccessNode>(&CodeGenerator::GenerateMemberAccess);
		this->GeneratorWalker.RegisterDerived<TypeMemberAccessNode>(&CodeGenerator::GenerateMemberAccess);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateTypeCast);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateTypeId);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateLocalVariableReference);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateReturnValue);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateFunctionCall);
		this->GeneratorWalker.Register(&CodeGenerator::CollectValue);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateStringInterpolants);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateDelete);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateThrow);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateCreationCall);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateCreationInitializer);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateUnnamedOperand);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateBreak);
		this->GeneratorWalker.Register(&CodeGenerator::GenerateContinue);

		this->PropertySetWalker.Register(&CodeGenerator::GeneratePropertySetMemberAccess);
	}

	//***************************************************************************
	LibraryRef CodeGenerator::Generate(SyntaxTree& syntaxTree, LibraryBuilder& builder)
	{
		// Create the context
		GeneratorContext generatorContext;

		// Store the builder
		this->Builder = &builder;

		// Walk the tree and look at functions (this doesn't really use the context)
		this->FunctionWalker.Walk(this, syntaxTree.Root, &generatorContext);

		// Now generate all the code
		this->GeneratorWalker.Walk(this, syntaxTree.Root, &generatorContext);

		// Create the library
		return this->Builder->CreateLibrary();
	}

	//***************************************************************************
	void CodeGenerator::GenerateFunction(FunctionNode*& node, GeneratorContext* context)
	{
		// Store the return type for ease of use
		Function* function = node->DefinedFunction;
		Type* returnType = function->Type->Return;

		// Reserve registers (in the front) for the function's return value (void is size 0)
		function->RequiredStackSpace += returnType->GetCopyableSize();
	}

	//***************************************************************************
	void CodeGenerator::ClassContext(ClassNode*& node, GeneratorContext* context)
	{
		// Push the class onto the stack so that children can access it
		// (the top of the stack will be the most relevant class to them)
		context->ClassTypeStack.push_back(node->Type);

		// Walk all children of the class generically
		context->Walker->GenericWalkChildren(this, node, context);

		// We are exiting this class, so pop it off
		context->ClassTypeStack.pop_back();
	}

	//***************************************************************************
	void CodeGenerator::GeneratePreConstructorAndPushClassContext(ClassNode*& node, GeneratorContext* context)
	{
		// Store the pre-constructor for ease of use
		Function* preCtor = node->PreConstructor;

		// Since the pre-constructor has no returns and parameters, we need no required stack space
		preCtor->RequiredStackSpace = 0;

		// This expression's result will be stored in the last created register
		preCtor->This->Local = preCtor->AllocateRegister(preCtor->This->ResultType->GetCopyableSize());

		// Invoke the class context, which walks the rest of the tree and pushes the class type
		this->ClassContext(node, context);
	}

	//***************************************************************************
	void CodeGenerator::GenerateEventNameProperties(SendsEventNode*& node, GeneratorContext* context)
	{
		// If we have an event property...
		// It is possible to not have once since we could have a duplicate declaration, which is allowed
		if (node->EventProperty != nullptr)
		{
			// Grab the getter function
			Function* get = node->EventProperty->Get;

			// Change the getter/setter to include the integral value
			get->BoundFunction = VirtualMachine::EventsProperty;

			// Store the event name in the complex user data (the 'EventsProperty' will pull it out when it needs it)
			get->ComplexUserData.WriteObject(node->Name->Token);
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateEnumValueProperties(EnumValueNode*& node, GeneratorContext* context)
	{
		// Grab the getter function
		Function* get = node->IntegralProperty->Get;

		// Change the getter/setter to include the integral value
		get->BoundFunction = VirtualMachine::EnumProperty;

		// Store the integral value as the user data (our enum property function will grab that value on the other side)
		get->UserData = (void*)node->IntegralValue;
	}

	//***************************************************************************
	void CodeGenerator::ClassAndPreconstructorContext(ClassNode*& node, GeneratorContext* context)
	{
		// Store the pre-constructor for convenience
		Function* preCtor = node->PreConstructor;

		// We're about to generate code for the pre-constructor, push it onto the stack
		context->FunctionStack.push_back(preCtor);

		// NOTE:
		// This was here, but if you look above in 'GeneratePreConstructorAndPushClassContext'
		// it is already doing this (doing it again would not break anything, just use extra memory)
		// Allocate space for the implicit 'this' pointer
		//preCtor->AllocateRegister(preCtor->This->ResultType->GetCopyableSize());

		// Invoke the class context, which walks the rest of the tree and pushes the class type
		this->ClassContext(node, context);

		// Generate the return opcode, which simply just stops execution of a function
		preCtor->AllocateArgumentFreeOpcode(Instruction::Return, DebugOrigin::ReturnValue, node->Location);

		// Pop the pre constructor
		context->FunctionStack.pop_back();
	}

	// Store the function in the code context
	void CodeGenerator::FunctionContext(GenericFunctionNode*& node, GeneratorContext* context)
	{
		// Push the function onto the stack so that children can access it
		// (the top of the stack will be the most relevant function to them)
		Function* function = node->DefinedFunction;
		context->FunctionStack.push_back(function);

		// Loop through all the parameters
		// The parameters are supposed to occur before checking if the function is static
		// That way, the 'this' pointer always ends up at the end of the stack
		// Yet the instruction ends up at the beginning
		// See CodeGenerator.cpp, approximately line 695, in the function GenerateFunctionCall there is an explanation
		for (size_t i = 0; i < node->Parameters.size(); ++i)
		{
			// Walk the statements
			context->Walker->Walk(this, node->Parameters[i], context);
		}

		// Because it hasn't been done yet, we need to generate a 'this' variable for the function
		// If the function is a member function (non static)...
		if (function->This != nullptr)
		{
			// Get the 'this' variable
			Variable* thisVariable = function->This;

			// The variable's position will be after all the parameters
			thisVariable->Local = function->AllocateRegister(function->This->ResultType->GetCopyableSize());
		}

		// Loop through all the statements
		for (size_t i = 0; i < node->Statements.size(); ++i)
		{
			// Walk the statements
			context->Walker->Walk(this, node->Statements[i], context);
		}

		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// If the function has no return type and not all code paths return...
		if (Type::IsSame(function->Type->Return, core.VoidType) && node->AllPathsReturn == false)
		{
			// Generate an implicit return opcode at the end of the function
			function->AllocateArgumentFreeOpcode(Instruction::Return, DebugOrigin::FunctionContext, node->Location.GetEndOnlyLocation());
		}

		// We are exiting this function, so pop it off
		context->FunctionStack.pop_back();
	}

	//***************************************************************************
	void CodeGenerator::GenerateOutOfScope(ScopeNode*& node, GeneratorContext* context)
	{
		VariableValueRange variables = node->ScopedVariables.values();
		ZilchTodo("Todo: Generate out of scope destructors")

			//// Loop through all the variables in this scope
			//while (variables.empty() == false)
			//{
			//  // Get the current variable and iterate to the next
			//  Variable* variable = variables.front();
			//  variables.popFront();
			//  // 
			//  //variable->ResultType
			//}
	}

	//***************************************************************************
	void CodeGenerator::GenerateParameter(ParameterNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		ZilchTodo("Default parameter values (expressions)");

		//TODO
		//HACK
		// We want to walk the initial value, but we're not generating function code in this case (per se)
		//context->Walker->Walk(this, node->InitialValue, context);

		// Get the type of the function that this parameter belongs to
		//DelegateType* type = function->Type;

		//HACK
		// We simply just allocate registers for each parameter type (we don't need to account for the return type since we've already done that)
		node->CreatedVariable->Local = function->AllocateRegister(node->CreatedVariable->ResultType->GetCopyableSize());
	}

	//***************************************************************************
	void CodeGenerator::GenerateLocalVariable(LocalVariableNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Make sure we generate code for the initial value of the variable
		context->Walker->Walk(this, node->InitialValue, context);

		// Note: This node is not an expression, and therefore does not result in setting an Access/Operand on the node
		// Instead it uses an associated 'CreatedVariable' object to communicate where it's value is stored

		// This expression's result will be stored in the last created register
		node->CreatedVariable->Local = function->AllocateRegister(node->CreatedVariable->ResultType->GetCopyableSize());

		// Generate a copy to copy the initial value to the local register
		// The register is not yet initialized, so this must be an init copy
		GenerateCopyInitialize
			(
			function,
			node->CreatedVariable->ResultType,
			node->InitialValue->Access,
			Operand(node->CreatedVariable->Local),
			DebugOrigin::LocalVariable,
			node->Location
			);
	}

	//***************************************************************************
	void CodeGenerator::GenerateDebugBreak(DebugBreakNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Generate the simple debug breakpoint opcode
		function->AllocateOpcode<Opcode>(Instruction::InternalDebugBreakpoint, DebugOrigin::DebugBreak, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateMemberVariablePreConstructor(MemberVariableNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// The function should always be the pre-constructor
		ErrorIf(function != context->ClassTypeStack.back()->PreConstructor,
			"The function on the top of the stack should be the pre-constructor");

		// Error checking
		ErrorIf(node->IsProperty && node->InitialValue != nullptr,
			"Properties should not have initial values");

		// If this is a data member...
		if (node->IsProperty == false)
		{
			// Make sure we generate code for the initial value of the member variable
			// This code will be generated in the pre-constructor function
			context->Walker->Walk(this, node->InitialValue, context);

			// Get the 'this' parameter (which will be the only parameter, since this is the Pre-Constructor)
			Variable* thisVariable = function->This;

			// Establish where we're going to be writing to
			Operand destination(thisVariable->Local, node->CreatedField->Offset, OperandType::Field);

			// Generate a copy to copy the initial value to the member
			// Since this is copying over un-initialized memory, then this is a init copy
			GenerateCopyInitialize
				(
				function,
				node->ResultType,
				node->InitialValue->Access,
				destination,
				DebugOrigin::LocalVariable,
				node->Location
				);
		}

		// Generate the get function if we have one
		if (node->Get != nullptr)
		{
			context->Walker->Walk(this, node->Get, context);
		}

		// Generate the set function if we have one
		if (node->Set != nullptr)
		{
			context->Walker->Walk(this, node->Set, context);
		}
	}

	//***************************************************************************
	// All the if statements (except for the last one) need to jump to the end of the entire if statement
	struct IfEndJump
	{
		RelativeJumpOpcode* Opcode;
		size_t JumpInstructionIndex;
	};

	//***************************************************************************
	void CodeGenerator::GenerateIfRoot(IfRootNode*& node, GeneratorContext* context)
	{
		// At the end of each if statement (except for the last one) we need a jump
		// that jumps to the very end of the entire if, store pointers to all those opcode here
		Array<IfEndJump> jumpsAfterEveryElse;

		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Walk through all the parts of the if statement
		for (size_t i = 0; i < node->IfParts.size(); ++i)
		{
			// Grab the current if part node
			IfNode* ifPart = node->IfParts[i];

			// If we have no condition... (that means we're an else statement)
			if (ifPart->Condition == nullptr)
			{
				// Loop through all the statements and generate opcode for each
				this->GenerateStatements(context, ifPart);
				break;
			}

			// Generate code for the condition of the if statement
			context->Walker->Walk(this, ifPart->Condition, context);

			// Store the index that we generated the opcode
			size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

			// Generate an opcode that will jump if the given conditional-expression is false
			// For now, we'll leave out the "jump to" address as we don't yet know where to go
			// The jump-to address will be filled in upon the post pass
			IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfFalseRelativeGoTo, DebugOrigin::If, ifPart->Condition->Location);
			ifOpcode.Condition = ifPart->Condition->Access;

			// Loop through all the statements and generate opcode for each
			this->GenerateStatements(context, ifPart);

			// If this if part has another else statement to follow (literally whether we're the last node)
			bool hasElseStatement = (i != node->IfParts.size() - 1);

			// The index of the jump instruction
			RelativeJumpOpcode* jumpOpcode = nullptr;
			size_t jumpInstructionIndex = 0;

			// If we have an else statement, we need one more opcode
			// This has to be here (and not below) because the if-false needs to skip this instruction
			if (hasElseStatement)
			{
				// Create a jump opcode and store it so we can fill in the parameters after we've 
				IfEndJump& endJump = jumpsAfterEveryElse.push_back();
				endJump.JumpInstructionIndex = function->GetCurrentOpcodeIndex();
				endJump.Opcode = &function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::If, ifPart->Location);
			}

			// Jump to wherever the statements inside the if-statement end
			size_t opcodeIndexAfterStatements = function->GetCurrentOpcodeIndex();
			ifOpcode.JumpOffset = (ByteCodeOffset)(opcodeIndexAfterStatements - ifFalseInstructionIndex);
		}

		// Get the opcode index after all the else statements have been processed
		size_t opcodeIndexAfterAllElses = function->GetCurrentOpcodeIndex();

		// Loop through all the jumps
		for (size_t i = 0; i < jumpsAfterEveryElse.size(); ++i)
		{
			// Grab the current jump
			IfEndJump& endJump = jumpsAfterEveryElse[i];

			// Retreive that jump opcode we made earlier, and set its jump offset
			endJump.Opcode->JumpOffset = (ByteCodeOffset)(opcodeIndexAfterAllElses - endJump.JumpInstructionIndex);
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateStatements(GeneratorContext* context, ScopeNode* node)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Loop through all the statements
		for (size_t i = 0; i < node->Statements.size(); ++i)
		{
			// Walk the statements and generate all their code
			context->Walker->Walk(this, node->Statements[i], context);
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateLoopStatementsAndContinues(GeneratorContext* context, LoopScopeNode* node)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Generate all statements for the loop node
		this->GenerateStatements(context, node);

		// By here, we should have collected any continue statements
		// (for break to work properly, this has to come after that backwards jump opcode)
		for (size_t i = 0; i < node->Continues.size(); ++i)
		{
			// Get the current continue node
			ContinueNode* continueNode = node->Continues[i];

			// Get the instruction index for the continue's jump
			size_t continueInstructionIndex = continueNode->InstructionIndex;

			// Get the continue opcode
			RelativeJumpOpcode& continueOpcode = *continueNode->JumpOpcode;

			// We want to jump forward
			continueOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - continueInstructionIndex);
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateBackwardsLoopJump(GeneratorContext* context, size_t backwardsJumpInstructionIndex, const CodeLocation& debugLocation)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Determine the jump offset that we'd like to jump
		ByteCodeOffset jumpOffset = (ByteCodeOffset)(backwardsJumpInstructionIndex - function->GetCurrentOpcodeIndex());

		// Generate one more opcode that will jump back up the beginning (before the condition is checked)
		RelativeJumpOpcode& jumpOpcode = function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::While, debugLocation);
		jumpOpcode.JumpOffset = jumpOffset;
	}

	//***************************************************************************
	void CodeGenerator::GenerateLoopBreaks(GeneratorContext* context, LoopScopeNode* node)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// By here, we should have collected any break statements
		// and finished the opcode that returns to the beginning of the loop
		// (for break to work properly, this has to come after that backwards jump opcode)
		for (size_t i = 0; i < node->Breaks.size(); ++i)
		{
			// Get the current break node
			BreakNode* breakNode = node->Breaks[i];

			// Get the instruction index for the break's jump
			size_t breakInstructionIndex = breakNode->InstructionIndex;

			// Get the break opcode
			RelativeJumpOpcode& breakOpcode = *breakNode->JumpOpcode;

			// We want to jump forward
			breakOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - breakInstructionIndex);
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateTimeout(TimeoutNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Generate the beginning of the scope
		function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::Timeout, node->Location);

		// Generate the beginning of the timeout with seconds
		TimeoutOpcode& timeout = function->AllocateOpcode<TimeoutOpcode>(Instruction::BeginTimeout, DebugOrigin::Timeout, node->Location);
		timeout.LengthSeconds = node->Seconds;

		// Generate all the statements code and continues
		this->GenerateStatements(context, node);

		// Generate the ending of the timeout scope
		function->AllocateOpcode<Opcode>(Instruction::EndTimeout, DebugOrigin::Timeout, node->Location);

		// Generate the final ending of the scope
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Timeout, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateWhile(WhileNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Store the index that we'd like to jump back to at the end of the loop
		size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();

		// Generate the beginning of the scope
		function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::While, node->Location);

		// Generate code for the condition of the while statement
		context->Walker->Walk(this, node->Condition, context);

		// Store the index that we generated the opcode
		size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

		// Generate an opcode that will jump if the given conditional-expression is false
		// For now, we'll leave out the "jump to" address as we don't yet know where to go
		// The jump-to address will be filled in upon the post pass
		IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfFalseRelativeGoTo, DebugOrigin::While, node->Condition->Location);
		ifOpcode.Condition = node->Condition->Access;

		// Generate all the statements code and continues
		GenerateLoopStatementsAndContinues(context, node);

		// Generate the ending of the scope
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::While, node->Location);

		// Generate the backwards jump, and the breaks
		GenerateBackwardsLoopJump(context, backwardsJumpInstructionIndex, node->Location);
		GenerateLoopBreaks(context, node);

		// Jump to wherever the statements inside the if-statement end
		ifOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - ifFalseInstructionIndex);

		// Generate the final ending of the scope, called when we break or fail the loop conditional
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::While, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateDoWhile(DoWhileNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Store the index that we'd like to jump back to at the end of the loop
		size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();

		// Generate the beginning of the scope
		function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::DoWhile, node->Location);

		// Generate all the statements code and continues
		// (we don't actually have a typical backwards jump, that's on the condition)
		GenerateLoopStatementsAndContinues(context, node);

		// Generate code for the condition of the while statement
		context->Walker->Walk(this, node->Condition, context);

		// Generate the ending of the scope
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::DoWhile, node->Location);

		// We have to compute the jump offset before creating the if-opcode, since we don't typically include the
		// size of any opcode when jumping backwards
		ByteCodeOffset jumpOffset = (ByteCodeOffset)(backwardsJumpInstructionIndex - function->GetCurrentOpcodeIndex());

		// Generate an opcode that will jump if the given conditional-expression is false
		// For now, we'll leave out the "jump to" address as we don't yet know where to go
		// The jump-to address will be filled in upon the post pass
		IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfTrueRelativeGoTo, DebugOrigin::DoWhile, node->Condition->Location);
		ifOpcode.Condition = node->Condition->Access;
		ifOpcode.JumpOffset = jumpOffset;

		// Store the index that we'd like to jump back to at the end of the loop
		size_t jumpInstructionIndex = function->GetCurrentOpcodeIndex();

		// Typically in other loops we end up having one 'EndScope' at the end because the last iteration always terminates inside a BeginScope (while, for, etc)
		// Since the if-condition in a do-while comes outside the BeginScope/EndScope, then we need to take special care because we do NOT need another EndScope opcode
		// The EndScope NEEDS to be run in the case of a break statement, however, because breaks are within the BeginScope/EndScope
		RelativeJumpOpcode& jumpPastEndScopeWhenConditionMet = function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::DoWhile, node->Condition->Location);

		// Generate the break (note that we have to have an EndScope after this, but not after the condition fails)
		GenerateLoopBreaks(context, node);

		// Generate the final ending of the scope, called when we break or fail the loop conditional
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::While, node->Location);

		// Get the opcode index after the 'EndScope' instruction
		size_t opcodeIndexAfterEndScope = function->GetCurrentOpcodeIndex();

		// Retreive that jump opcode we made earlier, and set its jump offset
		jumpPastEndScopeWhenConditionMet.JumpOffset = (ByteCodeOffset)(opcodeIndexAfterEndScope - jumpInstructionIndex);
	}

	//***************************************************************************
	void CodeGenerator::GenerateFor(ForNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// If we have a range variable, generate it first
		if (node->RangeVariable != nullptr)
		{
			// Generate code for the variable
			context->Walker->Walk(this, node->RangeVariable, context);
		}

		// If we have a variable
		if (node->ValueVariable != nullptr)
		{
			// Generate code for the variable
			context->Walker->Walk(this, node->ValueVariable, context);
		}
		else if (node->Initialization != nullptr)
		{
			// Generate code for the initialization expression
			context->Walker->Walk(this, node->Initialization, context);
		}

		// Store the index that we'd like to jump back to at the end of the loop
		size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();

		// Generate the beginning of the scope
		function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::For, node->Location);

		// Generate code for the condition of the while statement
		context->Walker->Walk(this, node->Condition, context);

		// Store the index that we generated the opcode
		size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

		// Generate an opcode that will jump if the given conditional-expression is false
		// For now, we'll leave out the "jump to" address as we don't yet know where to go
		// The jump-to address will be filled in upon the post pass
		IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(Instruction::IfFalseRelativeGoTo, DebugOrigin::For, node->Condition->Location);
		ifOpcode.Condition = node->Condition->Access;

		// Generate all the statements code, the continues
		GenerateLoopStatementsAndContinues(context, node);

		// Walk the iterator since that will still come after a continue
		context->Walker->Walk(this, node->Iterator, context);

		// Generate the ending of the scope
		// All continues and proper loops will hit here, however, the loop conditional failing
		// or a break statement being hit will cause this opcode to not be reached, hense the one below
		// The break / loop conditional should be the only ways to exit the loop
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::For, node->Location);

		// After the iterator, do the backwards jump, and then any breaks
		GenerateBackwardsLoopJump(context, backwardsJumpInstructionIndex, node->Location);
		GenerateLoopBreaks(context, node);

		// Jump to wherever the statements inside the if-statement end
		ifOpcode.JumpOffset = (ByteCodeOffset)(function->GetCurrentOpcodeIndex() - ifFalseInstructionIndex);

		// Generate the final ending of the scope, called when we break or fail the loop conditional
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::For, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateScope(ScopeNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Generate the beginning of the scope
		function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::Scope, node->Location);

		// Loop through all the statements and generate opcode for each
		this->GenerateStatements(context, node);

		// Generate the ending of the scope
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Scope, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateLoop(LoopNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Store the index that we'd like to jump back to at the end of the loop
		size_t backwardsJumpInstructionIndex = function->GetCurrentOpcodeIndex();

		// Generate the beginning of the scope
		function->AllocateOpcode<Opcode>(Instruction::BeginScope, DebugOrigin::Loop, node->Location);

		// Generate all the statements code, the continues, the backwards jump, and the breaks
		GenerateLoopStatementsAndContinues(context, node);

		// Generate the ending of the scope
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Loop, node->Location);

		// Do the backwards jump, and then any breaks
		GenerateBackwardsLoopJump(context, backwardsJumpInstructionIndex, node->Location);
		GenerateLoopBreaks(context, node);

		// Generate the final ending of the scope, called when we break on the last iteration
		function->AllocateOpcode<Opcode>(Instruction::EndScope, DebugOrigin::Loop, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateBreak(BreakNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Make an opcode that will jump to the end of the loop
		node->InstructionIndex = function->GetCurrentOpcodeIndex();
		node->JumpOpcode = &function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::Break, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateContinue(ContinueNode*& node, GeneratorContext* context)
	{
		// Get a pointer to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Make an opcode that will jump to the end of the loop
		node->InstructionIndex = function->GetCurrentOpcodeIndex();
		node->JumpOpcode = &function->AllocateOpcode<RelativeJumpOpcode>(Instruction::RelativeGoTo, DebugOrigin::Continue, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateBinaryOperation(BinaryOperatorNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Create the opcode so that we can fill it in
		size_t opcodeStart = function->GetCurrentOpcodeIndex();

		// Grab the token we used for this operator
		Grammar::Enum opToken = node->Operator->TokenId;

		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Store the binary operator info for convenience (shared definition)
		BinaryOperator& info = node->OperatorInfo;

		// If we need to flip the arguments (only matters for the opcode, but in these cases the result should be the same
		if (info.FlipArguments)
		{
			// Swap the left and right operands
			ExpressionNode* oldLeft = node->LeftOperand;
			node->LeftOperand = node->RightOperand;
			node->RightOperand = oldLeft;
		}

		// For debugging...
		DebugOrigin::Enum debug = DebugOrigin::BinaryOperation;

		// We always handle assignment specially since it's actually just the same as a copy opcode
		if (opToken == Grammar::Assignment)
		{
			// Generate code for the left and right operands
			context->Walker->Walk(this, node->LeftOperand, context);
			context->Walker->Walk(this, node->RightOperand, context);

			// Pull out things we need
			Type* type = node->RightOperand->ResultType;
			Operand& source = node->RightOperand->Access;
			Operand& destination = node->LeftOperand->Access;

			// If this is a strict property set...
			if (node->LeftOperand->IoUsage & IoMode::StrictPropertySet)
			{
				// We actually need to perform initialization, despite it being an assignment
				// because a strict property set just generates a temporary space to initialize
				CreateCopyOpcode(function, CopyMode::Initialize, type, source, destination, debug, node->Location);
			}
			else
			{
				// This is just a straight assignment copy
				CreateCopyOpcode(function, CopyMode::Assignment, type, source, destination, debug, node->Location);
			}
		}
		// If the operator results in an l-value...
		else if (info.Io & IoMode::WriteLValue)
		{
			// Generate code for the left and right operands
			context->Walker->Walk(this, node->LeftOperand, context);
			context->Walker->Walk(this, node->RightOperand, context);

			// Create the opcode
			BinaryLValueOpcode& opcode = function->AllocateOpcode<BinaryLValueOpcode>(info.Instruction, debug, node->Location);

			// All l-value binary operations result in a chained left hand value,
			// therefore we use the same primary and secondary index as the left operand
			// (no register allocation should ever be needed)
			node->Access = node->LeftOperand->Access;

			// We output to the left operand, and our right operand is the right expression
			opcode.Output = node->LeftOperand->Access;
			opcode.Right = node->RightOperand->Access;
		}
		// Otherwise, the operator results in an r-value...
		else
		{
			// All r-value binary operations result in a value (temporary) on the stack
			// Therefore we need to allocate a register to store our result in
			CreateLocal(function, node->ResultType->GetCopyableSize(), node->Access);

			// Handle the short-circuit operators specially
			if (opToken == Grammar::LogicalAnd || opToken == Grammar::LogicalOr)
			{
				// The first thing we do is always walk the left, because we could end up not running the right's opcode
				context->Walker->Walk(this, node->LeftOperand, context);

				// In both short circuit cases, we generate an if-jump that jumps after the right opcode
				Instruction::Enum ifInstruction = Instruction::InvalidInstruction;

				// For a logical 'and', we need to evaluate the first argument and if it returns false we early out
				if (opToken == Grammar::LogicalAnd)
				{
					ifInstruction = Instruction::IfFalseRelativeGoTo;
				}
				// For a logical 'or', we need to evaluate the first argument and if it returns true we early out
				else
				{
					ifInstruction = Instruction::IfTrueRelativeGoTo;
				}

				// OPTIMIZATION:
				// This could be removed if we just had the left operand directly output to our own local, instead of its own
				// Copy the resulting value from the left to the output, even though it may not be the final result
				GenerateCopyInitialize
					(
					function,
					node->ResultType,
					node->LeftOperand->Access,
					node->Access,
					DebugOrigin::BinaryOperation,
					node->Location
					);

				// Store the index that we generated the if opcode (so we know how far to relative jump)
				size_t ifFalseInstructionIndex = function->GetCurrentOpcodeIndex();

				// The condition (regardless of whether testing false or true) is always based on the left argument
				IfOpcode& ifOpcode = function->AllocateOpcode<IfOpcode>(ifInstruction, DebugOrigin::BinaryOperation, node->Location);
				ifOpcode.Condition = node->LeftOperand->Access;

				// Now generate opcode to evaluate the right argument
				context->Walker->Walk(this, node->RightOperand, context);

				// OPTIMIZATION: (see above)
				// This could be removed if we just had the right operand directly output to our own local, instead of its own
				// Copy the resulting value from the right to the output, if this occurs it will always be the final result (may be skipped by above if)
				// Not that it really matters for value types, but this copy is an 'Assignment', because technically the local will always be initialized above
				CreateCopyOpcode
					(
					function,
					CopyMode::Assignment,
					node->ResultType,
					node->RightOperand->Access,
					node->Access,
					DebugOrigin::BinaryOperation,
					node->Location
					);

				// The jump we generated before will skip directly to here, after the right argument gets evaluated
				size_t opcodeIndexAfterStatements = function->GetCurrentOpcodeIndex();
				ifOpcode.JumpOffset = (ByteCodeOffset)(opcodeIndexAfterStatements - ifFalseInstructionIndex);
			}
			else
			{
				// Note: The walkers MUST come before allocating the opcode (makes sense) otherwise the parent
				// opcode will run before the children's opcode get evaluated
				// Generate code for the left and right operands
				context->Walker->Walk(this, node->LeftOperand, context);
				context->Walker->Walk(this, node->RightOperand, context);

				// Create the opcode
				BinaryRValueOpcode& opcode = function->AllocateOpcode<BinaryRValueOpcode>(info.Instruction, debug, node->Location);

				// We always output to the stack
				opcode.Output = node->Access.HandleConstantLocal;

				// Initialize both operands
				opcode.Left = node->LeftOperand->Access;
				opcode.Right = node->RightOperand->Access;

				// The size is needed for some operations, such as value comparison
				opcode.Size = node->LeftOperand->ResultType->GetCopyableSize();
			}
		}

		// Error checking
		ErrorIf(opcodeStart == function->GetCurrentOpcodeIndex(), "No instructions were written!");

		// We have to generate set functions for any properties that need it
		GeneratorContext propContext;
		propContext.FunctionStack.push_back(function);
		this->PropertySetWalker.Walk(this, node->LeftOperand, &propContext);
		propContext.FunctionStack.pop_back();
	}

	//***************************************************************************
	void CodeGenerator::GeneratePropertyDelegateOperation(PropertyDelegateOperatorNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Attempt to get the operand as a member access node...
		// This operator only works on properties and members
		MemberAccessNode* member = TypeBinding::DynamicCast<MemberAccessNode*>(node->Operand);

		// We already verified that this was a member access in 
		ErrorIf(member == nullptr,
			"Somehow our operand was not a MemberAccessNode, even though we verified that in the Syntaxer");

		// Normally we would walk the operand, but we need to only
		// walk the operand's left since we're ignoring the property
		context->Walker->Walk(this, member->LeftOperand, context);

		// The 'this' of the property is going to be the left operand (who we're accessing the property on)
		Type* thisType = member->LeftOperand->ResultType;
		Operand& thisSource = member->LeftOperand->Access;

		// Create a location on the stack to store the 'this' handle
		OperandLocal thisHandle = function->AllocateRegister(sizeof(Handle));

		// Make sure that we make a handle out of the left argument (will be used as our this handle)
		// We'll save this new handle on the stack in the location that we allocated above
		GenerateHandleInitialize
			(
			function,
			thisType,
			thisSource,
			Operand(thisHandle),
			DebugOrigin::FunctionMemberAccess,
			node->Location
			);

		// Make an opcode that will jump to the end of the loop
		CreatePropertyDelegateOpcode& opcode = function->AllocateOpcode<CreatePropertyDelegateOpcode>(Instruction::PropertyDelegate, DebugOrigin::PropertyDelegate, node->Location);

		// Tell the opcode the type it will be creating (this cast should always be safe, because property delegates are always bound types)
		opcode.CreatedType = (BoundType*)node->ResultType;

		// Setup the 'this' handle from where we get the properties
		opcode.ThisHandleLocal = thisHandle;

		// Setup the save handle where the property delegate goes
		// This expression's result will be stored in the last created register
		CreateLocal(function, sizeof(Handle), node->Access);
		opcode.SaveHandleLocal = node->Access.HandleConstantLocal;

		// Tell the opcode the getter and setter functions it will be using from the accessed property
		opcode.Get = node->AccessedProperty->Get;
		opcode.Set = node->AccessedProperty->Set;
	}

	//***************************************************************************
	void CodeGenerator::GenerateUnaryOperation(UnaryOperatorNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Generate code for the only operand
		context->Walker->Walk(this, node->Operand, context);

		// Generate the binary operator instructions, and also make sure to set our register/secondary index and access modes
		GenerateUnaryOp(function, *node, DebugOrigin::UnaryOperation);

		// We have to generate set functions for any properties that need it
		GeneratorContext propContext;
		propContext.FunctionStack.push_back(function);
		this->PropertySetWalker.Walk(this, node->Operand, &propContext);
		propContext.FunctionStack.pop_back();
	}

	//***************************************************************************
	void CodeGenerator::GenerateMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
	{
		if (node->MemberType == MemberAccessType::Field)
		{
			GenerateFieldAccess(node, context);
		}
		else if (node->MemberType == MemberAccessType::Function)
		{
			GenerateFunctionDelegateMemberAccess(node, context);
		}
		else if (node->MemberType == MemberAccessType::Property)
		{
			GeneratePropertyGetMemberAccess(node, context);
		}
		else if (node->MemberType == MemberAccessType::Dynamic)
		{
			//GenerateDynamicGetMemberAccess(node, context);
		}
		else
		{
			Error("A member access type was used that we didn't know about, or memory got corrupted");
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateFieldAccess(MemberAccessNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// For the awkward reason that type refernces are post expressions, we need to check
		if (node->LeftOperand != nullptr)
		{
			// Generate the code for the left operand
			context->Walker->Walk(this, node->LeftOperand, context);
		}

		// Note: In the case where we're accessing a static from a type reference the
		// 'node->LeftOperand' will always be null, but note we do not need it (no this handle)!

		// Get the resulting type
		Type* type = node->LeftOperand->ResultType;

		// Delegates will need a special
		ErrorIf(TypeBinding::DynamicCast<DelegateType*>(type) != nullptr,
			"I haven't properly handled accessing members on delegates yet, see below");

		// If the left-hand type is a handle (indirection type or a reference type)...
		if (Type::IsHandleType(type))
		{
			// Set the handle index to be the left's primary index
			OperandIndex handleIndex = node->LeftOperand->Access.HandleConstantLocal;

			// If the left type is accessed as a data member... (we need to copy it onto the stack!)
			if (node->LeftOperand->Access.Type == OperandType::Field)
			{
				// Allocate a register to store the handle
				handleIndex = function->AllocateRegister(type->GetCopyableSize());

				// Generate a copy to bring the handle to the local register
				// Since we are not assigning (we're copying this to the stack) then
				// this is a copy over uninitialized memory
				GenerateCopyInitialize
					(
					function,
					type,
					node->LeftOperand->Access,
					Operand(handleIndex),
					DebugOrigin::DataMemberAccess,
					node->Location
					);
			}

			// Set our primary index to be the handle index
			node->Access.HandleConstantLocal = handleIndex;

			// Use the member index into the class
			node->Access.Field = node->AccessedField->Offset;

			// We are accessed as a field...
			node->Access.Type = OperandType::Field;
		}
		// If the left-hand type is a data-type / value...
		else
		{
			// If the left hand side is entirely on the stack
			if (node->LeftOperand->Access.Type == OperandType::Local)
			{
				// Simply just offset the primary index so that it points at the member on the stack
				node->Access.HandleConstantLocal = node->LeftOperand->Access.HandleConstantLocal + node->AccessedField->Offset;

				// Our secondary index is zero since we don't use it
				node->Access.Field = 0;

				// Just treat this as if it's just any other local on the stack
				node->Access.Type = OperandType::Local;
			}
			// If the left hand side is still being accessed as a field
			else if (node->LeftOperand->Access.Type == OperandType::Field)
			{
				// This expression's result will be stored in the newly added register
				node->Access.HandleConstantLocal = node->LeftOperand->Access.HandleConstantLocal;

				// Use the member index into the class
				node->Access.Field = node->LeftOperand->Access.Field + node->AccessedField->Offset;

				// We are accessed as a field...
				node->Access.Type = OperandType::Field;
			}
			else
			{
				// We should never be able to get here
				Error("Unhandled case");
			}
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateFunctionDelegateMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// For the awkward reason that type refernces are post expressions, we need to check
		if (node->LeftOperand != nullptr)
		{
			// Generate the code for the left operand
			context->Walker->Walk(this, node->LeftOperand, context);
		}

		// A temporary barrier whilst we don't have a way to resolve overloads with anything other than function calls
		if (node->AccessedFunction == nullptr)
			return;

		// Note: In the case where we're accessing a static from a type reference the
		// 'node->LeftOperand' will always be null, but note we do not need it (no this handle)!

		// If the function we're calling is a member function (not a static function)
		if (node->AccessedFunction->This != nullptr)
		{
			this->CreateInstanceDelegateAndThisHandle
				(
				function,
				node->AccessedFunction,
				node->LeftOperand->ResultType, // Note that the left operand in a member access is the object ('this')
				node->LeftOperand->Access,
				node->Access,
				(node->Operator->TokenId != Grammar::NonVirtualAccess),
				node->Location,
				DebugOrigin::FunctionMemberAccess
				);
		}
		else
		{
			this->CreateStaticDelegate
				(
				function,
				node->AccessedFunction,
				node->Access,
				node->Location,
				DebugOrigin::FunctionMemberAccess
				);
		}
	}

	//***************************************************************************
	void CodeGenerator::GeneratePropertyGetMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// For the awkward reason that type references are post expressions, we need to check
		if (node->LeftOperand != nullptr)
		{
			// Generate the code for the left operand
			context->Walker->Walk(this, node->LeftOperand, context);
		}

		// Note: In the case where we're accessing a static from a type reference the
		// 'node->LeftOperand' will always be null, but note we do not need it (no this handle)!

		// Get the property for ease of use
		Property* property = node->AccessedProperty;

		// Check if we're even being read
		if ((node->IoUsage & IoMode::ReadRValue) != 0)
		{
			// Get the 'get' for ease of use
			Function* get = property->Get;

			// We generate a delegate before calling the function
			Operand delegateLocal;

			// If the get function we're calling is a member function (not a static function)
			if (get->This != nullptr)
			{
				this->CreateInstanceDelegateAndThisHandle
					(
					function,
					get,
					node->LeftOperand->ResultType, // Note that the left operand in a member access is the object ('this')
					node->LeftOperand->Access,
					delegateLocal,
					(node->Operator->TokenId != Grammar::NonVirtualAccess),
					node->Location,
					DebugOrigin::PropertyGetMemberAccess
					);
			}
			else
			{
				this->CreateStaticDelegate
					(
					function,
					get,
					delegateLocal,
					node->Location,
					DebugOrigin::PropertyGetMemberAccess
					);
			}

			// Generate opcode for calling the function (we still need to copy arguments ourselves)
			GenerateCallOpcodePreArgs(function, get->Type, delegateLocal, node->Location, DebugOrigin::PropertyGetMemberAccess);

			// Generate opcode for finishing up the call to the function
			GenerateCallOpcodePostArgs(function, get->Type, &node->Access, node->Location, DebugOrigin::PropertyGetMemberAccess);
		}
		// Check if we're ONLY being written to
		else if ((node->IoUsage & IoMode::WriteLValue) != 0)
		{
			// We need to let any assignments know that this is NOT an initialized
			// value, and therefore the copy must also perform initialization!
			// Note: Assignment should be the only thing possible with a set-only property
			node->IoUsage = (IoMode::Enum)(node->IoUsage | IoMode::StrictPropertySet);

			// Make space that any operator will write to
			CreateLocal(function, property->PropertyType->GetCopyableSize(), node->Access);
		}
		else
		{
			// Otherwise, we're not being used by anything
			ErrorIf(node->IoUsage != IoMode::Ignore, "Unexpected case");
		}
	}

	//***************************************************************************
	void CodeGenerator::GeneratePropertySetMemberAccess(MemberAccessNode*& node, GeneratorContext* context)
	{
		// If this node is a property, we don't care about it
		if (node->MemberType != MemberAccessType::Property)
		{
			return;
		}

		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Note: We never need to walk the left operand (it was already done)

		// Check if we're even being written to
		if ((node->IoUsage & IoMode::WriteLValue) != 0)
		{
			// Get the property for ease of use
			Property* property = node->AccessedProperty;
			Function* set = property->Set;

			// We generate a delegate before calling the function
			Operand delegateLocal;

			// If the set function we're calling is a member function (not a static function)
			if (set->This != nullptr)
			{
				this->CreateInstanceDelegateAndThisHandle
					(
					function,
					set,
					node->LeftOperand->ResultType, // Note that the left operand in a member access is the object ('this')
					node->LeftOperand->Access,
					delegateLocal,
					(node->Operator->TokenId != Grammar::NonVirtualAccess),
					node->Location,
					DebugOrigin::PropertySetMemberAccess
					);
			}
			else
			{
				this->CreateStaticDelegate
					(
					function,
					set,
					delegateLocal,
					node->Location,
					DebugOrigin::PropertySetMemberAccess
					);
			}

			// Generate opcode for calling the function (we still need to copy arguments ourselves)
			GenerateCallOpcodePreArgs(function, set->Type, delegateLocal, node->Location, DebugOrigin::PropertySetMemberAccess);

			// Check if we were read, then we assume that 'get' was
			// already called, and our modified value is on the stack
			if ((node->IoUsage & IoMode::ReadRValue) != 0)
			{
				// Note: In the case where 'get'  was called, we know our ResultType is the property type
				ErrorIf(node->ResultType != property->PropertyType,
					"The resulting type when a property has 'get' called on it should be the property type");

				// Generate the opcode for copying a parameter in a function call
				GenerateCopyToParameter
					(
					function,
					node->ResultType,
					node->Access,
					set->Type->Parameters.front().StackOffset,
					DebugOrigin::PropertySetMemberAccess,
					node->Location
					);
			}
			else
			{
				// Generate the opcode for copying a parameter in a function call
				GenerateCopyToParameter
					(
					function,
					property->PropertyType,
					node->Access,
					set->Type->Parameters.front().StackOffset,
					DebugOrigin::PropertySetMemberAccess,
					node->Location
					);
			}

			// Generate opcode for finishing up the call to the function
			GenerateCallOpcodePostArgs(function, set->Type, nullptr, node->Location, DebugOrigin::PropertySetMemberAccess);
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateInitializer(InitializerNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// If the function we're calling is a member function (not a static function)
		if (node->InitializerFunction->This != nullptr)
		{
			this->CreateInstanceDelegateAndThisHandle
				(
				function,
				node->InitializerFunction,
				function->This->ResultType,     // The this type is the type we're compiling
				Operand(function->This->Local), // Get the 'this' handle from the local variable
				node->Access,
				false,
				node->Location,
				DebugOrigin::FunctionMemberAccess
				);
		}
		else
		{
			this->CreateStaticDelegate
				(
				function,
				node->InitializerFunction,
				node->Access,
				node->Location,
				DebugOrigin::FunctionMemberAccess
				);
		}
	}

	//***************************************************************************
	template <typename T>
	T& CodeGenerator::DelegateOpcode
		(
		Function*           caller,
		Function*           toCall,
		OperandIndex        delegateDest,
		const CodeLocation& location,
		Instruction::Enum   instruction,
		DebugOrigin::Enum   debug
		)
	{
		// Create an opcode that will create a delegate
		T& opcode = caller->AllocateOpcode<T>(instruction, debug, location);
		opcode.BoundFunction = toCall;

		// We'll save the delegate at the location indicated by this node
		opcode.SaveLocal = delegateDest;

		// Return the allocated opcode
		return opcode;
	}

	//***************************************************************************
	void CodeGenerator::CreateInstanceDelegateAndThisHandle
		(
		Function*           caller,
		Function*           toCall,
		Type*               thisType,
		const Operand&      thisSource,
		Operand&            delegateDestOut,
		bool                canBeVirtual,
		const CodeLocation& location,
		DebugOrigin::Enum   debug
		)
	{
		// Note: 'thisSource' is NOT necessarily a handle
		// as it is possible to invoke a function on value types (we need to generate a handle for those cases)
		// By default we just assume the source is a handle
		Operand thisHandle = thisSource;

		// If the type is not already a handle, we need to make a handle for it on the stack
		if (Type::IsHandleType(thisType) == false)
		{
			// Create a location on the stack to store the 'this' handle
			OperandLocal thisHandleLocal = caller->AllocateRegister(sizeof(Handle));
			thisHandle = Operand(thisHandleLocal);

			// Make sure that we make a handle out of the left argument (will be used as our this handle)
			// We'll save this new handle on the stack in the location that we allocated above
			GenerateHandleInitialize
				(
				caller,
				thisType,
				thisSource,
				Operand(thisHandleLocal),
				DebugOrigin::FunctionMemberAccess,
				location
				);
		}

		// Now create the delegate (the 'this' handle could be copied, or not)
		this->CreateInstanceDelegateWithThisHandle
			(
			caller,
			toCall,
			thisHandle,
			delegateDestOut,
			canBeVirtual,
			location,
			debug
			);
	}

	//***************************************************************************
	void CodeGenerator::CreateInstanceDelegateWithThisHandle
		(
		Function*           caller,
		Function*           toCall,
		const Operand&      thisHandle,
		Operand&            delegateDestOut,
		bool                canBeVirtual,
		const CodeLocation& location,
		DebugOrigin::Enum   debug
		)
	{
		// This expression's result will be stored in the last created register
		CreateLocal(caller, toCall->Type->GetCopyableSize(), delegateDestOut);

		// Create an instance delegate opcode
		CreateInstanceDelegateOpcode& delegateOpcode = DelegateOpcode<CreateInstanceDelegateOpcode>
			(
			caller,
			toCall,
			delegateDestOut.HandleConstantLocal,
			location,
			Instruction::CreateInstanceDelegate,
			debug
			);

		// Mark whether or not this member can be virtual
		delegateOpcode.CanBeVirtual = canBeVirtual;

		// Let the delegate know where to get it's 'this' handle from
		delegateOpcode.ThisHandle = thisHandle;
	}

	//***************************************************************************
	void CodeGenerator::CreateStaticDelegate
		(
		Function*           caller,
		Function*           toCall,
		Operand&            delegateDest,
		const CodeLocation& location,
		DebugOrigin::Enum   debug
		)
	{
		// This expression's result will be stored in the last created register
		CreateLocal(caller, toCall->Type->GetCopyableSize(), delegateDest);

		// Create a static delegate opcode
		DelegateOpcode<CreateStaticDelegateOpcode>
			(
			caller,
			toCall,
			delegateDest.HandleConstantLocal,
			location,
			Instruction::CreateStaticDelegate,
			debug
			);
	}

	//***************************************************************************
	void CodeGenerator::GenerateTypeCast(TypeCastNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Generate the code for the operand of the type cast
		context->Walker->Walk(this, node->Operand, context);

		// Generate a copy opcode for the return type to the return value
		// (also puts the result in a register and sets this node's register index)
		GenerateConversion(function, *node, DebugOrigin::TypeCast);
	}

	//***************************************************************************
	void CodeGenerator::GenerateTypeId(TypeIdNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// If we have a value...
		if (node->Value != nullptr)
		{
			// Technically the expression inside a type-id does not need
			// to be run, but just for the principle of least surprise
			context->Walker->Walk(this, node->Value, context);
		}

		// We treat the type as a constant
		node->Access.Type = OperandType::Constant;
		node->Access.Field = 0;

		// Create a handle in constant space for the type pointer
		Handle& handle = function->AllocateConstant<Handle>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal);

		// Set the handle manager and type of the handle
		// We know explicitly that the string handle manager is a shared manager
		HandleManagers& managers = HandleManagers::GetInstance();
		handle.Manager = managers.GetSharedManager(ZilchManagerId(PointerManager));
		handle.Type = node->ResultType->ZilchGetDerivedType();

		// Store the pointer to the compile time type into the handle
		handle.Manager->ObjectToHandle((byte*)node->CompileTimeType, handle);
	}

	//***************************************************************************
	void CodeGenerator::GenerateLocalVariableReference(LocalVariableReferenceNode*& node, GeneratorContext* /*context*/)
	{
		// Point to the exact same register as the local variable
		node->Access.HandleConstantLocal = node->AccessedVariable->Local;

		// We have no secondary index
		node->Access.Field = 0;

		// We are accessing a local variable on the stack
		node->Access.Type = OperandType::Local;
	}

	//***************************************************************************
	void CodeGenerator::GenerateReturnValue(ReturnNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Loop through all the return values
		if (node->ReturnValue != nullptr)
		{
			// Store the return value for convenience
			ExpressionNode* returnValue = node->ReturnValue;

			// Generate the code for the current return expression
			context->Walker->Walk(this, returnValue, context);

			// Generate a copy opcode for the return type to the return value
			// The return value should be uninitialized memory before this point
			// so this must be an initialized copy
			GenerateCopyToReturn
				(
				function,
				returnValue->ResultType,
				returnValue->Access,
				Operand(0),
				DebugOrigin::ReturnValue,
				returnValue->Location
				);
		}

		// Generate the return opcode, which simply just stops execution of a function
		function->AllocateArgumentFreeOpcode(Instruction::Return, DebugOrigin::ReturnValue, node->Location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateFunctionCall(FunctionCallNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Generate the code for the left operand first
		context->Walker->Walk(this, node->LeftOperand, context);

		// Note: We generate code for the passed in arguments below, but we needed to do the left
		//       expression right here since we immediately grab its delegate type and start using it
		Operand delegateLocal;

		// Store the delegate type that we'll be calling
		DelegateType* delegateType = nullptr;

		// For debugging purposes
		DebugOrigin::Enum debugOrigin = DebugOrigin::FunctionCall;

		// We need to generate access for a return value (except in some cases, like creation calls!)
		Operand* returnValueAccess = &node->Access;

		// If the left hand node is a creation call node (basicall is this a constructor?)...
		if (CreationCallNode* creationNode = TypeBinding::DynamicCast<CreationCallNode*>(node->LeftOperand))
		{
			// A creation call does not return a handle to the created value, primarily because
			// we do not know whether it is being allocated as a handle or as a local!
			// Therefore, it always returns void (however, we definately do not want to generate anything for returns)
			returnValueAccess = nullptr;

			// Update the debug origin to be a little more clear (we're in a constructor)
			debugOrigin = DebugOrigin::FunctionCallConstructor;

			// Technically this constructor call comes above the actual new/local in the syntax tree
			// which means that whoever is referencing the new/local will actually be getting our FunctionCallNode result
			// Because this is specifically a constructor, we need to return exactly what the left operand returns
			// Our result type should have already been set in the syntaxer phase
			node->Access = creationNode->Access;

			// If we have no constructor function (eg the default constructor, or just pre-constructor)
			if (creationNode->ConstructorFunction == nullptr)
			{
				// Return early, since there is no function call to be made
				return;
			}

			// Create an instance delegate for the constructor
			this->CreateInstanceDelegateWithThisHandle
				(
				function,
				creationNode->ConstructorFunction,
				Operand(creationNode->ThisHandleLocal),
				delegateLocal,
				false,
				node->Location,
				debugOrigin
				);

			// The delegate type should be grabbed from the contstructor
			delegateType = creationNode->ConstructorFunction->Type;
		}
		else
		{
			// The delegate local is the left expression
			delegateLocal = node->LeftOperand->Access;

			// The delegate type should be grabbed from the left operand
			delegateType = TypeBinding::DynamicCast<DelegateType*>(node->LeftOperand->ResultType);
		}

		// Generate opcode for calling the function (we still need to copy arguments ourselves)
		GenerateCallOpcodePreArgs(function, delegateType, delegateLocal, node->Location, debugOrigin);

		ZilchTodo("Parameters are currently not re-ordered");

		// Loop through all the function's parameters
		for (size_t i = 0; i < node->Arguments.size(); ++i)
		{
			// Get the expression node that will be placed into the parameter
			ExpressionNode* currentArgument = node->Arguments[i];

			// Generate the code for the current expression
			context->Walker->Walk(this, currentArgument, context);

			// Generate the opcode for copying a parameter in a function call
			GenerateCopyToParameter
				(
				function,
				currentArgument->ResultType,
				currentArgument->Access,
				delegateType->Parameters[i].StackOffset,
				DebugOrigin::FunctionCall,
				currentArgument->Location
				);
		}

		// Generate opcode for finishing up the call to the function
		GenerateCallOpcodePostArgs(function, delegateType, returnValueAccess, node->Location, debugOrigin);
	}

	//***************************************************************************
	void CodeGenerator::GenerateCallOpcodePreArgs
		(
		Function* caller,
		DelegateType* delegateTypeToCall,
		const Operand& delegateOperand,
		const CodeLocation& location,
		DebugOrigin::Enum debugOrigin
		)
	{
		// Record the current offset in instructions (this is not where we will jump to)
		size_t opcodePosBeforeThisCopy = caller->GetCurrentOpcodeIndex();

		// Allocate the prep-for-function instruction, and give it the index that the 
		// function lives as well as the register that we'd like to store the return value
		PrepForFunctionCallOpcode& prepOpcode = caller->AllocateOpcode<PrepForFunctionCallOpcode>(Instruction::PrepForFunctionCall, debugOrigin, location);
		prepOpcode.Delegate = delegateOperand;

		// We basically always generate the copy opcode for copying a 'this' parameter, even when its a static function
		// That being said, this opcode will be skipped if the PrepForFunctionCall opcode determines that the calling function is not static
		// Note that the calling convention is currently that the 'this' object goes last, but that it's the first opcode to be run
		// Being last in memory allows it to be easily omitted for static function calls
		// Being the first opcode to run allows the opcode to easily be skipped after the PrepForFunctionCall
		// See CodeGenerator.cpp, approximately line 292, in the function FunctionContext is the counterpart to this explanation
		{
			// Determine the position of the handle (it resides inside the delegate)
			Operand handleOperand = delegateOperand;

			if (handleOperand.Type == OperandType::Field)
			{
				handleOperand.Field += offsetof(Delegate, ThisHandle);
			}
			else
			{
				handleOperand.HandleConstantLocal += offsetof(Delegate, ThisHandle);
			}

			// Get the instance of the type database
			Core& core = Core::GetInstance();

			// Copy the handle from the delegate local into the first argument
			GenerateCopyToParameter
				(
				caller,
				core.NullType,
				handleOperand,
				delegateTypeToCall->ThisHandleStackOffset,
				debugOrigin,
				location
				);
		}

		// We want to jump to the next opcode if the function is static
		prepOpcode.JumpOffsetIfStatic = (OperandIndex)(caller->GetCurrentOpcodeIndex() - opcodePosBeforeThisCopy);
	}

	//***************************************************************************
	void CodeGenerator::GenerateCallOpcodePostArgs
		(
		Function* caller,
		DelegateType* delegateTypeToCall,
		Operand* returnAccessOut,
		const CodeLocation& location,
		DebugOrigin::Enum debugOrigin
		)
	{
		// Generate an opcode for a function call (the last parameter is where the return value will be stored)
		caller->AllocateArgumentFreeOpcode(Instruction::FunctionCall, debugOrigin, location);

		// Grab the core
		Core& core = Core::GetInstance();

		// In certain cases it is possible that we're not even able to get the return value (even if it is void!)
		// For example, the case of a setter (technically returns void, which is storable, but cannot every be accessed)
		// In these cases, the 'returnAccessOut' will be null since there's nothing to return
		if (returnAccessOut != nullptr)
		{
			// Note: We used to have an exception here for Void types (we wouldn't generate a return because they could not be stored)
			// Now void types can actually be stored, so therefore we must create a local for the void type
			// Having said that, a Void type has a size of 0 (creating a 0 sized local does nothing)
			// Moreover, we should also not copy the void type to the return, as there is nothing to copy (optimization and sanity!)

			// Note: There was a previous bug where we relied upon the node->ResultType as our return, which is true
			// for all function calls, however this is not the case in terms of constructor calls
			// A constructor call's delegateType will always be null (and for a function, it should be the same as node->ResultType)

			// This function call's result will be stored in the last created register
			CreateLocal(caller, delegateTypeToCall->Return->GetCopyableSize(), *returnAccessOut);

			// Generate the opcode for copying a return in a function call
			GenerateCopyFromReturn
				(
				caller,
				delegateTypeToCall->Return,
				0,
				returnAccessOut->HandleConstantLocal,
				debugOrigin,
				location
				);
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateStringInterpolants(StringInterpolantNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// We need to create a temporary string builder that we use to efficiently concatenate strings together
		function->AllocateOpcode<BeginStringBuilderOpcode>(Instruction::BeginStringBuilder, DebugOrigin::StringInterpolant, node->Location);

		// Walk through all the children we want to stringify
		for (size_t i = 0; i < node->Elements.size(); ++i)
		{
			// Get the current element (it may be a string itself...)
			ExpressionNode* elementNode = node->Elements[i];

			// Make sure we generate code for the element expression
			context->Walker->Walk(this, elementNode, context);

			// Set the register indices for the operands, and set the location that the result should be stored into
			AddToStringBuilderOpcode& opcode = function->AllocateOpcode<AddToStringBuilderOpcode>(Instruction::AddToStringBuilder, DebugOrigin::StringInterpolant, node->Location);
			opcode.Value = elementNode->Access;
			opcode.TypeToConvert = elementNode->ResultType;
		}

		// Make space for the string local (the string should be the result type)
		CreateLocal(function, node->ResultType->GetCopyableSize(), node->Access);

		// Finish off the string builder (with all our additions to it) and store the resulting string on the stack
		EndStringBuilderOpcode& endOpcode = function->AllocateOpcode<EndStringBuilderOpcode>(Instruction::EndStringBuilder, DebugOrigin::StringInterpolant, node->Location);
		endOpcode.SaveStringHandleLocal = node->Access.HandleConstantLocal;
	}

	//***************************************************************************
	void CodeGenerator::CollectValue(ValueNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// A value is always a constant
		node->Access.Type = OperandType::Constant;

		// We have no secondary index
		node->Access.Field = 0;

		// Based off the type of token...
		switch (node->Value.TokenId)
		{
			// The value is an integer
		case Grammar::IntegerLiteral:
		{
			// Read the value as an Integer (and allocate a constant for it)
			function->AllocateConstant<Integer>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = atoi(node->Value.Token.c_str());
			break;
		}

		// The value is an double integer
		case Grammar::DoubleIntegerLiteral:
		{
			// Read the value as an Integer (and allocate a constant for it)
			function->AllocateConstant<DoubleInteger>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = ZilchStrToDoubleInteger(node->Value.Token.c_str(), 10);
			break;
		}

		// The value is a real
		case Grammar::RealLiteral:
		{
			// Read the value as a Real (and allocate a constant for it)
			function->AllocateConstant<Real>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = (Real)atof(node->Value.Token.c_str());
			break;
		}

		// The value is a double real
		case Grammar::DoubleRealLiteral:
		{
			// Read the value as a DoubleReal (and allocate a constant for it)
			function->AllocateConstant<DoubleReal>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = (DoubleReal)atof(node->Value.Token.c_str());
			break;
		}

		// The value is a string
		case Grammar::StringLiteral:
		{
			// Get a reference to the core library
			Core& core = Core::GetInstance();

			// Create a new handle that will point at a string node
			Handle& handle = function->AllocateConstant<Handle>(core.StringType->GetCopyableSize(), node->Access.HandleConstantLocal);

			// Set the handle manager and type of the handle
			// We know explicitly that the string handle manager is a shared manager
			HandleManagers& managers = HandleManagers::GetInstance();
			handle.Manager = managers.GetSharedManager(ZilchManagerId(StringManager));
			handle.Type = core.StringType;

			// The token is always stored in it's original vanilla form
			// We need to get rid of any quotes and perform escape replacements
			String& token = node->Value.Token;
			String unescapedString = ReplaceStringEscapesAndStripQuotes(token);

			// Create the string literal in the library builder
			const String& stringLiteral = this->Builder->AddStringLiteral(unescapedString);

			// Copy a string into the handle
			// This method will actually increase the reference count
			// which means we would need to store an array of destructors for constant memory (which we do)
			handle.Manager->ObjectToHandle((byte*)&stringLiteral, handle);
			break;
		}

		// The value is a bool
		case Grammar::True:
		{
			// Read the value as a "real" (and allocate a constant for it)
			function->AllocateConstant<Boolean>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = true;
			break;
		}

		// The value is a bool
		case Grammar::False:
		{
			// Read the value as a "real" (and allocate a constant for it)
			function->AllocateConstant<Boolean>(node->ResultType->GetCopyableSize(), node->Access.HandleConstantLocal) = false;
			break;
		}

		// The value is a null
		case Grammar::Null:
		{
			ZilchTodo("We probably want to eventually share null constants, also examine the behavior of using sizeof(Delegate)!");

			// At the moment, since we use null for handles, delegates, etc, we just allocate wiped space (with 0s) that
			// is big enough to support all nullable things (all primtives support being set to all 0)
			size_t largeIndex;
			byte* data = function->Constants.Allocate(sizeof(Delegate), nullptr, &largeIndex);
			memset(data, 0, sizeof(Delegate));
			node->Access.HandleConstantLocal = (OperandIndex)largeIndex;
			break;
		}

		default:
		{
			// We don't know what type it is???
			// This especially should not be an identifier, since identifiers are caught as VariableReferences
			Error("The node was marked as being a value node, but had a token that was not recognizable as a value type");
		}
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateDelete(DeleteNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Make sure we generate code for the deleted object expression (its most likely a variable reference)
		context->Walker->Walk(this, node->DeletedObject, context);

		// Set the register indices for the operands, and set the location that the result should be stored into
		DeleteObjectOpcode& opcode = function->AllocateOpcode<DeleteObjectOpcode>(Instruction::DeleteObject, DebugOrigin::DeleteObject, node->Location);
		opcode.Object = node->DeletedObject->Access;
	}

	//***************************************************************************
	void CodeGenerator::GenerateThrow(ThrowNode*& node, GeneratorContext* context)
	{
		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// Make sure we generate code for the exception expression
		context->Walker->Walk(this, node->Exception, context);

		// Set the register indices for the operands, and set the location that the result should be stored into
		ThrowExceptionOpcode& opcode = function->AllocateOpcode<ThrowExceptionOpcode>(Instruction::ThrowException, DebugOrigin::ThrowException, node->Location);
		opcode.Exception = node->Exception->Access;
	}

	//***************************************************************************
	void CodeGenerator::GenerateCreationInitializer(CreationInitializerNode*& node, GeneratorContext* context)
	{
		// Walk the left operand first (allocate and pre-construct an object, then invoke a constructor on it)
		context->Walker->Walk(this, node->LeftOperand, context);

		// Now walk the rest of the statements to invoke 'Add's and initialize members
		context->Walker->Walk(this, node->InitializerStatements, context);

		// Our output is just the output of the construction call
		node->Access = node->LeftOperand->Access;
	}

	//***************************************************************************
	void CodeGenerator::GenerateUnnamedOperand(UnnamedOperandNode*& node, GeneratorContext* context)
	{
		// Forward the access from one to the other
		node->Access = node->ToBeForwarded->Access;
	}

	//***************************************************************************
	void CodeGenerator::GenerateCreationCall(CreationCallNode*& node, GeneratorContext* context)
	{
		// Note: The NewObject/LocalObject opcodes only invoke the pre-constructor (via InvokePreConstructorOrRelease)
		// This pre-constructs all classes up to the base class
		// The function call that has the CreationCallNode as its Operand is what is responsible for invoking the real constructor
		// Constructors walk up and invoke their base constructors, via the InitializerNode

		// Get a reference to the current function that we're building
		Function* function = context->FunctionStack.back();

		// This expression's result will be stored in the last created register
		CreateLocal(function, node->ResultType->GetCopyableSize(), node->Access);

		// If we're creating a heap object with 'new'
		if (node->Mode == CreationMode::New)
		{
			// Set the register indices for the operands, and set the location that the result should be stored into
			CreateTypeOpcode& opcode = function->AllocateOpcode<CreateTypeOpcode>(Instruction::NewObject, DebugOrigin::NewObject, node->Location);
			opcode.SaveHandleLocal = node->Access.HandleConstantLocal;
			opcode.CreatedType = node->CreatedType;

			// We want an object handle for other calls (such as the constructor)
			node->ThisHandleLocal = node->Access.HandleConstantLocal;
		}
		// Otherwise we're creating a local or member object with 'local'
		else
		{
			// Set the register indices for the operands, and set the location that the result should be stored into
			CreateLocalTypeOpcode& opcode = function->AllocateOpcode<CreateLocalTypeOpcode>(Instruction::LocalObject, DebugOrigin::LocalObject, node->Location);
			opcode.CreatedType = node->CreatedType;

			// Error checking
			ErrorIf(node->CreatedType != node->ResultType,
				"The created type should always be the expression type");

			// Allocate space for a handle created to the local object
			// The local creation opcode will generate a handle for us at the specified location
			// This handle gets used in calling the preconstructor (inside the 'LocalObject' instruction)
			// and in calling the actual constructor (inside of 'FunctionCall')
			OperandIndex handleIndex = function->AllocateRegister(this->Builder->ReferenceOf(node->CreatedType)->GetCopyableSize());
			opcode.SaveHandleLocal = handleIndex;

			// The object should be allocated here on the stack
			opcode.StackLocal = node->Access.HandleConstantLocal;

			// We want an object handle for other calls (such as the constructor)
			node->ThisHandleLocal = handleIndex;
		}
	}

	//***************************************************************************
	void CodeGenerator::GenerateHandleInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
	{
		// If the type is a handle...
		if (Type::IsHandleType(type))
		{
			// Since the type of the expression is already a handle, just copy it to the location that the user wants it at
			// This handle is always initializing uninitialized memory on the stack
			GenerateCopyInitialize(function, type, source, destination, debugOrigin, location);
		}
		// If the type is a named-type / value...
		else if (BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type))
		{
			// Allocate an opcode for creating a handle from a local
			ToHandleOpcode& opcode = function->AllocateOpcode<ToHandleOpcode>(Instruction::ToHandle, debugOrigin, location);

			// Get the handle type
			Type* handleType = this->Builder->ReferenceOf(boundType);

			// If we're attempting to generate a handle to a constant, then we want to copy it locally to the stack first
			if (source.Type == OperandType::Constant)
			{
				// Generate a stack local to store the constant
				Operand stackLocal(function->AllocateRegister(type->GetCopyableSize()));

				// Copy the constant to the stack
				this->GenerateCopyInitialize(function, type, source, stackLocal, debugOrigin, location);

				// Create a handle to the stack local
				opcode.ToHandle = stackLocal;
			}
			else
			{
				// Set the value that we want to make a handle of
				opcode.ToHandle = source;
			}

			// Save the handle in a newly allocated register
			opcode.SaveLocal = function->AllocateRegister(handleType->GetCopyableSize());

			// We also need to know the type of this handle
			opcode.Type = boundType;

			// Since the type of the expression is already a handle, just copy it to the location that the user wants it at
			// This handle is always initializing uninitialized memory on the stack
			GenerateCopyInitialize(function, handleType, Operand(opcode.SaveLocal), destination, debugOrigin, location);
		}
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	CodeLocation::CodeLocation() :
		StartLine(1),
		PrimaryLine(1),
		EndLine(1),
		StartCharacter(1),
		PrimaryCharacter(1),
		EndCharacter(1),
		Origin(UnknownOrigin),
		CodeUserData(nullptr),
		IsNative(false)
	{
	}

	//***************************************************************************
	CodeLocation CodeLocation::GetStartOnlyLocation()
	{
		// First copy the current code location, then just change the end and primary to point at the start
		CodeLocation result;
		result = *this;
		result.EndCharacter = result.StartCharacter;
		result.EndLine = result.StartLine;
		result.PrimaryCharacter = result.StartCharacter;
		result.PrimaryLine = result.StartLine;
		return result;
	}

	//***************************************************************************
	CodeLocation CodeLocation::GetEndOnlyLocation()
	{
		// First copy the current code location, then just change the start and primary to point at the end
		CodeLocation result;
		result = *this;
		result.StartCharacter = result.EndCharacter;
		result.StartLine = result.EndLine;
		result.PrimaryCharacter = result.EndCharacter;
		result.PrimaryLine = result.EndLine;
		return result;
	}

	//***************************************************************************
	size_t CodeLocation::GetHash()
	{
		return this->Code.hash() ^ this->Origin.hash() * 5689;
	}

	//***************************************************************************
	bool CodeLocation::IsValid()
	{
		// As long as we have code, we consider this valid
		return this->Code.empty() == false;
	}

	//***************************************************************************
	String CodeLocation::GetFormattedString(MessageFormat::Enum format) const
	{
		// Based on the format (typically we support many different language formats)
		switch (format)
		{
		case MessageFormat::Zilch:
		{
			// If we have no function name...
			if (this->Function.empty())
			{
				return String::Format("  In %s at line %d, character %d",
					this->Origin.c_str(),
					this->PrimaryLine,
					this->PrimaryCharacter);
			}
			// Otherwise, a function name was provided
			else
			{
				return String::Format("  In %s at line %d, character %d (within function %s)",
					this->Origin.c_str(),
					this->PrimaryLine,
					this->PrimaryCharacter,
					this->Function.c_str());
			}
		}

		case MessageFormat::Python:
		{
			// If we have no function name...
			if (this->Function.empty())
			{
				return String::Format("  File \"%s\", line %d",
					this->Origin.c_str(),
					this->PrimaryLine);
			}
			// Otherwise, a function name was provided
			else
			{
				return String::Format("  File \"%s\", line %d, in %s",
					this->Origin.c_str(),
					this->PrimaryLine,
					this->Function.c_str());
			}
		}

		case MessageFormat::MsvcCpp:
		{
			// If we have no function name...
			if (this->Function.empty())
			{
				return String::Format("  %s(%d)",
					this->Origin.c_str(),
					this->PrimaryLine);
			}
			// Otherwise, a function name was provided
			else
			{
				return String::Format("  %s(%d) in %s",
					this->Origin.c_str(),
					this->PrimaryLine,
					this->Function.c_str());
			}
		}
		}

		// We should never end up here!
		Error("Unhandled format type or the user passed in a garbage value");
		return String();
	}

	//***************************************************************************
	//bool CodeLocation::IsValid()
	//{
	//  return this->CodeEntryId != 0;
	//}

	//***************************************************************************
	String CodeLocation::GetFormattedStringWithMessage(MessageFormat::Enum format, StringParam message) const
	{
		// First, just get the formatted code location
		String formattedLocation = this->GetFormattedString(format);

		// This will be used as the format string
		cstr strFormat = nullptr;

		// Based on the format (typically we support many different language formats)
		switch (format)
		{
		case MessageFormat::Zilch:
		{
			strFormat = "%s:\n    %s\n";
			break;
		}

		case MessageFormat::Python:
		{
			strFormat = "%s\n    %s\n";
			break;
		}

		case MessageFormat::MsvcCpp:
		{
			strFormat = "%s: %s\n";
			break;
		}
		}

		// Make sure we got a string format from above
		ErrorIf(strFormat == nullptr, "Unhandled format type or the user passed in a garbage value");

		// Return the formatted location with the message attached
		return String::Format(strFormat,
			formattedLocation.c_str(),
			message.c_str());
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

#ifdef __clang__
// At the moment, these are missing from the clang libc (no idea what they are!)
void* __gxx_personality_v0 = NULL;
void* _Unwind_Resume = NULL;
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	void DefaultErrorCallback(const ErrorDetails& errorDetails, const void* /*userData*/)
	{
		// Print out the standard formatted error message to the console
		fprintf(stderr, "%s", errorDetails.GetFormattedMessage(MessageFormat::Zilch).c_str());
	}

	//***************************************************************************
	CompilationErrors::CompilationErrors() :
		WasError(false),
		IgnoreMultipleErrors(true),
		UserData(nullptr),
		TolerantMode(false)
	{
	}

	//***************************************************************************
	void CompilationErrors::AddCallback(ErrorCallback callback, const void* userData)
	{
		// Create a delegate out of the callback and userdata
		ErrorDelegate errorDelegate = { callback, userData };

		// Add the delegate to the handlers
		this->ErrorHandlers.push_back(errorDelegate);
	}

	//***************************************************************************
	void CompilationErrors::RaiseArgs(const CodeLocation& location, ErrorCode::Enum errorCode, va_list args)
	{
		return RaiseArgs(location, String(), LocationArray(), errorCode, args);
	}

	//***************************************************************************
	void CompilationErrors::RaiseArgs(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, va_list args)
	{
		LocationArray associatedLocations;
		associatedLocations.push_back(&associatedLocation);
		return RaiseArgs(location, String(), associatedLocations, errorCode, args);
	}

	//***************************************************************************
	void CompilationErrors::RaiseArgs(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, va_list args)
	{
		// If there already was an error and we're set to ignore multiple errors, exit out early
		if (this->WasError && this->IgnoreMultipleErrors)
			return;

		// If we're not in tolerant mode, which lets us continue past errors...
		if (this->TolerantMode == false)
		{
			// An error occurred, set the flag
			this->WasError = true;
		}

		// Get the error information from the database
		const ErrorInfo& errorInfo = this->Database.GetErrorInfo(errorCode);

		// Create an error details object that encompasses the error (including the context of the error)
		ErrorDetails errorDetails(errorInfo, location, errorCode, args);

		// Copy over any associated locations
		// For example, duplicate class definitions, where is the duplicate class?
		errorDetails.AssociatedOtherLocations = associatedLocations;

		// Append any extra context to the error
		// Eg. when the parser expects something, it will say what it got and what it expected
		errorDetails.ExactError = BuildString(errorDetails.ExactError, extra);

		// Loop through all the handlers
		for (size_t i = 0; i < this->ErrorHandlers.size(); ++i)
		{
			// Get a reference to the current handler
			const ErrorDelegate& errorDelegate = this->ErrorHandlers[i];

			// Call the error callback
			errorDelegate.Callback(errorDetails, errorDelegate.UserData);
		}

		// If the error was an internal error, then break here
		if (errorCode == ErrorCode::InternalError)
		{
			// We have to break and solve this issue
			Error("Internal error: %s", errorDetails.ExactError.c_str());
		}
	}

	//***************************************************************************
	void CompilationErrors::Raise(const CodeLocation& location, ErrorCode::Enum errorCode, ...)
	{
		// Create a variable argument list
		va_list argList;
		va_start(argList, errorCode);

		// Raise the error with the argument list
		RaiseArgs(location, String(), LocationArray(), errorCode, argList);

		// Finish reading variable argments
		va_end(argList);
	}

	//***************************************************************************
	void CompilationErrors::Raise(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, ...)
	{
		// Create a variable argument list
		va_list argList;
		va_start(argList, errorCode);

		// Raise the error with the argument list
		LocationArray associatedLocations;
		associatedLocations.push_back(&associatedLocation);
		RaiseArgs(location, String(), associatedLocations, errorCode, argList);

		// Finish reading variable argments
		va_end(argList);
	}

	//***************************************************************************
	void CompilationErrors::Raise(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, ...)
	{
		// Create a variable argument list
		va_list argList;
		va_start(argList, errorCode);

		// Raise the error with the argument list
		RaiseArgs(location, errorCode, argList);

		// Finish reading variable argments
		va_end(argList);
	}
}/**************************************************************\
 * Author: Trevor Sundberg
 * Copyright 2012-2014, DigiPen Institute of Technology
 \**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	Core& Core::GetInstance()
	{
		static Core instance;
		return instance;
	}

	//***************************************************************************
	Core::Core() :
		StaticLibrary("Core"),
		IntegerType(nullptr),
		DoubleIntegerType(nullptr),
		RealType(nullptr),
		DoubleRealType(nullptr),
		BooleanType(nullptr),
		Real2Type(nullptr),
		Real3Type(nullptr),
		Real4Type(nullptr),
		Integer2Type(nullptr),
		Integer3Type(nullptr),
		Integer4Type(nullptr),
		Boolean2Type(nullptr),
		Boolean3Type(nullptr),
		Boolean4Type(nullptr),
		QuaternionType(nullptr),
		StringType(nullptr),
		EventsType(nullptr),
		ExceptionType(nullptr),
		MathType(nullptr),
		VoidType(nullptr),
		NullType(nullptr),
		ErrorType(nullptr),
		AnyDelegateType(nullptr),
		AnythingType(nullptr)
	{
		// Clear out all the vector types
		memset(this->RealTypes, 0, sizeof(this->RealTypes));
		memset(this->IntegerTypes, 0, sizeof(this->IntegerTypes));
		memset(this->BooleanTypes, 0, sizeof(this->BooleanTypes));
	}

	//***************************************************************************
	Core::~Core()
	{
		// Right now we have to manually clean up the any-delegate type because it is special
		// and cannot be directly owned by the library (it causes other conflicts)
		delete this->AnyDelegateType;
	}

	////***************************************************************************
	//template <typename T>
	//void Sign(ExecutableState* state)
	//{
	//  // Get a pointer to the stack data
	//  byte* stack = state->GetCurrentStackFrame();

	//  // The return value is the first value (then comes the input)
	//  Integer& returnValue = ReadValue<Integer>(stack);
	//  T& input = ReadValue<T>(stack);

	//  // If the input is greater than zero
	//  if (input > T(+0))
	//  {
	//    returnValue = +1;
	//  }
	//  // If the input is less than zero
	//  else if (input < T(-0))
	//  {
	//    returnValue = -1;
	//  }
	//  // Otherwise, the input is zero
	//  else
	//  {
	//    returnValue = 0;
	//  }
	//}
	//
	////***************************************************************************
	//template <typename T>
	//void Max(ExecutableState* state)
	//{
	//  // Get a pointer to the stack data
	//  byte* stack = state->GetCurrentStackFrame();

	//  // The return value is the first value (then comes the input)
	//  T& returnValue = ReadValue<T>(stack);
	//  T& input1 = ReadValue<T>(stack);
	//  T& input2 = ReadValue<T>(stack);

	//  // If the first input is greater than the second
	//  if (input1 > input2)
	//  {
	//    returnValue = input1;
	//  }
	//  // Otherwise, the second was greater than the first
	//  // or they were equal, and it won't matter
	//  else
	//  {
	//    returnValue = input2;
	//  }
	//}
	//
	////***************************************************************************
	//template <typename T>
	//void Min(ExecutableState* state)
	//{
	//  // Get a pointer to the stack data
	//  byte* stack = state->GetCurrentStackFrame();

	//  // The return value is the first value (then comes the input)
	//  T& returnValue = ReadValue<T>(stack);
	//  T& input1 = ReadValue<T>(stack);
	//  T& input2 = ReadValue<T>(stack);

	//  // If the first input is less than the second
	//  if (input1 < input2)
	//  {
	//    returnValue = input1;
	//  }
	//  // Otherwise, the second was less than the first
	//  // or they were equal, and it won't matter
	//  else
	//  {
	//    returnValue = input2;
	//  }
	//}

	//***************************************************************************
	void IntegerAbs(Call& call, ExceptionReport& report)
	{
		// Get the input value
		Integer input = call.Get<Integer>(0);

		// Apply the absolute value function
		if (input < 0)
		{
			input = -input;
		}

		call.Set(Call::Return, input);
	}

	////***************************************************************************
	//template <typename T>
	//void Lerp(Call& call, ExceptionReport& report)
	//{
	//  // The return value is the first value (then comes the input)
	//  T& returnValue = ReadValue<T>(stack);
	//  
	//  T& input0 = call.Get<T>(0);
	//  T& input1 = call.Get<T>(1);

	//  Real interpolant = call.Get<Real>(2);

	//  // Apply the lerp function
	//  T result = input1 * interpolant + input2 * (1.0f - interpolant);
	//  call.Set(Call::Return, result);
	//}

	//***************************************************************************
	template <typename T>
	T Lerp(T start, T end, Real t)
	{
		return (Real(1.0) - t) * start + t * end;
	}

	////***************************************************************************
	//template <typename T>
	//void Clamp(ExecutableState* state)
	//{
	//  // Get a pointer to the stack data
	//  byte* stack = state->GetCurrentStackFrame();

	//  // The return value is the first value (then comes the input)
	//  T& returnValue = ReadValue<T>(stack);
	//  T& input = ReadValue<T>(stack);

	//  // If the input is less than our lower bound (0)
	//  if (input < T(0))
	//  {
	//    returnValue = T(0);
	//  }
	//  // If the input is greater than our upper bound (1)
	//  else if (input > T(1))
	//  {
	//    returnValue = T(1);
	//  }
	//  // Otherwise, the input is within range
	//  else
	//  {
	//    returnValue = input;
	//  }
	//}
	//
	////***************************************************************************
	//template <typename T>
	//void ClampBounds(ExecutableState* state)
	//{
	//  // Get a pointer to the stack data
	//  byte* stack = state->GetCurrentStackFrame();
	//  
	//  // The return value is the first value (then comes the input)
	//  T& returnValue = ReadValue<T>(stack);
	//  T& input = ReadValue<T>(stack);
	//  T& lower = ReadValue<T>(stack);
	//  T& upper = ReadValue<T>(stack);

	//  // If the input is less than our lower bound
	//  if (input < lower)
	//  {
	//    returnValue = lower;
	//  }
	//  // If the input is greater than our upper bound
	//  else if (input > upper)
	//  {
	//    returnValue = upper;
	//  }
	//  // Otherwise, the input is within range
	//  else
	//  {
	//    returnValue = input;
	//  }
	//}

	//***************************************************************************
	void Pi(Call& call, ExceptionReport& report)
	{
		call.Set(Call::Return, 3.1415926535897932384626433832795f);
	}

	//***************************************************************************
	void E(Call& call, ExceptionReport& report)
	{
		call.Set(Call::Return, 2.7182818284590452353602874713526f);
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void VectorDefaultConstructor(Call& call, ExceptionReport& report)
	{
		// Get the handle to ourselves
		Handle& selfHandle = call.GetHandle(Call::This);
		byte* self = selfHandle.Dereference();

		// Clear out the object's data (for all vector types)
		memset(self, 0, Components * sizeof(ComponentType));
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void VectorScalarConstructor(Call& call, ExceptionReport& report)
	{
		// Get the handle to ourselves
		Handle& selfHandle = call.GetHandle(Call::This);
		ComponentType* self = (ComponentType*)selfHandle.Dereference();

		// The first thing on the stack will be the single value (scalar)
		ComponentType scalar = call.Get<ComponentType>(0);

		// Loop through all the components
		for (size_t i = 0; i < Components; ++i)
		{
			self[i] = scalar;
		}
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void GenerateVectorScalarConstructor(LibraryBuilder& builder, BoundType* type, BoundType* scalarType)
	{
		// We only have one parameter
		ParameterArray parameters;
		DelegateParameter& scalarParam = parameters.push_back();
		scalarParam.ParameterType = scalarType;
		scalarParam.Name = "scalar";

		// Bind constructors to the vector types
		builder.AddBoundConstructor(type, VectorScalarConstructor<Components, ComponentType>, parameters);
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void VectorComponentConstructor(Call& call, ExceptionReport& report)
	{
		// Get the handle to ourselves
		Handle& selfHandle = call.GetHandle(Call::This);
		ComponentType* self = (ComponentType*)selfHandle.Dereference();

		// Get the stack memory where all the values live
		byte* stackValues = call.GetParametersUnchecked();

		// We want to get the alignment of the stack values
		size_t alignedComponentSize = AlignToBusWidth(sizeof(ComponentType));

		// This is very subltle but because of padding we can't assume the values on the stakc
		// directly align with the values inside our structure. For example, sizeof(bool) is typically 1,
		// however on the stack each bool is aligned by 4 bytes so therefore 3 bools in the stack is 3 * 4 = 12,
		// rather than a Boolean3 which is actually sizeof(bool) * 3 = 3 + padding = 4
		for (size_t i = 0; i < Components; ++i)
		{
			// Grab the current value fo the stack
			ComponentType value = *(ComponentType*)(stackValues + i * alignedComponentSize);

			// Treat ourself like a contiguous array and directly set our members
			self[i] = value;
		}
	}

	//***************************************************************************
	template <size_t Components>
	void VectorCount(Call& call, ExceptionReport& report)
	{
		// Return the number of components in the vector
		call.Set(Call::Return, (Integer)Components);
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void VectorGet(Call& call, ExceptionReport& report)
	{
		// Get the handle to ourselves
		Handle& selfHandle = call.GetHandle(Call::This);
		ComponentType* self = (ComponentType*)selfHandle.Dereference();

		// Read the index off the stack
		Integer index = call.Get<Integer>(0);

		// Make sure the index is within range
		if (index < 0 || index >= Components)
		{
			call.GetState()->ThrowException(report, String::Format("The index used to access a component of a vector was out of range [0-%d]", Components - 1));
			return;
		}

		// Return the vector's value at that index
		ComponentType result = self[index];
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void VectorSet(Call& call, ExceptionReport& report)
	{
		// Get the handle to ourselves
		Handle& selfHandle = call.GetHandle(Call::This);
		ComponentType* self = (ComponentType*)selfHandle.Dereference();

		// Read the index off the stack
		Integer index = call.Get<Integer>(0);

		// Read the value we want to set
		ComponentType value = call.Get<ComponentType>(1);

		// Make sure the index is within range
		if (index < 0 || index >= Components)
		{
			call.GetState()->ThrowException(report, String::Format("The index used to access a component of a vector was out of range [0-%d]", Components - 1));
			return;
		}

		// Set the value on the vector
		self[index] = value;
	}

	//***************************************************************************
	void Vector3CrossProduct(Call& call, ExceptionReport& report)
	{
		// Read in the two vectors
		Real3& vector0 = call.Get<Real3&>(0);
		Real3& vector1 = call.Get<Real3&>(1);

		// Perform the cross product
		Real3 result = Math::Cross(vector0, vector1);

		// Output the result
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void Vector2PerpDotProduct(Call& call, ExceptionReport& report)
	{
		// Get a pointer to the two 2 dimensional input vector
		Real2& vector1 = call.Get<Real2&>(0);
		Real2& vector2 = call.Get<Real2&>(1);

		// Compute the perpendicular dot product
		Real result = vector1.x * vector2.y - vector2.x * vector1.y;
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void Vector2Perpendicular(Call& call, ExceptionReport& report)
	{
		Real2& input = call.Get<Real2&>(0);

		// Compute the perpendicular
		Real2 result(+input.y, -input.x);
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	template <size_t Components>
	Real VectorDotProduct(Real* vector0, Real* vector1)
	{
		// Initialize the result to zero
		Real returnValue = 0.0f;

		// Loop through all the components to apply the dot product
		for (size_t i = 0; i < Components; ++i)
		{
			// Perform the dot product operation
			returnValue += vector0[i] * vector1[i];
		}

		// Return the computed dot product
		return returnValue;
	}

	//***************************************************************************
	template <size_t Components>
	void VectorDotProduct(Call& call, ExceptionReport& report)
	{
		// Get pointers to the two vectors
		Real* vector0 = (Real*)call.GetParameterUnchecked(0);
		Real* vector1 = (Real*)call.GetParameterUnchecked(1);

		// Compute the dot product
		Real result = VectorDotProduct<Components>(vector0, vector1);
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	//template <size_t Components>
	//void VectorDistance(ExecutableState* state)
	//{
	//}

	//// Gets a vector whose components are the
	//// minimum of the components from the two vectors
	//template <size_t Components>
	//static void MinReal(ExecutableState* state);
	//template <size_t Components>
	//static void MinComponent(ExecutableState* state);

	//// Gets a vector whose components are the
	//// maximum of the components from the two vectors
	//template <size_t Components>
	//static void MaxReal(ExecutableState* state);
	//template <size_t Components>
	//static void MaxComponent(ExecutableState* state);

	//***************************************************************************
	template <size_t Components>
	void VectorLengthSq(Call& call, ExceptionReport& report)
	{
		// Get a pointer to the vector
		Real* vector = (Real*)call.GetParameterUnchecked(0);

		// Dot the vector with itself (it's the equivalent of length squared)
		Real lengthSq = VectorDotProduct<Components>(vector, vector);
		call.Set(Call::Return, lengthSq);
	}

	//***************************************************************************
	template <size_t Components>
	void VectorLength(Call& call, ExceptionReport& report)
	{
		// Get a pointer to the vector
		Real* vector = (Real*)call.GetParameterUnchecked(0);

		// Dot the vector with itself (it's the equivalent of length squared)
		Real lengthSq = VectorDotProduct<Components>(vector, vector);
		Real length = sqrt(lengthSq);
		call.Set(Call::Return, length);
	}

	//***************************************************************************
	template <size_t Components>
	void VectorDistance(Call& call, ExceptionReport& report)
	{
		// Get a pointer to the vectors
		Real* vector1 = (Real*)call.GetParameterUnchecked(0);
		Real* vector2 = (Real*)call.GetParameterUnchecked(1);

		Real diff[Components];
		for (size_t i = 0; i < Components; ++i)
		{
			diff[i] = vector1[i] - vector2[i];
		}

		// Dot the vector with itself (it's the equivalent of length squared)
		Real distanceSq = VectorDotProduct<Components>(diff, diff);
		Real distance = sqrt(distanceSq);
		call.Set(Call::Return, distance);
	}

	//***************************************************************************
	template <size_t Components>
	void VectorNormalize(Call& call, ExceptionReport& report)
	{
		// Get a pointer to the vector
		Real* vector = (Real*)call.GetParameterUnchecked(0);

		// Dot the vector with itself (it's the equivalent of length squared)
		Real lengthSq = VectorDotProduct<Components>(vector, vector);
		Real length = sqrt(lengthSq);

		Real* result = (Real*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// If the length is non zero (don't want undefined divisions)
		if (length != 0.0f)
		{
			// Loop through all the components and divide out the length
			for (size_t i = 0; i < Components; ++i)
			{
				result[i] = vector[i] / length;
			}
		}
		else
		{
			// Zero out all elements of the returned vector
			for (size_t i = 0; i < Components; ++i)
			{
				result[i] = 0.0f;
			}
		}
	}

	//***************************************************************************
	void QuaternionDefaultConstructor(Call& call, ExceptionReport& report)
	{
		// Get our own object
		//Quaternion& self = call.Get<Quaternion&>(Call::This);

		// Set the quaternion to the identity quaternion (0, 0, 0, 1)
		//self = Quaternion::cIdentity;

		Handle& selfHandle = call.GetHandle(Call::This);
		byte* self = selfHandle.Dereference();

		*(Quaternion*)self = Quaternion::cIdentity;
	}

	//***************************************************************************
	void QuaternionIdentity(Call& call, ExceptionReport& report)
	{
		call.Set(Call::Return, Quaternion::cIdentity);
	}

	//***************************************************************************
	void QuaternionAdd(Call& call, ExceptionReport& report)
	{
		Quaternion& input0 = call.Get<Quaternion&>(0);
		Quaternion& input1 = call.Get<Quaternion&>(1);

		Quaternion result = input0 + input1;
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionSubtract(Call& call, ExceptionReport& report)
	{
		Quaternion& input0 = call.Get<Quaternion&>(0);
		Quaternion& input1 = call.Get<Quaternion&>(1);

		Quaternion result = input0 - input1;
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionInvert(Call& call, ExceptionReport& report)
	{
		Quaternion& input = call.Get<Quaternion&>(0);
		Real lengthSq = input.LengthSq();

		// We can't invert a zero length quaternion
		if (lengthSq == 0.0f)
		{
			call.GetState()->ThrowException(report, "Attempting to invert a zero length quaternion which would result in a 0 division");
			return;
		}
		Real inverseLengthSq = 1.0f / lengthSq;

		Quaternion result;
		result.x = -input.x * inverseLengthSq;
		result.y = -input.y * inverseLengthSq;
		result.z = -input.z * inverseLengthSq;
		result.w = +input.w * inverseLengthSq;

		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionSlerp(Call& call, ExceptionReport& report)
	{
		// Get pointers to the two vectors
		Quaternion& start = call.Get<Quaternion&>(0);
		Quaternion& end = call.Get<Quaternion&>(1);

		// Get the interpolant value
		Real interpolant = call.Get<Real>(2);

		Quaternion result = Math::Slerp(start, end, interpolant);
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionAxisAngleConstructor(Call& call, ExceptionReport& report)
	{
		Real3& axis = call.Get<Real3&>(0);
		Real radian = call.Get<Real>(1);

		Quaternion result = ToQuaternion(axis, radian);
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionTransformQuaternion(Call& call, ExceptionReport& report)
	{
		Quaternion& value = call.Get<Quaternion&>(0);
		Quaternion& by = call.Get<Quaternion&>(1);

		Quaternion result = by * value;
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionTransformVector3(Call& call, ExceptionReport& report)
	{
		Real3& value = call.Get<Real3&>(0);
		Quaternion& by = call.Get<Quaternion&>(1);

		Real3 result = by.RotatedVector(value);
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionMultiplyQuaternion(Call& call, ExceptionReport& report)
	{
		Quaternion& by = call.Get<Quaternion&>(0);
		Quaternion& the = call.Get<Quaternion&>(1);

		Quaternion result = by * the;
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void QuaternionMultiplyVector3(Call& call, ExceptionReport& report)
	{
		Quaternion& by = call.Get<Quaternion&>(0);
		Real3& the = call.Get<Real3&>(1);

		Real3 result = by.RotatedVector(the);
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	bool EvolvePermutation(size_t indices[], size_t count, size_t upperBound)
	{
		// Increment the first index
		++indices[0];

		// Now we need to check if we need to overflow into the next slot
		size_t innerIndex = 0;

		// Loop while we're overflowing and our index hasn't gone outside the 
		while (indices[innerIndex] == upperBound)
		{
			// If we hit the last index, and it's at the upper bound (confirmed above)
			if (innerIndex == (count - 1))
				return false;

			// Reset the current counter
			indices[innerIndex] = 0;

			// Increment the index so we can increment the next value (overflow)
			++innerIndex;
			++indices[innerIndex];
		}

		// We need to continue the permutation!
		return true;
	}

	//***************************************************************************
	template <typename ComponentType>
	void VectorSwizzleSet(Call& call, ExceptionReport& report)
	{
		// Get the function that's executing us
		Function* function = call.GetFunction();

		// Get the order of the swizzle from the user data (directly!)
		unsigned order = *(unsigned*)&function->UserData;

		// Get how many components the swizzle uses
		unsigned swizzleCount = (order & 7);  // 00 00 00 00 111

		// Read the userdata to figure out which components are being swizzled
		const size_t MaxComponents = 4;
		size_t componentIndex[MaxComponents] =
		{
			(order >> 3) & 3, // 00 00 00 11 000
			(order >> 5) & 3, // 00 00 11 00 000
			(order >> 7) & 3, // 00 11 00 00 000
			(order >> 9) & 3, // 11 00 00 00 000
		};

		// Get a pointer to the vector that we're being set to
		ComponentType* vector = (ComponentType*)call.GetParameterUnchecked(0);

		// Get a pointer to our handle
		Handle& selfHandle = call.GetHandle(Call::This);
		ComponentType* self = (ComponentType*)selfHandle.Dereference();

		// Loop through all the components and read the index that we're supposed to swizzle
		for (size_t i = 0; i < swizzleCount; ++i)
		{
			// Get the index for the current component swizzle
			size_t index = (size_t)componentIndex[i];

			// Perform the component wise set
			self[index] = vector[i];
		}
	}

	//***************************************************************************
	template <typename ComponentType>
	void VectorSwizzleGet(Call& call, ExceptionReport& report)
	{
		// Get the function that's executing us
		Function* function = call.GetFunction();

		// Get the order of the swizzle from the user data (directly!)
		unsigned order = *(unsigned*)&function->UserData;

		// Get how many components the swizzle uses
		unsigned swizzleCount = (order & 7);  // 00 00 00 00 111

		// Read the userdata to figure out which components are being swizzled
		const size_t MaxComponents = 4;
		size_t componentIndex[MaxComponents] =
		{
			(order >> 3) & 3, // 00 00 00 11 000
			(order >> 5) & 3, // 00 00 11 00 000
			(order >> 7) & 3, // 00 11 00 00 000
			(order >> 9) & 3, // 11 00 00 00 000
		};

		// Get a pointer to the the resulting vector
		ComponentType* result = (ComponentType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Get a pointer to our handle
		Handle& selfHandle = call.GetHandle(Call::This);
		ComponentType* self = (ComponentType*)selfHandle.Dereference();

		// Loop through all the components and read the index that we're supposed to swizzle
		for (size_t i = 0; i < swizzleCount; ++i)
		{
			// Get the index for the current component swizzle
			size_t index = (size_t)componentIndex[i];

			// Perform the component wise get
			result[i] = self[index];
		}
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void GenerateVectorSwizzles(LibraryBuilder& builder, BoundType* type, BoundType* componentTypes[Core::MaxComponents])
	{
		// Get a reference to the core so we can access all the vector/real types
		Core& core = Core::GetInstance();

		char componentNamesSet[2][4] = { { 'X', 'Y', 'Z', 'W' }, { 'R', 'G', 'B', 'A' } };

		// For now only bind the XYZW components (until code completion is better)
		for (size_t namesIndex = 0; namesIndex < 1; ++namesIndex)
		{
			// Loop through the number of components, down to one
			for (size_t count = Core::MaxComponents; count > 0; --count)
			{
				// Indices into a specific component (x, y, z, w)
				char *componentNames = componentNamesSet[namesIndex];
				size_t componentIndex[Core::MaxComponents] = { 0 };

				Type* sizeType = componentTypes[count - 1];

				// Loop through all the permutations
				do
				{
					StringBuilder nameBuilder;

					bool inOrder = true;
					bool noDuplicateComponents = true;
					bool usedComponent[Core::MaxComponents] = { 0 };

					for (size_t i = 0; i < count; ++i)
					{
						size_t index = componentIndex[i];

						// Check if the components are in order
						if (i > 0 && componentIndex[i - 1] != index - 1)
						{
							inOrder = false;
						}

						bool& used = usedComponent[index];

						if (used)
						{
							noDuplicateComponents = false;
						}

						used = true;

						nameBuilder.Append(componentNames[index]);
					}

					String name = nameBuilder.ToString();

					// Store whatever property we make in here so we can set whether it's hidden afterwards
					Property* property = nullptr;

					// If the swizzle is a completely in order swizzle
					// That means that we can directly access the memory of the structure (no properties needed)
					if (inOrder)
					{
						// Compute the offset into the vector
						// X is at the front, and therefore is 0, y should be 1 real in, etc
						size_t offset = componentIndex[0] * sizeof(ComponentType);

						// Add the swizzle field
						property = builder.AddBoundField(type, name, sizeType, offset, MemberOptions::None);
					}
					// It must be a property then
					else
					{
						// Create a single integer to be used as userdata to describe the order of the swizzle
						void* orderUserData = nullptr;

						// Put the order into a series of bytes that we store directly as the user data pointer
						size_t& order = *(size_t*)&orderUserData;

						order = count |
							(componentIndex[0] << 3) |
							(componentIndex[1] << 5) |
							(componentIndex[2] << 7) |
							(componentIndex[3] << 9);

						// As long as we have no duplicate components, we
						// can at least make it a read/write property (with a get/set)
						if (noDuplicateComponents)
						{
							// Add the get/set property
							property = builder.AddBoundProperty
								(
								type,
								name,
								sizeType,
								VectorSwizzleSet<ComponentType>,
								VectorSwizzleGet<ComponentType>,
								MemberOptions::None
								);

							// Store the userdata on the property get/set functions
							property->Get->UserData = orderUserData;
							property->Set->UserData = orderUserData;
						}
						else
						{
							// Add the get (read only) property
							property = builder.AddBoundProperty
								(
								type,
								name,
								sizeType,
								nullptr,
								VectorSwizzleGet<ComponentType>,
								MemberOptions::None
								);

							// Store the userdata on the property get function
							property->Get->UserData = orderUserData;
						}
					}

					// Hide all properties that aren't just .X, .Y, .Z, .W
					// Also hide .X on single values
					if (count != 1 || type == componentTypes[0])
						property->IsHidden = true;
				} while (EvolvePermutation(componentIndex, count, Components));
			}
		}
	}

	//***************************************************************************
	template <size_t Components, typename ComponentType>
	void GenerateVectorComponentConstructors(LibraryBuilder& builder, BoundType* type, BoundType* componentTypes[Core::MaxComponents])
	{
		// Get a reference to the core so we can access all the vector/real types
		Core& core = Core::GetInstance();

		// We're generating constructors for a fixed number of components (a specific vector type)
		for (size_t count = Components; count > 0; --count)
		{
			// Only ever index up to 'count' in size
			// This array is an array of indices into the component types above
			// This array will be incremented much like an N counter
			size_t typeIndex[Core::MaxComponents] = { 0 };

			// Loop through all the 
			do
			{
				// Create an array to hold all the parameters
				ParameterArray parameters;

				// With this permutation of constructor, what does the size end up being?
				size_t size = 0;

				// Walk through all the types, make sure the sum of the sizes of types we could take matches our size
				for (size_t i = 0; i < count; ++i)
				{
					// The type index corresponds to its size (component type) + 1
					size += (typeIndex[i] + 1);
				}

				// If the size of all the arguments matched our vector size...
				if (size == Components)
				{
					// Then walk through the arguments and generate a constructor signature for it
					for (size_t i = 0; i < count; ++i)
					{
						// Each parameter contributes to the signature (set it's type to the permuted vector types)
						DelegateParameter& param = parameters.push_back();
						param.ParameterType = componentTypes[typeIndex[i]];
					}

					// Finally, add the constructor to both our type and the library itself
					builder.AddBoundConstructor(type, VectorComponentConstructor<Components, ComponentType>, parameters);
				}
			}
			// Walk through all possible constructor permutations
			while (EvolvePermutation(typeIndex, count, count + 1));
		}
	}

	//***************************************************************************
	template <typename ComponentType>
	BoundType* CreateVectorType(String name, size_t components)
	{
		return new BoundType(name, TypeCopyMode::ValueType, components * sizeof(ComponentType), 0);
	}

	//***************************************************************************
	BoundType* Core::InstantiatePropertyDelegate
		(
		LibraryBuilder& builder,
		StringParam baseName,
		StringParam fullyQualifiedName,
		const Array<Type*>& templateTypes,
		const void* userData
		)
	{
		// Get the type that we're getting / setting
		Type* innerType = templateTypes.front();

		// We could have put core in our userdata, but no real need
		Core& core = Core::GetInstance();

		ParameterArray setParameters;
		DelegateParameter& setParameter = setParameters.push_back();
		setParameter.Name = "value";
		setParameter.ParameterType = innerType;

		DelegateType* setDelegateType = builder.GetDelegateType(setParameters, core.VoidType);
		DelegateType* getDelegateType = builder.GetDelegateType(ParameterArray(), innerType);

		BoundType* type = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(PropertyDelegateTemplate));
		builder.AddBoundField(type, "Set", setDelegateType, offsetof(PropertyDelegateTemplate, Set), MemberOptions::None);
		builder.AddBoundField(type, "Get", getDelegateType, offsetof(PropertyDelegateTemplate, Get), MemberOptions::None);

		// Bind the constructor
		ZilchBindCustomConstructor(builder, type, PropertyDelegateTemplate);
		ZilchBindCustomDestructor(builder, type, PropertyDelegateTemplate);

		return type;
	}

	//***************************************************************************
	void SubString(Call& call, ExceptionReport& report)
	{
		// Get this string object
		String& self = call.Get<String&>(Call::This);

		Integer start = call.Get<Integer>(0);
		Integer length = call.Get<Integer>(1);

		Integer stringCount = (Integer)self.size();
		Integer end = start + length;

		// Check the character index (note that 'end' being equal to the string count is valid
		if (start < 0 || end > stringCount)
		{
			call.GetState()->ThrowException(report, "String index was out of bounds");
			return;
		}
		if (length < 0)
		{
			call.GetState()->ThrowException(report, "A negative substring length is not supported");
			return;
		}

		String result = self.sub_string_unsafe(start, length);
		call.Set(Call::Return, &result);
	}

	//***************************************************************************
	void StringCount(Call& call, ExceptionReport& report)
	{
		// Get this string object
		String& self = call.Get<String&>(Call::This);

		Integer count = (Integer)self.size();
		call.Set(Call::Return, count);
	}

	//***************************************************************************
	void StringConcatenate(Call& call, ExceptionReport& report)
	{
		String* first = call.Get<String*>(0);
		String* second = call.Get<String*>(1);

		if (first == nullptr || second == nullptr)
		{
			call.GetState()->ThrowNullReferenceException(report);
			return;
		}

		String result = BuildString(*first, *second);
		call.Set(Call::Return, &result);
	}

	//***************************************************************************
	void StringFromChar(Call& call, ExceptionReport& report)
	{
		char character = (char)call.Get<Integer>(0);
		String result(&character, 1);
		call.Set(Call::Return, &result);
	}

	//***************************************************************************
	class FormatCState;
	class FormatCEdge
	{
	public:

		// The characters we test against
		HashSet<int> Characters;

		// The name of this state, just for debugging
		cstr Name;

		// The state we want to transition to
		FormatCState* TransitionTo;

		// Create an edge that looks for any of the given characters
		FormatCEdge(cstr name, size_t charcterCount, ...) :
			Name(name),
			TransitionTo(nullptr)
		{
			va_list args;
			va_start(args, charcterCount);

			for (size_t i = 0; i < charcterCount; ++i)
			{
				int character = va_arg(args, int);
				this->Characters.insertOrError(character, "Two characters mapped to the same edge");
			}

			va_end(args);
		}

		// Check an edge for a transition on a character
		bool CheckEdge(char c)
		{
			return this->Characters.contains(c);
		}
	};

	//***************************************************************************
	class FormatCState
	{
	public:

		// All the edges to be evaluated, in order
		Array<FormatCEdge*> Edges;

		// The name of this state, just for debugging
		cstr Name;

		// Create a state with a given number of edges
		FormatCState(cstr name) :
			Name(name)
		{
		}
	};

	//***************************************************************************
	static FormatCState FormatCStateRoot("Root");
	//---------------------------------------------------------------------------
	static FormatCState FormatCStateParsedFlags("ParsedFlags");
	//---------------------------------------------------------------------------
	static FormatCState FormatCStateParsedWidthStar("ParsedWidthStar");
	static FormatCState FormatCStateParsedWidthNumber("ParsedWidthNumber");
	//---------------------------------------------------------------------------
	static FormatCState FormatCStateParsedPrecisionDot("ParsedPrecisionDot");
	static FormatCState FormatCStateParsedPrecisionStar("ParsedPrecisionStar");
	static FormatCState FormatCStateParsedPrecisionNumber("ParsedPrecisionNumber");
	//---------------------------------------------------------------------------
	static FormatCState FormatCStateParsedSpecifier("ParsedSpecifier");

	//***************************************************************************
	static FormatCEdge  FormatCEdgeFlags("Flags", 5, '-', '+', ' ', '#', '0');
	static FormatCEdge  FormatCEdgeFlagsLoop("FlagsLoop", 5, '-', '+', ' ', '#', '0');
	//---------------------------------------------------------------------------
	static FormatCEdge  FormatCEdgeWidthStar("WidthStar", 1, '*');
	static FormatCEdge  FormatCEdgeWidthNumber("WidthNumber", 10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
	static FormatCEdge  FormatCEdgeWidthNumberLoop("WidthNumberLoop", 10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
	//---------------------------------------------------------------------------
	static FormatCEdge  FormatCEdgePrecisionDot("PrecisionDot", 1, '.');
	static FormatCEdge  FormatCEdgePrecisionStar("PrecisionStar", 1, '*');
	static FormatCEdge  FormatCEdgePrecisionNumber("PrecisionNumber", 10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
	static FormatCEdge  FormatCEdgePrecisionNumberLoop("PrecisionNumberLoop", 10, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
	//---------------------------------------------------------------------------
	static FormatCEdge  FormatCEdgeSpecifiers("Specifiers", 18, 'd', 'i', 'u', 'o', 'x', 'X', 'f', 'F', 'e', 'E', 'g', 'G', 'a', 'A', 'c', 's', 'p', '%');

	//***************************************************************************
	static void InitializeFormatCStates()
	{
		// If we never initialized the state machine...
		static bool initialized = false;
		if (initialized == false)
		{
			// One time initialization
			initialized = true;

			/**** States ****/
			// From the root, we can basically go down any of the edges (except the loops and precision star/number, because that requires a .)
			FormatCStateRoot.Edges.push_back(&FormatCEdgeFlags);
			FormatCStateRoot.Edges.push_back(&FormatCEdgeWidthStar);
			FormatCStateRoot.Edges.push_back(&FormatCEdgeWidthNumber);
			FormatCStateRoot.Edges.push_back(&FormatCEdgePrecisionDot);
			FormatCStateRoot.Edges.push_back(&FormatCEdgeSpecifiers);

			// Once we've parsed flags, we can parse width, precision, or a specifier
			FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeWidthStar);
			FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeWidthNumber);
			FormatCStateParsedFlags.Edges.push_back(&FormatCEdgePrecisionDot);
			FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeSpecifiers);

			// The user can technically specify as many flags as they want
			FormatCStateParsedFlags.Edges.push_back(&FormatCEdgeFlagsLoop);

			// Once we've parsed width, we can parse precision or a specifier (note we have to handle both width states here)
			FormatCStateParsedWidthStar.Edges.push_back(&FormatCEdgePrecisionDot);
			FormatCStateParsedWidthStar.Edges.push_back(&FormatCEdgeSpecifiers);
			FormatCStateParsedWidthNumber.Edges.push_back(&FormatCEdgePrecisionDot);
			FormatCStateParsedWidthNumber.Edges.push_back(&FormatCEdgeSpecifiers);

			// Make sure the width number edge loops back to itself
			FormatCStateParsedWidthNumber.Edges.push_back(&FormatCEdgeWidthNumberLoop);

			// The dot state we have to handle specially, because it's not legal to transition to anything except the precision star/number
			FormatCStateParsedPrecisionDot.Edges.push_back(&FormatCEdgePrecisionStar);
			FormatCStateParsedPrecisionDot.Edges.push_back(&FormatCEdgePrecisionNumber);

			// Once we've parsed precision, we can only parse a specifier (note we have to handle both precision states here, but not dot!)
			FormatCStateParsedPrecisionStar.Edges.push_back(&FormatCEdgeSpecifiers);
			FormatCStateParsedPrecisionNumber.Edges.push_back(&FormatCEdgeSpecifiers);

			// Make sure the precision number edge loops back to itself
			FormatCStateParsedPrecisionNumber.Edges.push_back(&FormatCEdgePrecisionNumberLoop);

			/**** Edges ****/
			FormatCEdgeFlags.TransitionTo = &FormatCStateParsedFlags;
			FormatCEdgeFlagsLoop.TransitionTo = &FormatCStateParsedFlags;
			FormatCEdgeWidthStar.TransitionTo = &FormatCStateParsedWidthStar;
			FormatCEdgeWidthNumber.TransitionTo = &FormatCStateParsedWidthNumber;
			FormatCEdgeWidthNumberLoop.TransitionTo = &FormatCStateParsedWidthNumber;
			FormatCEdgePrecisionDot.TransitionTo = &FormatCStateParsedPrecisionDot;
			FormatCEdgePrecisionStar.TransitionTo = &FormatCStateParsedPrecisionStar;
			FormatCEdgePrecisionNumber.TransitionTo = &FormatCStateParsedPrecisionNumber;
			FormatCEdgePrecisionNumberLoop.TransitionTo = &FormatCStateParsedPrecisionNumber;
			FormatCEdgeSpecifiers.TransitionTo = &FormatCStateParsedSpecifier;
		}
	}

	//***************************************************************************
	namespace FormatCInputType
	{
		enum Enum
		{
			DoubleInteger,
			DoubleReal,
			String,
			Pointer
		};
	}

	//***************************************************************************
	template <typename T>
	int FormatCSprintf(char* buffer, cstr format, int widthStar, int precisionStar, T value)
	{
		// If no buffer was provided, it means we're just counting the length
		if (buffer == nullptr)
		{
			// We have to determine the correct arguments to pass in based on whether the * was used for with or precision
			if (widthStar >= 0 && precisionStar >= 0)
				return SPrintfCount(format, widthStar, precisionStar, value);
			else if (widthStar >= 0)
				return SPrintfCount(format, widthStar, value);
			else if (precisionStar >= 0)
				return SPrintfCount(format, widthStar, value);
			else
				return SPrintfCount(format, value);
		}
		else
		{
			// We have to determine the correct arguments to pass in based on whether the * was used for with or precision
			if (widthStar >= 0 && precisionStar >= 0)
				return sprintf(buffer, format, widthStar, precisionStar, value);
			else if (widthStar >= 0)
				return sprintf(buffer, format, widthStar, value);
			else if (precisionStar >= 0)
				return sprintf(buffer, format, precisionStar, value);
			else
				return sprintf(buffer, format, value);
		}
	}

	//***************************************************************************
	template <typename T>
	void FormatCPrint(ExecutableState* state, ExceptionReport& report, StringBuilder& builder, StringParam format, Array<char>& temporaryBuffer, int widthStar, int precisionStar, const Any& argument, T value)
	{
		// Grab the stored type of the argument, for error printing
		Type* argumentType = argument.StoredType;

		// First, get the length that the printf would output
		int sprintfLength = FormatCSprintf(nullptr, format.c_str(), widthStar, precisionStar, value);

		// If the print failed, let the user know
		if (sprintfLength < 0)
		{
			state->ThrowException(report, String::Format("The format specifier '%s' was invalid. The argument was '%s' of type '%s'", format.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));
			return;
		}

		// This must be less than or equal to, because we need extra space for the null
		if (temporaryBuffer.size() <= (size_t)sprintfLength)
		{
			// Expand it just a bit to prevent a lot of re-allocating (and +1 just for the null)
			temporaryBuffer.resize(sprintfLength * 2 + 1);

			// Clear the memory just in case for some reason sprintf fails
			memset(temporaryBuffer.data(), 0, temporaryBuffer.size());
		}

		// Now that we've sized our buffer to fit the text, actually print out to the buffer
		sprintfLength = FormatCSprintf(temporaryBuffer.data(), format.c_str(), widthStar, precisionStar, value);

		// This should basically never happen... but just in case it does!
		if (sprintfLength < 0)
		{
			state->ThrowException(report, String::Format("The format specifier '%s' was invalid. The argument was '%s' of type '%s'", format.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));
			return;
		}

		// Finally, append the formatted text to the builder
		builder.Append(temporaryBuffer.data());
	}

	//***************************************************************************
	void StringFormatC(Call& call, ExceptionReport& report)
	{
		// Make sure all the edges and states are setup for our DFA
		InitializeFormatCStates();

		// How many arguments this overload is going to read off the stack (from 1 to 10)
		size_t argumentCount = (size_t)call.GetFunction()->UserData;

		// The format string (as used with sprintf)
		StringParam format = call.Get<StringParam>(0);

		// Create a stack array to hold all the arguments we read off the Zilch stack
		// The 'Any' type can hold any value from Zilch, including primitives and classes
		const Any** arguments = (const Any**)alloca(sizeof(const Any*) * argumentCount);

		// Read each argument off the stack
		for (size_t i = 0; i < argumentCount; ++i)
		{
			// Put each argument into the static array we created
			// The +1 is for the format argument at the beginning
			const Any* argument = call.Get<const Any*>(i + 1);
			arguments[i] = argument;
		}

		// Get the current state (for throwing exceptions)
		ExecutableState* state = call.GetState();

		// What we'll use to concatenate all the strings together
		StringBuilder builder;

		// The index we use when reading in format specifiers
		size_t argumentIndex = 0;

		// A temporary buffer where we print out each argumnent / format specifier to
		Array<char> temporaryBuffer;

		// Loop through all characters in the format string
		for (size_t i = 0; i < format.size(); ++i)
		{
			// Grab the current character
			char c = format[i];

			// If this is a format specifier...
			if (c == '%')
			{
				// Format specifier syntax: (we do not support length)
				// %[flags][width][.precision]specifier

				// We use a state machine / DFA to parse the format specifiers
				FormatCState* currentState = &FormatCStateRoot;

				// Save where this format specifier started, right at the % sign
				size_t formatSpecifierStart = i;

				// Because we already read the '%', we want to advance to the first character of the specifier
				++i;

				// Loop until we read the rest of the specifier, or the end of the string (null terminates the DFA!)
				for (; i <= format.size(); ++i)
				{
					// Read the current character
					c = format[i];

					// This will tell us if, after testing all the edges, we transitioned to a new state
					// Note: Not transitioning is considered an error
					bool transitioned = false;

					// Loop through all the current state's outgoing edges
					for (size_t e = 0; e < currentState->Edges.size(); ++e)
					{
						// Grab the current edge
						FormatCEdge* edge = currentState->Edges[e];

						// Check to see if this edge would transition on the character
						if (edge->CheckEdge(c))
						{
							// We transitioned, move to the next state
							currentState = edge->TransitionTo;
							transitioned = true;
							break;
						}
					}

					// Create a range that represents the format specifier up to this point (the +1 is because i is actually at the current character)
					StringRange formatSpecifierRange(format.c_str() + formatSpecifierStart, i - formatSpecifierStart + 1);

					// If we didn't transition, that means we found an invalid format specifier
					if (transitioned == false)
					{
						state->ThrowException(report, BuildString("Invalid or unsupported format specifier: '", formatSpecifierRange, "'"));
						return;
					}
					// If we reached the end (parsed the format specifier)
					else if (currentState == &FormatCStateParsedSpecifier)
					{
						// We finished parsing the format specifier, time to try it out!
						String formatSpecifierString = formatSpecifierRange;

						// Get the format specifier character
						char formatSpecifier = formatSpecifierString.back();

						// Sting is the safest fallback, just in case something happens
						FormatCInputType::Enum inputType = FormatCInputType::String;

						// Check for the integral, float, and pointer types
						switch (formatSpecifier)
						{
							// Printf integer format specifiers
						case 'd':
						case 'i':
						case 'o':
						case 'u':
						case 'x':
						case 'X':
							inputType = FormatCInputType::DoubleInteger;
							break;

							// Printf float format specifiers
						case 'f':
						case 'F':
						case 'e':
						case 'E':
						case 'g':
						case 'G':
						case 'a':
						case 'A':
							inputType = FormatCInputType::DoubleReal;
							break;

							// Printf pointer format specifier
						case 'p':
							inputType = FormatCInputType::Pointer;
							break;
						}

						// Usign a * in printf can add extra integer arguments to the va-list
						Integer widthStar = -1;
						Integer precisionStar = -1;

						// Count the number of extra integral arguments we need
						for (size_t j = 0; j < formatSpecifierString.size(); ++j)
						{
							// If we hit the * operator...
							if (formatSpecifierString[j] == '*')
							{
								// So long as we haven't run out of arguments...
								if (argumentIndex >= argumentCount)
								{
									state->ThrowException(report, "There are more '%' format specifiers or '*' operators then there are arguments");
									return;
								}

								// This is always valid to check the previous character because we know format specifiers must start with %
								// If the previous character was a '.', then we know this is a 'precision' star
								bool isPrecision = (formatSpecifierString[j - 1] == '.');

								// Grab the current integer argument (for either width or precision)
								const Any& argument = *arguments[argumentIndex];
								Type* argumentType = argument.StoredType;
								const byte* argumentData = argument.GetData();
								++argumentIndex;

								// Make sure the type was an integer
								if (Type::IsSame(argumentType, ZilchTypeId(Integer)) == false)
								{
									// It wasn't an integer, inform the user of which * was wrong
									cstr starType = "width";
									if (isPrecision)
										starType = "precision";

									// Let the user know about the * requiring an integer argument, including as much info as possible
									state->ThrowException
										(
										report,
										String::Format("When using * for %s an Integer must be provided before the argument, instead we found '%s' of type '%s' for the '%s' format specifier",
										starType,
										argument.ToString().c_str(),
										argumentType->ToString().c_str(),
										formatSpecifierString.c_str())
										);
									return;
								}

								// Finally, if this is a precision or width star get the actual integral value...
								if (isPrecision)
									precisionStar = *(Integer*)argumentData;
								else
									widthStar = *(Integer*)argumentData;
							}
						}

						// After we may have read any * arguments, we need to check if the current format specifier actually has a valid argument (too few?)
						if (argumentIndex >= argumentCount)
						{
							state->ThrowException(report, "There are more '%' format specifiers or '*' operators then there are arguments");
							return;
						}

						// Grab the current argument for the format specifier
						const Any& argument = *arguments[argumentIndex];
						Type* argumentType = argument.StoredType;
						const byte* argumentData = argument.GetData();

						// We're using a format specifier that accepts a DoubleInteger
						if (inputType == FormatCInputType::DoubleInteger)
						{
							// If it's an integer, we always just print out long longs
							// We basically add the 'll' format specifier before the last character, which is the format specifier that told us it was an integer
							String integralFormatSpecifierString = BuildString
								(
								StringRange(formatSpecifierRange.begin, formatSpecifierRange.end - 1),
								"ll",
								StringRange(formatSpecifierRange.end - 1, formatSpecifierRange.end)
								);

							// Convert as many types as we can to the DoubleInteger value
							DoubleInteger value = 0;

							// Look for Integer, DoubleInteger, Real, and DoubleReal
							if (Type::IsSame(argumentType, ZilchTypeId(Integer)))
								value = (DoubleInteger)*(Integer*)argumentData;
							else if (Type::IsSame(argumentType, ZilchTypeId(DoubleInteger)))
								value = (DoubleInteger)*(DoubleInteger*)argumentData;
							else if (Type::IsSame(argumentType, ZilchTypeId(Real)))
								value = (DoubleInteger)*(Real*)argumentData;
							else if (Type::IsSame(argumentType, ZilchTypeId(DoubleReal)))
								value = (DoubleInteger)*(DoubleReal*)argumentData;
							else
								// Anything else must be an error since we don't know what it is
								return state->ThrowException(report, String::Format("The format specifier '%s' requires an integral or real type, instead we got '%s' of type '%s'", formatSpecifierString.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));

							// Print the value out and store it in the builder (this can throw an exception)
							FormatCPrint(state, report, builder, integralFormatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, value);
							if (report.HasThrownExceptions())
								return;
						}
						// We're using a format specifier that accepts a DoubleReal
						else if (inputType == FormatCInputType::DoubleReal)
						{
							// Convert as many types as we can to the DoubleReal value
							DoubleReal value = 0.0;

							// Look for Integer, DoubleInteger, Real, and DoubleReal
							if (Type::IsSame(argumentType, ZilchTypeId(Integer)))
								value = (DoubleReal)*(Integer*)argumentData;
							else if (Type::IsSame(argumentType, ZilchTypeId(DoubleInteger)))
								value = (DoubleReal)*(DoubleInteger*)argumentData;
							else if (Type::IsSame(argumentType, ZilchTypeId(Real)))
								value = (DoubleReal)*(Real*)argumentData;
							else if (Type::IsSame(argumentType, ZilchTypeId(DoubleReal)))
								value = (DoubleReal)*(DoubleReal*)argumentData;
							else
								// Anything else must be an error since we don't know what it is
								return state->ThrowException(report, String::Format("The format specifier '%s' requires an integral or real type, instead we got '%s' of type '%s'", formatSpecifierString.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));

							// Print the value out and store it in the builder (this can throw an exception)
							FormatCPrint(state, report, builder, formatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, value);
							if (report.HasThrownExceptions())
								return;
						}
						// When expecting a string, we actually just allow the user to print anything (%s is our one size fits all)
						// String's 'ToString' just results in itself
						else if (inputType == FormatCInputType::String)
						{
							// Print the value out and store it in the builder (this can throw an exception)
							FormatCPrint(state, report, builder, formatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, argument.ToString().c_str());
							if (report.HasThrownExceptions())
								return;
						}
						// The pointer format specifier just prints out special pointer values
						else if (inputType == FormatCInputType::Pointer)
						{
							// The meaning of the pointer is not entirely relevant, but can be used for debugging
							void* pointerValue = nullptr;
							bool isValidValue = false;

							// If the argument is a handle type (bound type as a class/reference type, or an indirect / ref struct)
							if (Type::IsHandleType(argumentType))
							{
								// Dereference the handle to get the actual value we point at
								pointerValue = ((Handle*)argumentData)->Dereference();
								isValidValue = true;
							}
							// If the argument is a delegate, we can at least give the 'Function' pointer
							else if (Type::IsDelegateType(argumentType))
							{
								// Just tell the user the location of the function
								pointerValue = ((Delegate*)argumentData)->BoundFunction;
								isValidValue = true;
							}

							// If we didn't detect the type of value, throw an exception
							if (isValidValue == false)
							{
								state->ThrowException(report, String::Format("The format specifier '%s' requires a class, ref struct, or delegate type. Instead we got '%s' of type '%s'", formatSpecifierString.c_str(), argument.ToString().c_str(), argumentType->ToString().c_str()));
								return;
							}

							// Print the value out and store it in the builder (this can throw an exception)
							FormatCPrint(state, report, builder, formatSpecifierString, temporaryBuffer, widthStar, precisionStar, argument, pointerValue);
							if (report.HasThrownExceptions())
								return;
						}

						// We read and processed the format specifier, no need to continue
						// This will break to the outer loop where we keep reading the format string
						break;
					}
				}

				// We parsed a format specifier, so move to the next argument
				++argumentIndex;
			}
			else
			{
				// Nothing special, just append the character directly from the format
				builder.Append(c);
			}
		}

		// If we didn't consume all the arguments...
		if (argumentIndex != argumentCount)
		{
			state->ThrowException(report, "There are more arguments then there are '%' format specifiers or '*' operators");
			return;
		}

		// Return the string we built to the Zilch stack
		String result = builder.ToString();
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	void StringGetChar(Call& call, ExceptionReport& report)
	{
		// Get this string object
		String& self = call.Get<String&>(Call::This);
		Integer index = call.Get<Integer>(0);

		Integer stringCount = (Integer)self.size();

		// Check the character index (here, index CANNOT be the string count)
		if (index < 0 || index >= stringCount)
		{
			call.GetState()->ThrowException(report, "String index was out of bounds");
			return;
		}

		char result = self[index];
		call.Set(Call::Return, result);
	}

	//***************************************************************************
	String BooleanToString(Boolean value)
	{
		// Basically because we only have two outcomes, just pre-create the strings
		static const String True("true");
		static const String False("false");

		if (value)
		{
			return True;
		}
		else
		{
			return False;
		}
	}

	//***************************************************************************
	cstr TrueFalseCstr(Boolean value)
	{
		return value ? "true" : "false";
	}

	//***************************************************************************
	String Boolean2ToString(Boolean2Param value)
	{
		return String::Format("(%s, %s)", TrueFalseCstr(value.x), TrueFalseCstr(value.y));
	}

	//***************************************************************************
	String Boolean3ToString(Boolean3Param value)
	{
		return String::Format("(%s, %s, %s)", TrueFalseCstr(value.x), TrueFalseCstr(value.y), TrueFalseCstr(value.z));
	}

	//***************************************************************************
	String Boolean4ToString(Boolean4Param value)
	{
		return String::Format("(%s, %s, %s, %s)", TrueFalseCstr(value.x), TrueFalseCstr(value.y), TrueFalseCstr(value.z), TrueFalseCstr(value.w));
	}

	//***************************************************************************
	String IntegerToString(Integer value)
	{
		return String::Format("%d", value);
	}

	//***************************************************************************
	String Integer2ToString(Integer2Param value)
	{
		return String::Format("(%d, %d)", value.x, value.y);
	}

	//***************************************************************************
	String Integer3ToString(Integer3Param value)
	{
		return String::Format("(%d, %d, %d)", value.x, value.y, value.z);
	}

	//***************************************************************************
	String Integer4ToString(Integer4Param value)
	{
		return String::Format("(%d, %d, %d, %d)", value.x, value.y, value.z, value.w);
	}

	//***************************************************************************
	String RealToString(Real value)
	{
		return String::Format("%g", value);
	}

	//***************************************************************************
	String Real2ToString(Real2Param value)
	{
		return String::Format("(%g, %g)", value.x, value.y);
	}

	//***************************************************************************
	String Real3ToString(Real3Param value)
	{
		return String::Format("(%g, %g, %g)", value.x, value.y, value.z);
	}

	//***************************************************************************
	String Real4ToString(Real4Param value)
	{
		return String::Format("(%g, %g, %g, %g)", value.x, value.y, value.z, value.w);
	}

	//***************************************************************************
	String QuaternionToString(QuaternionParam value)
	{
		// First, convert the quaternion to Euler Angles (simple to read/understand)
		EulerAngles angles(Math::EulerOrders::XYZs);
		ToEulerAngles(value, &angles);

		// Also convert the quaternion to Axis/Angle form, as it may be more intuitive
		Real3 axis;
		Real angle;
		ToAxisAngle(value, &axis, &angle);

		// Print out the quaternion, then the Euler Angles form, then the Axis/Angle form
		return String::Format
			(
			"(%g, %g, %g, %g), Euler: (%g, %g, %g), Axis: (%g, %g, %g), Angle: %g",
			value.x, value.y, value.z, value.w,
			angles.Angles.x, angles.Angles.y, angles.Angles.z,
			axis.x, axis.y, axis.z,
			angle
			);
	}

	//***************************************************************************
	String DoubleIntegerToString(DoubleInteger value)
	{
		return String::Format("%lld", value);
	}

	//***************************************************************************
	String DoubleRealToString(DoubleReal value)
	{
		return String::Format("%g", value);
	}

	//***************************************************************************
	String StringToString(const BoundType* type, const byte* data)
	{
		return *(String*)data;
	}

	//***************************************************************************
	String BooleanToString(const BoundType* type, const byte* data)
	{
		return BooleanToString(*(Boolean*)data);
	}

	//***************************************************************************
	String Boolean2ToString(const BoundType* type, const byte* data)
	{
		return Boolean2ToString(*(Boolean2*)data);
	}

	//***************************************************************************
	String Boolean3ToString(const BoundType* type, const byte* data)
	{
		return Boolean3ToString(*(Boolean3*)data);
	}

	//***************************************************************************
	String Boolean4ToString(const BoundType* type, const byte* data)
	{
		return Boolean4ToString(*(Boolean4*)data);
	}

	//***************************************************************************
	String IntegerToString(const BoundType* type, const byte* data)
	{
		return IntegerToString(*(Integer*)data);
	}

	//***************************************************************************
	String Integer2ToString(const BoundType* type, const byte* data)
	{
		return Integer2ToString(*(Integer2*)data);
	}

	//***************************************************************************
	String Integer3ToString(const BoundType* type, const byte* data)
	{
		return Integer3ToString(*(Integer3*)data);
	}

	//***************************************************************************
	String Integer4ToString(const BoundType* type, const byte* data)
	{
		return Integer4ToString(*(Integer4*)data);
	}

	//***************************************************************************
	String RealToString(const BoundType* type, const byte* data)
	{
		return RealToString(*(Real*)data);
	}

	//***************************************************************************
	String Real2ToString(const BoundType* type, const byte* data)
	{
		return Real2ToString(*(Real2*)data);
	}

	//***************************************************************************
	String Real3ToString(const BoundType* type, const byte* data)
	{
		return Real3ToString(*(Real3*)data);
	}

	//***************************************************************************
	String Real4ToString(const BoundType* type, const byte* data)
	{
		return Real4ToString(*(Real4*)data);
	}

	//***************************************************************************
	String QuaternionToString(const BoundType* type, const byte* data)
	{
		return QuaternionToString(*(Quaternion*)data);
	}

	//***************************************************************************
	String DoubleIntegerToString(const BoundType* type, const byte* data)
	{
		return DoubleIntegerToString(*(DoubleInteger*)data);
	}

	//***************************************************************************
	String DoubleRealToString(const BoundType* type, const byte* data)
	{
		return DoubleRealToString(*(DoubleReal*)data);
	}

	//***************************************************************************
	String VectorToString(Real* vector, size_t vectorSize)
	{
		if (vectorSize == 1)
			return RealToString(*(Real*)vector);
		else if (vectorSize == 2)
			return Real2ToString(*(Real2*)vector);
		else if (vectorSize == 3)
			return Real3ToString(*(Real3*)vector);
		else if (vectorSize == 4)
			return Real4ToString(*(Real4*)vector);

		Error("Somehow we tried to turn a vector into a string that has a size greater than 4");
		return "";
	}

	//***************************************************************************
	// Splats a function of the type Scalar Fn(Scalar) to
	// Vec(n) Fn(Vec(n)) (vector could be of whatever scalar type is)
	template <size_t Components, typename ScalarType, ScalarType(*Function)(ScalarType)>
	void SplatVecToVec(Call& call, ExceptionReport& report)
	{
		// Get a pointer to our input vector
		ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < Components; ++i)
		{
			// Call the function on the single input (splat)
			result[i] = Function(input[i]);
		}
	}

	//***************************************************************************
	// Splats a function of the type Scalar Fn(Scalar) to
	// Vec(n) Fn(Vec(n), a) (vector could be of whatever scalar type is)
	template <size_t Components, typename ScalarType, typename ExtraA, ScalarType(*Function)(ScalarType, ExtraA)>
	void SplatVecToVecOneExtra(Call& call, ExceptionReport& report)
	{
		// Get a pointer to our input vector
		ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

		// Grab the extra parameter
		ExtraA a = call.Get<ExtraA>(1);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < Components; ++i)
		{
			// Call the function on the single input (splat)
			result[i] = Function(input[i], a);
		}
	}

	//***************************************************************************
	// Splats a function of the type Scalar Fn(Scalar) to
	// Vec(n) Fn(Vec(n), a, b) (vector could be of whatever scalar type is)
	template <size_t Components, typename ScalarType, typename ExtraA, typename ExtraB, ScalarType(*Function)(ScalarType, ExtraA, ExtraB)>
	void SplatVecToVecTwoExtra(Call& call, ExceptionReport& report)
	{
		// Get a pointer to our input vector
		ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

		// Grab the extra two parameters
		ExtraA a = call.Get<ExtraA>(1);
		ExtraB b = call.Get<ExtraB>(2);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < Components; ++i)
		{
			// Call the function on the single input (splat)
			result[i] = Function(input[i], a, b);
		}
	}

	//***************************************************************************
	// Splats a function of the type Boolean Fn(Scalar, Scalar&) to
	// Vec(n) Fn(Vec(n)). The function being splatted is a Scalar Fn(Scalar)
	// function that has been altered to return if it failed so an exception
	// can be thrown.
	template <size_t Components, typename ScalarType, bool(*Function)(ScalarType, ScalarType&)>
	void SplatVecToVecWithError(Call& call, ExceptionReport& report)
	{
		// Get a pointer to our input vector
		ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		bool success = true;
		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < Components; ++i)
		{
			// Call the function on the single input (splat)
			success = Function(input[i], result[i]);

			// If the function failed for whatever reason then throw an exception
			if (success == false)
			{
				// The user data of this function should contain a format string with
				// one %s in it to display the input value that failed.
				cstr errFormat = (cstr)call.GetFunction()->UserData;
				String vectorValue = VectorToString(input, Components);
				String msg = String::Format(errFormat, vectorValue.c_str());
				call.GetState()->ThrowException(report, msg);
				return;
			}
		}
	}

	//***************************************************************************
	// Splats a function of the type Scalar Fn(Scalar, Scalar) to
	// Vec(n) Fn(Vec(n), Vec(n)) (vector could be of whatever scalar type is)
	template <size_t Components, typename ScalarType, ScalarType(*Function)(ScalarType, ScalarType)>
	void SplatTwoVecToVec(Call& call, ExceptionReport& report)
	{
		// Get a pointer to our input vector
		ScalarType* input0 = (ScalarType*)call.GetParameterUnchecked(0);
		ScalarType* input1 = (ScalarType*)call.GetParameterUnchecked(1);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.DisableReturnChecks();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < Components; ++i)
		{
			// Call the function on the single inputs (splat)
			result[i] = Function(input0[i], input1[i]);
		}
	}

	//***************************************************************************
	//Splats a function of the type Scalar Fn(Scalar, Scalar, Scalar) to
	//Vec(n) Fn(Vec(n), Vec(n), Vec(n)) (vector could be of whatever scalar type is)
	template <size_t Components, typename ScalarType, ScalarType(*Function)(ScalarType, ScalarType, ScalarType)>
	void SplatThreeVecToVec(Call& call, ExceptionReport& report)
	{
		// Get a pointer to our input vector
		ScalarType* input0 = (ScalarType*)call.GetParameterUnchecked(0);
		ScalarType* input1 = (ScalarType*)call.GetParameterUnchecked(1);
		ScalarType* input2 = (ScalarType*)call.GetParameterUnchecked(2);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.DisableReturnChecks();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < Components; ++i)
		{
			// Call the function on the single inputs (splat)
			result[i] = Function(input0[i], input1[i], input2[i]);
		}
	}

	//***************************************************************************
	//Splats a function of the type Scalar Fn(Scalar, Scalar, Real) to
	//Vec(n) Fn(Vec(n), Vec(n), Real) (vector could be of whatever scalar type is)
	template <size_t Components, typename ScalarType, ScalarType(*Function)(ScalarType, ScalarType, Real)>
	void SplatTwoVecAndRealToVec(Call& call, ExceptionReport& report)
	{
		// Get pointers to the two vectors
		ScalarType* input0 = (ScalarType*)call.GetParameterUnchecked(0);
		ScalarType* input1 = (ScalarType*)call.GetParameterUnchecked(1);
		Real inputReal = call.Get<Real>(2);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < Components; ++i)
		{
			// Call the function on the single inputs (splat)
			result[i] = Function(input0[i], input1[i], inputReal);
		}
	}

	// Macro to allow removing of the doc string. For now it doesn't do anything though.
#define ZilchDocString(docString) docString

#define ZilchSplatAllVectorOperationsAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type ), this->type##Type , FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVec<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); 

#define ZilchSplatNamedAllVectorOperationsTwoExtraAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, typeA, typeB, Method, Name, p1, p2, p3, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<1, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##Type , p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##Type , FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<2, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##2Type, p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<3, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##3Type, p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecTwoExtra<4, type, typeA, typeB, NamespaceAndClass::Method>, ThreeParameters(this->type##4Type, p1, ZilchTypeId(typeA), p2, ZilchTypeId(typeB), p3), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); 

#define ZilchSplatNamedAllVectorOperationsOneExtraAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, typeA, Method, Name, p1, p2, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<1, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##Type , p1, ZilchTypeId(typeA), p2), this->type##Type , FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<2, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##2Type, p1, ZilchTypeId(typeA), p2), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<3, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##3Type, p1, ZilchTypeId(typeA), p2), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatVecToVecOneExtra<4, type, typeA, NamespaceAndClass::Method>, TwoParameters(this->type##4Type, p1, ZilchTypeId(typeA), p2), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); 

#define ZilchSplatNamedAllVectorOperationsAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, ParamName, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type , ParamName), this->type##Type,  FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type, ParamName), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type, ParamName), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVec<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type, ParamName), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatAllVectorOperationsWithErrorAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, ErrorFormatString) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type ),  this->type##Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type), this->type##2Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type), this->type##3Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type), this->type##4Type, FunctionOptions::Static)->UserData = ErrorFormatString;

#define ZilchSplatNamedAllVectorOperationsWithErrorAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, ParamName, ErrorFormatString) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<1, type, NamespaceAndClass::Method>, OneParameter(this->type##Type , ParamName),  this->type##Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<2, type, NamespaceAndClass::Method>, OneParameter(this->type##2Type, ParamName), this->type##2Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<3, type, NamespaceAndClass::Method>, OneParameter(this->type##3Type, ParamName), this->type##3Type, FunctionOptions::Static)->UserData = ErrorFormatString; \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatVecToVecWithError<4, type, NamespaceAndClass::Method>, OneParameter(this->type##4Type, ParamName), this->type##4Type, FunctionOptions::Static)->UserData = ErrorFormatString;

#define ZilchSplatAllTwoVecToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<1, type, NamespaceAndClass::Method>, TwoParameters(this->type##Type),  this->type##Type,  FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<2, type, NamespaceAndClass::Method>, TwoParameters(this->type##2Type), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<3, type, NamespaceAndClass::Method>, TwoParameters(this->type##3Type), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecToVec<4, type, NamespaceAndClass::Method>, TwoParameters(this->type##4Type), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatNamedAllTwoVecToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, FunctionName, Param1Name, Param2Name, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<1, type, NamespaceAndClass::Method>, TwoParameters( this->type##Type, Param1Name,  this->type##Type, Param2Name), this->type##Type,  FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<2, type, NamespaceAndClass::Method>, TwoParameters(this->type##2Type, Param1Name, this->type##2Type, Param2Name), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<3, type, NamespaceAndClass::Method>, TwoParameters(this->type##3Type, Param1Name, this->type##3Type, Param2Name), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, FunctionName, SplatTwoVecToVec<4, type, NamespaceAndClass::Method>, TwoParameters(this->type##4Type, Param1Name, this->type##4Type, Param2Name), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatAllThreeVecToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, p1, p2, p3, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<1, type, NamespaceAndClass::Method>, ThreeParameters(this->type##Type,   p1, this->type##Type,   p2,  this->type##Type, p3),  this->type##Type, FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<2, type, NamespaceAndClass::Method>, ThreeParameters(this->type##2Type,  p1, this->type##2Type,  p2, this->type##2Type, p3), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<3, type, NamespaceAndClass::Method>, ThreeParameters(this->type##3Type,  p1, this->type##3Type,  p2, this->type##3Type, p3), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatThreeVecToVec<4, type, NamespaceAndClass::Method>, ThreeParameters(this->type##4Type,  p1, this->type##4Type,  p2, this->type##4Type, p3), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise."));

#define ZilchSplatAllTwoVecAndRealToVecAs(ZilchBuilder, ZilchType, NamespaceAndClass, type, Method, Name, p1, p2, p3, UserDescription) \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<1, type, NamespaceAndClass::Method>, ThreeParameters(this->type##Type,  p1, this->type##Type,  p2, this->type##Type, p3),  this->type##Type, FunctionOptions::Static)->Description = ZilchDocString(UserDescription); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<2, type, NamespaceAndClass::Method>, ThreeParameters(this->type##2Type, p1, this->type##2Type, p2, this->type##Type, p3), this->type##2Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<3, type, NamespaceAndClass::Method>, ThreeParameters(this->type##3Type, p1, this->type##3Type, p2, this->type##Type, p3), this->type##3Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise.")); \
  ZilchBuilder.AddBoundFunction(ZilchType, Name, SplatTwoVecAndRealToVec<4, type, NamespaceAndClass::Method>, ThreeParameters(this->type##4Type, p1, this->type##4Type, p2, this->type##Type, p3), this->type##4Type, FunctionOptions::Static)->Description = ZilchDocString(BuildString(UserDescription, " Performed component-wise."));

	//***************************************************************************
	// Splat a one parameter function across a vector/matrix.
	template <typename ScalarType0, typename ResultType,
		size_t ScalarType0Offset,
		typename FunctionPointer, FunctionPointer Fn>
		void FullOneParameterSplat(Call& call, ExceptionReport& report)
	{
		size_t size = (size_t)call.GetFunction()->UserData;

		// Get pointers to our input data
		ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);

		// Get a pointer to our return/output vector
		ResultType* result = (ResultType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < size; ++i)
		{
			// Call the function bound function
			// (the offset is used to generically control if an input should be only one scalar or another vector type)
			result[i] = Fn(input0[i * ScalarType0Offset]);
		}
	}

	//***************************************************************************
	// This version of one parameter splatting allows the user to specify an overloaded function (by providing the types manually)
	template <typename ScalarType0, typename ResultType,
		typename FnScalarType0,
		size_t ScalarType0Offset,
		ResultType(*Function)(FnScalarType0)>
		void FullOneParameterSplatAs(Call& call, ExceptionReport& report)
	{
		FullOneParameterSplat<ScalarType0, ResultType,
			ScalarType0Offset,
			TypeOfFunctionPointer(Function), Function>(call, report);
	}

	//***************************************************************************
	// Splats a function of the type Result Fn(Scalar0, Scalar1).
	// The offset numbers are used to generically control if an input is a scalar or a vector.
	// ie. scalarOffsets of <1, 1> are used to splat Real3 Max(Real3, Real3) while
	// scalarOffset of <1, 0> are used to splat Real3 Ceil(Real3, Real).

	template <typename ScalarType0, typename ScalarType1, typename ResultType,
		size_t ScalarType0Offset, size_t ScalarType1Offset,
		typename FunctionPointer, FunctionPointer Fn>
		void FullTwoParameterSplat(Call& call, ExceptionReport& report)
	{
		size_t size = (size_t)call.GetFunction()->UserData;

		// Get pointers to our input data
		ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);
		ScalarType1* input1 = (ScalarType1*)call.GetParameterUnchecked(1);

		// Get a pointer to our return/output vector
		ResultType* result = (ResultType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < size; ++i)
		{
			// Call the function bound function
			// (the offset is used to generically control if an input should be only one scalar or another vector type)
			result[i] = Fn(input0[i * ScalarType0Offset], input1[i * ScalarType1Offset]);
		}
	}

	//***************************************************************************
	// This version of two parameter splatting allows the user to specify an overloaded function (by providing the types manually)
	template <typename ScalarType0, typename ScalarType1, typename ResultType,
		typename FnScalarType0, typename FnScalarType1,
		size_t ScalarType0Offset, size_t ScalarType1Offset,
		ResultType(*Function)(ScalarType0, ScalarType1)>
		void FullTwoParameterSplatAs(Call& call, ExceptionReport& report)
	{
		FullTwoParameterSplat<ScalarType0, ScalarType1, ResultType,
			ScalarType0Offset, ScalarType1Offset,
			TypeOfFunctionPointer(Function), Function>(call, report);
	}

	//***************************************************************************
	// Splats a function of the type Result Fn(Scalar0, Scalar1, Scalar2).
	// The offset numbers are used to generically control if an input is a scalar or a vector.
	// ie. scalarOffsets of <1, 1, 1> are used to splat Real3 Clamp(Real3, Real3, Real3) while
	// scalarOffset of <1, 1, 0> are used to splat Real3 Lerp(Real3, Real3, Real).
	// This is the most general case splat so that the function parameters can be specified separately
	// (mainly so the the ScalarType can be Real while the function can take const Real&)
	template <typename ScalarType0, typename ScalarType1, typename ScalarType2, typename ResultType,
		size_t ScalarType0Offset, size_t ScalarType1Offset, size_t ScalarType2Offset,
		typename FunctionPointer, FunctionPointer Fn>
		void FullThreeParameterSplat(Call& call, ExceptionReport& report)
	{
		size_t size = (size_t)call.GetFunction()->UserData;

		// Get pointers to our input data
		ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);
		ScalarType1* input1 = (ScalarType1*)call.GetParameterUnchecked(1);
		ScalarType2* input2 = (ScalarType2*)call.GetParameterUnchecked(2);

		// Get a pointer to our return/output vector
		ResultType* result = (ResultType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < size; ++i)
		{
			// Call the function bound function
			// (the offset is used to generically control if an input should be only one scalar or another vector type)
			result[i] = Fn(input0[i * ScalarType0Offset], input1[i * ScalarType1Offset], input2[i * ScalarType2Offset]);
		}
	}

	//***************************************************************************
	// This version of two parameter splatting allows the user to specify an overloaded function (by providing the types manually)
	template <typename ScalarType0, typename ScalarType1, typename ScalarType2, typename ResultType,
		typename FnScalarType0, typename FnScalarType1, typename FnScalarType2,
		size_t ScalarType0Offset, size_t ScalarType1Offset, size_t ScalarType2Offset,
		ResultType(*Function)(FnScalarType0, FnScalarType1, FnScalarType2)>
		void FullThreeParameterSplatAs(Call& call, ExceptionReport& report)
	{
		FullThreeParameterSplat<ScalarType0, ScalarType1, ScalarType2, ResultType,
			ScalarType0Offset, ScalarType1Offset, ScalarType2Offset,
			TypeOfFunctionPointer(Function), Function>(call, report);

	}

	//***************************************************************************
	// User data for splatting a function with a custom error message. 
	// Used by Sqrt to deal with negative numbers and a few other functions.
	class SplatWithErrorUserData
	{
	public:

		SplatWithErrorUserData(size_t size, cstr errorFormat, BoundType* boundType) :
			Size(size),
			ErrorFormat(errorFormat),
			Type(boundType)
		{

		}

		size_t Size;
		cstr ErrorFormat;
		BoundType* Type;
	};

	//***************************************************************************
	void AllNonZero(Call& call, ExceptionReport& report)
	{
		SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);

		size_t elementSize = userData.Type->Size / userData.Size;

		// This should always be a small allocation so just allocate it on the stack
		byte* data = (byte*)alloca(elementSize);
		memset(data, 0, elementSize);

		byte* input = call.GetParameterUnchecked(0);

		bool allTrue = true;
		for (size_t i = 0; i < userData.Size; ++i)
		{
			if (memcmp(input + i * elementSize, data, elementSize) == 0)
				allTrue = false;
		}

		call.Set(Call::Return, allTrue);
	}

	//***************************************************************************
	void AnyNonZero(Call& call, ExceptionReport& report)
	{
		SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);

		size_t elementSize = userData.Type->Size / userData.Size;

		// This should always be a small allocation so just allocate it on the stack
		byte* data = (byte*)alloca(elementSize);
		memset(data, 0, elementSize);

		byte* input = call.GetParameterUnchecked(0);

		bool anyTrue = false;
		for (size_t i = 0; i < userData.Size; ++i)
		{
			if (memcmp(input + i * elementSize, data, elementSize) != 0)
			{
				anyTrue = true;
				break;
			}
		}

		call.Set(Call::Return, anyTrue);
	}

	//***************************************************************************
	// Splats a function of the type Boolean Fn(Scalar, Scalar&) to
	// Vec(n) Fn(Vec(n)). The function being splatted is a Scalar Fn(Scalar)
	// function that has been altered to return if it failed so an exception
	// can be thrown.
	template <typename ScalarType, bool(*Function)(ScalarType, ScalarType&)>
	void SimpleSplatWithError(Call& call, ExceptionReport& report)
	{
		SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);

		// Get a pointer to our input vector
		ScalarType* input = (ScalarType*)call.GetParameterUnchecked(0);

		// Get a pointer to our return/output vector
		ScalarType* result = (ScalarType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		bool success = true;
		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < userData.Size; ++i)
		{
			// Call the function on the single input (splat)
			success = Function(input[i], result[i]);

			// If the function failed for whatever reason then throw an exception
			if (success == false)
			{
				// The user data of this function should contain a format string with
				// one %s in it to display the input value that failed.
				cstr errFormat = userData.ErrorFormat;
				String inputAsString = userData.Type->GenericToString((byte*)input);
				String msg = String::Format(errFormat, inputAsString.c_str());
				call.GetState()->ThrowException(report, msg);
				return;
			}
		}
	}

	//***************************************************************************
	// Splats a function of the type Boolean Fn(Scalar, Scalar&) to
	// Vec(n) Fn(Vec(n)). The function being splatted is a Scalar Fn(Scalar)
	// function that has been altered to return if it failed so an exception
	// can be thrown.
	template <typename ScalarType0, typename ScalarType1, typename ResultType,
		size_t ScalarType0Offset, size_t ScalarType1Offset,
		bool(*Function)(ScalarType0, ScalarType1, ResultType&)>
		void FullTwoParameterSplatWithError(Call& call, ExceptionReport& report)
	{
		SplatWithErrorUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<SplatWithErrorUserData>(0);

		// Get a pointer to our input vector
		ScalarType0* input0 = (ScalarType0*)call.GetParameterUnchecked(0);
		ScalarType1* input1 = (ScalarType1*)call.GetParameterUnchecked(1);

		// Get a pointer to our return/output vector
		ResultType* result = (ResultType*)call.GetReturnUnchecked();
		call.MarkReturnAsSet();

		bool success = true;
		// Loop through all the components to apply the given function (splat)
		for (size_t i = 0; i < userData.Size; ++i)
		{
			// Call the function on the single input (splat)
			success = Function(input0[i * ScalarType0Offset], input1[i * ScalarType0Offset], result[i]);

			// If the function failed for whatever reason then throw an exception
			if (success == false)
			{
				// The user data of this function should contain a format string with
				// two %s in it to display the input value that failed.
				cstr errFormat = userData.ErrorFormat;
				String input0AsString = userData.Type->GenericToString((byte*)input0);
				String input1AsString = userData.Type->GenericToString((byte*)input1);
				String msg = String::Format(errFormat, input0AsString.c_str(), input1AsString.c_str());
				call.GetState()->ThrowException(report, msg);
				return;
			}
		}
	}

#define ZilchSetUserDataAndDescription(function, boundType, scalarBoundType, docString)    \
  f->UserData = (void*)(boundType->Size / scalarBoundType->Size);                          \
  if (boundType == scalarBoundType)                                                        \
    f->Description = ZilchDocString(docString);                                            \
    else                                                                                     \
    f->Description = ZilchDocString(BuildString(docString, " Performed component-wise.")); 

#define ZilchComplexOneParameterSplatBinder(scalarType0, returnType, offset0, function) \
  FullOneParameterSplatAs<scalarType0, returnType, scalarType0, offset0, function>

#define ZilchBindBasicSplat(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString) \
	  {                                                                                                                                \
    Zilch::BoundFn boundFn = ZilchComplexOneParameterSplatBinder(scalarType, scalarType, 1, function);                             \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);          \
    ZilchSetUserDataAndDescription(f, boundType, scalarBoundType, docString);                                                      \
	  }

#define ZilchBindBasicSplatWithError(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString, errorFormat)     \
	  {                                                                                                                                                          \
    Function* f = builder.AddBoundFunction(owner, functionName, SimpleSplatWithError<scalarType, function>, parameters, boundType, FunctionOptions::Static); \
    SplatWithErrorUserData userData(boundType->Size / scalarBoundType->Size, errorFormat, boundType);                                                        \
    f->ComplexUserData.WriteObject(userData);                                                                                                                \
    if (boundType == scalarBoundType)                                                                                                                        \
      f->Description = ZilchDocString(docString);                                                                                                            \
	    else                                                                                                                                                     \
      f->Description = ZilchDocString(BuildString(docString, " Performed component-wise."));                                                                 \
	  }

#define ZilchComplexTwoParameterSplatBinder(scalarType0, scalarType1, returnType, offset0, offset1, function) \
  FullTwoParameterSplatAs<scalarType0, scalarType1, returnType, scalarType0, scalarType1, offset0, offset1, function>

#define ZilchBindBasicTwoParamSplat(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString) \
	  {                                                                                                                                        \
    Zilch::BoundFn boundFn = ZilchComplexTwoParameterSplatBinder(scalarType, scalarType, scalarType, 1, 1, function);                      \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);                  \
    ZilchSetUserDataAndDescription(f, boundType, scalarBoundType, docString);                                                              \
	  }

#define ZilchBindBasicTwoParamSplatWithError(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString, errorFormat) \
	  {                                                                                                                                                              \
    Zilch::BoundFn boundFn = FullTwoParameterSplatWithError<scalarType, scalarType, scalarType, 1, 1, function>;                                                 \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);                                        \
    SplatWithErrorUserData userData(boundType->Size / scalarBoundType->Size, errorFormat, boundType);                                                            \
    f->ComplexUserData.WriteObject(userData);                                                                                                                    \
    if (boundType == scalarBoundType)                                                                                                                            \
      f->Description = ZilchDocString(docString);                                                                                                                \
	    else                                                                                                                                                         \
      f->Description = ZilchDocString(BuildString(docString, " Performed component-wise."));                                                                     \
	  }

#define ZilchFullThreeParameterSplatBinder(Type0, Type1, Type2, ReturnType, Offset0, Offset1, Offset2, BoundFunction) \
  FullThreeParameterSplat<Type0, Type1, Type2, ReturnType, Offset0, Offset1, Offset2, ZilchTypeOfFunctionPointer(BoundFunction) , BoundFunction>

#define ZilchComplexThreeParameterSplatBinder(scalarType0, scalarType1, scalarType2, returnType, offset0, offset1, offset2, function) \
  FullThreeParameterSplatAs<scalarType0, scalarType1, scalarType2, returnType, scalarType0, scalarType1, scalarType2, offset0, offset1, offset2, function>

#define ZilchBindBasicThreeParamSplat(builder, owner, scalarType, scalarBoundType, functionName, function, boundType, parameters, docString) \
	  {                                                                                                                                          \
    Zilch::BoundFn boundFn = ZilchComplexThreeParameterSplatBinder(scalarType, scalarType, scalarType, scalarType, 1, 1, 1, function);       \
    Function* f = builder.AddBoundFunction(owner, functionName, boundFn, parameters, boundType, FunctionOptions::Static);                    \
    ZilchSetUserDataAndDescription(f, boundType, scalarBoundType, docString);                                                                \
	  }

	//***************************************************************************
	void Core::PreSetupBinding(LibraryBuilder& builder)
	{
		// Setup all the primitive types
		BoundType* doubleIntegerType = ZilchTypeId(DoubleInteger);
		BoundType* doubleRealType = ZilchTypeId(DoubleReal);
		BoundType* booleanType = ZilchTypeId(Boolean);
		BoundType* boolean2Type = ZilchTypeId(Boolean2);
		BoundType* boolean3Type = ZilchTypeId(Boolean3);
		BoundType* boolean4Type = ZilchTypeId(Boolean4);
		BoundType* integerType = ZilchTypeId(Integer);
		BoundType* integer2Type = ZilchTypeId(Integer2);
		BoundType* integer3Type = ZilchTypeId(Integer3);
		BoundType* integer4Type = ZilchTypeId(Integer4);
		BoundType* realType = ZilchTypeId(Real);
		BoundType* real2Type = ZilchTypeId(Real2);
		BoundType* real3Type = ZilchTypeId(Real3);
		BoundType* real4Type = ZilchTypeId(Real4);
		BoundType* quaternionType = ZilchTypeId(Quaternion);
		BoundType* nullType = new BoundType("Null", TypeCopyMode::ReferenceType, 0, 0);
		BoundType* voidType = new BoundType("Void", TypeCopyMode::ValueType, 0, 0);
		BoundType* errorType = new BoundType("[ErrorType]", TypeCopyMode::ValueType, 0, 0);
		BoundType* overloadedMethodsType = new BoundType("[MultipleMethodsOfTheSameName]", TypeCopyMode::ValueType, 0, 0);
		DelegateType* anyDelegateType = new DelegateType();

		// The any delegate has no return
		anyDelegateType->Return = voidType;

		// Add ourselves to the library
		builder.AddRawBoundType(nullType);
		builder.AddRawBoundType(voidType);
		builder.AddRawBoundType(errorType);
		builder.AddRawBoundType(overloadedMethodsType);

		// Store the primitive types as global constants
		this->BooleanType = booleanType;
		this->Boolean2Type = boolean2Type;
		this->Boolean3Type = boolean3Type;
		this->Boolean4Type = boolean4Type;
		this->IntegerType = integerType;
		this->Integer2Type = integer2Type;
		this->Integer3Type = integer3Type;
		this->Integer4Type = integer4Type;
		this->RealType = realType;
		this->Real2Type = real2Type;
		this->Real3Type = real3Type;
		this->Real4Type = real4Type;
		this->QuaternionType = quaternionType;
		this->DoubleIntegerType = doubleIntegerType;
		this->DoubleRealType = doubleRealType;
		this->VoidType = voidType;
		this->NullType = nullType;
		this->ErrorType = errorType;
		this->OverloadedMethodsType = overloadedMethodsType;
		this->AnyDelegateType = anyDelegateType;

		// Fill out the real array
		this->BooleanTypes[0] = booleanType;
		this->BooleanTypes[1] = boolean2Type;
		this->BooleanTypes[2] = boolean3Type;
		this->BooleanTypes[3] = boolean4Type;
		this->AllBooleanTypes.push_back(booleanType);
		this->AllBooleanTypes.push_back(boolean2Type);
		this->AllBooleanTypes.push_back(boolean3Type);
		this->AllBooleanTypes.push_back(boolean4Type);
		this->IntegerTypes[0] = integerType;
		this->IntegerTypes[1] = integer2Type;
		this->IntegerTypes[2] = integer3Type;
		this->IntegerTypes[3] = integer4Type;
		this->AllIntegerTypes.push_back(integerType);
		this->AllIntegerTypes.push_back(integer2Type);
		this->AllIntegerTypes.push_back(integer3Type);
		this->AllIntegerTypes.push_back(integer4Type);
		this->RealTypes[0] = realType;
		this->RealTypes[1] = real2Type;
		this->RealTypes[2] = real3Type;
		this->RealTypes[3] = real4Type;
		this->AllRealTypes.push_back(realType);
		this->AllRealTypes.push_back(real2Type);
		this->AllRealTypes.push_back(real3Type);
		this->AllRealTypes.push_back(real4Type);
		this->MatrixElementTypes[0] = realType;
		this->MatrixElementTypes[1] = integerType;
		this->MatrixElementTypes[2] = booleanType;

		// Create the one special any type (there should only ever be one instantiation of this!)
		this->AnythingType = new AnyType();
		builder.BuiltLibrary->OwnedTypes.push_back(this->AnythingType);

		// Add the array template instantiator
		StringArray arrayArguments;
		arrayArguments.push_back("Type");
		builder.AddTemplateInstantiator("Property", InstantiatePropertyDelegate, arrayArguments, nullptr);
		builder.AddTemplateInstantiator("Array", InstantiateArray, arrayArguments, nullptr);

		StringArray keyValueArguments;
		keyValueArguments.push_back("Key");
		keyValueArguments.push_back("Value");

		// Add the hash-map template instantiator
		builder.AddTemplateInstantiator("HashMap", InstantiateHashMap, keyValueArguments, nullptr);
		builder.AddTemplateInstantiator("KeyValue", InstantiateKeyValue, keyValueArguments, nullptr);

		// Create the events class
		BoundType* events = builder.AddBoundType("Events", TypeCopyMode::ReferenceType, 0);
		this->EventsType = events;

		// Create the string type as a reference type
		BoundType* stringType = ZilchTypeId(String);
		stringType->HandleManager = ZilchManagerId(StringManager);
		builder.AddBoundFunction(stringType, "SubString", SubString, TwoParameters(integerType, "start", "length"), stringType, FunctionOptions::None);
		builder.AddBoundFunction(stringType, "Get", StringGetChar, OneParameter(integerType, "index"), integerType, FunctionOptions::None);
		builder.AddBoundProperty(stringType, "Count", integerType, nullptr, StringCount, MemberOptions::None);
		builder.AddBoundFunction(stringType, "Concatenate", StringConcatenate, TwoParameters(stringType), stringType, FunctionOptions::Static);
		builder.AddBoundFunction(stringType, "FromChar", StringFromChar, OneParameter(integerType), stringType, FunctionOptions::Static);

		// Bind the FormatC function which has "variadic arguments"
		ParameterArray parameters;
		DelegateParameter& formatParameter = parameters.push_back();
		formatParameter.Name = "format";
		formatParameter.ParameterType = stringType;
		for (size_t i = 0; i < 10; ++i)
		{
			DelegateParameter& parameter = parameters.push_back();
			parameter.ParameterType = ZilchTypeId(Any);
			Function* formatFunction = builder.AddBoundFunction(stringType, "FormatC", StringFormatC, parameters, stringType, FunctionOptions::Static);
			formatFunction->UserData = (void*)(i + 1);
		}

		this->StringType = stringType;

		// Bind any stringify functions
		booleanType->ToStringFunction = BooleanToString;
		boolean2Type->ToStringFunction = Boolean2ToString;
		boolean3Type->ToStringFunction = Boolean3ToString;
		boolean4Type->ToStringFunction = Boolean4ToString;
		integerType->ToStringFunction = IntegerToString;
		integer2Type->ToStringFunction = Integer2ToString;
		integer3Type->ToStringFunction = Integer3ToString;
		integer4Type->ToStringFunction = Integer4ToString;
		realType->ToStringFunction = RealToString;
		real2Type->ToStringFunction = Real2ToString;
		real3Type->ToStringFunction = Real3ToString;
		real4Type->ToStringFunction = Real4ToString;
		quaternionType->ToStringFunction = QuaternionToString;
		doubleIntegerType->ToStringFunction = DoubleIntegerToString;
		doubleRealType->ToStringFunction = DoubleRealToString;
		stringType->ToStringFunction = StringToString;

		// Add ourselves to the library
		BoundType* math = builder.AddBoundType("Math", TypeCopyMode::ReferenceType, 0);
		MathType = math;

		// Bind default constructors to the vector types
		builder.AddBoundDefaultConstructor(booleanType, VectorDefaultConstructor<1, Boolean>);
		builder.AddBoundDefaultConstructor(boolean2Type, VectorDefaultConstructor<2, Boolean>);
		builder.AddBoundDefaultConstructor(boolean3Type, VectorDefaultConstructor<3, Boolean>);
		builder.AddBoundDefaultConstructor(boolean4Type, VectorDefaultConstructor<4, Boolean>);
		builder.AddBoundDefaultConstructor(integerType, VectorDefaultConstructor<1, Integer>);
		builder.AddBoundDefaultConstructor(integer2Type, VectorDefaultConstructor<2, Integer>);
		builder.AddBoundDefaultConstructor(integer3Type, VectorDefaultConstructor<3, Integer>);
		builder.AddBoundDefaultConstructor(integer4Type, VectorDefaultConstructor<4, Integer>);
		builder.AddBoundDefaultConstructor(realType, VectorDefaultConstructor<1, Real>);
		builder.AddBoundDefaultConstructor(real2Type, VectorDefaultConstructor<2, Real>);
		builder.AddBoundDefaultConstructor(real3Type, VectorDefaultConstructor<3, Real>);
		builder.AddBoundDefaultConstructor(real4Type, VectorDefaultConstructor<4, Real>);
		builder.AddBoundDefaultConstructor(quaternionType, QuaternionDefaultConstructor);

		// The scalar constructors
		{
			ParameterArray parameters;
			DelegateParameter& scalarParam = parameters.push_back();
			scalarParam.ParameterType = this->RealType;
			scalarParam.Name = "scalar";

			// Bind constructors to the vector types
			GenerateVectorScalarConstructor<1, Boolean>(builder, booleanType, booleanType);
			GenerateVectorScalarConstructor<2, Boolean>(builder, boolean2Type, booleanType);
			GenerateVectorScalarConstructor<3, Boolean>(builder, boolean3Type, booleanType);
			GenerateVectorScalarConstructor<4, Boolean>(builder, boolean4Type, booleanType);
			GenerateVectorScalarConstructor<1, Integer>(builder, integerType, integerType);
			GenerateVectorScalarConstructor<2, Integer>(builder, integer2Type, integerType);
			GenerateVectorScalarConstructor<3, Integer>(builder, integer3Type, integerType);
			GenerateVectorScalarConstructor<4, Integer>(builder, integer4Type, integerType);
			GenerateVectorScalarConstructor<1, Real   >(builder, realType, realType);
			GenerateVectorScalarConstructor<2, Real   >(builder, real2Type, realType);
			GenerateVectorScalarConstructor<3, Real   >(builder, real3Type, realType);
			GenerateVectorScalarConstructor<4, Real   >(builder, real4Type, realType);
		}

		// Generate the different permutations of constructors (no need to do the singles, they only have the scalar/default constructors)
		GenerateVectorComponentConstructors<2, Boolean>(builder, boolean2Type, this->BooleanTypes);
		GenerateVectorComponentConstructors<3, Boolean>(builder, boolean3Type, this->BooleanTypes);
		GenerateVectorComponentConstructors<4, Boolean>(builder, boolean4Type, this->BooleanTypes);
		GenerateVectorComponentConstructors<2, Integer>(builder, integer2Type, this->IntegerTypes);
		GenerateVectorComponentConstructors<3, Integer>(builder, integer3Type, this->IntegerTypes);
		GenerateVectorComponentConstructors<4, Integer>(builder, integer4Type, this->IntegerTypes);
		GenerateVectorComponentConstructors<2, Real   >(builder, real2Type, this->RealTypes);
		GenerateVectorComponentConstructors<3, Real   >(builder, real3Type, this->RealTypes);
		GenerateVectorComponentConstructors<4, Real   >(builder, real4Type, this->RealTypes);
		GenerateVectorComponentConstructors<4, Real   >(builder, quaternionType, this->RealTypes);

		// Generate swizzles for all of our vector types
		GenerateVectorSwizzles<1, Boolean >(builder, booleanType, this->BooleanTypes);
		GenerateVectorSwizzles<2, Boolean >(builder, boolean2Type, this->BooleanTypes);
		GenerateVectorSwizzles<3, Boolean >(builder, boolean3Type, this->BooleanTypes);
		GenerateVectorSwizzles<4, Boolean >(builder, boolean4Type, this->BooleanTypes);
		GenerateVectorSwizzles<1, Integer >(builder, integerType, this->IntegerTypes);
		GenerateVectorSwizzles<2, Integer >(builder, integer2Type, this->IntegerTypes);
		GenerateVectorSwizzles<3, Integer >(builder, integer3Type, this->IntegerTypes);
		GenerateVectorSwizzles<4, Integer >(builder, integer4Type, this->IntegerTypes);
		GenerateVectorSwizzles<1, Real    >(builder, realType, this->RealTypes);
		GenerateVectorSwizzles<2, Real    >(builder, real2Type, this->RealTypes);
		GenerateVectorSwizzles<3, Real    >(builder, real3Type, this->RealTypes);
		GenerateVectorSwizzles<4, Real    >(builder, real4Type, this->RealTypes);
		GenerateVectorSwizzles<4, Real    >(builder, quaternionType, this->RealTypes);

		// Every vector gets a count which tells you how many elements there are, for generic programming
		builder.AddBoundProperty(booleanType, "Count", this->IntegerType, nullptr, VectorCount<1>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(boolean2Type, "Count", this->IntegerType, nullptr, VectorCount<2>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(boolean3Type, "Count", this->IntegerType, nullptr, VectorCount<3>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(boolean4Type, "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(integerType, "Count", this->IntegerType, nullptr, VectorCount<1>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(integer2Type, "Count", this->IntegerType, nullptr, VectorCount<2>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(integer3Type, "Count", this->IntegerType, nullptr, VectorCount<3>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(integer4Type, "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(realType, "Count", this->IntegerType, nullptr, VectorCount<1>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(real2Type, "Count", this->IntegerType, nullptr, VectorCount<2>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(real3Type, "Count", this->IntegerType, nullptr, VectorCount<3>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(real4Type, "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;
		builder.AddBoundProperty(quaternionType, "Count", this->IntegerType, nullptr, VectorCount<4>, FunctionOptions::None)->IsHidden = true;

		// Bind the get functions for vectors (indexing)
		builder.AddBoundFunction(booleanType, "Get", VectorGet<1, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
		builder.AddBoundFunction(boolean2Type, "Get", VectorGet<2, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
		builder.AddBoundFunction(boolean3Type, "Get", VectorGet<3, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
		builder.AddBoundFunction(boolean4Type, "Get", VectorGet<4, Boolean>, OneParameter(this->IntegerType), this->BooleanType, FunctionOptions::None);
		builder.AddBoundFunction(integerType, "Get", VectorGet<1, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
		builder.AddBoundFunction(integer2Type, "Get", VectorGet<2, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
		builder.AddBoundFunction(integer3Type, "Get", VectorGet<3, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
		builder.AddBoundFunction(integer4Type, "Get", VectorGet<4, Integer>, OneParameter(this->IntegerType), this->IntegerType, FunctionOptions::None);
		builder.AddBoundFunction(realType, "Get", VectorGet<1, Real>, OneParameter(this->IntegerType), this->RealType, FunctionOptions::None);
		builder.AddBoundFunction(real2Type, "Get", VectorGet<2, Real>, OneParameter(this->IntegerType), this->RealType, FunctionOptions::None);
		builder.AddBoundFunction(real3Type, "Get", VectorGet<3, Real>, OneParameter(this->IntegerType), this->RealType, FunctionOptions::None);
		builder.AddBoundFunction(real4Type, "Get", VectorGet<4, Real>, OneParameter(this->IntegerType), this->RealType, FunctionOptions::None);
		builder.AddBoundFunction(quaternionType, "Get", VectorGet<4, Real>, OneParameter(this->IntegerType), this->RealType, FunctionOptions::None);

		// Bind the set functions for vectors (indexing)
		builder.AddBoundFunction(booleanType, "Set", VectorSet<1, Boolean>, TwoParameters(this->IntegerType, this->BooleanType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(boolean2Type, "Set", VectorSet<2, Boolean>, TwoParameters(this->IntegerType, this->BooleanType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(boolean3Type, "Set", VectorSet<3, Boolean>, TwoParameters(this->IntegerType, this->BooleanType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(boolean4Type, "Set", VectorSet<4, Boolean>, TwoParameters(this->IntegerType, this->BooleanType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(integerType, "Set", VectorSet<1, Integer>, TwoParameters(this->IntegerType, this->IntegerType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(integer2Type, "Set", VectorSet<2, Integer>, TwoParameters(this->IntegerType, this->IntegerType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(integer3Type, "Set", VectorSet<3, Integer>, TwoParameters(this->IntegerType, this->IntegerType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(integer4Type, "Set", VectorSet<4, Integer>, TwoParameters(this->IntegerType, this->IntegerType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(realType, "Set", VectorSet<1, Real>, TwoParameters(this->IntegerType, this->RealType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(real2Type, "Set", VectorSet<2, Real>, TwoParameters(this->IntegerType, this->RealType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(real3Type, "Set", VectorSet<3, Real>, TwoParameters(this->IntegerType, this->RealType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(real4Type, "Set", VectorSet<4, Real>, TwoParameters(this->IntegerType, this->RealType), this->VoidType, FunctionOptions::None);
		builder.AddBoundFunction(quaternionType, "Set", VectorSet<4, Real>, TwoParameters(this->IntegerType, this->RealType), this->VoidType, FunctionOptions::None);

		FunctionOptions::Enum options = FunctionOptions::Static;

		ZilchBindCustomStaticNamedParameterMethodOverload(builder, math, Math, RotateVector, "vector axis radians", Real3, Math::Vec3Param, Math::Vec3Param, Math::real)->Description = ZilchDocString("Rotate a vector about an axis by the given radians.");

		ZilchBindCustomStaticMethodOverloadAs(builder, math, Math, Angle, "AngleBetween", Real, Math::Vec2Param, Math::Vec2Param)->Description = ZilchDocString("Returns the angle between two Real2s in radians.");
		ZilchBindCustomStaticMethodOverloadAs(builder, math, Math, Angle, "AngleBetween", Real, Math::Vec3Param, Math::Vec3Param)->Description = ZilchDocString("Returns the angle between two Real3s in radians.");
		ZilchBindCustomStaticMethodOverloadAs(builder, math, Math, Angle, "AngleBetween", Real, Math::QuatParam, Math::QuatParam)->Description = ZilchDocString("Returns the angle between two Quaternions in radians.");

		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, SafeSlerp, "Slerp", "start end t", Real2, Math::Vec2Param, Math::Vec2Param, Real)->Description = ZilchDocString("Spherical linear interpolation. Used to interpolate between two vectors by the parameter t.");
		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, SafeSlerp, "Slerp", "start end t", Real3, Math::Vec3Param, Math::Vec3Param, Real)->Description = ZilchDocString("Spherical linear interpolation. Used to interpolate between two vectors by the parameter t.");
		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, Slerp, "Slerp", "start end t", Quaternion, Math::QuatParam, Math::QuatParam, Real)->Description = ZilchDocString("Spherical linear interpolation. Used to interpolate between two rotations by the parameter t.");

		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, SafeRotateTowards, "RotateTowards", "p0 p1 maxRadians", Real2, Math::Vec2Param, Math::Vec2Param, Real)->Description = ZilchDocString("Rotate a vector towards another vector changing at most maxRadians.");
		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, SafeRotateTowards, "RotateTowards", "p0 p1 maxRadians", Real3, Math::Vec3Param, Math::Vec3Param, Real)->Description = ZilchDocString("Rotate a vector towards another vector changing at most maxRadians.");
		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, RotateTowards, "RotateTowards", "p0 p1 maxRadians", Quaternion, Math::QuatParam, Math::QuatParam, Real)->Description = ZilchDocString("Rotate a quaternion towards another quaternion changing at most maxRadians.");

		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, SignedAngle, "SignedAngle", "p0 p1 up", Real, Math::Vec3Param, Math::Vec3Param, Math::Vec3Param)->Description = ZilchDocString("Get the rotation angle between two vectors in radians.");
		ZilchBindCustomStaticMethodOverloadAs(builder, math, Math, Angle2D, "Angle2D", Real, Math::Vec3Param)->Description = ZilchDocString("Computes the angle (in radians) about the z-axis between the vector and the x-axis.");
		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, Project, "Project", "vector axis", Real3, Math::Vec3Param, Math::Vec3Param)->Description = ZilchDocString("Projects the vector onto the axis.");
		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, Reflect, "Reflect", "vector axis", Real3, Math::Vec3Param, Math::Vec3Param)->Description = ZilchDocString("Reflects the vector across the axis.");

		ZilchBindCustomStaticMethodOverloadAs(builder, math, , sqrt, "Sqrt", DoubleReal, DoubleReal);

		//Lots of quaternion construction functions
		ZilchBindCustomStaticNamedParameterMethodOverload(builder, math, Math, ToQuaternion, "axis radians", Quaternion, Math::Vec3Param, Real)->Description = ZilchDocString("Generates the quaternion that rotates about the axis vector by the given radians.");
		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, ToQuaternion, "AxisAngle", "axis radians", Quaternion, Math::Vec3Param, Real)->Description = ZilchDocString("Generates the quaternion that rotates about the axis vector by the given radians.");
		ZilchBindCustomStaticNamedParameterMethodOverload(builder, math, Math, ToQuaternion, "facing up", Quaternion, Math::Vec3Param, Math::Vec3Param)->Description = ZilchDocString("Generates the orientation represented by the given facing and up vectors.");
		ZilchBindCustomStaticNamedParameterMethodOverload(builder, math, Math, ToQuaternion, "facing up right", Quaternion, Math::Vec3Param, Math::Vec3Param, Math::Vec3Param)->Description = ZilchDocString("Generates the orientation represented by the given facing, up, and right vectors.");
		ZilchBindCustomStaticNamedParameterMethodOverload(builder, math, Math, ToQuaternion, "xRadians yRadians zRadians", Quaternion, Real, Real, Real)->Description = ZilchDocString("Generates the orientation from the given Euler angles.");
		ZilchBindCustomStaticNamedParameterMethodOverload(builder, math, Math, ToQuaternion, "eulerRadians", Quaternion, Math::Vec3Param)->Description = ZilchDocString("Generates the orientation from the given Euler angle vector");

		ZilchBindCustomStaticNamedParameterMethodOverloadAs(builder, math, Math, ToQuaternion, "Euler", "eulerRadians", Quaternion, Math::Vec3Param)->Description = ZilchDocString("Generates the orientation from the given Euler angle vector.");
		ZilchBindCustomStaticNamedParameterMethodOverload(builder, math, Math, RotationQuaternionBetween, "start end", Quaternion, Math::Vec3Param, Math::Vec3Param)->Description = ZilchDocString("Generates the quaternion that rotates from parameter 1 to parameter 2.");


		builder.AddBoundFunction(math, "Dot", VectorDotProduct<2>, TwoParameters(this->Real2Type), this->RealType, options)->Description = ZilchDocString("The vector dot product");
		builder.AddBoundFunction(math, "Dot", VectorDotProduct<3>, TwoParameters(this->Real3Type), this->RealType, options)->Description = ZilchDocString("The vector dot product");
		builder.AddBoundFunction(math, "Dot", VectorDotProduct<4>, TwoParameters(this->Real4Type), this->RealType, options)->Description = ZilchDocString("The vector dot product");
		builder.AddBoundFunction(math, "Dot", VectorDotProduct<4>, TwoParameters(this->QuaternionType), this->RealType, options)->Description = ZilchDocString("The vector dot product");

		//builder.AddBoundFunction(math, "Perp",    Vector2Perpendicular, GenerateTwoParameters(this->Real2Type), this->RealType, options);
		builder.AddBoundFunction(math, "PerpDot", Vector2PerpDotProduct, TwoParameters(this->Real2Type), this->RealType, options)->Description = ZilchDocString("The dot product between p0 and a vector perpendicular to p1. This is the two-dimensional equivalent of a cross product. Can be used to get the angle between two vectors (PerpDot(p0, p1) = |p0|*|p1|*sin(theta)).");
		builder.AddBoundFunction(math, "Cross", Vector3CrossProduct, TwoParameters(this->Real3Type), this->Real3Type, options)->Description = ZilchDocString("The vector cross product. Creates a new vector perpendicular to p0 and p1 using the right hand rule.");

		builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<2>, OneParameter(this->Real2Type), this->RealType, options)->Description = ZilchDocString("The squared length of the vector. Used to avoid a square root when possible.");
		builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<3>, OneParameter(this->Real3Type), this->RealType, options)->Description = ZilchDocString("The squared length of the vector. Used to avoid a square root when possible.");
		builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<4>, OneParameter(this->Real4Type), this->RealType, options)->Description = ZilchDocString("The squared length of the vector. Used to avoid a square root when possible.");
		builder.AddBoundFunction(math, "LengthSq", VectorLengthSq<4>, OneParameter(this->QuaternionType), this->RealType, options)->Description = ZilchDocString("The squared length of the vector. Used to avoid a square root when possible.");

		builder.AddBoundFunction(math, "Length", VectorLength<2>, OneParameter(this->Real2Type), this->RealType, options);
		builder.AddBoundFunction(math, "Length", VectorLength<3>, OneParameter(this->Real3Type), this->RealType, options);
		builder.AddBoundFunction(math, "Length", VectorLength<4>, OneParameter(this->Real4Type), this->RealType, options);
		builder.AddBoundFunction(math, "Length", VectorLength<4>, OneParameter(this->QuaternionType), this->RealType, options);

		builder.AddBoundFunction(math, "Distance", VectorDistance<2>, TwoParameters(this->Real2Type), this->RealType, options)->Description = ZilchDocString("Returns the absolute value of value.");
		builder.AddBoundFunction(math, "Distance", VectorDistance<3>, TwoParameters(this->Real3Type), this->RealType, options)->Description = ZilchDocString("Returns the absolute value of value.");
		builder.AddBoundFunction(math, "Distance", VectorDistance<4>, TwoParameters(this->Real4Type), this->RealType, options)->Description = ZilchDocString("Returns the absolute value of value.");

		builder.AddBoundFunction(math, "Normalize", VectorNormalize<2>, OneParameter(this->Real2Type), this->Real2Type, options)->Description = ZilchDocString("Returns a vector that points in the same direction but has a length of 1.");
		builder.AddBoundFunction(math, "Normalize", VectorNormalize<3>, OneParameter(this->Real3Type), this->Real3Type, options)->Description = ZilchDocString("Returns a vector that points in the same direction but has a length of 1.");
		builder.AddBoundFunction(math, "Normalize", VectorNormalize<4>, OneParameter(this->Real4Type), this->Real4Type, options)->Description = ZilchDocString("Returns a vector that points in the same direction but has a length of 1.");
		builder.AddBoundFunction(math, "Normalize", VectorNormalize<4>, OneParameter(this->QuaternionType), this->QuaternionType, options)->Description = ZilchDocString("Returns a unit quaternion that represents a pure rotation.");

		builder.AddBoundProperty(math, "Pi", this->RealType, nullptr, Pi, MemberOptions::Static);
		builder.AddBoundProperty(math, "E", this->RealType, nullptr, E, MemberOptions::Static)->Description = ZilchDocString("Euler's number.");

		builder.AddBoundFunction(math, "Transform", QuaternionTransformQuaternion, TwoParameters(this->QuaternionType, "the", this->QuaternionType, "by"), this->QuaternionType, FunctionOptions::Static)->Description = ZilchDocString("Creates a new rotation that represents rotating by parameter 1 and then parameter 2.");
		builder.AddBoundFunction(math, "Transform", QuaternionTransformVector3, TwoParameters(this->Real3Type, "the", this->QuaternionType, "by"), this->Real3Type, FunctionOptions::Static)->Description = ZilchDocString("Creates a new vector that represents parameter 1 being rotated by parameter 2.");
		builder.AddBoundFunction(math, "Multiply", QuaternionMultiplyQuaternion, TwoParameters(this->QuaternionType, "by", this->QuaternionType, "the"), this->QuaternionType, FunctionOptions::Static)->Description = ZilchDocString("Creates a new rotation that represents rotating by parameter 2 and then parameter 1.");
		builder.AddBoundFunction(math, "Multiply", QuaternionMultiplyVector3, TwoParameters(this->QuaternionType, "by", this->Real3Type, "the"), this->Real3Type, FunctionOptions::Static)->Description = ZilchDocString("Creates a new vector that represents parameter 2 being rotated by parameter 1.");
		builder.AddBoundFunction(math, "Invert", QuaternionInvert, OneParameter(this->QuaternionType), this->QuaternionType, options)->Description = ZilchDocString("Returns the inverse rotation.");

		builder.AddBoundProperty(quaternionType, "Identity", this->QuaternionType, nullptr, QuaternionIdentity, MemberOptions::Static);

		CreateMatrixTypes(builder);

		for (size_t i = 0; i < AllRealTypes.size(); ++i)
		{
			BoundType* boundType = AllRealTypes[i];
			Function* f = nullptr;

			ZilchBindBasicSplat(builder, math, Real, realType, "Abs", Math::Abs, boundType, OneParameter(boundType), "Returns the absolute value of value.");
			ZilchBindBasicSplatWithError(builder, math, Real, realType, "ACos", Math::SafeArcCos, boundType, OneParameter(boundType, "units"), "The transcendental function arc-sine", "ACos of '%s' is invalid. Values must be in the range [-1, 1].");
			f = builder.AddBoundFunction(math, "AllNonZero", AllNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
			f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / realType->Size, nullptr, boundType));
			f = builder.AddBoundFunction(math, "AnyNonZero", AnyNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
			f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / realType->Size, nullptr, boundType));
			ZilchBindBasicSplatWithError(builder, math, Real, realType, "ASin", Math::SafeArcSin, boundType, OneParameter(boundType, "units"), "The transcendental function arc-cosine", "ASin of '%s' is invalid. Values must be in the range [-1, 1].");
			ZilchBindBasicSplat(builder, math, Real, realType, "ATan", Math::ArcTan, boundType, OneParameter(boundType, "units"), "The transcendental function arc-tangent. The return type is in radians.");
			ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "ATan2", Math::ArcTan2, boundType, TwoParameters(boundType, "y", "x"), "Performs the arc-tangent using the signs of x and y to determine what quadrant the angle lies in. Returns a value in the range of [-pi, pi]. The return type is in radians.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Ceil", Math::Ceil, boundType, OneParameter(boundType), "Rounds value upward.");
			f = builder.AddBoundFunction(math, "Ceil", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Ceil),
				TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value upward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
			f = builder.AddBoundFunction(math, "Ceil", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Ceil),
				ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value upward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");

			ZilchBindBasicThreeParamSplat(builder, math, Real, realType, "Clamp", Math::Clamp<Real>, boundType, ThreeParameters(boundType, "value", "min", "max"), "Limits the value between the provided min and max.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Cos", Math::Cos, boundType, OneParameter(boundType, "radians"), "The transcendental function cosine.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Cosh", Math::Cosh, boundType, OneParameter(boundType, "radians"), "The hyperbolic cosine function.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Exp", Math::Exp, boundType, OneParameter(boundType), "Returns the base-e exponentiation of value, which is e^value.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Exp2", Math::Exp2, boundType, OneParameter(boundType), "Returns the base-2 exponentiation of value, which is 2^value.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Floor", Math::Floor, boundType, OneParameter(boundType), "Rounds value downward.");

			f = builder.AddBoundFunction(math, "Floor", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Floor),
				TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value downward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
			f = builder.AddBoundFunction(math, "Floor", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Floor),
				ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value downward. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");

			ZilchBindBasicTwoParamSplatWithError(builder, math, Real, realType, "FMod", Math::SafeFMod, boundType, TwoParameters(boundType, "numerator", "denominator"), "Returns the floating-point remainder of numerator/denominator (rounded towards zero).", "Fmod(%s, %s) is invalid because the denominator would produce a zero division");
			ZilchBindBasicSplat(builder, math, Real, realType, "Frac", Math::Fractional, boundType, OneParameter(boundType), "Returns the fractional part of value, a value between 0 and 1.");

			f = builder.AddBoundFunction(math, "Lerp", ZilchComplexThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 1, Zilch::Lerp<Real>),
				ThreeParameters(boundType, "start", boundType, "end", boundType, "t"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Linearly interpolates from start to end by the fraction t. T of 0 is start and t of 1 is end.");
			// Add another version for lerp that is always of real type
			if (boundType != realType)
			{
				f = builder.AddBoundFunction(math, "Lerp", ZilchComplexThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 0, Zilch::Lerp<Real>),
					ThreeParameters(boundType, "start", boundType, "end", realType, "t"), boundType, FunctionOptions::Static);
				ZilchSetUserDataAndDescription(f, boundType, realType, "Linearly interpolates from start to end by the fraction t. T of 0 is start and t of 1 is end.");
			}

			ZilchBindBasicSplat(builder, math, Real, realType, "Log", Math::Log, boundType, OneParameter(boundType), "Base e logarithm.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Log10", Math::Log10, boundType, OneParameter(boundType), "Base 10 logarithm.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Log2", Math::Log2, boundType, OneParameter(boundType), "Base 2 logarithm.");
			ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Max", Math::Max<Real>, boundType, TwoParameters(boundType), "Returns whichever value is larger.");
			ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Min", Math::Min<Real>, boundType, TwoParameters(boundType), "Returns whichever value is smaller.");
			ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Pow", Math::Pow, boundType, TwoParameters(boundType, "base", "exponent"), "Returns base raised to the power of the exponent.");

			ZilchBindBasicSplat(builder, math, Real, realType, "Round", Math::Round, boundType, OneParameter(boundType), "Returns the integer value closest to value.");
			f = builder.AddBoundFunction(math, "Round", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Round),
				TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Returns the integer value closest to value. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
			f = builder.AddBoundFunction(math, "Round", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Round),
				ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Returns the integer value closest to value. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");

			ZilchBindBasicSplat(builder, math, Real, realType, "RSqrt", Math::Rsqrt, boundType, OneParameter(boundType), "Reciprocal square root approximation. Used for efficiency when higher accuracy is not need.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Saturate", Math::Clamp<Real>, boundType, OneParameter(boundType), "Limits the value between 0 and 1");

			f = builder.AddBoundFunction(math, "Sign", ZilchComplexOneParameterSplatBinder(Real, Integer, 1, Math::Sign),
				OneParameter(boundType), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Returns the sign of the value as either 1 or -1.");

			ZilchBindBasicSplat(builder, math, Real, realType, "Sin", Math::Sin, boundType, OneParameter(boundType, "radians"), "The transcendental function sine.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Sinh", Math::Sinh, boundType, OneParameter(boundType, "radians"), "The hyperbolic sine function.");

			f = builder.AddBoundFunction(math, "SmoothStep", ZilchFullThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 1, Math::SmoothStep<Real>),
				ThreeParameters(boundType, "min", boundType, "max", boundType, "x"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Returns a smooth Hermite interpolation between 0 and 1 if x is in-between min and max.");
			// Add another version for smoothstep that is always of real type
			if (boundType != realType)
			{
				f = builder.AddBoundFunction(math, "SmoothStep", ZilchFullThreeParameterSplatBinder(Real, Real, Real, Real, 1, 1, 0, Math::SmoothStep<Real>),
					ThreeParameters(boundType, "min", boundType, "max", realType, "t"), boundType, FunctionOptions::Static);
				ZilchSetUserDataAndDescription(f, boundType, realType, "Returns a smooth Hermite interpolation between 0 and 1 if t is in-between min and max.");
			}

			ZilchBindBasicSplatWithError(builder, math, Real, realType, "Sqrt", Math::SafeSqrt, boundType, OneParameter(boundType), "Computes the square root", "Sqrt of the negative number '%s' is invalid.");
			ZilchBindBasicTwoParamSplat(builder, math, Real, realType, "Step", Math::Step, boundType, TwoParameters(boundType, "y", "x"), "If y < x then 0 is returned, otherwise 1 is returned.")
				ZilchBindBasicSplat(builder, math, Real, realType, "Tan", Math::Tan, boundType, OneParameter(boundType, "radians"), "The transcendental function tangent.");
			ZilchBindBasicSplat(builder, math, Real, realType, "Tanh", Math::Tanh, boundType, OneParameter(boundType, "radians"), "The hyperbolic tangent function.");
			ZilchBindBasicSplat(builder, math, Real, realType, "ToRadians", Math::DegToRad, boundType, OneParameter(boundType, "degrees"), "Converts the given degrees to radians.");
			ZilchBindBasicSplat(builder, math, Real, realType, "ToDegrees", Math::RadToDeg, boundType, OneParameter(boundType, "radians"), "Converts the given radians to degrees.");

			ZilchBindBasicSplat(builder, math, Real, realType, "Truncate", Math::Truncate, boundType, OneParameter(boundType), "Rounds value towards zero.");
			f = builder.AddBoundFunction(math, "Truncate", ZilchComplexTwoParameterSplatBinder(Real, Integer, Real, 1, 0, Math::Truncate),
				TwoParameters(boundType, "value", integerType, "places"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value towards zero. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
			f = builder.AddBoundFunction(math, "Truncate", ZilchComplexThreeParameterSplatBinder(Real, Integer, Integer, Real, 1, 0, 0, Math::Truncate),
				ThreeParameters(boundType, "value", integerType, "places", integerType, "base"), boundType, FunctionOptions::Static);
			ZilchSetUserDataAndDescription(f, boundType, realType, "Rounds value towards zero. The place represents where in the number we want to perform rounding (0 is the 1s place, 1 is the 10s place, -1 is the tenths place, etc).");
		}

		// Bind the integer functions separately (not many functions make sense to be splatted on integers)
		for (size_t i = 0; i < AllIntegerTypes.size(); ++i)
		{
			BoundType* boundType = AllIntegerTypes[i];
			Function* f = nullptr;

			ZilchBindBasicSplat(builder, math, Integer, integerType, "Abs", Math::Abs, boundType, OneParameter(boundType), "Returns the absolute value of value.");
			f = builder.AddBoundFunction(math, "AllNonZero", AllNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
			f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / integerType->Size, nullptr, boundType));
			f = builder.AddBoundFunction(math, "AnyNonZero", AnyNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
			f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / integerType->Size, nullptr, boundType));
			ZilchBindBasicThreeParamSplat(builder, math, Integer, integerType, "Clamp", Math::Clamp<Integer>, boundType, ThreeParameters(boundType, "value", "min", "max"), "Limits the value between the provided min and max.");
			ZilchBindBasicSplat(builder, math, Integer, integerType, "CountBits", Math::CountBits, boundType, OneParameter(boundType), "Counts the number of bits set on the input.");
			ZilchBindBasicTwoParamSplat(builder, math, Integer, integerType, "Max", Math::Max<Integer>, boundType, TwoParameters(boundType), "Returns whichever value is larger.");
			ZilchBindBasicTwoParamSplat(builder, math, Integer, integerType, "Min", Math::Min<Integer>, boundType, TwoParameters(boundType), "Returns whichever value is smaller.");
			ZilchBindBasicSplat(builder, math, Integer, integerType, "Sign", Math::Sign, boundType, OneParameter(boundType), "Returns the sign of the value as either 1 or -1.");
		}

		// Bind the boolean functions
		for (size_t i = 0; i < AllBooleanTypes.size(); ++i)
		{
			BoundType* boundType = AllBooleanTypes[i];
			Function* f = nullptr;

			f = builder.AddBoundFunction(math, "AllNonZero", AllNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
			f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / booleanType->Size, nullptr, boundType));
			f = builder.AddBoundFunction(math, "AnyNonZero", AnyNonZero, OneParameter(boundType), booleanType, FunctionOptions::Static);
			f->ComplexUserData.WriteObject(SplatWithErrorUserData(boundType->Size / booleanType->Size, nullptr, boundType));
		}
	}

	//***************************************************************************
	StackEntry::StackEntry() :
		ExecutingFunction(nullptr)
	{
	}

	//***************************************************************************
	StackEntry* StackTrace::GetMostRecentNonNativeStackEntry()
	{
		// Walk in newest from oldest to oldest calls
		for (int i = (int)(this->Stack.size() - 1); i >= 0; --i)
		{
			// Grab the current stack entry
			StackEntry& entry = this->Stack[i];

			// If we reached a non-native location, then return it
			if (entry.Location.IsNative == false)
			{
				// Return the most recent entry
				return &entry;
			}
		}

		// Either our stack trace was empty or we had an entirely native stack, return nothing
		return nullptr;
	}

	//***************************************************************************
	CodeLocation StackTrace::GetMostRecentNonNativeLocation()
	{
		// Get the most recent stack entry
		StackEntry* entry = this->GetMostRecentNonNativeStackEntry();

		// If the stack entry doesn't exist, return an empty location
		if (entry == nullptr)
			return CodeLocation();

		// Otherwise, return the location at the last entry
		return entry->Location;
	}

	//***************************************************************************
	String StackTrace::GetFormattedMessage(MessageFormat::Enum format)
	{
		// Create a string builder to output the stack trace
		StringBuilder builder;

		// Walk in order from oldest to newest calls
		for (size_t i = 0; i < this->Stack.size(); ++i)
		{
			// Get the current stack 
			StackEntry& stack = this->Stack[i];

			// Get the location in a formatted string
			String locationText = stack.Location.GetFormattedString(format);

			// Append the location to the full exception printout
			builder.Append(locationText);
			builder.Append('\n');
		}

		// Now return the full trace message
		return builder.ToString();
	}

	//***************************************************************************
	ZilchDefineType(Exception, Core)
	{
		// Store this type on the core library
		Core& core = Core::GetInstance();
		core.ExceptionType = type;

		ZilchBindConstructor();
		ZilchBindConstructor(StringParam);
		ZilchBindDestructor();

		ZilchBindFieldGetSet(Message);
		//ZilchBindMethod(GetFormattedMessage);
	}

	//***************************************************************************
	Exception::Exception()
	{
	}

	//***************************************************************************
	Exception::Exception(StringParam message) :
		Message(message)
	{
	}

	//***************************************************************************
	String Exception::GetFormattedMessage(MessageFormat::Enum format)
	{
		// Create a string builder to output the exception message and stack trace
		StringBuilder builder;
		builder.Append("********************** Zilch Exception **********************\n");

		// Convert the stack trace into a string and append it to our output
		String traceOutput = this->Trace.GetFormattedMessage(format);
		builder.Append(traceOutput);

		// If we have an error...
		if (this->Message.empty() == false)
		{
			// Append the error and a newline
			builder.Append(this->Message);
			builder.Append("\n");
		}

		// Print the end of the exception
		builder.Append("*************************************************************\n");

		// Now return the full error message
		return builder.ToString();
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Redirection header based on the platform
#ifdef _MSC_VER
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>

namespace Zilch
{
	//***************************************************************************
	String StripQuotes(cstr text)
	{
		// Use this to build a quote removed message
		StringBuilder builder;

		// Remove quotes from message
		while ((*text) != '\0')
		{
			// Get the current character
			char c = *text;

			// If the character is a quote...
			if (c == '"')
			{
				// Append a single quote
				builder.Append('\'');
			}
			else
			{
				// Otherwise, append the character
				builder.Append(*text);
			}

			// Increment our text iterator
			++text;
		}

		// Output the message
		return builder.ToString();
	}

	//***************************************************************************
	bool DebugErrorHandler(ErrorSignaler::ErrorData& errorData)
	{
		// Stores the resulting quote removed message from below
		String message;
		String expression = StripQuotes(errorData.Expression);

		// Check if no message was provided
		if (errorData.Message != nullptr)
		{
			message = StripQuotes(errorData.Message);
		}
		else
		{
			message = "No message";
		}

		// Output the command line
		String commandLine = String::Format("ErrorDialog.exe \"%s\" \"%s\" \"%s:%d\" %s",
			message.c_str(), expression.c_str(), errorData.File, errorData.Line, "Default");

		// Create a structure to facilitating starting of a process
		STARTUPINFO startUpInfo;
		memset(&startUpInfo, 0, sizeof(startUpInfo));

		// Create another structure to store process information
		PROCESS_INFORMATION processInfo;
		memset(&processInfo, 0, sizeof(processInfo));

		// Start the child process.
		BOOL result = CreateProcess
			(
			NULL,                         // No module name (use command line)
			(LPTSTR)commandLine.c_str(),  // Command line
			NULL,                         // Process handle not inheritable
			NULL,                         // Thread handle not inheritable
			FALSE,                        // Set handle inheritance to FALSE
			CREATE_NO_WINDOW,             // Creation flags
			NULL,                         // Use parent's environment block
			NULL,                         // Use parent's starting directory
			&startUpInfo,                 // Pointer to STARTUPINFO structure
			&processInfo
			);

		// If we failed to start the process...
		if (!result)
		{
			// Show a message box instead
			message = BuildString(message, "\nWould you like to continue?");
			int result = MessageBoxA(NULL, message.c_str(), "Error", MB_YESNO);

			// Trigger a break point
			return result == IDNO;
		}

		// Now wait forever for the process to finish
		WaitForSingleObject(processInfo.hProcess, INFINITE);

		// Get the exit code of the process since it should have finished by now
		DWORD exitCode = 0;
		BOOL success = GetExitCodeProcess(processInfo.hProcess, &exitCode);

		// Close unused thread handle
		CloseHandle(processInfo.hThread);

		// If we somehow failed to get the exit code, trigger a break point
		if (!success)
		{
			return true;
		}

		// Special exit codes
		const DWORD Continue = 0;
		const DWORD DebugBreak = 1;
		const DWORD ForceShutdown = 2;

		// Based on the exit code...
		switch (exitCode)
		{
		case Continue:
			// No debug break, just continue
			return false;

		case DebugBreak:
			// Returning true will cause a break point
			return true;

		case ForceShutdown:
			// Immediately kill the application
			exit(0);
			break;

		default:
			// Force a break point, we have no idea what we got back
			return true;
		}
	}
}

#else
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

namespace Zilch
{
	//***************************************************************************
	bool DebugErrorHandler(ErrorSignaler::ErrorData& errorData)
	{
		// Just print out the error
		printf("%s(%d) : %s %s\n", errorData.File, errorData.Line, errorData.Message, errorData.Expression);

		// Returning true will cause a break point
		return true;
	}
}

#endif

namespace Zilch
{
	//***************************************************************************
	Debugger::Debugger() :
		Action(DebuggerAction::Resume),
		LastState(nullptr),
		LastCallStackDepth(0),
		StepOutOverCallStackDepth(0),
		StepOutOverState(nullptr),
		Server(1),
		AllProjectsHashCode(0)
	{
		// We want to know when the console writes anything
		EventConnect(&Console::Events, Events::ConsoleWrite, &Debugger::OnConsoleWrite, this);

		// Connect all our event handlers up to the server
		EventConnect(&this->Server, Events::WebSocketAcceptedConnection, &Debugger::OnAcceptedConnection, this);
		EventConnect(&this->Server, Events::WebSocketDisconnected, &Debugger::OnDisconnected, this);
		EventConnect(&this->Server, Events::WebSocketError, &Debugger::OnError, this);
		EventConnect(&this->Server, Events::WebSocketReceivedData, &Debugger::OnReceivedData, this);

		// Register our message handlers
		this->AddMessageHandler("ChangeBreakpoint", OnChangeBreakpoint, this);
		this->AddMessageHandler("Resume", OnResume, this);
		this->AddMessageHandler("Pause", OnPause, this);
		this->AddMessageHandler("StepOver", OnStepOver, this);
		this->AddMessageHandler("StepIn", OnStepIn, this);
		this->AddMessageHandler("StepOut", OnStepOut, this);
		this->AddMessageHandler("QueryExpression", OnQueryExpression, this);
		this->AddMessageHandler("ViewExplorerItem", OnViewExplorerItem, this);
	}

	//***************************************************************************
	Debugger::~Debugger()
	{
	}

	//***************************************************************************
	void Debugger::Host(int port)
	{
		// If the server hasn't been initialized yet, then host the server on a given port
		if (this->Server.IsValid() == false)
			this->Server.Host(port);
	}

	//***************************************************************************
	bool Debugger::IsValid()
	{
		return this->Server.IsValid();
	}

	//***************************************************************************
	void Debugger::Update()
	{
		// Make sure we pump incoming messages
		this->Server.Update();

		// Loop through all the projects using a total hash to see if any project has changed (including files)
		unsigned long long projectsHash = 0;
		for (size_t i = 0; i < this->Projects.size(); ++i)
		{
			// Grab the current project
			Project* project = this->Projects[i];

			// Loop through all the code entries in this project
			for (size_t j = 0; j < project->Entries.size(); ++j)
			{
				// Grab the current code entry
				CodeEntry& entry = project->Entries[j];
				projectsHash ^= (unsigned long long)entry.GetHash();
				projectsHash *= 5209;
			}
		}

		// If the hash wasn't the same as the last time...
		if (projectsHash != this->AllProjectsHashCode)
		{
			// Update the remote explorer view
			this->UpdateExplorerView();
			this->AllProjectsHashCode = projectsHash;
		}
	}

	//***************************************************************************
	void Debugger::OnPause(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;
		self->Action = DebuggerAction::Pause;
	}

	//***************************************************************************
	void Debugger::OnResume(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;
		self->Action = DebuggerAction::Resume;
	}

	//***************************************************************************
	void Debugger::OnStepOver(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;
		self->Action = DebuggerAction::StepOver;
		self->StepLocation = self->LastLocation;
		self->StepOutOverCallStackDepth = self->LastCallStackDepth;
		self->StepOutOverState = self->LastState;
	}

	//***************************************************************************
	void Debugger::OnStepIn(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;
		self->Action = DebuggerAction::StepIn;
		self->StepLocation = self->LastLocation;
	}

	//***************************************************************************
	void Debugger::OnStepOut(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;
		self->Action = DebuggerAction::StepOut;
		self->StepLocation = self->LastLocation;
		self->StepOutOverCallStackDepth = self->LastCallStackDepth;
		self->StepOutOverState = self->LastState;
	}

	//***************************************************************************
	CodeEntry* Debugger::FindCodeEntry(size_t hash)
	{
		// Loop through all the projects
		for (size_t i = 0; i < this->Projects.size(); ++i)
		{
			// Grab the current project
			Project* project = this->Projects[i];

			// Loop through all code entries in the project
			for (size_t j = 0; j < project->Entries.size(); ++j)
			{
				// Grab the current code entry from the project
				CodeEntry* entry = &project->Entries[j];
				if (entry->GetHash() == hash)
					return entry;
			}
		}

		// Loop through all the states
		for (size_t i = 0; i < this->States.size(); ++i)
		{
			// Grab the current executable state
			ExecutableState* state = this->States[i];

			// Look in the current state for the code entry...
			CodeEntry* foundEntry = state->CodeHashToCodeEntry.findValue(hash, nullptr);
			if (foundEntry != nullptr)
				return foundEntry;
		}

		// We found nothing!
		return nullptr;
	}

	//***************************************************************************
	void Debugger::OnViewExplorerItem(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;

		// With the breakpoint message comes a unqiue identifier object that describes exact paths to code entries
		// This is the same as the object sent from 'AddState' with each code entry
		JsonValue* codeData = message.JsonRoot->GetMember("CodeData");
		if (codeData == nullptr)
		{
			Error("CodeData object was not specified in the 'AddBreakpoint' message");
			return;
		}

		// When looking for any code file that we put a breakpoint in, we can identify the code by an id
		size_t codeHash = (size_t)codeData->MemberAsLongLong("CodeHash");

		// Look for the code entry in a map to all code files
		CodeEntry* entry = self->FindCodeEntry(codeHash);
		if (entry == nullptr)
		{
			Error("We couldn't find the code file for the given id");
			return;
		}

		JsonBuilder builder;
		builder.Begin(JsonType::Object);
		{
			builder.Key("MessageType");
			builder.Value("ShowCodeEntry");
			builder.Key("Origin");
			builder.Value(entry->Origin);
			builder.Key("Code");
			builder.Value(entry->Code);

			builder.Key("CodeData");
			builder.Begin(JsonType::Object);
			{
				// All data sent within here is stored directly on the debugger side
				// and is directly returned to us in messages such as 'AddBreakpoint'
				builder.Key("CodeHash");
				builder.Value(entry->GetHash());
			}
			builder.End();
		}
		builder.End();

		String toSend = builder.ToString();
		self->SendPacket(toSend);
	}

	//***************************************************************************
	void Debugger::OnQueryExpression(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;
		String expression = message.JsonRoot->MemberAsString("Expression");

		// The remote side gives every query and id, so that way when we respond to multiple it can distingquish which is which
		int queryId = message.JsonRoot->MemberAsInteger("QueryId");

		// Assume we're querying an expression for whatever state we're currently debugging
		ExecutableState* state = self->LastState;

		// If we're not debugging a state, return early
		if (state == nullptr)
			return;

		// Save away all the state callbacks (we don't want them to get called while we make calls)
		OpcodeStepDelegate SavedOpcodePreStepCallback = state->OpcodePreStepCallback;
		OpcodeStepDelegate SavedOpcodePostStepCallback = state->OpcodePostStepCallback;
		FunctionStepDelegate SavedEnterFunctionCallback = state->EnterFunctionCallback;
		FunctionStepDelegate SavedExitFunctionCallback = state->ExitFunctionCallback;
		FatalErrorDelegate SavedFatalCallback = state->FatalCallback;
		ExceptionDelegate SavedExceptionThrownCallback = state->ExceptionThrownCallback;

		// Restore all the state callbacks
		state->OpcodePreStepCallback = OpcodeStepDelegate();
		state->OpcodePostStepCallback = OpcodeStepDelegate();
		state->EnterFunctionCallback = FunctionStepDelegate();
		state->ExitFunctionCallback = FunctionStepDelegate();
		state->FatalCallback = FatalErrorDelegate();
		state->ExceptionThrownCallback = ExceptionDelegate();

		// Temporary space used for traversing object paths and copying zilch objects (Delegate is the largest object)
		byte tempSpace[sizeof(Delegate)];

		// Send a message back to answer the expression query
		JsonBuilder builder;
		builder.Begin(JsonType::Object);
		{
			builder.Key("MessageType");
			builder.Value("QueryResult");
			builder.Key("QueryId");
			builder.Value(queryId);
			builder.Key("Expression");
			builder.Value(expression);
			builder.Key("Values");
			builder.Begin(JsonType::ArrayMultiLine);
			{
				Zero::StringTokenRange splitter(expression, '.');
				if (splitter.empty() == false)
				{
					// Grab just the variable name
					String variableName = splitter.front();
					splitter.popFront();

					// Loop through the frames from top to bottom (backwards)
					for (int i = state->StackFrames.size() - 1; i >= 0; --i)
					{
						// Grab the current frame
						PerFrameData* frame = state->StackFrames[i];

						// Skip any non-active frames (frames in the process of being called)
						if (frame->ProgramCounter == ProgramCounterNotActive)
							continue;

						// Get the current function
						Function* function = frame->CurrentFunction;

						// Loop through all variables in the current function
						for (size_t j = 0; j < function->Variables.size(); ++j)
						{
							// Grab the current variable
							Variable* variable = function->Variables[j];

							// If the variable's name matches our expression...
							if (variable->Name == variableName)
							{
								// Get the memory that points directly at the variable on the stack
								String valueName = variableName;
								Type* type = variable->ResultType;

								// If the frame is currently initialized
								if (frame->IsVariableInitialized(variable) == false)
									continue;

								// Get the stack location of the variable
								byte* variableStackMemory = frame->Frame + variable->Local;
								type->GenericCopyConstruct(tempSpace, variableStackMemory);

								// If this is the first value, then write out its value (otherwise the parent would have written out our value)
								if (splitter.empty())
								{
									// Stringify the variable (gets its value)
									String value = type->GenericToString(tempSpace);
									builder.Begin(JsonType::Object);
									{
										builder.Key("Property");
										builder.Value(valueName);
										builder.Key("Value");
										builder.Value(value);
										builder.Key("Expandable");
										builder.Value(false);
									}
									builder.End();
								}

								// Until we run out of sub-strings...
								while (splitter.empty() == false)
								{
									// Get the most virtual version of that memory (dereferences handles, gets the most derived type, etc)
									byte* valueMemory = type->GenericGetMemory(tempSpace);
									type = type->GenericGetVirtualType(tempSpace);

									// Get the current property name
									String propertyName = splitter.front();
									splitter.popFront();

									// Grab the property or field by name
									Property* property = type->GetInstanceProperty(propertyName);
									if (property == nullptr)
										property = type->GetInstanceField(propertyName);

									// We allowe debugging of hidden properties, we just don't enumerate them
									if (property != nullptr && property->Get != nullptr)
									{
										type->GenericDestruct(tempSpace);

										valueName = propertyName;
										type = property->PropertyType;

										Call call(property->Get, state);

										// Set the this handle (just as a global pointer...)
										call.DisableThisChecks();
										Handle* thisHandle = new (call.GetThisUnchecked()) Handle();
										PointerManager* manager = state->GetHandleManager<PointerManager>();
										manager->ObjectToHandle(valueMemory, *thisHandle);
										thisHandle->Type = (BoundType*)type; // HACK DO NOT COMMIT
										thisHandle->Manager = state->GetHandleManager<PointerManager>();

										ExceptionReport report;
										call.Invoke(report);

										if (report.HasThrownExceptions())
											goto END;

										byte* returnValue = call.GetReturnUnchecked();
										type->GenericCopyConstruct(tempSpace, returnValue);
									}
									else
									{
										// WE FOUND NOTHING! NOOOOOOTHING!!!
										goto END;
									}
								}

								// We want to avoid showing duplicate properties (when they are the exact same value)
								// We do want to however support showing hidden properties
								HashMap<String, String> evaluatedProperties;

								// Check to see if the type is a bound type
								BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

								// If the type is a bound type...
								while (boundType != nullptr)
								{
									// Either dereference the handle or get the memory for the value
									byte* memory = boundType->GenericGetMemory(tempSpace);

									// Loop through all the instance properties
									PropertyArray& properties = boundType->AllProperties;
									for (size_t i = 0; i < properties.size(); ++i)
									{
										// Grab the current property
										Property* property = properties[i];

										// If it's a static or hidden property, skip it
										if (property->IsStatic || property->IsHidden || property->Get == nullptr)
											continue;

										Call call(property->Get, state);

										// Set the this handle (just as a global pointer...)
										call.DisableThisChecks();
										Handle* thisHandle = new (call.GetThisUnchecked()) Handle();
										PointerManager* manager = state->GetHandleManager<PointerManager>();
										manager->ObjectToHandle(memory, *thisHandle);
										thisHandle->Type = boundType;
										thisHandle->Manager = state->GetHandleManager<PointerManager>();

										ExceptionReport report;
										call.Invoke(report);

										// The value we evaluated for this property (its return value stringified)
										String propertyValue;

										if (report.HasThrownExceptions())
										{
											// Just treat the property value as the concatenation of all the exceptions thrown
											propertyValue = report.GetConcatenatedMessages();
										}
										else
										{
											byte* returnValue = call.GetReturnUnchecked();

											// If the property should be hidden when null...
											if (property->IsHiddenWhenNull)
											{
												// If the dereferenced property is null, then skip it
												byte* returnValueDereferenced = property->PropertyType->GenericGetMemory(returnValue);
												if (returnValueDereferenced == nullptr)
													continue;
											}

											// Stringify the variable (gets its value)
											propertyValue = property->PropertyType->GenericToString(returnValue);
										}

										// If we haven't seen this EXACT property value before...
										String& evaluatedValue = evaluatedProperties[property->Name];
										if (evaluatedValue != propertyValue)
										{
											// Let the debugger know about this property / value
											builder.Begin(JsonType::Object);
											{
												builder.Key("Property");
												builder.Value(property->Name);
												builder.Key("Value");
												builder.Value(propertyValue);
												builder.Key("Expandable");
												builder.Value(HasDebuggableProperties(property->PropertyType));
											}
											builder.End();
										}

										// Update the value stored in the evaluated property map, so that next time we'll know if we've seen this
										evaluatedProperties[property->Name] = propertyValue;

										// TEMPORARY - Because we do not have the ExecutableState in bound C++ functions, we can only
										// print out fields (because we know their type and know where they exist in memory
										//if (Field* field = TypeBinding::DynamicCast<Field*>(property))
										//{
										//  byte* fieldData = memory + field->Offset;
										//  
										//  // Stringify the variable (gets its value)
										//  String fieldValue = field->PropertyType->GenericToString(fieldData);
										//
										//  // Let the debugger know about this property / value
										//  builder.Begin(JsonType::Object);
										//  {
										//    builder.Key("Property");
										//    builder.Value(field->Name);
										//    builder.Key("Value");
										//    builder.Value(fieldValue);
										//    builder.Key("Expandable");
										//    builder.Value(HasDebuggableProperties(field->PropertyType));
										//  }
										//  builder.End();
										//}
									}

									// Iterate up to the base class (because we want to access base class properties too)
									boundType = boundType->BaseType;
								}

								type->GenericDestruct(tempSpace);

								// We discovered a valid variable, time to break out of all loops
								goto END;
							}
						}
					}
				}
			}
		END:
			builder.End();
		}
		builder.End();

		String toSend = builder.ToString();
		self->SendPacket(toSend);

		// Restore all the state callbacks
		state->OpcodePreStepCallback = SavedOpcodePreStepCallback;
		state->OpcodePostStepCallback = SavedOpcodePostStepCallback;
		state->EnterFunctionCallback = SavedEnterFunctionCallback;
		state->ExitFunctionCallback = SavedExitFunctionCallback;
		state->FatalCallback = SavedFatalCallback;
		state->ExceptionThrownCallback = SavedExceptionThrownCallback;
	}

	//***************************************************************************
	bool Debugger::HasDebuggableProperties(Type* type)
	{
		// Grab the type as a bound type
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

		// If this is not a bound type, then it has no properties...
		if (boundType == nullptr)
			return false;

		// We have to walk through all properties and check for any non hidden properties
		for (size_t i = 0; i < boundType->AllProperties.size(); ++i)
		{
			// Grab the current property
			Property* property = boundType->AllProperties[i];

			// As long as this property isn't hidden or marked static, then we can debug it!
			if (property->IsHidden == false && property->IsStatic == false)
				return true;
		}

		// We didn't find a single expandable property...
		return false;
	}

	//***************************************************************************
	void Debugger::OnChangeBreakpoint(const DebuggerMessage& message, void* userData)
	{
		Debugger* self = (Debugger*)userData;

		// With the breakpoint message comes a unqiue identifier object that describes exact paths to code entries
		// This is the same as the object sent from 'AddState' with each code entry
		JsonValue* codeData = message.JsonRoot->GetMember("CodeData");
		if (codeData == nullptr)
		{
			Error("CodeData object was not specified in the 'AddBreakpoint' message");
			return;
		}

		// When looking for any code file that we put a breakpoint in, we can identify the code by an id
		size_t codeHash = (size_t)codeData->MemberAsLongLong("CodeHash");

		// Look for the code entry in a map to all code files
		CodeEntry* entry = self->FindCodeEntry(codeHash);
		if (entry == nullptr)
		{
			Error("We couldn't find the code file for the given id");
			return;
		}

		// Get the line that this is associated with
		size_t line = (size_t)message.JsonRoot->MemberAsLongLong("Line");

		// Grab breakpointed lines by the state and code entry id
		HashSet<size_t>& breakpointedLines = self->Breakpoints[entry->GetHash()];

		// We need to know whether we're adding or removing a breakpoint
		if (message.JsonRoot->MemberAsString("Action") == "Add")
			breakpointedLines.insert(line);
		else
			breakpointedLines.erase(line);
	}

	//***************************************************************************
	void Debugger::SendPacket(const JsonBuilder& message)
	{
		this->SendPacket(message.ToString());
	}

	//***************************************************************************
	void Debugger::SendPacket(StringParam message)
	{
		// Send the packet to 'all' (the only client we have connected, or drop the packet if nobody is connected)
		this->Server.SendPacketToAll(message, WebSocketPacketType::Text);
	}

	//***************************************************************************
	void Debugger::OnConsoleWrite(ConsoleEvent* event)
	{
		// The code location this is called from (may not be set if we're being called directly from C++, see below)
		CodeLocation location;

		// We want to know where this console write came from
		// Obviously we need to skip the actual call to Write or WriteLine
		// Warning: If the write was called from C++, it may not have a valid executable state
		// Moreover, if the call was made from C++ which was being called from Zilch, we'll only show the Zilch location
		if (event->State != nullptr)
		{
			// Grab the entire stack trace, possibly not the most efficient but it works
			StackTrace trace;
			event->State->GetStackTrace(trace);
			StackEntry* zilchStackEntry = trace.GetMostRecentNonNativeStackEntry();

			// If there was indeed a some Zilch function calling this (or called C++ that called this)
			if (zilchStackEntry != nullptr)
				location = zilchStackEntry->Location;
		}

		// Send a message back that we hit a breakpoint
		JsonBuilder builder;
		builder.Begin(JsonType::Object);
		{
			builder.Key("MessageType");
			builder.Value("Output");
			builder.Key("Text");
			builder.Value(event->Text);

			// If the location was set to something (otherwise we don't know where the call came from)
			if (location.IsValid())
			{
				builder.Key("Origin");
				builder.Value(location.Origin);
				builder.Key("Line");
				builder.Value(location.StartLine);
				builder.Key("CodeData");
				builder.Begin(JsonType::Object);
				{
					// This data allows the debugger to uniquely identify the
					// file this came from (so they can click on it and such)
					builder.Key("CodeHash");
					builder.Value(location.GetHash());
				}
				builder.End();
			}
		}
		builder.End();

		String message = builder.ToString();
		this->SendPacket(message);
	}

	//***************************************************************************
	void Debugger::OnEnterFunction(ExecutableState* state, Function* function, size_t stackOffset, CodeLocation* location, const void* userData)
	{
		Debugger* self = (Debugger*)userData;

		// Make sure we pump incoming messages
		self->Server.Update();

		if (location == nullptr)
			return;

		// What do we do here?
	}

	//***************************************************************************
	void Debugger::OnExitFunction(ExecutableState* state, Function* function, size_t stackOffset, CodeLocation* location, const void* userData)
	{
		Debugger* self = (Debugger*)userData;

		// Make sure we pump incoming messages
		self->Server.Update();

		if (location == nullptr)
			return;
	}

	//***************************************************************************
	void Debugger::OnException(ExecutableState* state, Exception* exception, const void* userData)
	{
		Debugger* self = (Debugger*)userData;
		CodeLocation location = exception->Trace.GetMostRecentNonNativeLocation();

		ConsoleEvent exceptionEvent;
		exceptionEvent.Text = String::Format("Exception: %s\n", exception->Message.c_str());
		exceptionEvent.State = state;
		self->OnConsoleWrite(&exceptionEvent);
		self->PauseExecution(&location, state);
	}

	//***************************************************************************
	void Debugger::OnOpcodePreStep(ExecutableState* state, size_t programCounter, CodeLocation* location, const void* userData)
	{
		Debugger* self = (Debugger*)userData;

		// Make sure we pump incoming messages
		self->Server.Update();

		// If we didn't get a code location, just skip this (something invalid must have happened)
		if (location == nullptr)
			return;

		// If we have a timeout, just basically disable it... we're in the debugger!
		if (state->Timeouts.empty() == false)
		{
			// Just set the timeout to the max time
			state->Timeouts.back().LengthTicks = 0x7FFFFFFFFFFFE;
		}

		// Figure out if we changed to a new line by entering this opcode
		bool isNewLineOrFileFromLastLocation = location->StartLine != self->LastLocation.StartLine || location->Code != self->LastLocation.Code || state != self->LastState;
		bool isNewLineOrFileFromStepLocation = location->StartLine != self->StepLocation.StartLine || location->Code != self->StepLocation.Code;

		// Store the last code location so we can step by single lines
		self->LastLocation = *location;
		self->LastState = state;
		self->LastCallStackDepth = state->StackFrames.size();

		// Lets us know whether the action was handled (so we don't need to check for breakpoints)
		bool actionPausedExecution = false;

		// Based on the action that was last set by the remote client
		switch (self->Action)
		{
			// The user wanted to pause, just pause immediately on the current opcode
		case DebuggerAction::Pause:
		{
			self->PauseExecution(location, state);
			actionPausedExecution = true;
		}
		break;

		// The user wanted to step into the next function it sees
		// Basically we just break on every new line of opcode
		case DebuggerAction::StepIn:
		{
			// If we changed lines or code entry ids (files), then we want to pause
			if (isNewLineOrFileFromLastLocation)
			{
				self->PauseExecution(location, state);
				actionPausedExecution = true;
			}
		}
		break;

		// If we're stepping out of a function...
		case DebuggerAction::StepOut:
		{
			// If we're in the same state that we wanted to step out, and the call stack depth is less than what we started at
			if (isNewLineOrFileFromStepLocation && state == self->StepOutOverState && state->StackFrames.size() < self->StepOutOverCallStackDepth)
			{
				// Not necessary, but lets just clear the state and depth to make things clearer
				self->StepOutOverState = nullptr;
				self->StepOutOverCallStackDepth = 0;

				// We stepped out of a function!
				self->PauseExecution(location, state);
				actionPausedExecution = true;
			}
			break;
		}

		// The user wanted to pause on the next line (or next file, etc)...
		case DebuggerAction::StepOver:
		{
			// If we're in the same state that we wanted to step over, and the call stack depth is the same as what we started at
			if (isNewLineOrFileFromStepLocation && state == self->StepOutOverState && state->StackFrames.size() <= self->StepOutOverCallStackDepth)
			{
				// Not necessary, but lets just clear the state and depth to make things clearer
				self->StepOutOverState = nullptr;
				self->StepOutOverCallStackDepth = 0;

				// We stepped out of a function!
				self->PauseExecution(location, state);
				actionPausedExecution = true;
			}
		}
		break;
		}

		// Note: We always test for breakpoints (when resumed, when stepping in, when stepping out, etc)
		// Even when testing for breakpoints, there may be many opcode associated with one line
		// We only want to break upon the first opcode for that line
		if (isNewLineOrFileFromLastLocation && actionPausedExecution == false)
		{
			// Grab the breakpoint line list by code location/id and state
			HashSet<size_t>& breakpointedLines = self->Breakpoints[location->GetHash()];

			// If the breakpoints has the current line we're hitting
			if (breakpointedLines.contains(location->StartLine))
				self->PauseExecution(location, state);
		}
	}

	//***************************************************************************
	void Debugger::SetExecutionPoint(CodeLocation* codeLocation, ExecutableState* state)
	{
		// Send a message back that we hit a breakpoint
		JsonBuilder builder;
		builder.Begin(JsonType::Object);
		{
			builder.Key("MessageType");
			builder.Value("SetExecutionPoint");
			builder.Key("Line");
			builder.Value(codeLocation->StartLine);
			builder.Key("CodeData");
			builder.Begin(JsonType::Object);
			{
				// All data sent within here is stored directly on the debugger side
				// and is directly returned to us in messages such as 'AddBreakpoint'
				builder.Key("CodeHash");
				builder.Value(codeLocation->GetHash());
			}
			builder.End();

			builder.Key("CallStack");
			builder.Begin(JsonType::ArrayMultiLine);
			{
				// Perform a stack trace so we can grab the entire stack
				StackTrace trace;
				state->GetStackTrace(trace);

				// Loop through the entire stack trace and send it in a message
				// Note: We loop backwards so that the most recent entries appear at the top (typical for debuggers)
				for (int i = trace.Stack.size() - 1; i >= 0; --i)
				{
					builder.Begin(JsonType::Object);
					{
						// Grab the current stack entry and emit a message to the debugger
						StackEntry& entry = trace.Stack[i];
						builder.Key("Text");
						builder.Value(entry.ExecutingFunction->ToString());
						builder.Key("Language");
						if (codeLocation->IsNative)
						{
							builder.Value("Native");
						}
						else
						{
							builder.Value("Zilch");
							builder.Key("Line");
							builder.Value(entry.Location.StartLine);
							builder.Key("CodeData");
							builder.Begin(JsonType::Object);
							{
								// This data allows the debugger to identify exactly which file is being shown
								builder.Key("CodeHash");
								builder.Value(entry.Location.GetHash());
							}
							builder.End();
						}
					}
					builder.End();
				}
			}
			builder.End();
		}
		builder.End();

		String message = builder.ToString();
		this->SendPacket(message);
	}

	//***************************************************************************
	void Debugger::ClearExecutionPoint()
	{
		// Send a message back that we hit a breakpoint
		JsonBuilder builder;
		builder.Begin(JsonType::Object);
		builder.Key("MessageType");
		builder.Value("ClearExecutionPoint");
		builder.End();

		String message = builder.ToString();
		this->SendPacket(message);
	}

	//***************************************************************************
	void AddCodeEntryToExplorerviewUpdate(HashSet<size_t>& processedCodeHashes, JsonBuilder& builder, CodeEntry& entry)
	{
		// We want to skip any code entries we've already seen
		size_t entryHash = entry.GetHash();
		if (processedCodeHashes.contains(entryHash))
			return;

		// Next time we see this hash, we'll know to skip it
		processedCodeHashes.insert(entryHash);

		// Write out this code entry (the id is the index combined with the state id)
		builder.Begin(JsonType::Object);
		{
			builder.Key("Id");
			builder.Value(entryHash);
			builder.Key("Name");
			builder.Value(entry.Origin);
			builder.Key("CodeData");
			builder.Begin(JsonType::Object);
			{
				// All data sent within here is stored directly on the debugger side
				// and is directly returned to us in messages such as 'ViewExplorerItem'
				builder.Key("CodeHash");
				builder.Value(entry.GetHash());
			}
			builder.End();
		}
		builder.End();
	}

	//***************************************************************************
	void Debugger::UpdateExplorerView()
	{
		JsonBuilder builder;
		builder.Begin(JsonType::Object);
		{
			builder.Key("MessageType");
			builder.Value("UpdateExplorer");

			// A simple set to see if we've already processed a code entry
			HashSet<size_t> processedCodeHashes;

			builder.Key("Roots");
			builder.Begin(JsonType::ArrayMultiLine);
			{
				// Loop through all the projects
				for (size_t i = 0; i < this->Projects.size(); ++i)
				{
					// Grab the current project
					Project* project = this->Projects[i];

					// Loop through all code entries in the project
					for (size_t j = 0; j < project->Entries.size(); ++j)
					{
						// Grab the current code entry from the project
						CodeEntry& entry = project->Entries[j];
						AddCodeEntryToExplorerviewUpdate(processedCodeHashes, builder, entry);
					}
				}

				// Loop through all the states
				for (size_t i = 0; i < this->States.size(); ++i)
				{
					// Grab the current executable state
					ExecutableState* state = this->States[i];

					// Loop through all dependent libraries so we can get the original source code files
					for (size_t j = 0; j < state->Dependencies.size(); ++j)
					{
						// Get the current dependent library
						LibraryRef& library = state->Dependencies[j];

						// We only process this library if it has any entries (otheriwse we would always show core!)
						if (library->Entries.empty())
							continue;

						// Loop through the original source code entries that built this library
						// Note: The entries may be empty if it was a generated library
						for (size_t k = 0; k < library->Entries.size(); ++k)
						{
							// Grab the current code entry
							CodeEntry& entry = library->Entries[k];
							AddCodeEntryToExplorerviewUpdate(processedCodeHashes, builder, entry);
						}
					}
				}
			}
			builder.End();
		}
		builder.End();

		String message = builder.ToString();
		this->SendPacket(message);
	}


	//***************************************************************************
	void Debugger::AddProject(Project* project)
	{
		// If the project already exists within the project array, then don't add it again
		if (this->Projects.findIndex(project) != Array<Project*>::InvalidIndex)
			return;

		this->Projects.push_back(project);
		this->UpdateExplorerView();
	}

	//***************************************************************************
	void Debugger::RemoveProject(Project* project)
	{
		// Attempt to find the project in the array of all project we're viewing
		size_t index = this->Projects.findIndex(project);

		// If it didn't exist in the array, then there's nothing for us to do!
		if (index == Array<Project*>::InvalidIndex)
			return;

		// Remove the project from the array
		this->Projects.eraseAt(index);

		// Lastly, if any client is connected then update the explorer view they have because the project is now gone
		this->UpdateExplorerView();
	}

	//***************************************************************************
	void Debugger::AddState(ExecutableState* state)
	{
		// If the state already exists within the state array, then don't add it again
		if (this->States.findIndex(state) != Array<ExecutableState*>::InvalidIndex)
			return;

		this->States.push_back(state);

		state->SetOpcodePreStepCallback(OnOpcodePreStep, this);
		state->SetEnterFunctionCallback(OnEnterFunction, this);
		state->SetExitFunctionCallback(OnExitFunction, this);
		state->SetExceptionCallback(OnException, this);

		this->UpdateExplorerView();
	}

	//***************************************************************************
	void Debugger::RemoveState(ExecutableState* state)
	{
		// Attempt to find the state in the array of all states we're debugging
		size_t index = this->States.findIndex(state);

		// If it didn't exist in the array, then there's nothing for us to do!
		if (index == Array<ExecutableState*>::InvalidIndex)
			return;

		// Remove the state from the array
		this->States.eraseAt(index);

		// If the last state we were stepping out of was this state, then clear the step out info
		if (this->StepOutOverState == state)
		{
			this->StepOutOverState = nullptr;
			this->StepOutOverCallStackDepth = 0;
		}

		// If the last state we were debugging was this state, then clear it
		if (this->LastState == state)
			this->LastState = nullptr;

		// Lastly, if any client is connected then update the explorer view they have because the state is now gone
		this->UpdateExplorerView();
	}

	//***************************************************************************
	void Debugger::AddMessageHandler(StringParam type, MessageFn callback, void* userData)
	{
		// Add the delegate to the message handlers
		DebuggerMessageDelegate delegate;
		delegate.MessageCallback = callback;
		delegate.UserData = userData;
		this->MessageHandlers.insertOrError(type, delegate);
	}

	//***************************************************************************
	void Debugger::PauseExecution(CodeLocation* codeLocation, ExecutableState* state)
	{
		// We hit a breakpoint, so pause execution
		this->Action = DebuggerAction::Pause;

		// Inform the client where we stopped in code execution
		this->SetExecutionPoint(codeLocation, state);

		// Just create a single empty event that we send just once
		DebuggerEvent toSend;
		toSend.RunningDebugger = this;
		toSend.State = state;
		toSend.Location = codeLocation;

		// Let the user know that we just paused...
		this->Send(Events::DebuggerPause, &toSend);

		// Loop until we hit an again that causes us to resume
		while (this->Action == DebuggerAction::Pause)
		{
			// We should probably wait on a signal here (typically we don't want to wait inside of processing received messages
			// because we often want to continue, even if there are no messages
			// For now, sleep just to prevent this from using all the cpu
			Zero::Os::Sleep(1);

			// Send out an event that lets the hosting application update its visuals (it's being debugged!)
			this->Send(Events::DebuggerPauseUpdate, &toSend);

			// While we're paused just pump messages (could be a breakpoint, after a step, or a true pause)
			this->Server.Update();
		}

		// Since we're resuming, clear execution
		this->ClearExecutionPoint();

		// Let the user know that we just resumed...
		this->Send(Events::DebuggerResume, &toSend);
	}

	//***************************************************************************
	void Debugger::OnAcceptedConnection(WebSocketEvent* event)
	{
		// Update the explorer view for the newly connected client
		this->UpdateExplorerView();
	}

	//***************************************************************************
	void Debugger::OnError(WebSocketEvent* event)
	{
		Error("Debugger Error: %s", event->ErrorStatus.Message.c_str());
	}

	//***************************************************************************
	void Debugger::OnDisconnected(WebSocketEvent* event)
	{
		// Make sure we clear out all the data so the program can continue
		this->Action = DebuggerAction::Resume;
		this->Breakpoints.clear();
		this->LastLocation = CodeLocation();
		this->LastCallStackDepth = 0;
		this->LastState = nullptr;
		this->StepLocation = CodeLocation();
		this->StepOutOverState = nullptr;
	}

	//***************************************************************************
	void Debugger::OnReceivedData(WebSocketEvent* event)
	{
		// Now parse the string into a json tree
		static const String Origin("Received Json");
		CompilationErrors errors;
		JsonValue* root = JsonReader::ReadIntoTreeFromString(errors, event->Data, Origin, nullptr);

		// Read the message type from the json message
		String messageType = root->MemberAsString("MessageType");

		// Grab the current handler by message type
		DebuggerMessageDelegate* delegate = this->MessageHandlers.findPointer(messageType);

		// As long as we registered a delegate to handle this message...
		if (delegate != nullptr)
		{
			// Invoke the debugger message callback
			DebuggerMessage message;
			message.Type = messageType;
			message.JsonRoot = root;
			delegate->MessageCallback(message, delegate->UserData);
		}
		else
		{
			Error("Unknown message type '%s'", messageType.c_str());
		}

		// Get rid of the json tree
		delete root;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	Delegate::Delegate() :
		BoundFunction(nullptr)
	{
		ZilchErrorIfNotStarted(Handle);
	}

	//***************************************************************************
	bool Delegate::operator==(const Delegate& rhs) const
	{
		// First start by making sure the function indices are the same
		if (this->BoundFunction != rhs.BoundFunction)
			return false;

		// We also need to compare the handles
		return this->ThisHandle == rhs.ThisHandle;
	}

	//***************************************************************************
	bool Delegate::operator!=(const Delegate& rhs) const
	{
		return !(*this == rhs);
	}

	//***************************************************************************
	int Delegate::Hash() const
	{
		// Hash the function first
		int hash = (int)(this->BoundFunction->Hash() * 735977940532462813);

		// Combine that hash with the handle hash
		return hash ^ this->ThisHandle.Hash();
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	size_t AlignToBusWidth(size_t value)
	{
		return value;
		//// The machine bus width (32 bit = 4 bytes, etc)
		//// For right now, we always align to 4 bytes
		//const size_t BusWidth = 4;

		//// If the value is already aligned...
		//if (value % BusWidth == 0)
		//{
		//  return value;
		//}
		//else
		//{
		//  // Otherwise, we need to choose a value higher then the input which aligns it
		//  size_t alignedValue = ((value / BusWidth) + 1) * BusWidth;
		//  return alignedValue;
		//}
	}

	//***************************************************************************
	DestructableBuffer::~DestructableBuffer()
	{
		// Clear and invoke all the destructors on our data
		this->Clear();
	}

	//**************************************************************************
	size_t DestructableBuffer::GetSize()
	{
		return this->Data.AbsoluteSize();
	}

	//**************************************************************************
	void DestructableBuffer::Clear()
	{
		// Loop through all the destructors
		for (size_t i = 0; i < this->Destructors.size(); ++i)
		{
			// Get the current destructable object
			Destructable& destructable = this->Destructors[i];

			// Get the pointer to where the object exists in our memory
			byte* object = this->Data.GetAbsoluteElement(destructable.AbsolutePosition);

			// Invoke its destructor since we're being erased
			destructable.Destructor(object);
		}

		// Clear the destructable objects as well as the data
		this->Destructors.clear();
		this->Data.Clear();
	}

	//***************************************************************************
	byte* DestructableBuffer::Allocate(size_t size, DestructFn destructor, size_t* positionOut)
	{
		// Make sure the size aligns with the bus for efficiency
		size = AlignToBusWidth(size);

		// Get a pointer directly to the new data
		size_t absolutePosition = 0;
		byte* newData = this->Data.RequestElementOfSize(size, &absolutePosition);

		// If the user also wants the position...
		if (positionOut != nullptr)
		{
			// The position is our absolute position
			*positionOut = absolutePosition;
		}

		// Clear out the new data, just for safety (this also helps when we align data)
		memset(newData, 0, size);

		// If we were given a destructor
		if (destructor != nullptr)
		{
			// Add a new destructable component
			Destructable& destructable = this->Destructors.push_back();

			// Setup the destructable so that it destroys
			// the object at the new memory position
			destructable.Destructor = destructor;
			destructable.AbsolutePosition = absolutePosition;
		}

		// Return the writable data
		return newData;
	}

	//***************************************************************************
	byte* DestructableBuffer::WriteMemory(void* source, size_t size, DestructFn destructor)
	{
		// Allocate data and use the given destructor (it may be null)
		byte* newData = this->Allocate(size, destructor);

		// Copy the user's data over the new data
		memcpy(newData, source, size);

		// Finally, return the new writable data
		return newData;
	}

	//***************************************************************************
	byte* DestructableBuffer::Read(size_t position, size_t length, size_t* nextPositionOut)
	{
		// Make sure we only jump by full aligned blocks
		length = AlignToBusWidth(length);

		// Get the position of the memory the user is reading
		byte* memory = this->Data.GetAbsoluteElement(position);

		// Error checking
		ErrorIf(position != 0 && nextPositionOut == nullptr,
			"In cases where the position is not 0 (the front), you "
			"must get the next position via 'nextPositionOut'");

		// If the user needs us to output the next position
		if (nextPositionOut != nullptr)
		{
			// If the read causes a lapse in length...
			size_t newBlockPosition = (position % BlockSize) + length;
			if (newBlockPosition >= BlockSize)
			{
				// Move the position to the next block
				*nextPositionOut = position + (newBlockPosition - BlockSize);
			}
			else
			{
				// Move the position forward by the length
				*nextPositionOut = position + length;
			}
		}

		// Now return the memory
		return memory;
	}

	//***************************************************************************
	byte* DestructableBuffer::GetElement(size_t position)
	{
		return this->Data.GetAbsoluteElement(position);
	}
}/**************************************************************\
 * Author: Trevor Sundberg
 * Copyright 2012-2014, DigiPen Institute of Technology
 \**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	DocumentationProperty::DocumentationProperty() :
		IsSettable(true),
		IsGettable(true),
		IsField(true)
	{
	}

	//***************************************************************************
	DocumentationType::DocumentationType() :
		IsValueType(false)
	{
	}

	//***************************************************************************
	RstTable::RstTable() :
		Columns(0),
		Rows(0),
		HeaderRows(0)
	{
	}

	//***************************************************************************
	void RstTable::Resize(size_t columns, size_t rows)
	{
		this->Cells.resize(columns * rows);
		this->Columns = columns;
		this->Rows = rows;
	}

	//***************************************************************************
	void RstTable::SetCell(StringParam value, size_t column, size_t row)
	{
		this->Cells[column + row * this->Columns] = value;
	}

	//***************************************************************************
	String RstTable::GetCell(size_t column, size_t row)
	{
		return this->Cells[column + row * this->Columns];
	}

	//***************************************************************************
	void RstBuilder::WriteLine(RstTable& table)
	{
		if (table.Columns == 0 || table.Rows == 0)
			return;

		// We need to get the max size of all of the entries in each column
		Array<size_t> columnLengths;
		columnLengths.resize(table.Columns);

		// Get the lengths of each of the columns
		for (size_t c = 0; c < table.Columns; ++c)
		{
			size_t columnLength = 0;

			for (size_t r = 0; r < table.Rows; ++r)
			{
				// Get the max of the running column lengths
				size_t currentLength = table.GetCell(c, r).size();
				columnLength = Math::Max(columnLength, currentLength);
			}

			columnLengths[c] = columnLength;
		}

		// We include two padding spaces
		const size_t Padding = 2;

		// Walk through all the rows and print out their values
		// Note: We pretend we have one more row than we do, but we only do that to write out the last line bar
		for (size_t r = 0; r <= table.Rows; ++r)
		{
			// Output the top bar for the current row
			for (size_t c = 0; c < table.Columns; ++c)
			{
				this->Write("+");
				size_t columnLength = columnLengths[c];

				char rowSeparator = '-';
				if (r == table.HeaderRows)
					rowSeparator = '=';

				this->Write(String::Repeat(rowSeparator, columnLength + Padding));
			}
			this->WriteLine("+");

			// Don't write out cell values for the last bar
			if (r == table.Rows)
				break;

			// Now write out the cell values (mind the space, must match padding!)
			for (size_t c = 0; c < table.Columns; ++c)
			{
				this->Write("| ");
				size_t columnLength = columnLengths[c];
				String cell = table.GetCell(c, r);
				this->Write(cell);
				this->Write(String::Repeat(' ', columnLength - cell.size()));

				// Write out the ending padding space
				this->Write(" ");
			}
			this->WriteLine("|");
		}
	}

	//***************************************************************************
	void RstBuilder::WriteLineHeading(StringRange heading, RstHeadingType::Enum type)
	{
		char lineCharacter = ' ';
		bool needsOverline = false;

		switch (type)
		{
		case RstHeadingType::Part:
			lineCharacter = '#';
			needsOverline = true;
			break;
		case RstHeadingType::Chapter:
			lineCharacter = '=';
			needsOverline = true;
			break;
		case RstHeadingType::Section:
			lineCharacter = '=';
			break;
		case RstHeadingType::SubSection:
			lineCharacter = '-';
			break;
		case RstHeadingType::SubSubSection:
			lineCharacter = '^';
			break;
		case RstHeadingType::Paragraph:
			lineCharacter = '"';
			break;
		}

		// If we need an overline
		if (needsOverline)
			this->WriteLine(String::Repeat(lineCharacter, heading.size()));

		this->WriteLine(heading);
		this->WriteLine(String::Repeat(lineCharacter, heading.size()));
	}

	//***************************************************************************
	JsonBuilder::JsonBuilder() :
		IsMember(false),
		IsWrittenTo(false),
		IsCompactMode(false)
	{
	}

	//***************************************************************************
	JsonMember::JsonMember() :
		Value(nullptr)
	{
	}

	//***************************************************************************
	JsonMember::~JsonMember()
	{
		delete this->Value;
	}

	//***************************************************************************
	JsonValue::JsonValue() :
		Type(JsonValueType::Invalid),
		RealValue(0.0),
		IntegralValue(0)
	{
	}

	//***************************************************************************
	JsonValue* JsonValue::GetMember(StringParam name, JsonErrorMode::Enum errorMode)
	{
		ErrorIf(this->Type != JsonValueType::Object && errorMode == JsonErrorMode::ReportError,
			"This value was not an object type, and therefore cannot have members");

		JsonValue* value = this->Members.findValue(name, nullptr);

		ErrorIf(value == nullptr && errorMode == JsonErrorMode::ReportError,
			"Unable to find json member by the name of '%s'", name.c_str());

		return value;
	}

	//***************************************************************************
	JsonValue* JsonValue::IndexValue(size_t index, JsonErrorMode::Enum errorMode)
	{
		ErrorIf(this->Type != JsonValueType::Array && errorMode == JsonErrorMode::ReportError,
			"This value was not an array type, and therefore cannot be indexed");

		ReturnIf(index >= this->ArrayElements.size(), nullptr,
			"The index given was outside the range provided by the array");

		return this->ArrayElements[index];
	}

	//***************************************************************************
	bool JsonValue::AsBool(bool defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (this->Type == JsonValueType::True)
		{
			return true;
		}
		else if (this->Type == JsonValueType::False)
		{
			return false;
		}
		else if (errorMode == JsonErrorMode::ReportError)
		{
			Error("The json value was not a bool value");
		}

		return defaultValue;
	}

	//***************************************************************************
	String JsonValue::AsString(StringParam defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (this->Type == JsonValueType::String)
		{
			return this->StringValue;
		}
		else if (errorMode == JsonErrorMode::ReportError)
		{
			Error("The json value was not a String value");
		}

		return defaultValue;
	}

	//***************************************************************************
	double JsonValue::AsDouble(double defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (this->Type == JsonValueType::Real)
		{
			return this->RealValue;
		}
		else if (errorMode == JsonErrorMode::ReportError)
		{
			Error("The json value was not a Real value");
		}

		return defaultValue;
	}

	//***************************************************************************
	float JsonValue::AsFloat(float defaultValue, JsonErrorMode::Enum errorMode)
	{
		return (float)AsDouble(defaultValue, errorMode);
	}

	//***************************************************************************
	long long JsonValue::AsLongLong(long long defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (this->Type == JsonValueType::Integer)
		{
			return this->IntegralValue;
		}
		else if (errorMode == JsonErrorMode::ReportError)
		{
			Error("The json value was not an Integer value");
		}

		return defaultValue;
	}

	//***************************************************************************
	int JsonValue::AsInteger(int defaultValue, JsonErrorMode::Enum errorMode)
	{
		return (int)AsLongLong(defaultValue, errorMode);
	}

	//***************************************************************************
	bool JsonValue::MemberAsBool(StringParam name, bool defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = GetMember(name, errorMode))
			return value->AsBool(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	String JsonValue::MemberAsString(StringParam name, StringParam defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = GetMember(name, errorMode))
			return value->AsString(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	double JsonValue::MemberAsDouble(StringParam name, double defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = GetMember(name, errorMode))
			return value->AsDouble(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	long long JsonValue::MemberAsLongLong(StringParam name, long long defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = GetMember(name, errorMode))
			return value->AsLongLong(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	int JsonValue::MemberAsInteger(StringParam name, int defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = GetMember(name, errorMode))
			return value->AsInteger(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	float JsonValue::MemberAsFloat(StringParam name, float defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = GetMember(name, errorMode))
			return value->AsFloat(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	bool JsonValue::IndexAsBool(size_t index, bool defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = IndexValue(index, errorMode))
			return value->AsBool(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	String JsonValue::IndexAsString(size_t index, StringParam defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = IndexValue(index, errorMode))
			return value->AsString(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	double JsonValue::IndexAsDouble(size_t index, double defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = IndexValue(index, errorMode))
			return value->AsDouble(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	long long JsonValue::IndexAsLongLong(size_t index, long long defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = IndexValue(index, errorMode))
			return value->AsLongLong(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	int JsonValue::IndexAsInteger(size_t index, int defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = IndexValue(index, errorMode))
			return value->AsInteger(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	float JsonValue::IndexAsFloat(size_t index, float defaultValue, JsonErrorMode::Enum errorMode)
	{
		if (JsonValue* value = IndexValue(index, errorMode))
			return value->AsFloat(defaultValue, errorMode);
		return defaultValue;
	}

	//***************************************************************************
	JsonValue* JsonReader::ReadIntoTreeFromFile(CompilationErrors& errors, StringParam fileName, void* userData)
	{
		String json;

		if (Project::ReadTextFile(fileName, json) == false)
		{
			return nullptr;
		}

		return ReadIntoTreeFromString(errors, json, fileName, userData);
	}

	//***************************************************************************
	JsonValue* JsonReader::ReadIntoTreeFromString(CompilationErrors& errors, StringParam json, StringParam origin, void* userData)
	{
		Array<UserToken> tokens;
		Array<UserToken> comments;

		Tokenizer tokenizer(errors);
		tokenizer.EnableStringInterpolation = false;

		CodeEntry entry;
		entry.Code = json;
		entry.CodeUserData = userData;
		entry.Origin = origin;

		if (tokenizer.Parse(entry, tokens, comments) == false)
		{
			return nullptr;
		}

		JsonValue* root = nullptr;

		Array<JsonValue*> objectArrayStack;

		// Normally we'd have to worry about this being a pointer to an element in an array that's resizing
		// however, this will only ever point to the back element and therefore will be valid
		JsonMember* member = nullptr;
		bool foundColon = false;

		for (size_t i = 0; i < tokens.size(); ++i)
		{
			UserToken& token = tokens[i];

			JsonValue* createdValue = nullptr;

			if (token.TokenId == Grammar::True)
			{
				createdValue = new JsonValue();
				createdValue->Type = JsonValueType::True;
			}
			else if (token.TokenId == Grammar::False)
			{
				createdValue = new JsonValue();
				createdValue->Type = JsonValueType::True;
			}
			else if (token.TokenId == Grammar::Null)
			{
				createdValue = new JsonValue();
				createdValue->Type = JsonValueType::Null;
			}
			else if (token.TokenId == Grammar::IntegerLiteral)
			{
				createdValue = new JsonValue();
				createdValue->Type = JsonValueType::Integer;
				Zero::ToValue(token.Token, createdValue->IntegralValue);
			}
			else if (token.TokenId == Grammar::RealLiteral)
			{
				createdValue = new JsonValue();
				createdValue->Type = JsonValueType::Real;
				Zero::ToValue(token.Token, createdValue->RealValue);
			}
			else if (token.TokenId == Grammar::StringLiteral)
			{
				String strValue = ReplaceStringEscapesAndStripQuotes(token.Token);

				// If we're inside an object and not a member...
				if (objectArrayStack.empty() == false && objectArrayStack.back()->Type == JsonValueType::Object && member == nullptr)
				{
					// We're starting a member!
					member = new JsonMember();
					objectArrayStack.back()->OrderedMembers.push_back(member);
					member->Key = strValue;
				}
				else
				{
					createdValue = new JsonValue();
					createdValue->Type = JsonValueType::String;
					createdValue->StringValue = strValue;
				}
			}
			else if (token.TokenId == Grammar::NameSpecifier)
			{
				ErrorIf(member == nullptr, "Invalid : found");
				foundColon = true;
			}
			else if (token.TokenId == Grammar::BeginScope)
			{
				createdValue = new JsonValue();
				createdValue->Type = JsonValueType::Object;
			}
			else if (token.TokenId == Grammar::BeginIndex)
			{
				createdValue = new JsonValue();
				createdValue->Type = JsonValueType::Array;
			}
			else if (token.TokenId == Grammar::EndScope || token.TokenId == Grammar::EndIndex)
			{
				objectArrayStack.pop_back();
			}
			else if (token.TokenId == Grammar::ArgumentSeparator)
			{
			}
			else
			{
				Error("Unexpected token type");
				delete root;
				return nullptr;
			}

			if (createdValue != nullptr)
			{
				if (member != nullptr)
				{
					ErrorIf(foundColon == false, "A colon ':' was not found when specifying the value");
					foundColon = false;
					member->Value = createdValue;
					objectArrayStack.back()->Members.insert(member->Key, member->Value);
					member = nullptr;
				}
				else
				{
					if (objectArrayStack.empty())
					{
						ErrorIf(createdValue->Type != JsonValueType::Object);
						root = createdValue;
					}
					else
					{
						JsonValue* array = objectArrayStack.back();

						ErrorIf(array->Type != JsonValueType::Array,
							"If the thing on the top of the stack was an object, then a member should have been created for this value (or the file is invalid)");
						array->ArrayElements.push_back(createdValue);
					}
				}

				if (createdValue->Type == JsonValueType::Object || createdValue->Type == JsonValueType::Array)
				{
					objectArrayStack.push_back(createdValue);
				}
			}
		}

		return root;
	}

	//***************************************************************************
	String JsonBuilder::ToString() const
	{
		// Error checking
		ErrorIf(this->Stack.size() != 0,
			"The resulting Json object will be incomplete");

		// Output the final string
		return this->Builder.ToString();
	}

	//***************************************************************************
	void JsonBuilder::WriteTree(JsonValue* value)
	{
		switch (value->Type)
		{
		case JsonValueType::True:
			this->Value(true);
			break;
		case JsonValueType::False:
			this->Value(false);
			break;
		case JsonValueType::Null:
			this->Null();
			break;
		case JsonValueType::String:
			this->Value(value->StringValue);
			break;
		case JsonValueType::Integer:
			this->Value(value->IntegralValue);
			break;
		case JsonValueType::Real:
			this->Value(value->RealValue);
			break;
		case JsonValueType::Object:
			this->Begin(JsonType::Object);
			for (size_t i = 0; i < value->OrderedMembers.size(); ++i)
			{
				JsonMember* member = value->OrderedMembers[i];
				this->Key(member->Key);
				this->WriteTree(member->Value);
			}
			this->End();
			break;
		case JsonValueType::Array:
			this->Begin(JsonType::ArrayMultiLine);
			for (size_t i = 0; i < value->ArrayElements.size(); ++i)
			{
				JsonValue* element = value->ArrayElements[i];
				this->WriteTree(element);
			}
			this->End();
			break;
		default:
			Error("Invalid json value type");
			break;
		}
	}

	//***************************************************************************
	void JsonBuilder::Key(StringRange name)
	{
		// If the stack size is zero...
		ReturnIf(this->Stack.size() == 0, ,
			"You must be in the middle of an object to start a key/member (currently at the root!)");

		// Error checking
		ErrorIf(this->Stack.back() != JsonType::Object,
			"You must be in the middle of an object to start a key/member");

		// Error checking
		ErrorIf(this->IsMember,
			"A member of the object was already started");

		// Make sure to append a trailing comma if it's needed (after the last value)
		this->AttemptComma();

		this->AttemptNewline();

		// Append the quoted name with a following ':'
		this->Builder.Write("\"");
		this->Builder.Write(name);
		this->Builder.Write("\":");

		if (this->IsCompactMode == false)
		{
			this->Builder.Write(" ");
		}

		// We're now writing to a member
		this->IsMember = true;

		// Mark that we have yet to write anything since we started a new member
		this->IsWrittenTo = false;
	}

	//***************************************************************************
	void JsonBuilder::Value(int value)
	{
		this->RawValue(String::Format("%d", value));
	}

	//***************************************************************************
	void JsonBuilder::Value(unsigned int value)
	{
		this->RawValue(String::Format("%u", value));
	}

	//***************************************************************************
	void JsonBuilder::Value(long long value)
	{
		this->RawValue(String::Format("%lld", value));
	}

	//***************************************************************************
	void JsonBuilder::Value(long value)
	{
		this->RawValue(String::Format("%ld", value));
	}

	//***************************************************************************
	void JsonBuilder::Value(unsigned long value)
	{
		this->RawValue(String::Format("%lu", value));
	}

	//***************************************************************************
	void JsonBuilder::Value(unsigned long long value)
	{
		this->RawValue(String::Format("%llu", value));
	}

	//***************************************************************************
	void JsonBuilder::Value(double value)
	{
		this->RawValue(String::Format("%f", value));
	}

	//***************************************************************************
	void JsonBuilder::Value(cstr value)
	{
		this->Value(StringRange(value));
	}

	//***************************************************************************
	void JsonBuilder::Value(StringRange value)
	{
		// We need to build an escaped string
		StringBuilder escapedString;

		// Start with quotes on the front (and we'll add one to the end later)
		escapedString.Append("\"");

		// Loop through all the characters in the string
		for (size_t i = 0; i < value.size(); ++i)
		{
			// Get the current character
			char c = value[i];

			// Based on the character type...
			switch (c)
			{
			case '\\':
				// Escape the escape character
				escapedString.Append("\\\\");
				break;
			case '\n':
				// Escape the newline character
				escapedString.Append("\\n");
				break;
			case '\r':
				// Escape the carriage return character
				escapedString.Append("\\r");
				break;
			case '"':
				// Escape the quote character
				escapedString.Append("\\\"");
				break;
			default:
				// Just append the character like normal
				escapedString.Append(c);
				break;
			}
		}

		// Finish with an ending quote
		escapedString.Append("\"");

		// Get the resulting string we just built
		String result = escapedString.ToString();

		// Set the string as a value
		this->RawValue(result);
	}

	//***************************************************************************
	void JsonBuilder::Value(Boolean value)
	{
		// Write true or false dependent upon the value
		if (value)
		{
			this->RawValue("true");
		}
		else
		{
			this->RawValue("false");
		}
	}

	//***************************************************************************
	void JsonBuilder::Null()
	{
		this->RawValue("null");
	}

	//***************************************************************************
	void JsonBuilder::AttemptComma()
	{
		// If we're at the root, no comma is needed
		if (this->Stack.size() == 0)
		{
			return;
		}

		// If we're not written to
		if (this->IsWrittenTo)
		{
			this->Builder.Write(",");

			if (this->IsCompactMode == false)
			{
				this->Builder.Write(" ");
			}
		}
	}

	//***************************************************************************
	void JsonBuilder::AttemptNewline()
	{
		if (this->IsCompactMode == false)
		{
			// Get the last thing (object or array) that we started
			if (this->Stack.empty() || this->Stack.back() != JsonType::ArraySingleLine)
			{
				this->Builder.WriteLine();

				for (size_t i = 0; i < this->Stack.size(); ++i)
				{
					this->Builder.Write("  ");
				}
			}
		}
	}

	//***************************************************************************
	void JsonBuilder::RawValue(StringParam value)
	{
		// Error checking
		this->VerifyCanWriteValue();

		// Make sure to append a trailing comma if it's needed (after the last value)
		this->AttemptComma();

		if (this->IsMember == false)
		{
			this->AttemptNewline();
		}

		// Add the value to the builder
		this->Builder.Append(value);

		// For the node above us, we've always written to it when we get here
		this->IsWrittenTo = true;

		// No matter what, we either just wrote an array value or finished writing to a member
		this->IsMember = false;
	}

	//***************************************************************************
	void JsonBuilder::Begin(JsonType::Enum type)
	{
		// Error checking
		this->VerifyCanWriteValue();

		// Make sure to append a trailing comma if it's needed (after the last value)
		this->AttemptComma();

		if (!(type == JsonType::ArraySingleLine && this->IsMember))
		{
			this->AttemptNewline();
		}

		// Push the type on the stack so we know later what we're doing
		this->Stack.push_back(type);

		// If the type is an object...
		if (type == JsonType::Object)
		{
			// Start the object
			this->Builder.Write("{");
		}
		// Otherwise it's an array
		else
		{
			// Start the array
			this->Builder.Write("[");
		}

		// Mark that we have yet to write anything
		this->IsWrittenTo = false;

		// No matter what, we either just wrote an array value or finished writing to a member
		this->IsMember = false;
	}

	//***************************************************************************
	void JsonBuilder::End()
	{
		// Error checking
		ReturnIf(this->Stack.empty(), ,
			"There is no object or array to end (End was called one too many times)");

		// Get what we're in the top of the stack
		JsonType::Enum type = this->Stack.back();

		// Push the type on the stack so we know later what we're doing
		this->Stack.pop_back();

		if (type != JsonType::ArraySingleLine)
		{
			this->AttemptNewline();
		}

		// If the type is an object...
		if (type == JsonType::Object)
		{
			// End the object
			this->Builder.Write("}");
		}
		// Otherwise it's an array
		else
		{
			// End the array
			this->Builder.Write("]");
		}

		// For the node above us, we've always written to it when we get here
		this->IsWrittenTo = true;
	}

	//***************************************************************************
	void JsonBuilder::VerifyCanWriteValue()
	{
		// We can always write a value if we are at the root
		if (this->Stack.size() == 0)
		{
			// We can't write to the root twice...
			ErrorIf(this->Builder.GetSize() != 0,
				"Attempting to write to the root when something was already written");

			// Early out since there's nothing else to check
			return;
		}

		// Get the last thing (object or array) that we started
		JsonType::Enum last = this->Stack.back();

		// Verify that, if we're in the middle of an object, it must be as a member
		ErrorIf(last == JsonType::Object && this->IsMember == false,
			"You must make a member in order to add values inside of an object");
	}
}/**************************************************************\
 * Author: Trevor Sundberg
 * Copyright 2012-2014, DigiPen Institute of Technology
 \**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	ErrorDatabase::ErrorDatabase()
	{
		// Setup all the errors using generated code
		// AttributeNotComplete
		{
			ErrorInfo& error = this->Errors.push_back();
			error.Error = "The attribute '%s' was not completed (missing ']').";
			error.Name = "AttributeNotComplete";
			error.Reason = "";

		}

		// AttributesNotAttached
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Attributes were left at the end of the scope of the program and could not be attached to anything.";
	error.Name = "AttributesNotAttached";
	error.Reason = "";

}

// AttributeTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The attribute type was not found.";
	error.Name = "AttributeTypeNotFound";
	error.Reason = "";

}

// BaseClassInitializerMustComeFirst
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "To make the order of operations very clear, the base class initializer must come before any other initailizers (such as this).";
	error.Name = "BaseClassInitializerMustComeFirst";
	error.Reason = "Base classes are initialized before anything else, so it makes sense that it should actually come first.";

}

// BaseClassInitializerRequiresBaseClassInheritance
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A base class initializer can only be called when your class '%s' inherits from another class.";
	error.Name = "BaseClassInitializerRequiresBaseClassInheritance";
	error.Reason = "";

}

// BaseInitializerRequired
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Since '%s' inherits from '%s' (the base type), we require a base initializer after the constructor.";
	error.Name = "BaseInitializerRequired";
	error.Reason = "";

}

// BinaryOperatorRightOperandNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The right operand is invalid or not found for the '%s' operator '%s'.";
	error.Name = "BinaryOperatorRightOperandNotFound";
	error.Reason = "When an operator between two operands, such as the '+' operator, has a left operand (e.g. '5 + ') it must have a right operand as well.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "1.0 + ;";
		example.FixedCode = "1.0 + 2.0;\r\n";
		example.ExplanationOfFix = "*TBD*";
	}

}

// BlockCommentNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A block comment started wasn't properly closed when we reached the end of the file.";
	error.Name = "BlockCommentNotComplete";
	error.Reason = "Commonly, users accidentally delete or mistype the end of a block comment, which can cause code to be unnecessarily commented out. This can be dangerous if it was unintentional, hence the error.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "var cat : Animal := new Cat();\r\n\r\n/*\r\nvar dog : Animal := new Dog();";
		example.FixedCode = "var cat : Animal := new Cat();\r\n\r\n/*\r\nvar dog : Animal := new Dog();\r\n*/";
		example.ExplanationOfFix = "In the error case, we started a block comment (/*) but never finished it with (*/).";
	}

}

// BlockCommentNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A block comment end (*/) was found, but the beginning of the block comment (/*) was not found.";
	error.Name = "BlockCommentNotFound";
	error.Reason = "";

}

// BreakCountMustBeGreaterThanZero
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The break count is the number of loops we want to break out of, and therefore must be greater than or equal to 1.";
	error.Name = "BreakCountMustBeGreaterThanZero";
	error.Reason = "";

}

// BreakLoopNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A break statement was used, but we couldn't find the loop that it was breaking out of.";
	error.Name = "BreakLoopNotFound";
	error.Reason = "";

}

// CannotCreateType
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The type '%s' can only be created outside of Zilch.";
	error.Name = "CannotCreateType";
	error.Reason = "";

}

// CannotReplaceTemplateInstanceWithNonTemplateType
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "We tried to replace a type in a template, but couldn't do it since the type was used as an actual template type, and the type passed in as a template argument was not templatable.";
	error.Name = "CannotReplaceTemplateInstanceWithNonTemplateType";
	error.Reason = "";

}

// CannotReplaceTemplateInstanceWithTemplateArguments
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "It's complicated. I am really sorry, but it's just complicated.";
	error.Name = "CannotReplaceTemplateInstanceWithTemplateArguments";
	error.Reason = "";

}

// CastTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The casting operator 'as' is missing a cast type declaration (eg. x as Real).";
	error.Name = "CastTypeNotFound";
	error.Reason = "Casting allows us to convert one type to another. The 'as' operator was chosen because it gets rid of many unnecessary parentheses (eg C-style casts). The 'as' operator takes what we want to convert on the left and the type we want to convert it to on the right.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return 5 as ;\r\n  }\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return 5 as Real;\r\n  }\r\n}";
		example.ExplanationOfFix = "*TBD*";
	}

}

// ClassBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Class declaration '%s' does not have a closing '}'.";
	error.Name = "ClassBodyNotComplete";
	error.Reason = "In order for the compiler to understand where a class definition starts and ends, an opening ({) and closing (}) scope must be used. If the scope was not closed, the compiler would be forced to assume that the class encompasses all the code below it, which could be erroneous. There are a few likely cases that this could happen: the closing scope brace has been left off, a scope or parenthesis inside the class was not properly closed, or a variable or function declaration was garbled inside the class causing it to hault its parsing.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n";
		example.FixedCode = "class Animal\r\n{\r\n}\r\n";
		example.ExplanationOfFix = "In the error case, we started the definition of the class 'Animal' but never closed the scope. We fixed it by simply adding a closing scope (}) to the end of the class.";
	}

}

// ClassBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Class declaration '%s' does not have an opening '{'.";
	error.Name = "ClassBodyNotFound";
	error.Reason = "The compiler couldn't find the opening scope ({) for the class declaration, and therefore the class has no body. Check to make sure you added an opening scope and that the class name or inheritance list wasn't garbled. If you come from languages like C or C++ and you were trying to make a forward declaration, it is not required since the language globally shares all type-definitions between different scripts.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n";
		example.FixedCode = "class Animal\r\n{\r\n}";
		example.ExplanationOfFix = "In the error case, we forgot the opening scope ({). We fixed it by simply adding one in.";
	}

}

// ClassNameNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Class declaration is missing or invalid (we were unable to find the class name).";
	error.Name = "ClassNameNotFound";
	error.Reason = "Most likely the class name was invalid due to unnecessary symbols or to using a keyword in its place, or the class name was missing.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class\r\n{\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n}";
		example.ExplanationOfFix = "In the error case, we forgot to add the name of the class after the 'class' keyword. We fixed this by adding the name 'Animal' after the class, thus giving the type a name.";
	}

}

// CompositionCycleDetected
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A cycle of composition was detected. Eg. Type A includes Type B, Type B includes Type C, and Type C includes Type A (which is illegal).";
	error.Name = "CompositionCycleDetected";
	error.Reason = "";

}

// ConditionMustBeABooleanType
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The expression resulted in a '%s'. Any condition must result in a Boolean (true/false) type.";
	error.Name = "ConditionMustBeABooleanType";
	error.Reason = "";

}

// ConstructorCallNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The new/local constructor call was not found.";
	error.Name = "ConstructorCallNotFound";
	error.Reason = "";

}

// ContinueLoopNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A continue statement was used, but we couldn't find the loop that it was continuing from.";
	error.Name = "ContinueLoopNotFound";
	error.Reason = "";

}

// CreatedTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The new/local operator was missing a created type.";
	error.Name = "CreatedTypeNotFound";
	error.Reason = "";

}

// CreationInitializeMemberExpectedInitialValue
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "When initializing the member '%s', we need to specify a value expression to initialize to, eg '%s = 9'.";
	error.Name = "CreationInitializeMemberExpectedInitialValue";
	error.Reason = "";

}

// CreationInitializerExpectedExpression
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "We had a trailing argument separator ',' but no expression followed it (an incomplete list).";
	error.Name = "CreationInitializerExpectedExpression";
	error.Reason = "";

}

// CreationInitializerExpectedSubElement
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Failed to parse a sub-element of the creation initializer. The sub-element can be a member initialization 'Name: Value', an expression that can be added to a container, or a list of expressions to be added '[Value1, Value2, ...]'.";
	error.Name = "CreationInitializerExpectedSubElement";
	error.Reason = "";

}

// CreationInitializerNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Creation initializer is not properly closed with a ']'.";
	error.Name = "CreationInitializerNotComplete";
	error.Reason = "";

}

// CustomError
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "An error occurred: '%s'";
	error.Name = "CustomError";
	error.Reason = "";

}

// DelegateReturnTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Delegate declaration is missing the return type declaration, yet the type specifier ':' was found.";
	error.Name = "DelegateReturnTypeNotFound";
	error.Reason = "";

}

// DeletingNonReferenceType
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Unable to delete a non reference type.";
	error.Name = "DeletingNonReferenceType";
	error.Reason = "";

}

// DeletingNonWritableValue
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Objects that are not writable cannot be deleted.";
	error.Name = "DeletingNonWritableValue";
	error.Reason = "";

}

// DoWhileBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Do while statement body is not properly closed.";
	error.Name = "DoWhileBodyNotComplete";
	error.Reason = "";

}

// DoWhileBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Do while loop body was not found.";
	error.Name = "DoWhileBodyNotFound";
	error.Reason = "";

}

// DoWhileConditionalExpressionNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Do while statement conditional expression is not properly closed.";
	error.Name = "DoWhileConditionalExpressionNotComplete";
	error.Reason = "";

}

// DoWhileConditionalExpressionNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Do while statement conditional expression was not found.";
	error.Name = "DoWhileConditionalExpressionNotFound";
	error.Reason = "";

}

// DuplicateLocalVariableName
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A local variable (or parameter) with the same name '%s' has already been defined (or you attempted to name your parameter a reserved name, such as 'this').";
	error.Name = "DuplicateLocalVariableName";
	error.Reason = "";

}

// DuplicateMemberName
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A member with the same name '%s' has already been defined.";
	error.Name = "DuplicateMemberName";
	error.Reason = "";

}

// DuplicateTypeName
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A type with the same name '%s' has already been defined in the '%s' library.";
	error.Name = "DuplicateTypeName";
	error.Reason = "";

}

// EnumBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Enum declaration '%s' does not have a closing '}'.";
	error.Name = "EnumBodyNotComplete";
	error.Reason = "";

}

// EnumBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Enum declaration '%s' does not have an opening '{'.";
	error.Name = "EnumBodyNotFound";
	error.Reason = "";

}

// EnumDuplicateValue
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A value of the same name '%s' has already been declared in the enum '%s'. Names must only be used once.";
	error.Name = "EnumDuplicateValue";
	error.Reason = "";

}

// EnumNameNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Enum declaration is missing a name.";
	error.Name = "EnumNameNotFound";
	error.Reason = "";

}

// EnumValueRequiresIntegerLiteral
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "When assigning a specific value to '%s' by using '=', you must specify an integer literal (e.g. 5).";
	error.Name = "EnumValueRequiresIntegerLiteral";
	error.Reason = "";

}

// ExternalTypeNamesCollide
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The type '%s' from the library '%s' collides with another type of the same name from the library '%s'. Currently this is always an error, but in the future it will not be an error until someone tries to reference that type in their code.";
	error.Name = "ExternalTypeNamesCollide";
	error.Reason = "";

}

// ForEachInKeywordNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The foreach loop requires an 'in' keyword, which specifies which range we're iterating through.";
	error.Name = "ForEachInKeywordNotFound";
	error.Reason = "";

}

// ForEachRangeExpressionNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The foreach loop expects a range expression after the 'in' keyword.";
	error.Name = "ForEachRangeExpressionNotFound";
	error.Reason = "";

}

// ForEachVariableDeclarationNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The variable declaration in a foreach loop was not found.";
	error.Name = "ForEachVariableDeclarationNotFound";
	error.Reason = "";

}

// ForLoopBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "For loop body was not complete.";
	error.Name = "ForLoopBodyNotComplete";
	error.Reason = "";

}

// ForLoopBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "For loop body was not found.";
	error.Name = "ForLoopBodyNotFound";
	error.Reason = "";

}

// ForLoopExpressionsNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "For loop expressions were not complete.";
	error.Name = "ForLoopExpressionsNotComplete";
	error.Reason = "";

}

// ForLoopExpressionsNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "For loop expressions were not found.";
	error.Name = "ForLoopExpressionsNotFound";
	error.Reason = "";

}

// FunctionArgumentListNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Function declaration '%s' has an invalid argument list.";
	error.Name = "FunctionArgumentListNotComplete";
	error.Reason = "Argument list in function declaration must end with a ')' for the compiler to know when it is finished.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function TestFn(\r\n  {\r\n  }\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n  function TestFn()\r\n  {\r\n  }\r\n}";
		example.ExplanationOfFix = "Just adding a ')' finishes the argument list.";
	}

}

// FunctionArgumentListNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Function declaration '%s' is missing the argument list opening '('.";
	error.Name = "FunctionArgumentListNotFound";
	error.Reason = "Function declarations must contain an argument list opening with '(' and ending with ')'.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function TestFn\r\n  {\r\n  }\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n  function TestFn()\r\n  {\r\n  }\r\n}";
		example.ExplanationOfFix = "Added an empty argument list, but an argument list nonetheless.";
	}

}

// FunctionBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Function declaration '%s' does not have a closing '}'.";
	error.Name = "FunctionBodyNotComplete";
	error.Reason = "For the compiler to know the entirety of a function, the function body needs to begin and end with curly braces.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  var Number : Integer := 9;\r\n\r\n  function TestFn() : Real\r\n  {\r\n    return 1.0;\r\n\r\n  function AnotherFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n}\r\n";
		example.FixedCode = "class Animal\r\n{\r\n  var Number : Integer := 9;\r\n\r\n  function TestFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n  function AnotherFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n}";
		example.ExplanationOfFix = "The solution to this case is to add the closing bracket to the TestFn.";
	}

}

// FunctionBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Function declaration '%s' does not have an opening '{'.";
	error.Name = "FunctionBodyNotFound";
	error.Reason = "The compiler couldn't find the opening scope ({) for the function definition. Functions consist of a series of statements and expressions, and the compiler knows which of those belong to the function by what's inside the curly braces.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n}\r\n";
		example.FixedCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n    return 1.0;\r\n  }\r\n}";
		example.ExplanationOfFix = "Adding the rest of the function, such as the braces and return call.";
	}

}

// FunctionCallExpectedAfterInitializer
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "We expect a function call after any initializer (base, this, member initialization, etc).";
	error.Name = "FunctionCallExpectedAfterInitializer";
	error.Reason = "";

}

// FunctionCallNamedArgumentNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The right hand side of a named argument '%s' is missing or invalid.";
	error.Name = "FunctionCallNamedArgumentNotFound";
	error.Reason = "";

}

// FunctionCallNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A function call was not properly closed with ')', or one of the inner expressions was invalid.";
	error.Name = "FunctionCallNotComplete";
	error.Reason = "";

}

// FunctionCallOnNonCallableType
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The left hand side of a function call () must be a callable type, like a function or delegate.";
	error.Name = "FunctionCallOnNonCallableType";
	error.Reason = "";

}

// FunctionNameNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Function declaration is missing a name.";
	error.Name = "FunctionNameNotFound";
	error.Reason = "Function must have a name in order to be called.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function ()\r\n  {\r\n  }\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n  function Foo()\r\n  {\r\n  }\r\n}";
		example.ExplanationOfFix = "test";
	}

}

// FunctionParameterNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "An argument specified (,) was found, but no parameter was defined to the right of it.";
	error.Name = "FunctionParameterNotFound";
	error.Reason = "";

}

// FunctionReturnTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Function declaration '%s' has a return type specifier ':' but is missing the return type declaration.";
	error.Name = "FunctionReturnTypeNotFound";
	error.Reason = "':' was used after the parameter list, which signifies to the compiler that the function will be returning an object. The ':' must be followed by the type of object that will be returned. If you want nothing to be returned (ex 'void'), omit the usage of the ':'.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "function TestFn() :\r\n{\r\n}";
		example.FixedCode = "function TestFn()\r\n{\r\n}";
		example.ExplanationOfFix = "Fixed by removing the incomplete return type syntax.";
	}

}

// GetFoundAfterSet
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "When writing the property '%s', the 'get' must always come before the 'set', just for the sake of consistency.";
	error.Name = "GetFoundAfterSet";
	error.Reason = "";

}

// GroupingOperatorNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A grouping operator was not properly closed, or the expression in the grouping was missing or invalid.";
	error.Name = "GroupingOperatorNotComplete";
	error.Reason = "";

}

// IfBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "If statement body is not properly closed.";
	error.Name = "IfBodyNotComplete";
	error.Reason = "";

}

// IfBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "If statement body was not found.";
	error.Name = "IfBodyNotFound";
	error.Reason = "";

}

// IfConditionalExpressionNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "If statement conditional expression is not properly closed.";
	error.Name = "IfConditionalExpressionNotComplete";
	error.Reason = "";

}

// IfConditionalExpressionNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "If statement conditional expression was not found.";
	error.Name = "IfConditionalExpressionNotFound";
	error.Reason = "";

}

// IndexerIndicesNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The index or indices were invalid or not found for the index operator '[]'.";
	error.Name = "IndexerIndicesNotFound";
	error.Reason = "";

}

// IndexerNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "An index operator was not closed with ']' or its contents were invalid.";
	error.Name = "IndexerNotComplete";
	error.Reason = "";

}

// InternalError
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "An internal error occurred: '%s'";
	error.Name = "InternalError";
	error.Reason = "";

}

// InvalidBinaryOperation
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The binary '%s' operator '%s' is not valid with '%s' and '%s'.";
	error.Name = "InvalidBinaryOperation";
	error.Reason = "";

}

// InvalidEscapeInStringLiteral
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "An invalid escape sequence '\\%c' was used in a string literal.";
	error.Name = "InvalidEscapeInStringLiteral";
	error.Reason = "";

}

// InvalidNumberOfTemplateArguments
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "We expected %d template arguments but were only given %d.";
	error.Name = "InvalidNumberOfTemplateArguments";
	error.Reason = "";

}

// InvalidTypeCast
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Attempting to cast between two unrelated types '%s' and '%s' (like trying to convert a car into an apple).";
	error.Name = "InvalidTypeCast";
	error.Reason = "";

}

// InvalidUnaryOperation
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The unary operation is not valid on the type '%s'.";
	error.Name = "InvalidUnaryOperation";
	error.Reason = "";

}

// AttributeArgumentMustBeLiteral
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "All arguments given to an attribute must be literals (numbers, strings, true/false, or null).";
	error.Name = "AttributeArgumentMustBeLiteral";
	error.Reason = "";

}

// LocalCreateMustBeValueType
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The 'local' keyword can only be used to create value types (primitves and 'struct' types). '%s' is not a value type.";
	error.Name = "LocalCreateMustBeValueType";
	error.Reason = "The keyword 'local' is used to differentiate whether we are allocating something directly on the stack or on a class as a member. Locals must be value types because when they are copied we memory-copy the entire object (which isn't valid for reference types).";

}

// LocalVariableReferenceNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The variable '%s' could not be found. If the variable was defined above, but is in a nested scope, then we cannot access it.";
	error.Name = "LocalVariableReferenceNotFound";
	error.Reason = "";

}

// LoneTypeShouldOnlyAppearInAccessingStatics
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A type '%s' was used but the user wasn't trying to reference a static. To construct a type, use local/new. To access a member of the same name, always use 'this.Name'.";
	error.Name = "LoneTypeShouldOnlyAppearInAccessingStatics";
	error.Reason = "";

}

// LoopBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Loop statement body is not properly closed.";
	error.Name = "LoopBodyNotComplete";
	error.Reason = "";

}

// LoopBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Loop statement body was not found.";
	error.Name = "LoopBodyNotFound";
	error.Reason = "";

}

// MemberAccessNameNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Member access operator found without a valid member on the right hand side.";
	error.Name = "MemberAccessNameNotFound";
	error.Reason = "";

}

// MemberNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A member by the name of '%s' (either a function or a variable) could not be found.";
	error.Name = "MemberNotFound";
	error.Reason = "";

}

// MemberVariableTypesCannotBeInferred
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The type of a member variable '%s' cannot be inferred.";
	error.Name = "MemberVariableTypesCannotBeInferred";
	error.Reason = "";

}

// MultipleInheritanceNotSupported
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A class can only inherit from a single base class.";
	error.Name = "MultipleInheritanceNotSupported";
	error.Reason = "Mutltiple ineritance has the problems :B";

}

// NoConstructorsProvided
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The type '%s' cannot be created because no constructors were provided.";
	error.Name = "NoConstructorsProvided";
	error.Reason = "";

}

// NotAllPathsReturn
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A function is declared to return a type, yet not all code paths through the function result in it returning something.";
	error.Name = "NotAllPathsReturn";
	error.Reason = "";

}

// OnlyOneDestructorAllowed
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A class is only allowed to have one destructor (otherwise, which one would we call?).";
	error.Name = "OnlyOneDestructorAllowed";
	error.Reason = "";

}

// OverloadsCannotBeTheSame
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Two methods of the same name '%s' have the exact same signature, this is not allowed.";
	error.Name = "OverloadsCannotBeTheSame";
	error.Reason = "";

}

// ParameterTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Parameter declaration '%s' has a type specifier ':' but is missing the type declaration.";
	error.Name = "ParameterTypeNotFound";
	error.Reason = "Parameter names must have types associated with them. Ambiguously-typed parameters are not allowed in Zilch.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function TestFn(count : )\r\n  {\r\n  }\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n  function TestFn(count : Int)\r\n  {\r\n  }\r\n}";
		example.ExplanationOfFix = "Simply add the type of the parameter and all is good.";
	}

}

// ParameterTypeSpecifierNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Parameter declaration '%s' is missing the type specifier ':'.";
	error.Name = "ParameterTypeSpecifierNotFound";
	error.Reason = "Function parameters must have types associated with them, denoted by the syntax 'parameter : parameterType'. Zilch does not support ambiguously-typed parameters.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function TestFn(count )\r\n  {\r\n  }\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n  function TestFn(count : Int)\r\n  {\r\n  }\r\n}";
		example.ExplanationOfFix = "Adding the type specifier, ':', and a type to the parameter 'count'.";
	}

}

// ParsingNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Parsing could not be completed (we ran into something we didn't understand). The token we hit was '%s' with token type '%s'.";
	error.Name = "ParsingNotComplete";
	error.Reason = "";

}

// PropertyDeclarationNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The declaration of the property '%s' must be closed by an ending '}'.";
	error.Name = "PropertyDeclarationNotComplete";
	error.Reason = "";

}

// PropertyDelegateOperatorRequiresProperty
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The property delegate operator '@' only works on properties (which also includes data members).";
	error.Name = "PropertyDelegateOperatorRequiresProperty";
	error.Reason = "";

}

// PropertyDelegateRequiresGetOrSet
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The property delegate operator '@' requires the property to have either a 'get' or 'set' (or both). The property '%s' has neither.";
	error.Name = "PropertyDelegateRequiresGetOrSet";
	error.Reason = "";

}

// ReadingFromAWriteOnlyValue
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "An attempt was made to read from a write only value.";
	error.Name = "ReadingFromAWriteOnlyValue";
	error.Reason = "";

}

// ReferencesOnlyToNamedValueTypes
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "References (using the 'ref' keyword) can only be made to named value types, such as 'struct' types or primitives. '%s' is not a named value type.";
	error.Name = "ReferencesOnlyToNamedValueTypes";
	error.Reason = "";

}

// ReferenceToUndefinedType
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The type '%s' was referenced, but could not be found.";
	error.Name = "ReferenceToUndefinedType";
	error.Reason = "";

}

// ReturnTypeMismatch
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The '%s' type of the return value did not match the function's '%s' return type.";
	error.Name = "ReturnTypeMismatch";
	error.Reason = "";

}

// ReturnValueNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The return statement is expected to return a '%s' value, since the function declares it so (the ':' at the end specifies the return type).";
	error.Name = "ReturnValueNotFound";
	error.Reason = "";

}

// ReturnValueUnexpected
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The return statement was not expected to return a '%s' value, since the function does not declare it (no ':' at the end).";
	error.Name = "ReturnValueUnexpected";
	error.Reason = "";

}

// ScopeBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Scope statement body is not properly closed.";
	error.Name = "ScopeBodyNotComplete";
	error.Reason = "";

}

// ScopeBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Scope statement body was not found.";
	error.Name = "ScopeBodyNotFound";
	error.Reason = "";

}

// SendsEventStatementNameNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "In a 'sends' statement, we expect to see 'sends EventName : EventType;'. The name was not found.";
	error.Name = "SendsEventStatementNameNotFound";
	error.Reason = "";

}

// SendsEventStatementNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "In a 'sends %s' statement, we expect to see 'sends EventName : EventType;'. The statement was not complete (probably missing a ';').";
	error.Name = "SendsEventStatementNotComplete";
	error.Reason = "";

}

// SendsEventStatementTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "In a 'sends %s' statement, we expect to see 'sends EventName : EventType;'. The event type was not found.";
	error.Name = "SendsEventStatementTypeNotFound";
	error.Reason = "";

}

// SendsEventStatementTypeSpecifierNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "In a 'sends %s' statement, we expect to see 'sends EventName : EventType;'. The event type specifier ':' was not found.";
	error.Name = "SendsEventStatementTypeSpecifierNotFound";
	error.Reason = "";

}

// StatementSeparatorNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The statement must end with a semicolon.";
	error.Name = "StatementSeparatorNotFound";
	error.Reason = "";

}

// StatementsWillNotBeExecutedEarlyReturn
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The statement will not get hit because all code paths return before it would get to it. Use 'debug return' to exit early for debugging purposes.";
	error.Name = "StatementsWillNotBeExecutedEarlyReturn";
	error.Reason = "";

}

// StaticCannotBeOverriding
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The function or property '%s' marked as Static cannot also be marked as Override (because it can't be virtual).";
	error.Name = "StaticCannotBeOverriding";
	error.Reason = "";

}

// StaticCannotBeVirtual
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The function or property '%s' marked as Static cannot also be marked as Virtual.";
	error.Name = "StaticCannotBeVirtual";
	error.Reason = "";

}

// StringInterpolantExpectedExpression
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "When we start a string interpolant with '`' we expect an expression to follow that we will stringify.";
	error.Name = "StringInterpolantExpectedExpression";
	error.Reason = "";

}

// StringInterpolantNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "When we start a string interpolant with '`' we are expected to end it with another '`'.";
	error.Name = "StringInterpolantNotComplete";
	error.Reason = "";

}

// StringLiteralNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A string literal was started, but never finished before hitting the end of the line or stream.";
	error.Name = "StringLiteralNotComplete";
	error.Reason = "";

}

// StructsCanOnlyContainValueTypes
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The struct '%s' can only contain value types (other structs or primitive values). The member '%s' is not a value type.";
	error.Name = "StructsCanOnlyContainValueTypes";
	error.Reason = "A struct is a value type, which means it must be trivially copyable in memory and must not have a destructor. Structs are typically used for efficiency because they can be quickly copied around and stack allocated, unlike classes which must be heap allocated.";

}

// TemplateArgumentNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The argument to a template type was not found.";
	error.Name = "TemplateArgumentNotFound";
	error.Reason = "";

}

// TemplateTypeArgumentsNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Arguments for a templated type were provided, but were never closed or completed.";
	error.Name = "TemplateTypeArgumentsNotComplete";
	error.Reason = "";

}

// ThrowExceptionExpressionNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "A throw statement always requires an exception to be thrown, e.g. 'throw new Exception();'. The exception part of the throw statement wasn't found.";
	error.Name = "ThrowExceptionExpressionNotFound";
	error.Reason = "";

}

// ThrowTypeMustDeriveFromException
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The exception we're throwing must derive from the 'Exception' type.";
	error.Name = "ThrowTypeMustDeriveFromException";
	error.Reason = "";

}

// TimeoutBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Timeout statement body is not properly closed.";
	error.Name = "TimeoutBodyNotComplete";
	error.Reason = "";

}

// TimeoutBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Timeout statement body was not found.";
	error.Name = "TimeoutBodyNotFound";
	error.Reason = "";

}

// TimeoutSecondsExpectedIntegerLiteral
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The timeout statement only accepts Integer literals for seconds.";
	error.Name = "TimeoutSecondsExpectedIntegerLiteral";
	error.Reason = "";

}

// TimeoutSecondsMustBeNonZeroPositive
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The time in seconds given to the timeout statement must be positive and non-zero.";
	error.Name = "TimeoutSecondsMustBeNonZeroPositive";
	error.Reason = "";

}

// TimeoutSecondsNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Timeout statement's seconds is not properly closed with a ')'.";
	error.Name = "TimeoutSecondsNotComplete";
	error.Reason = "";

}

// TimeoutSecondsNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The timeout statement must be followed by a '(', the time in seconds, and a closing ')'.";
	error.Name = "TimeoutSecondsNotFound";
	error.Reason = "";

}

// TypeIdExpressionNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "In the typeid(...) expression we expect the value to be wrapped in parenthases, but we didn't find the closing ')'.";
	error.Name = "TypeIdExpressionNotComplete";
	error.Reason = "";

}

// TypeIdExpressionNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "In the typeid(...) expression we expect to find an expression wrapped in parentheses, but we couldn't find it.";
	error.Name = "TypeIdExpressionNotFound";
	error.Reason = "";

}

// UnableToResolveFunction
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The function '%s' exists, but could not be resolved since the types of the arguments used did not match. The arguments you gave were: %sThe possible choices were: %s";
	error.Name = "UnableToResolveFunction";
	error.Reason = "";

}

// UnaryOperatorOperandNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The operand was not found for the '%s' operator '%s'.";
	error.Name = "UnaryOperatorOperandNotFound";
	error.Reason = "The operators such as negation '-' and logical-not '!' must have an operand on the right-hand side for them to be valid syntax.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return - ;\r\n  }\r\n}";
		example.FixedCode = "class Animal\r\n{\r\n  function TestFn() : Real\r\n  {\r\n	return -1.0 ;\r\n  }\r\n}";
		example.ExplanationOfFix = "*TBD*";
	}

}

// UnidentifiedSymbol
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Invalid symbol or character '%c' encountered.";
	error.Name = "UnidentifiedSymbol";
	error.Reason = "The compiler ran into a symbol or character that it didn't understand, and therefore cannot continue.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "function #IsEmpty() : Bool32\r\n{\r\n  return mCount == 0;\r\n}";
		example.FixedCode = "function IsEmpty() : Bool32\r\n{\r\n  return mCount == 0;\r\n}";
		example.ExplanationOfFix = "In the error case, a # sign was introduced before the name of the function. The tokenizer would reach this symbol and hault, not knowing what it is.";
	}

}

// UnnecessaryVirtualAndOverride
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "When marking the method '%s' as overriding, it is unnecessary to also mark it as Virtual.";
	error.Name = "UnnecessaryVirtualAndOverride";
	error.Reason = "";

}

// VariableInitializationNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Variable declaration '%s' is missing a semicolon or the initialization expression is invalid.";
	error.Name = "VariableInitializationNotComplete";
	error.Reason = "This error occurred because the compiler was trying to parse a variable declaration with initialization and expected to find a semicolon at the end, but did not. The causes could be as simple as the semicolon is missing, or that the semicolon is in fact there, but the initialization expression was somehow garbled. If you're curious as to why a semicolon is needed, they are necessary because they act as a separator and help the parser to differentiate statements from each other, just like periods in a sentence. Imagine if a period was missing from a sentance, or worse yet if a sentance was so confusing to the point that you would expected a period!";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "var cat : Animal = new Cat()\r\nvar dog : Animal = new Dog();";
		example.FixedCode = "var cat : Animal = new Cat();\r\nvar dog : Animal = new Dog();";
		example.ExplanationOfFix = "In the error case, we forgot to put a semicolon (;) at the end of the 'cat' variable declaration. We fixed it by simply adding in a semicolon.";
	}

}

// VariableInitialValueNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Variable declaration '%s' has a missing or invalid initialization value.";
	error.Name = "VariableInitialValueNotFound";
	error.Reason = "Most probably the initial value of the variable was omitted, or a typo was made that caused the compiler to be unable to parse the initial value expression.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "var lives : Int32 := ;";
		example.FixedCode = "var lives : Int32 := 9;";
		example.ExplanationOfFix = "In the error case, the variable 'lives' was going to be initialized, but the value was left out. In the fixed case, we added a value (this value is known as the initialization expression).";
	}

}

// VariableMustBeInitialized
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Variable declaration '%s' is missing the initializer expression.";
	error.Name = "VariableMustBeInitialized";
	error.Reason = "All variables must be initialized for safety, and rather than letting the language decide some default value to initialize to, we forced the users to initialize all of their variables. Safety is a key concern for the language because it allows users to focus more on debugging logical bugs rather than bugs caused by indeterminate factors (like uninitialized variables).";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "var lives : Int32;";
		example.FixedCode = "var lives : Int32 = 9;";
		example.ExplanationOfFix = "In the error case, the variable 'lives' did not have an initializer after it, and therefore would have had an undefined value. We fixed this by giving it an initialization expression so that we would ultimately always be in control of its value.";
	}

}

// VariableNameNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Variable declaration has a missing or invalid name.";
	error.Name = "VariableNameNotFound";
	error.Reason = "One of the most common reasons for this error is that a keyword was used as a variable's name, which is not allowed because it could confuse the compiler. Also look to see if the name was left off, or if somehow the name was garbled with other symbols. If you're wondering why a variable needs a name, the reason is because a name gives us a way to refer to it in other parts of code, much like how people have names so we can refer to them and differentiate them apart.";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "var : Int32 := 9;";
		example.FixedCode = "var lives : Int32 := 9;";
		example.ExplanationOfFix = "In the error case, we forgot to name the variable. We fixed it simply by adding the variable name 'lives' after the 'var' keyword.";
	}

}

// VariableTypeMismatch
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "The value being assigned to '%s' must be of type '%s'. Its type is '%s'.";
	error.Name = "VariableTypeMismatch";
	error.Reason = "";

}

// VariableTypeNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "Variable declaration '%s' has a type specifier ':' but is missing the type declaration.";
	error.Name = "VariableTypeNotFound";
	error.Reason = "Mosty likely the type was just left out or the type contained some invalid keyword or symbol. If the type specifier (:) operator was found, then the variable expects a type. If you actually meant to make the variable an inferred type, then leave off the (:) and type declaration altogether. Inferred variables are variables whose type is gleaned by the initialization value (this feature is better known as Type Inference).";

	{
		ErrorExample& example = error.Examples.push_back();
		example.ErrorCode = "var lives : := 9;";
		example.FixedCode = "var lives : Int32 := 9;\r\n\r\n/* OR */\r\n\r\nvar lives := 9;";
		example.ExplanationOfFix = "In the error case, the type of lives was left out yet the type qualifier (:) was specified. We can fix it in two ways, first by actually specifying the type, and second by using type inference to infer the type automatically.";
	}

}

// WhileBodyNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "While statement body is not properly closed.";
	error.Name = "WhileBodyNotComplete";
	error.Reason = "";

}

// WhileBodyNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "While statement body was not found.";
	error.Name = "WhileBodyNotFound";
	error.Reason = "";

}

// WhileConditionalExpressionNotComplete
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "While statement conditional expression is not properly closed.";
	error.Name = "WhileConditionalExpressionNotComplete";
	error.Reason = "";

}

// WhileConditionalExpressionNotFound
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "While statement conditional expression was not found.";
	error.Name = "WhileConditionalExpressionNotFound";
	error.Reason = "";

}

// WritingToAReadOnlyValue
{
	ErrorInfo& error = this->Errors.push_back();
	error.Error = "An attempt was made to write to a read only value.";
	error.Name = "WritingToAReadOnlyValue";
	error.Reason = "";

}

	}

	//***************************************************************************
	const ErrorInfo& ErrorDatabase::GetErrorInfo(ErrorCode::Enum errorCode) const
	{
		return this->Errors[errorCode];
	}

	//***************************************************************************
	ErrorDetails::ErrorDetails(const ErrorInfo& info, const CodeLocation& location, ErrorCode::Enum code, va_list args) :
		Reason(info.Reason),
		Examples(info.Examples),
		Location(location),
		ExactError(String::FormatArgs(info.Error.c_str(), args)),
		ErrorCode(code)
	{
	}

	//***************************************************************************
	String ErrorDetails::GetFormattedMessage(MessageFormat::Enum format) const
	{
		// Print the error message out with the location (in a standard format)
		String message = this->Location.GetFormattedStringWithMessage(format, this->ExactError);

		// The message may have more things appended to it, so create a string builder
		StringBuilder builder;
		builder.Append(message);

		// Walk through all locations associated with this error (many errors have no associated locations, just the first 'Location')
		// Associated locations are things like duplicate class definitions, where it shows the other location the class was defined
		for (size_t i = 0; i < this->AssociatedOtherLocations.size(); ++i)
		{
			// Grab the current location and append it to the error message
			const CodeLocation* associatedLocation = this->AssociatedOtherLocations[i];
			String seeLocation = associatedLocation->GetFormattedString(format);
			builder.Append("      See");
			builder.Append(seeLocation);
		}

		// Compact the builder into one final string containing everything about the error
		return builder.ToString();
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	// Definition of static members
	EventHandler EventHandler::Global;

	//***************************************************************************
	ZilchDefineSimpleType(EventData, Core);

	//***************************************************************************
	EventData::~EventData()
	{
	}

	//***************************************************************************
	EventDelegate::EventDelegate() :
		Type(nullptr)
	{
	}

	//***************************************************************************
	EventDelegate::~EventDelegate()
	{
		// Event delegates are always responsible for unlinking themselves from the intrusive lists
		if (this->IncomingLink.Next != nullptr)
			IncomingList::Unlink(this);
		if (this->OutgoingLink.Next != nullptr)
			OutgoingList::Unlink(this);
	}

	//***************************************************************************
	EventDelegateList::~EventDelegateList()
	{
		// Delete all outgoing connections (using safe iteration)
		OnlyDeleteObjectIn(this->Outgoing);
	}

	//***************************************************************************
	void EventDelegateList::Send(EventData* event)
	{
		// If we have no connections then don't do anything
		if (this->Outgoing.empty())
			return;

		// Store the old event name, in case this event is being forwarded
		String lastEventName = event->EventName;
		event->EventName = this->EventName;

		// Get the type of event we're sending
		BoundType* sentEventType = event->ZilchGetDerivedType();

		// Because we want to ensure complete event safety, we have to make an entire copy of
		// all event delegates (and the container that holds them all)
		// That way if the user destroy objects, disconnect or reconnect new events, etc we won't
		// have issues referencing the original list / connections
		size_t totalOutgoing = 0;
		forRange(EventDelegate& delegate, this->Outgoing.all())
		{
			// Count how many outgoing event delegates we have
			++totalOutgoing;
		}

		// Allocate on the stack an array of pointers to the delegates
		byte* delegatesList = (byte*)alloca(EventDelegate::MaxEventDelegateSize * totalOutgoing);

		// Now copy all the event delegates into our stack local list (before we invoke any user code!)
		size_t i = 0;
		forRange(EventDelegate& delegate, this->Outgoing.all())
		{
			// Get the memory for the current delegate
			byte* currentDelegate = delegatesList + EventDelegate::MaxEventDelegateSize * i;

			// Copy construct (clone) the current delegate into the memory
			delegate.CopyInto(currentDelegate);
			++i;
		}

		// Now that we've made a copy of all delegates, go through and invoke them, erasing them as we go
		for (size_t j = 0; j < totalOutgoing; ++j)
		{
			// Get the memory for the current delegate
			EventDelegate* delegate = (EventDelegate*)(delegatesList + EventDelegate::MaxEventDelegateSize * j);

			// If the event is not of the correct type, then don't deliver it
			// We allow the delegate to accept a more base version of the event too
			if (TypeBinding::IsA(sentEventType, delegate->Type))
			{
				// Invoke the delegate with the event
				delegate->Invoke(event);
			}

			// Because the delegate is a temporary copy, we can destruct it using the virtual destructor
			delegate->~EventDelegate();
		}

		// Restore the last event name
		event->EventName = lastEventName;
	}

	//***************************************************************************
	EventDelegateList* EventHandler::GetOrCreateOutgoingDelegateList(StringParam eventName)
	{
		// Get the current list from the map, or insert a new entry (will be null)
		EventDelegateList*& list = this->OutgoingPerEventName[eventName];

		// If the list was null (just inserted) then allocate it right now
		// Because the list is grabbed as a reference, this will automatically update the list in the map
		if (list == nullptr)
		{
			// Create the new list and set its name
			list = new EventDelegateList();
			list->EventName = eventName;
		}

		// Return the list that we found or created
		return list;
	}

	//***************************************************************************
	EventHandler::~EventHandler()
	{
		// Destroy all incoming delegates
		OnlyDeleteObjectIn(this->Incoming);

		// Destroy all outgoing delegate lists (which in turn destroys those delegates)
		DeleteObjectsInContainer(this->OutgoingPerEventName);
	}

	//***************************************************************************
	void EventHandler::Send(StringParam eventName, EventData* event)
	{
		// We don't allow dispatching of null events
		if (event == nullptr)
		{
			Error("Cannot send a null event");
			return;
		}

		// Get the event delegate list for the given event name and send the event to all of them
		EventDelegateList* delegates = this->OutgoingPerEventName.findValue(eventName, nullptr);
		if (delegates != nullptr)
		{
			delegates->Send(event);
		}
	}

	//***************************************************************************
	void EventHandler::Connect(EventHandler* sender, StringParam eventName, EventDelegate* delegate, EventHandler* receiver)
	{
		// The receiver doesn't need to do anything special, it just directly stores a reference to the delegate
		receiver->Incoming.push_back(delegate);

		// Grab the list of outgoing delegates from the sender by this event name
		EventDelegateList* outgoingDelegates = sender->GetOrCreateOutgoingDelegateList(eventName);

		// Link in the delegate to this outgoing connection
		outgoingDelegates->Outgoing.push_back(delegate);
	}

	//***************************************************************************
	size_t EventHandler::Disconnect(EventHandler* sender, EventHandler* receiver, StringParam eventName, void* thisPointerOrUniqueId)
	{
		// Grab the list of outgoing delegates from the sender by this event name
		EventDelegateList* outgoingDelegates = sender->OutgoingPerEventName.findValue(eventName, nullptr);

		// If nobody signed up for this event, then early out (nothing to disconnect)
		if (outgoingDelegates == nullptr)
			return 0;

		// Loop through all the event delegates and remove anyone that has the same unique id/this pointer
		size_t removeCount = 0;
		EventDelegate* delegate = &outgoingDelegates->Outgoing.front();
		while (delegate != outgoingDelegates->Outgoing.end())
		{
			// List is intrusive so the pointer must be moved
			// before erasing the current connection.
			EventDelegate* currentDelegate = delegate;
			delegate = OutgoingList::Next(delegate);

			// If the delegate returns a matching this pointer...
			if (currentDelegate->GetThisPointerOrUniqueId() == thisPointerOrUniqueId)
			{
				// We can directly remove the delegate since we do safe iteration here, and we also
				// perform copying when dispatching
				// Note: Technically due to reference counting, if the delegate is keeping an object alive
				// and then we destroy it, that can cause user code to run, which could then delete the 'Next' delegate
				delete currentDelegate;
				++removeCount;
			}
		}

		// Return how many connections were deleted
		return removeCount;
	}

	//***************************************************************************
	ForwardingEventDelegate::ForwardingEventDelegate(EventHandler* forwardTo) :
		ForwardTo(forwardTo)
	{
		this->Type = ZilchTypeId(EventData);
	}

	//***************************************************************************
	void ForwardingEventDelegate::Invoke(EventData* event)
	{
		// Directly forward the event to the other handler
		this->ForwardTo->Send(event->EventName, event);
	}

	//***************************************************************************
	void* ForwardingEventDelegate::GetThisPointerOrUniqueId()
	{
		return this->ForwardTo;
	}

	//***************************************************************************
	void EventForward(EventHandler* sender, StringParam eventName, EventHandler* receiver)
	{
		// Create a member function delegate
		ForwardingEventDelegate* eventDelegate = new ForwardingEventDelegate(receiver);

		// Connect the event handler up to this newly created member delegate
		EventHandler::Connect(sender, eventName, eventDelegate, receiver);
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	void PerScopeData::PerformCleanup()
	{
		// Get the things we need to cleanup
		Array<Handle*>& handleCleanup = this->HandlesToBeCleaned;
		Array<Delegate*>& delegateCleanup = this->DelegatesToBeCleaned;
		Array<Any*>& anyCleanup = this->AnysToBeCleaned;

		// We need to go through all handles on the stack and destroy them
		for (size_t i = 0; i < handleCleanup.size(); ++i)
		{
			// Invoke the destructor (which should also decrement any reference counts)
			handleCleanup[i]->~Handle();
		}

		// We need to go through all delegates on the stack and destroy them
		for (size_t i = 0; i < delegateCleanup.size(); ++i)
		{
			// Invoke the destructor (which should also destroy the 'this' handle)
			delegateCleanup[i]->~Delegate();
		}

		// We need to go through all anys on the stack and destroy them
		for (size_t i = 0; i < anyCleanup.size(); ++i)
		{
			// Invoke the destructor (which should also destroy the stored value)
			anyCleanup[i]->~Any();
		}

		// Because this type is recycled, we need to clear the arrays for its next use
		handleCleanup.clear();
		delegateCleanup.clear();
		anyCleanup.clear();
	}

	//***************************************************************************
	PerFrameData::PerFrameData(ExecutableState* state) :
		Frame(nullptr),
		NextFrame(nullptr),
		CurrentFunction(nullptr),
		ProgramCounter(ProgramCounterNotActive),
		State(state),
		Debug(CallDebug::None),
		Report(nullptr),
		Timeouts(0),
		ErrorState(StackErrorState::Normal)
	{
	}

	//***************************************************************************
	void PerFrameData::QueueAnyCleanup(Any* any)
	{
		// Error checking
		ErrorIf(this->Scopes.back()->AnysToBeCleaned.findIndex(any) != Array<Any*>::InvalidIndex,
			"We should not be queuing the same address twice for cleanup!");

		this->Scopes.back()->AnysToBeCleaned.push_back(any);
	}

	//***************************************************************************
	void PerFrameData::QueueHandleCleanup(Handle* handle)
	{
		// Error checking
		ErrorIf(this->Scopes.back()->HandlesToBeCleaned.findIndex(handle) != Array<Handle*>::InvalidIndex,
			"We should not be queuing the same address twice for cleanup!");

		this->Scopes.back()->HandlesToBeCleaned.push_back(handle);
	}

	//***************************************************************************
	void PerFrameData::QueueDelegateCleanup(Delegate* delegate)
	{
		// Error checking
		ErrorIf(this->Scopes.back()->DelegatesToBeCleaned.findIndex(delegate) != Array<Delegate*>::InvalidIndex,
			"We should not be queuing the same address twice for cleanup!");

		this->Scopes.back()->DelegatesToBeCleaned.push_back(delegate);
	}

	//***************************************************************************
	bool PerFrameData::IsVariableInitialized(Variable* variable)
	{
		// Get the stack location of the variable
		byte* variableStackMemory = this->Frame + variable->Local;

		// If this is a value type...
		if (variable->ResultType->IsCopyComplex() == false)
		{
			// Consider it initialized... for now
			return true;
		}
		else
		{
			// Grab the curren't function's type, because we keep reusing it
			DelegateType* delegateType = this->CurrentFunction->Type;

			// If the variable is the this handle...
			byte* thisLocation = delegateType->ThisHandleStackOffset + this->Frame;
			if (thisLocation == variableStackMemory)
				return true;

			// If the pointer is any of the parameters...
			ParameterArray& parameters = delegateType->Parameters;
			for (size_t k = 0; k < parameters.size(); ++k)
			{
				// Get the current offset of the parameter...
				byte* parameterLocation = parameters[k].StackOffset + this->Frame;

				// If the parameter is the current variable we're looking at...
				if (parameterLocation == variableStackMemory)
					return true;
			}

			// Walk through all scopes
			for (size_t k = 0; k < this->Scopes.size(); ++k)
			{
				// Grab the current scope
				PerScopeData* scope = this->Scopes[k];

				// Loop through all handles, see if this pointer matches...
				for (size_t m = 0; m < scope->HandlesToBeCleaned.size(); ++m)
				{
					if (scope->HandlesToBeCleaned[m] == (Handle*)variableStackMemory)
						return true;
				}

				// Loop through all delegates, see if this pointer matches...
				for (size_t m = 0; m < scope->DelegatesToBeCleaned.size(); ++m)
				{
					if (scope->DelegatesToBeCleaned[m] == (Delegate*)variableStackMemory)
						return true;
				}

				// Loop through all any objects, see if this pointer matches...
				for (size_t m = 0; m < scope->AnysToBeCleaned.size(); ++m)
				{
					if (scope->AnysToBeCleaned[m] == (Any*)variableStackMemory)
						return true;
				}
			}
		}

		// We didn't find that it was initialized... it must not be
		return false;
	}

	//***************************************************************************
	bool PerFrameData::AttemptThrowStackExceptions(ExceptionReport& report)
	{
		// If we already know about the stack overflow, then ignore it
		if (this->State->HitStackOverflow)
		{
			return false;
		}

		// If we reached the max recursion depth (not necessarily an overflow, but definately a limit)
		if (this->ErrorState == StackErrorState::MaxRecursionReached)
		{
			this->State->HitStackOverflow = true;
			this->State->ThrowException(report, "Maximum recursion depth reached (too many function called inside of other functions)");
			return true;
		}
		// If we truly ran out of stack space...
		else if (this->ErrorState == StackErrorState::Overflowed)
		{
			this->State->HitStackOverflow = true;
			this->State->ThrowException(report, "The stack ran out of space (too many function called inside of other functions)");
			return true;
		}

		// No exceptions were thrown if we got here
		return false;
	}

	//***************************************************************************
	OperandLocation::OperandLocation() :
		Type(OperandType::NotSet),
		Memory(nullptr),
		MemorySize(0),
		Offset(0)
	{
	}

	//***************************************************************************
	Timeout::Timeout() :
		LengthTicks(0),
		AccumulatedTicks(0)
	{
	}

	//***************************************************************************
	bool ExceptionReport::HasThrownExceptions()
	{
		return !this->Exceptions.empty();
	}

	//***************************************************************************
	String ExceptionReport::GetConcatenatedMessages()
	{
		// Walk through all the exceptions and concatenate them
		StringBuilderExtended builder;
		for (size_t i = 0; i < this->Exceptions.size(); ++i)
		{
			// Read each of the exceptions from the handle
			Exception* exception = (Exception*)this->Exceptions[i].Dereference();

			// Write out the exception message
			builder.Write(exception->Message);

			// If this isn't the last exception...
			if (i != (this->Exceptions.size() - 1))
			{
				// Write out something that joins them together
				builder.Write(" / ");
			}
		}

		// Output the concatenated exceptions
		return builder.ToString();
	}

	//***************************************************************************
	void DefaultExceptionCallback(ExecutableState* state, Exception* exception, void* userData)
	{
		// Print out the standard formatted error message to the console
		fprintf(stderr, "%s", exception->GetFormattedMessage(MessageFormat::Zilch).c_str());
	}

	//***************************************************************************
	static const size_t DefaultStackSize = 2097152;
	static const String DefaultName("ExecutableState");
	ZilchThreadLocal ExecutableState* ExecutableState::CallingState = nullptr_constant;

	//***************************************************************************
	ExecutableState::ExecutableState() :
		Stack(new byte[DefaultStackSize + DefaultStackSize]),
		StackSize(DefaultStackSize),
		OverflowStackSize(DefaultStackSize),
		UserData(nullptr),
		MaxRecursionDepth(40),
		HitStackOverflow(false),
		TimeoutSeconds(0),
		Name(DefaultName)
	{
		ZilchErrorIfNotStarted(ExecutableState);

		// Reserve space for frames and scopes
		this->StackFrames.reserve(128);
		this->RecycledFrames.reserve(128);
		this->RecycledScopes.reserve(128);

		// Then add the rest of our handle managers
		this->HeapObjects = this->GetHandleManager<HeapManager>();
		this->StackObjects = this->GetHandleManager<StackManager>();
		this->PointerObjects = this->GetHandleManager<PointerManager>();

		// Clear the stack (including reserved space)
		memset(this->Stack, 0xCD, DefaultStackSize + DefaultStackSize);

		// Create a frame data that points to the beginning of the stack
		// This frame should never be popped (FrameData should have a minimum size of 1)
		PerFrameData* baseFrame = new PerFrameData(this);
		this->StackFrames.push_back(baseFrame);

		// Generate an empty function to help reduce code paths
		// When any function wants to get the next stack position,
		// they generally look at the current function + required space
		// The 'empty function' has a required space of zero (0) always
		Function* emptyFunction = new Function();

		// Initialize the frame data to defaults, except the stack pointer
		baseFrame->CurrentFunction = emptyFunction;
		baseFrame->Frame = this->Stack;
		baseFrame->NextFrame = this->Stack;
		baseFrame->ProgramCounter = ProgramCounterNotActive;
		baseFrame->State = this;
		baseFrame->Debug = CallDebug::None;
	}

	//***************************************************************************
	ExecutableState::~ExecutableState()
	{
		// We're not allowed to delete an executable state that isn't done executing
		ErrorIf(this->StackFrames.size() > 1, "Illegal to delete an ExecutableState that has a running stack frame");

		// We should always have the base frame
		ErrorIf(this->StackFrames.size() == 0, "Base frame should always exist (this is bad)");

		// Destroy the stack
		delete[] this->Stack;

		// We created a fake function as a 'base frame' function (need to clean it up)
		PerFrameData* baseFrame = this->StackFrames.back();
		delete baseFrame->CurrentFunction;
		delete baseFrame;

		// Get a range of all handle managers we uniquely created
		HashMap<HandleManagerId, HandleManager*>::valuerange managers = this->UniqueManagers.values();

		// Destroy all handle managers
		while (managers.empty() == false)
		{
			// Grab the handle manager and move to the next element
			HandleManager* manager = managers.front();
			managers.popFront();

			// Delete all of them (many will be null)
			delete manager;
		}

		// Loop through all native v-tables we created
		HashMap<BoundType*, byte*>::valuerange virtualTables = this->NativeVirtualTables.values();
		while (virtualTables.empty() == false)
		{
			// Clean up each v-table and move on
			delete virtualTables.front();
			virtualTables.popFront();
		}
	}

	//***************************************************************************
	byte* ExecutableState::GetCurrentStackFrame()
	{
		return this->StackFrames.back()->Frame;
	}

	//***************************************************************************
	byte* ExecutableState::GetNextStackFrame()
	{
		// Get the current frame data
		PerFrameData* current = this->StackFrames.back();

		// Compute the frame from the current position
		// (moved forward by the used stack space)
		return current->NextFrame;
	}

	//***************************************************************************
	PerFrameData* ExecutableState::PushFrame(Function* function)
	{
		// Get the next frame before we push our own frame data
		byte* frame = this->GetNextStackFrame();

		// Call the internal function
		return this->PushFrame(frame, function);
	}

	//***************************************************************************
	PerFrameData* ExecutableState::PushFrame(byte* frame, Function* function)
	{
		// Store a pointer to the newly created stack frame
		PerFrameData* newFrame = nullptr;

		// If we have no recycled stack frames...
		if (this->RecycledFrames.empty())
		{
			// There was nothing to be pulled from recycling,
			// so just make a new one (will be recycled later)
			newFrame = new PerFrameData(this);
		}
		else
		{
			// Otherwise, we just pop the latest one from the recycled list
			newFrame = this->RecycledFrames.back();
			this->RecycledFrames.pop_back();
		}

		// Clear any error state set on the frame data
		newFrame->ErrorState = StackErrorState::Normal;

		// If we got more calls then the max recursion depth...
		if (this->StackFrames.size() >= this->MaxRecursionDepth)
		{
			newFrame->ErrorState = StackErrorState::MaxRecursionReached;
		}

		// Compute the next frame on the stack
		byte* nextFrame = frame + function->RequiredStackSpace;

		// Compute the end of the real stack
		byte* endOfStack = this->Stack + this->StackSize;

		// If the next frame exceeds our max stack size...
		if (nextFrame >= endOfStack)
		{
			newFrame->ErrorState = StackErrorState::Overflowed;
		}

		// If we actually hit the end of the stack, including reserve size, then there's basically nothing we can do!
		if (nextFrame >= endOfStack + this->OverflowStackSize || this->StackFrames.size() >= this->MaxRecursionDepth * 2)
		{
			// Throw a fatal error!
			if (this->FatalCallback.Callback != nullptr)
			{
				this->FatalCallback.Callback(FatalError::StackReserveOverflow, this->FatalCallback.UserData);
			}

			// Time to quit the process!
			abort();
		}

		// If this is the first call being made into the state and we have a default timeout set
		// Note: This must be done before we push the stack frame below
		if (this->TimeoutSeconds != 0 && this->IsInCallStack() == false)
		{
			// Push the timeout with the number of seconds that the user set
			this->PushTimeout(newFrame, this->TimeoutSeconds);
		}

		// Take the newly allocated (or recycled) stack frame and push it onto the stack frames list
		this->StackFrames.push_back(newFrame);

		// Make sure we cleared out any scopes from before
		ErrorIf(newFrame->Scopes.empty() == false, "Improperly recycled stack frame");

		// Setup the frame data before we call the function
		// We need to initialize ALL members since this is recycled (also avoids constructors)
		// Note we don't need to set the State, as it should never change
		newFrame->Frame = frame;
		newFrame->NextFrame = nextFrame;
		newFrame->CurrentFunction = function;
		newFrame->ProgramCounter = ProgramCounterNotActive;
		newFrame->Debug = CallDebug::None;

		// Since every function gets an implicit scope, we'll add one to start
		newFrame->Scopes.push_back(this->AllocateScope());

		// Return the data we just created
		return newFrame;
	}

	//***************************************************************************
	PerFrameData* ExecutableState::PopFrame()
	{
		// Get the frame we're about to pop
		PerFrameData* frame = this->StackFrames.back();

		// We MUST save the timeout count as a temporary, because popping timeouts will decrement it
		size_t timeoutCount = frame->Timeouts;

		// Loop through all timeouts that still exist
		// Note: It is VERY important that we do this before cleaning up scopes (delegates/handles)
		// because destructors could get invoked and end up throwing exceptions again due to the timeout still existing
		for (size_t i = 0; i < timeoutCount; ++i)
		{
			// Pop any timeouts for this frame
			this->PopTimeout(frame);
		}

		// Loop through all the scopes
		for (size_t i = 0; i < frame->Scopes.size(); ++i)
		{
			// Get the current scope
			PerScopeData* scope = frame->Scopes[i];

			// Cleanup everything from this scope
			scope->PerformCleanup();

			// Recycle this scope (we will clear the scopes below)
			this->RecycledScopes.push_back(scope);
		}

		// We need to clean out all scopes (including the implicitly created first one)
		// because we are going to be recycling the frame
		frame->Scopes.clear();

		// Recycle the stack frame
		this->RecycledFrames.push_back(frame);

		// Pop the stack frame
		this->StackFrames.pop_back();

		// If we hit the stack overflow and turned the flag on, and
		// we just popped our last stack frame (no longer in a call stack)
		if (this->HitStackOverflow && this->IsInCallStack() == false)
		{
			// Clear the flag that lets us use extra stack space
			this->HitStackOverflow = false;
		}

		// Make sure the dummy always exists
		ErrorIf(this->StackFrames.empty(), "We popped the dummy stack frame and were not supposed to!");

		// Validation of timeouts
		ErrorIf(this->StackFrames.size() == 1 && this->Timeouts.empty() == false,
			"If we popped the last stack frame (except the dummy) then all timeouts should be gone!");

		// Even though the frame is invalid, we should return it for debugging
		return frame;
	}

	//***************************************************************************
	void ExecutableState::InitializeStackHandle(Handle& handle, byte* location, BoundType* type)
	{
		// Set the handle's manager
		handle.Manager = this->StackObjects;

		// Set the type of this handle
		handle.Type = type;

		// We are always guaranteed that the handle data is cleared before we get the user data portion
		StackHandleData& data = *(StackHandleData*)handle.Data;
		data.StackLocation = location;
		//data.UniqueId = 0;
		//data.ScopeCount = 0;

		ZilchTodo("Stack handles need to be properly initialized");
	}

	//***************************************************************************
	bool ExecutableState::PushTimeout(PerFrameData* frame, size_t seconds)
	{
		// When pushing the timeout we do a validation for any previous timeouts
		// Note: This is very important because it also updates the timer's last query
		// This will early out and skip pushing a timer
		if (this->ThrowExceptionOnTimeout(*frame->Report))
			return true;

		// Create a timeout structure...
		Timeout& timeout = this->Timeouts.push_back();

		// Set the length of the timeout based on the constant stored in the opcode
		timeout.LengthTicks = seconds * Timer::TicksPerSecond;

		// Increment the timeouts stored on that frame, so if an exception happens
		// or we need to unroll (return) then we know how many timeouts to pop
		++frame->Timeouts;

#if _DEBUG
		// This is not necessary, but it's nice for debugging
		// We use this to verify that 
		timeout.Frame = frame;
#endif

		// We didn't throw an exception above, so return false
		return false;
	}

	//***************************************************************************
	bool ExecutableState::PopTimeout(PerFrameData* frame)
	{
		// We assume we're not going to throw any exceptions, see below
		bool result = false;

		// If we already have an exception that we're dealing with, then don't try and throw another!
		if (frame->Report->HasThrownExceptions() == false)
		{
			// When popping the timeout we do one last validation
			result = this->ThrowExceptionOnTimeout(*frame->Report);
		}

#if _DEBUG
		// Verify that the frame is the same one that pushed this timeout
		ErrorIf(this->Timeouts.back().Frame != frame,
			"An incorrect frame was used to pop a timeout (not the one that pushed it!)");
#endif

		// Pop the last timeout off the stack
		this->Timeouts.pop_back();

		// We no longer need to pop this timeout if the stack unrolls
		--frame->Timeouts;

		// Return whether we threw an exception or not
		return result;
	}

	//***************************************************************************
	PerScopeData* ExecutableState::AllocateScope()
	{
		// The new scope we'll return
		PerScopeData* newScope = nullptr;

		// If we have no recycled scopes...
		if (this->RecycledScopes.empty())
		{
			// There was nothing to be pulled from recycling,
			// so just make a new one (will be recycled later)
			newScope = new PerScopeData();
		}
		else
		{
			// Otherwise, we just pop the latest one from the recycled list
			newScope = this->RecycledScopes.back();
			this->RecycledScopes.pop_back();
		}

		// Return the newly created or recycled scope
		return newScope;
	}

	//***************************************************************************
	void ExecutableState::InvokePreConstructorOrRelease(Handle& handle, ExceptionReport& report)
	{
		// Error checking
		ErrorIf(report.HasThrownExceptions(),
			"Exceptions still set on the report when attempting to invoke the pre-constructor");

		// Iterate through this type and all it's base types, so we can call pre-constructors on each of them
		// Technically, the order should not matter!
		BoundType* type = handle.Type;
		while (type != nullptr)
		{
			// If we have a pre-constructor...
			Function* preConstructor = type->GetPreConstructor();
			if (preConstructor != nullptr)
			{
				// Call the preconstructor
				Call call(preConstructor, this);
				call.SetHandle(Call::This, handle);
				call.Invoke(report);

				// If we failed to execute the pre constructor, return a null handle
				if (report.HasThrownExceptions())
				{
					// Clear the handle to a null handle (which should also delete the object)
					handle = Handle();
					return;
				}
			}

			// Iterate to the next base type
			type = type->BaseType;
		}
	}

	//***************************************************************************
	void ExecutableState::UpdateCppVirtualTable(byte* objectWithBaseVTable, BoundType* cppBaseType, BoundType* derivedType)
	{
		// Error checking
		ErrorIf(cppBaseType->BoundNativeVirtualCount > cppBaseType->RawNativeVirtualCount,
			"We should never have more bound native virtual functions than the actual v-table size");

		// First, check to see if this object is native or not
		if (cppBaseType->RawNativeVirtualCount == 0 || cppBaseType->BoundNativeVirtualCount == 0)
		{
			return;
		}

		// Get a pointer to the virtual table
		TypeBinding::VirtualTableFn*& virtualTable = *(TypeBinding::VirtualTableFn**)objectWithBaseVTable;

		// Check to see if we've already mapped up this virtual table
		byte* foundVirtualTable = this->NativeVirtualTables.findValue(cppBaseType, nullptr);

		// If we did find it (already made one)
		if (foundVirtualTable != nullptr)
		{
			// Just map the object's virtual table to this one (plus offset)
			virtualTable = (TypeBinding::VirtualTableFn*)(foundVirtualTable + sizeof(ExecutableState*));
			return;
		}

		// Compute the exact size of the native v-table in bytes
		size_t nativeVTableSizeBytes = cppBaseType->RawNativeVirtualCount * sizeof(TypeBinding::VirtualTableFn);

		// Create the new virtual table to store the executable state,
		// and a copy (with replacements) of the native virtual table
		byte* fullVirtualTable = new byte[sizeof(BoundType*) + sizeof(ExecutableState*) + nativeVTableSizeBytes];

		// Insert the type at the front of the v-table so we can resolve the virtual function
		// This must be properly destructed with the executable state
		new (fullVirtualTable)BoundType*(derivedType);

		// Insert the executable state at the front
		new (fullVirtualTable + sizeof(BoundType*)) ExecutableState*(this);

		// The full virtual table stores extra data at the front, but we only
		// want a view that looks like the native virtual table
		TypeBinding::VirtualTableFn* newVirtualTable = (TypeBinding::VirtualTableFn*)(fullVirtualTable + sizeof(BoundType*) + sizeof(ExecutableState*));

		// Now copy the actual v-table from the object into the new virtual table
		memcpy(newVirtualTable, virtualTable, nativeVTableSizeBytes);

		// We need to walk all parent types to generate the table
		BoundType* parentCppType = cppBaseType;

		// Loop until we hit the end of the parent types
		while (parentCppType != nullptr)
		{
			// Get all the instance functions
			FunctionMultiValueRange allInstanceFunctions = parentCppType->InstanceFunctions.values();

			// Loop until all the instance functions are empty
			while (allInstanceFunctions.empty() == false)
			{
				// Grab the current array of instance functions
				FunctionArray& functionArray = allInstanceFunctions.front();
				allInstanceFunctions.popFront();

				// Loop through all instance functions (those are the only virtuals!)
				for (size_t i = 0; i < functionArray.size(); ++i)
				{
					// Grab the current instance function
					Function* function = functionArray[i];

					// If the function is native virtual...
					if (function->NativeVirtual.Index != NativeVirtualInfo::NonVirtual)
					{
						// Map the thunk mixed with the bound function
						GuidType guid = derivedType->Hash() ^ function->NativeVirtual.Guid;

						BoundType* parentZilchType = derivedType;
						Function* mostDerived = nullptr;

						do
						{
							const FunctionArray* functionArray = parentZilchType->GetOverloadedInstanceFunctions(function->Name);

							if (functionArray != nullptr)
							{
								for (size_t j = 0; j < functionArray->size(); ++j)
								{
									Function* currentFunction = (*functionArray)[j];

									if (Type::IsSame(currentFunction->Type, function->Type))
									{
										mostDerived = currentFunction;
									}
								}
							}

							parentZilchType = parentZilchType->BaseType;

							if (parentZilchType == nullptr)
							{
								Error("We should never reach a null base class before hitting the Cpp type");
								break;
							}
						} while (parentZilchType != cppBaseType);

						// If we found that the user overwrote the vtable entry...
						if (mostDerived != nullptr)
						{
							this->ThunksToFunctions.insertOrError(guid, mostDerived);

							// Error checking for v-table indices
							ErrorIf(function->NativeVirtual.Index >= cppBaseType->RawNativeVirtualCount,
								"We should never have a native virtual whose index is greater than the total v-table indices");

							// Override the function in the v-table with our own thunk
							newVirtualTable[function->NativeVirtual.Index] = function->NativeVirtual.Thunk;
						}
					}
				}
			}

			// Move to the next parent type
			parentCppType = parentCppType->BaseType;
		}

		// Add the virtual table to our known v-tables
		this->NativeVirtualTables.insertOrError(cppBaseType, fullVirtualTable);

		// Finally, point this object instance at the new virtual table
		virtualTable = newVirtualTable;
	}

	//***************************************************************************
	void ExecutableState::SetTimeout(size_t seconds)
	{
		// Error checking
		ReturnIf(this->IsInCallStack(), ,
			"You cannot set a timeout while inside a call-stack");

		// Store the timeout
		this->TimeoutSeconds = seconds;
	}

	//***************************************************************************
	bool ExecutableState::IsInCallStack()
	{
		// Error checking
		ErrorIf(this->StackFrames.empty(),
			"The stack frames should never be empty (we should always have a dummy!)");

		// Technically we always have 1 dummy frame that exists
		return (this->StackFrames.size() != 1);
	}

	//***************************************************************************
	Handle ExecutableState::AllocateStackObject(byte* stackLocation, BoundType* type, ExceptionReport& report)
	{
		// Verify that the given pointer is within our stack
		ErrorIf(stackLocation < this->Stack || stackLocation > this->Stack + this->StackSize,
			"The given stack location for allocating a stack object was not within our stack");

		// Create a stack handle to point at the given location
		Handle handle;
		this->InitializeStackHandle(handle, stackLocation, type);

		// Pre-construct the handle (initialize memory) or clear it to null if we fail
		this->InvokePreConstructorOrRelease(handle, report);

		// Return the stack handle
		return handle;
	}

	//***************************************************************************
	Handle ExecutableState::AllocateDefaultConstructedHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags)
	{
		// Grab the default constructor
		const FunctionArray* constructors = type->GetOverloadedInheritedConstructors();

		// As long as we have constructors (could be inherited!)
		if (constructors != nullptr)
		{
			// Find the default constructor
			Function* defaultConstructor = Type::GetDefaultConstructor(constructors);

			// If the default constructor is null...
			if (defaultConstructor != nullptr)
			{
				// Allocate the heap object
				Handle handle = this->AllocateHeapObject(type, report, flags);

				// If allocating the heap object with just the pre-constructor threw an exception, early out
				if (report.HasThrownExceptions())
				{
					return Handle();
				}

				// Execute the constructor which returns a call
				Call call(defaultConstructor, this);
				call.SetHandle(Call::This, handle);
				call.Invoke(report);

				// If we failed to execute the default constructor, return a null handle
				if (report.HasThrownExceptions())
				{
					return Handle();
				}

				// Return the handle, even if we couldn't construct the object
				return handle;
			}
		}

		// Show an error since we couldn't construct the object
		Error("The default constructor could not be found for type '%s'",
			type->ToString().c_str());
		return Handle();
	}

	//***************************************************************************
	Handle ExecutableState::AllocateHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags)
	{
		// Let the heap objects initialize the handle
		Handle handle;
		handle.Type = type;
		handle.Manager = this->HeapObjects;
		this->HeapObjects->Allocate(type, handle, flags);

		//HACK (forces all handles to be direct pointers)
		//byte* obj = handle.Dereference();
		//handle.Manager = this->PointerObjects;
		//this->PointerObjects->ObjectToHandle(obj, handle);

		// Pre-construct the handle (initialize memory) or clear it to null if we fail
		this->InvokePreConstructorOrRelease(handle, report);

		// Return the handle
		return handle;
	}

	//***************************************************************************
	bool ExecutableState::ThrowExceptionOnTimeout(ExceptionReport& report)
	{
		// Get the ticks since last check (this also updates the timer to now)
		// This MUST be called before the early out so that we don't accumulate up time not spent in Zilch
		long long ticksSinceLastCheck = this->TimeoutTimer.GetAndUpdateTicks();

		// Reset the timer so the the timer always returns us 'time passed since last check'
		this->TimeoutTimer.Reset();

		// Early out if we don't have any timeouts to abide by
		if (this->Timeouts.empty())
			return false;

		// Get the time that we expect to timeout at
		Timeout& timeout = this->Timeouts.back();

		// Accumulate ticks for our timer
		timeout.AccumulatedTicks += ticksSinceLastCheck;

		// If we exceed the timeout, we need to throw an exception and stop everything
		if (timeout.AccumulatedTicks > timeout.LengthTicks)
		{
			// Throw an exception to say we timed out
			this->ThrowException
				(
				report,
				String::Format
				(
				"Exceeded the allowed execution time of %d second(s). Use the timeout statement to increase allowed time",
				timeout.LengthTicks / Timer::TicksPerSecond
				)
				);

			// We threw the exception and thus we return 'true', the timeout occurred
			return true;
		}

		// Otherwise, we got here so nothing bad happened
		return false;
	}

	//***************************************************************************
	void ExecutableState::ThrowNullReferenceException(ExceptionReport& report)
	{
		// Throw a null reference exception
		this->ThrowException(report, "Attempted to access a member of a null handle");
	}

	//***************************************************************************
	void ExecutableState::ThrowNullReferenceException(ExceptionReport& report, StringParam customMessage)
	{
		// Throw a null reference exception
		this->ThrowException
			(
			report,
			String::Format("Attempted to access a member of a null handle: %s", customMessage.c_str())
			);
	}

	//***************************************************************************
	void ExecutableState::ThrowException(ExceptionReport& report, StringParam message)
	{
		Core& core = Core::GetInstance();

		// Allocate a default constructed base exception
		// Note: We only allocate the exception and DO NOT default construct it
		// This is because we know the exception will be fully initialized, and moreover if we run out of allocation space
		// then returning a null handle is considered ok!
		// The StackTrace allocator originally did not support memset to zero, but we made a special one called MemsetZeroDefaultAllocator
		ExceptionReport defaultExceptionReport;
		Handle handle = this->AllocateHeapObject(core.ExceptionType, defaultExceptionReport, HeapFlags::ReferenceCounted);

		// Error testing
		ReturnIf(defaultExceptionReport.HasThrownExceptions(), ,
			"Allocating the default exception object should NEVER throw an exception");

		// Dereference a handle and grab a pointer to the exception object
		byte* memory = handle.Dereference();

		// Because an exception can be null if we truly run out of memory, then just skip this portion
		if (memory != nullptr)
		{
			// Grab a reference to the exception memory
			Exception& exception = *(Exception*)memory;

			// Set the friendly and exact error messages of the exception
			exception.Message = message;
		}

		// Forward this to the normal function that throws exceptions
		this->ThrowException(report, handle);
	}

	//***************************************************************************
	void ExecutableState::ThrowException(ExceptionReport& report, Handle& handle)
	{
		ZilchTodo("We need to verify that this handle is indeed a handle to an Exception type");

		// Dereference a handle and grab a pointer to the exception object
		Exception* exception = (Exception*)handle.Dereference();

		// Generate a stack trace for the exception
		this->GetStackTrace(exception->Trace);

		// If the exception callback is set...
		if (this->ExceptionThrownCallback.Callback != nullptr)
		{
			// Invoke a callback telling the user that an exception occurred
			this->ExceptionThrownCallback.Callback(this, exception, this->ExceptionThrownCallback.UserData);
		}

		// Add the current exception to the list of active exceptions
		report.Exceptions.push_back(handle);

		// The user should never touch this, it's only for debug!
		report.ExceptionsForDebugOnly.push_back(exception);
	}

	//***************************************************************************
	void ExecutableState::GetStackTrace(StackTrace& trace)
	{
		// Walk the stack frames from the bottom to top, building a call stack
		for (size_t i = 1; i < this->StackFrames.size(); ++i)
		{
			// Grab the current frame
			PerFrameData* frame = this->StackFrames[i];

			// Detect if this is the last stack frame
			bool isLastFrame = (i == (this->StackFrames.size() - 1));

			// As long as this frame's program counter is active in some sort...
			if (frame->ProgramCounter != ProgramCounterNotActive || (isLastFrame && trace.Stack.empty()))
			{
				// Create a new stack entry for this frame
				StackEntry& stackEntry = trace.Stack.push_back();

				// Add the current function to the stack entry
				Function* function = frame->CurrentFunction;
				stackEntry.ExecutingFunction = function;

				// If this is a frame that we're managing (so we can get more call stack information)
				// (Non-Active-Functions): For right now, since we don't have better location information about where the
				// function is (using the first opcode is WRONG and points at the wrong location)
				// We just opt to print the function out as if it's native, the user can search for it...
				size_t programCounter = frame->ProgramCounter;
				if (programCounter != ProgramCounterNative && programCounter != ProgramCounterNotActive)
				{
					// Get the code location (or null if for some reason we can't find it...)
					CodeLocation* codeLocation = function->OpcodeLocationToCodeLocation.findPointer(programCounter);

					// If we found the code location
					if (codeLocation != nullptr)
					{
						// Set the code location on the stack entry
						stackEntry.Location = *codeLocation;
					}
					else
					{
						Error("Unable to find code location for an opcode that belongs to a function (invalid opcode offset?)");
					}
				}
				else
				{
					// Initialize the location to the bound function
					stackEntry.Location.Origin = function->SourceLibrary->Name;
					stackEntry.Location.Library = function->SourceLibrary->Name;
					stackEntry.Location.Class = function->Owner->Name;
					stackEntry.Location.Function = function->Name;
					stackEntry.Location.IsNative = true;
				}
			}
		}
	}

	//***************************************************************************
	HandleManager* ExecutableState::GetHandleManager(HandleManagerId id) const
	{
		// See if we have a unique manager on us...
		HandleManager* manager = this->UniqueManagers.findValue(id, nullptr);

		// If we found the unqiue manager, just return it
		if (manager != nullptr)
		{
			return manager;
		}

		// Get a reference to the managers
		HandleManagers& managers = HandleManagers::GetInstance();

		// Otherwise, look for a shared manager
		manager = managers.GetSharedManager(id);

		// If we found the shared manager, just return it
		if (manager != nullptr)
		{
			return manager;
		}

		// Otherwise, we need to see if we can create one
		CreateHandleManagerFn creator = managers.GetUniqueCreator(id);

		// If the creator is valid...
		if (creator != nullptr)
		{
			// Run the creator to create the manager
			// The creator needs an executable state (will not modify it, but stores it)
			manager = creator(const_cast<ExecutableState*>(this));

			// Insert the manager into the map
			this->UniqueManagers.insert(id, manager);

			// Return the manager
			return manager;
		}
		else
		{
			// Error handling
			Error("We were not able to instantiate a handle manager or find a shared one for id '%d'", id);
			return nullptr;
		}
	}

	//***************************************************************************
	void ExecutableState::SetOpcodePreStepCallback(OpcodeStepCallback callback, void* userData)
	{
		this->OpcodePreStepCallback.Callback = callback;
		this->OpcodePreStepCallback.UserData = userData;
	}

	//***************************************************************************
	void ExecutableState::SetOpcodePostStepCallback(OpcodeStepCallback callback, void* userData)
	{
		this->OpcodePostStepCallback.Callback = callback;
		this->OpcodePostStepCallback.UserData = userData;
	}

	//***************************************************************************
	void ExecutableState::SetEnterFunctionCallback(FunctionStepCallback callback, void* userData)
	{
		this->EnterFunctionCallback.Callback = callback;
		this->EnterFunctionCallback.UserData = userData;
	}

	//***************************************************************************
	void ExecutableState::SetExitFunctionCallback(FunctionStepCallback callback, void* userData)
	{
		this->ExitFunctionCallback.Callback = callback;
		this->ExitFunctionCallback.UserData = userData;
	}

	//***************************************************************************
	void ExecutableState::SetFatalErrorCallback(FatalErrorCallback callback, void* userData)
	{
		this->FatalCallback.Callback = callback;
		this->FatalCallback.UserData = userData;
	}

	//***************************************************************************
	void ExecutableState::SetExceptionCallback(ExceptionCallback callback, void* userData)
	{
		this->ExceptionThrownCallback.Callback = callback;
		this->ExceptionThrownCallback.UserData = userData;
	}

	//***************************************************************************
	const byte* ExecutableState::GetRawStack()
	{
		return this->Stack;
	}

	//***************************************************************************
	void Call::PerformStandardChecks(size_t size, Type* userType, Type* actualType, CheckPrimitive::Enum primitive, Direction::Enum io)
	{
		// Check that the size is the same
		ErrorIf(AlignToBusWidth(size) != actualType->GetCopyableSize(),
			"The size of the types did not match");

		// If this is a value type...
		if (primitive == CheckPrimitive::Value)
		{
			// Check that the size of the value we're writing to is correct
			ErrorIf(actualType->IsCopyComplex(),
				"The type must be a value type");

			if (userType != nullptr)
			{
				if (Type::IsSame(userType, actualType) == false)
				{
					if (!((Type::IsEnumOrFlagsType(actualType)) && Type::IsSame(userType, ZilchTypeId(Integer))))
					{
						// Make sure we're trying to set the same type as the parameter
						Error("The user's type and the parameter/return/this type are not compatable");
					}
				}

			}

		}
		// If this is a reference/handle type...
		else if (primitive == CheckPrimitive::Handle)
		{
			// If the user type is a bound type
			BoundType* boundUserType = TypeBinding::DynamicCast<BoundType*>(userType);
			if (boundUserType != nullptr)
			{
				// If this is a value type being pointed at by a handle...
				if (boundUserType->GetCopyMode() == TypeCopyMode::ValueType)
				{
					IndirectionType* indirectionActualType = TypeBinding::DynamicCast<IndirectionType*>(actualType);

					if (indirectionActualType != nullptr)
					{
						// For now, we can't do much else
						userType = nullptr;
					}
					else
					{
						Error("Handles that refer to value types can only be passed in when the type is a ref type (indirect type)");
					}
				}
			}

			// Make sure the return type is a handle type
			ErrorIf(Type::IsHandleType(actualType) == false,
				"The parameter/return/this type is not a handle type");

			// If there was a provided user type to check
			if (userType != nullptr)
			{
				// Make sure the given type is a handle type
				ErrorIf(Type::IsHandleType(userType) == false,
					"The user's type is not a handle type");

				// We need to verify that the parameter is the same type
				// If we're getting a value...
				if (io == Direction::Get)
				{
					// Error checking
					ErrorIf(TypeBinding::GenericIsA(actualType, userType) == false,
						"When getting a handle, the parameter/return/this must either "
						"derive from or be the same type as what we're trying to get");
				}
				// Otherwise we're setting a value
				else
				{
					// Error checking
					/*ErrorIf(TypeBinding::GenericIsA(userType, actualType) == false,
						"When setting a handle, the handle must either derive "
						"from or be the same type as the parameter/return/this");*/
				}
			}
		}
		// If this is a delegate type...
		else if (primitive == CheckPrimitive::Delegate)
		{
			// Check that the delegate types are the same
			ErrorIf(Type::IsDelegateType(actualType) == false,
				"The parameter/return/this type is not a delegate type");

			// Check that the delegate types are the same
			ErrorIf(userType != nullptr && Type::IsDelegateType(userType) == false,
				"The user's type is not a delegate type");

			// Check that the delegate types are the same
			ErrorIf(userType != nullptr && Type::IsSame(userType, actualType) == false,
				"Attempting to pass in a delegate of an incorrect type");
		}
		// It must be the 'any' type...
		else
		{
			// Make sure this is the 'any type'
			ErrorIf(Type::IsAnyType(actualType) == false,
				"The parameter/return/this type is not the 'any' type");

			// If the user type was provided, make sure it's also the any type
			ErrorIf(userType != nullptr && Type::IsAnyType(userType) == false,
				"The user's type is not the 'any' type");
		}
	}

	//***************************************************************************
	byte* Call::GetChecked(size_t index, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
	{
		// If we're setting this... we need to mark that we did for debugging!
		if (io == Direction::Set)
		{
			// Mark and perform debug checks
			this->MarkAsSet(index);
		}

		// Based on the type of index...
		switch (index)
		{
			// It's an index that represents the return
		case Return:
			return this->GetReturnChecked(size, userType, primitive, io);

			// It's an index that represents the 'this' handle
		case This:
			return this->GetThisChecked(size, userType, primitive, io);

			// It's an index that represents any parameter
		default:
			return this->GetParameterChecked(index, size, userType, primitive, io);
		}
	}

	//***************************************************************************
	byte* Call::GetThisChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
	{
		// As long as the user didn't disable checks...
		if (!(this->Data->Debug & CallDebug::NoThisChecking))
		{
			// Make sure we don't try to request the 'this' handle as something weird
			ErrorIf(primitive != CheckPrimitive::Handle,
				"The 'this' handle for a function can only be retrieved as"
				" a handle/reference type, not as a value or delegate");

			// Get a reference to the this variable
			Variable* thisVariable = this->Data->CurrentFunction->This;

			// Error checking for if we're static
			ErrorIf(thisVariable == nullptr,
				"Cannot get the 'this' handle stack location for a static function");

			// Run a series of checks that tries to verify anything we can about what the user is doing
			this->PerformStandardChecks(size, userType, thisVariable->ResultType, primitive, io);
		}

		// Get the stack pointer where the 'this' should go
		return this->GetThisUnchecked();
	}

	//***************************************************************************
	byte* Call::GetReturnChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
	{
		// As long as the user didn't disable checks...
		if (!(this->Data->Debug & CallDebug::NoReturnChecking))
		{
			// Verify that this is not a void type
			ErrorIf(Core::GetInstance().VoidType == this->Data->CurrentFunction->Type->Return,
				"The return type is void and cannot be get/set");

			// Run a series of checks that tries to verify anything we can about what the user is doing
			this->PerformStandardChecks(size, userType, this->Data->CurrentFunction->Type->Return, primitive, io);
		}

		// Get the stack pointer where the return should go
		return this->GetReturnUnchecked();
	}

	//***************************************************************************
	byte* Call::GetParameterChecked(size_t parameterIndex, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io)
	{
		// Get a reference to the parameters
		ParameterArray& parameters = this->Data->CurrentFunction->Type->Parameters;

		// Error checking for the index
		ErrorIf(parameterIndex >= parameters.size(),
			"Attempting to access an invalid parameter by index (out of bounds)");

		// Get the current parameter
		DelegateParameter& parameter = parameters[parameterIndex];

		// As long as the user didn't disable checks...
		if (!(this->Data->Debug & CallDebug::NoParameterChecking))
		{
			// Run a series of checks that tries to verify anything we can about what the user is doing
			this->PerformStandardChecks(size, userType, parameter.ParameterType, primitive, io);
		}

		// Get the stack pointer where the parameter should go
		return this->Data->Frame + parameter.StackOffset;
	}

	//***************************************************************************
	void Call::SetValue(size_t index, const byte* input, size_t size)
	{
		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, size, nullptr, CheckPrimitive::Value, Direction::Set);

		// Copy the input into the stack position
		memcpy(stack, input, size);
	}

	//***************************************************************************
	void Call::SetHandle(size_t index, const Handle& value)
	{
		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, sizeof(Handle), value.Type, CheckPrimitive::Handle, Direction::Set);

		// Now copy the handle to the stack
		new (stack)Handle(value);
	}

	//***************************************************************************
	void Call::SetDelegate(size_t index, const Delegate& value)
	{
		// Get the exact function we're referencing
		Function* function = value.BoundFunction;

		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, sizeof(Delegate), function->Type, CheckPrimitive::Delegate, Direction::Set);

		// Now copy the handle to the stack
		new (stack)Delegate(value);
	}

	//***************************************************************************
	void Call::GetValue(size_t index, byte* output, size_t size)
	{
		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, size, nullptr, CheckPrimitive::Value, Direction::Get);

		// Copy the stack into the output
		memcpy(output, stack, size);
	}

	//***************************************************************************
	Handle& Call::GetHandle(size_t index)
	{
		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, sizeof(Handle), nullptr, CheckPrimitive::Handle, Direction::Get);

		// Return a reference to the stack
		return *(Handle*)stack;
	}

	//***************************************************************************
	Delegate& Call::GetDelegate(size_t index)
	{
		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, sizeof(Delegate), nullptr, CheckPrimitive::Delegate, Direction::Get);

		// Return a reference to the stack
		return *(Delegate*)stack;
	}

	//***************************************************************************
	ExecutableState* Call::GetState()
	{
		return this->Data->State;
	}

	//***************************************************************************
	byte* Call::GetStackUnchecked()
	{
		return this->Data->Frame;
	}

	//***************************************************************************
	byte* Call::GetThisUnchecked()
	{
		// Get the stack offsetted by to the 'this' handle location
		return this->Data->Frame + this->Data->CurrentFunction->Type->ThisHandleStackOffset;
	}

	//***************************************************************************
	byte* Call::GetParametersUnchecked()
	{
		// Get the stack offsetted by the size of the return (to where the parameters are)
		return this->Data->Frame + this->Data->CurrentFunction->Type->Return->GetCopyableSize();
	}

	//***************************************************************************
	byte* Call::GetParameterUnchecked(size_t parameterIndex)
	{
		// Get a reference to the parameters
		ParameterArray& parameters = this->Data->CurrentFunction->Type->Parameters;

		// Error checking for the index
		ErrorIf(parameterIndex >= parameters.size(),
			"Attempting to access an invalid parameter index (out of bounds)");

		// Return the stack offsetted by the current parameter's position
		return this->Data->Frame + parameters[parameterIndex].StackOffset;
	}

	//***************************************************************************
	byte* Call::GetReturnUnchecked()
	{
		// General error checking for our own assumptions
		ErrorIf(this->Data->CurrentFunction->Type->ReturnStackOffset != 0,
			"Unexpected stack return location (internal error)");

		// The returns always exist at the beginning
		return this->Data->Frame;
	}

	//***************************************************************************
	Function* Call::GetFunction()
	{
		return this->Data->CurrentFunction;
	}

	//***************************************************************************
	void Call::DisableParameterChecks()
	{
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoParameterChecking);
	}

	//***************************************************************************
	void Call::DisableThisChecks()
	{
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoThisChecking);
	}

	//***************************************************************************
	void Call::DisableReturnChecks()
	{
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoReturnChecking);
	}

	//***************************************************************************
	void Call::DisableParameterDestruction()
	{
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoParameterDestruction);
	}

	//***************************************************************************
	void Call::DisableThisDestruction()
	{
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoThisDestruction);
	}

	//***************************************************************************
	void Call::DisableReturnDestruction()
	{
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::NoReturnDestruction);
	}

	//***************************************************************************
	void Call::MarkAsSet(size_t index)
	{
		// Based on the type of index...
		switch (index)
		{
			// It's an index that represents the return
		case Return:
			this->MarkReturnAsSet();
			break;

			// It's an index that represents the 'this' handle
		case This:
			this->MarkThisAsSet();
			break;

			// It's an index that represents any parameter
		default:
			this->MarkParameterAsSet(index);
			break;
		}
	}

	//***************************************************************************
	void Call::MarkReturnAsSet()
	{
		// Make sure we only call this once
		ErrorIf((this->Data->Debug & CallDebug::SetReturn) != 0,
			"Attempting to set the return twice");

		// For debugging, mark that we set the return
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::SetReturn);
	}

	//***************************************************************************
	void Call::MarkThisAsSet()
	{
		// Make sure we only call this once
		ErrorIf((this->Data->Debug & CallDebug::SetThis) != 0,
			"Attempting to set the this handle twice");

		// For debugging, mark that we set the 'this' handle
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | CallDebug::SetThis);
	}

	//***************************************************************************
	void Call::MarkParameterAsSet(size_t parameterIndex)
	{
		// We have a bit for each parameter we set
		CallDebug::Enum parameterFlag = (CallDebug::Enum)(1 << parameterIndex);

		// Make sure we only call this once
		ErrorIf((this->Data->Debug & parameterFlag) != 0,
			"Attempting to set the parameter twice");

		// For debugging, mark that we set this parameter
		this->Data->Debug = (CallDebug::Enum)(this->Data->Debug | parameterFlag);
	}

	//***************************************************************************
	Call::Call(Function* function, ExecutableState* state)
	{
		// If this is call being generated for the user, then we have to push the frame
		// The virtual machine will do these steps for us when it's performing the call
		ErrorIf(function == nullptr, "Attempting to invoke a null function in Call");

		// Push a new stack frame for the function we want to invoke
		this->Data = state->PushFrame(function);
	}

	//***************************************************************************
	Call::Call(const Delegate& delegate, ExecutableState* state)
	{
		// The delegate directly stores the function to be executed on it
		Function* function = delegate.BoundFunction;
		ErrorIf(function == nullptr, "Attempting to invoke a null delegate in Call");

		// Push a new stack frame for the function we want to invoke
		this->Data = state->PushFrame(function);

		// If this is a non-static delegate
		if (function->This != nullptr)
		{
			// Set the this handle
			this->SetHandle(Call::This, delegate.ThisHandle);
		}
	}

	//***************************************************************************
	Call::Call(PerFrameData* data)
	{
		// We still need to grab the stack
		this->Data = data;

		// For calls being made by the VM, we don't care about parameters or 'this' being checked
		// We also don't want anything to be destructed
		// Having said that, we still want the return to be checked as it's set by the called
		this->Data->Debug = (CallDebug::Enum)
			(CallDebug::NoParameterChecking |
			CallDebug::NoThisChecking |
			CallDebug::NoParameterDestruction |
			CallDebug::NoThisDestruction |
			CallDebug::NoReturnDestruction);
	}

	//***************************************************************************
	Call::~Call()
	{
		//HACK WE CURRENTLY DONT HANDLE EXCEPTIONS
		ZilchTodo("Make sure we handle exceptions here (could have thrown before returning)");

		// For convenience, get the current function
		Function* function = this->Data->CurrentFunction;
		ExecutableState* state = this->Data->State;

		// Get the stack offset that we're at
		size_t stackOffset = (size_t)(this->Data->Frame - this->Data->State->Stack);

		// Grab the parameters of the function type
		ParameterArray& parameters = function->Type->Parameters;

		// If parameter destruction is enabled...
		if ((this->Data->Debug & CallDebug::NoParameterDestruction) == 0)
		{
			// Loop through all the parameters and destruct anything that needs to be destructed
			for (size_t i = 0; i < parameters.size(); ++i)
			{
				// Get the current parameter
				DelegateParameter& parameter = parameters[i];

				// Get the stack offset of that parameter
				byte* stack = this->Data->Frame + parameter.StackOffset;

				// Release / destruct that parameter
				parameter.ParameterType->GenericDestruct(stack);
			}
		}

		// If 'this' handle destruction is enabled...
		if ((this->Data->Debug & CallDebug::NoThisDestruction) == 0)
		{
			// If this is an instance (non-static) function
			if (function->This != nullptr)
			{
				// Get the stack offset of the this handle
				byte* thisStack = this->Data->Frame + function->Type->ThisHandleStackOffset;

				// Destroy the this handle
				((Handle*)thisStack)->~Handle();
			}
		}

		// If we're ignoring outputs (return)
		if ((this->Data->Debug & CallDebug::NoReturnDestruction) == 0)
		{
			// Get the core library just for the void type
			Core& core = Core::GetInstance();

			// As long as our return isn't void...
			if (function->Type->Return != core.VoidType)
			{
				// Get the return stack frame (should be right at the front)
				byte* returnStack = this->Data->Frame;

				// Verify that return position is always at the front
				ErrorIf(function->Type->ReturnStackOffset != 0,
					"Internal error, the return stack position was not 0");

				// Finally, release/destruct the return value
				function->Type->Return->GenericDestruct(returnStack);
			}
		}

		// If the call was invoked, we need to pop
		if (this->Data->Debug & CallDebug::Invoked)
		{
			// If a function-step-out callback is set
			FunctionStepDelegate& outCallback = state->ExitFunctionCallback;
			if (outCallback.Callback != nullptr)
			{
				// Get the location of this opcode
				CodeLocation* location = function->GetCodeLocationFromProgramCounter(this->Data->ProgramCounter);

				// Invoke the callback
				outCallback.Callback(state, function, stackOffset, location, outCallback.UserData);
			}
		}

		// Pop all frames up to our own
		// Note: This is very important since it's possible that other frames may exist that have no Call owner
		// If an exception gets thrown between PrepForCall / FunctionCall opcodes, we will have an extra frame on the stack
		PerFrameData* poppedFrame = nullptr;
		do
		{
			// Pop the frame and get back what we just popped
			poppedFrame = state->PopFrame();
		}
		// Loop until we pop our own
		while (poppedFrame != this->Data);

		// Clear out our data, just for safety
		this->Data = nullptr;
	}

	//***************************************************************************
	void Call::Invoke(ExceptionReport& report)
	{
		// If this stack frame needed to throw any exceptions (such as stack overflow or maximum recursion depth...)
		if (this->Data->AttemptThrowStackExceptions(report))
		{
			// Early out, there's no need to do anything else from this call
			return;
		}

		// Make sure we're not doing a call inside a call
		// At some point in time a code refactor happened that introduced the PerFrameData* onto the Call object
		// The scary part about this was that we were still getting the topFrame using 'state->StackFrames.back()',
		// instead of just accessing the PerFrameData* we stored (currently called Data), not sure why this was
		// as maybe it was just missed code in a cleanup, but if we ever falsely get this assert this may be why!
		ErrorIf(this->Data != this->Data->State->StackFrames.back(),
			"The function being invoked should always be the top of the frame (it is illegal to run a Call inside another Call)");

		// Store the top frame locally for efficiency
		PerFrameData* topFrame = this->Data;

		// Check if any exceptions are left on the state
		ErrorIf(report.HasThrownExceptions(),
			"Attempting to call another function when there are exceptions present in the report");

		// Make sure we don't call this twice
		ErrorIf((topFrame->Debug & CallDebug::Invoked) != 0,
			"Attempting to invoke the function twice via the same call");

		// Make sure the 'this' handle was set
		ErrorIf(!(topFrame->Debug & CallDebug::NoThisChecking) &&
			topFrame->CurrentFunction->This != nullptr &&
			(topFrame->Debug & CallDebug::SetThis) == 0,
			"The 'this' handle was not set before invoking the function");

		// Make a bit mask that includes 1s for all parameters that we have
		CallDebug::Enum allParameters = (CallDebug::Enum)((1 << topFrame->CurrentFunction->Type->Parameters.size()) - 1);

		// Make sure all parameters have been set
		ErrorIf(!(topFrame->Debug & CallDebug::NoParameterChecking) &&
			allParameters != (topFrame->Debug & allParameters),
			"Not all of the parameters were set");

		// Set the exception reporter on the top frame
		topFrame->Report = &report;

		// Get a reference to the state for convenience
		ExecutableState* state = topFrame->State;

		// Also grab the current function we're executing
		Function* function = topFrame->CurrentFunction;
		size_t stackOffset = (size_t)(topFrame->Frame - state->Stack);

		// If this function is a non-static function
		if (function->This != nullptr)
		{
			// We need to check to see if the 'this' handle is valid
			// Technically this is slower and maybe we should only do it for functions that are not the VM function
			// It does make it a lot safer (so people writing external functions can always assume 'this' is valid)
			Handle& thisHandle = *(Handle*)(topFrame->Frame + function->This->Local);

			// Dereference the handle and get a pointer back (may be null)
			byte* thisData = thisHandle.Dereference();

			// If the 'this' handle was actually null...
			if (thisData == nullptr)
			{
				// Throw the null reference exception and jump out
				state->ThrowNullReferenceException(report, "Attempted to call a member function on a null object");

				// We didn't even invoke the function, don't destruct the return type
				this->DisableReturnDestruction();
				return;
			}
		}

		// If a function-step-in callback is set
		FunctionStepDelegate& inCallback = state->EnterFunctionCallback;
		if (inCallback.Callback != nullptr)
		{
			// Get the location of this opcode
			CodeLocation* location = function->GetCodeLocationFromProgramCounter(0);

			// Invoke the callback
			inCallback.Callback(state, function, stackOffset, location, inCallback.UserData);
		}

		// Set the flag that says we've invoked the function
		topFrame->Debug = (CallDebug::Enum)(topFrame->Debug | CallDebug::Invoked);

		// Get the bound function we're going to run
		BoundFn boundFunction = function->BoundFunction;

		// If the function is not our own...
		if (boundFunction != VirtualMachine::ExecuteNext)
		{
			// We need to let any debugging/exceptions know that we're
			// entering a C++ bound function (for building the call stack)
			topFrame->ProgramCounter = ProgramCounterNative;
		}

		// Set the thread local calling state to the current state invoking
		// this function (so the function always knows the caller!)
		ExecutableState* lastCallingState = ExecutableState::CallingState;
		ExecutableState::CallingState = state;

		// Actually execute the function
		boundFunction(*this, report);

		// Get whether the return value was set
		bool returnWasSet = (this->Data->Debug & CallDebug::SetReturn) != 0;

		// If we threw any exceptions and the return value was not set, we will want to disable return destruction
		if (report.HasThrownExceptions() && returnWasSet == false)
			this->DisableReturnDestruction();

		// Reset the calling state back to the last one
		ExecutableState::CallingState = lastCallingState;

		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// Make sure the return value was set (we can ignore this if an exception gets thrown)
		ErrorIf(!(this->Data->Debug & CallDebug::NoReturnChecking) &&
			(this->Data->Debug & CallDebug::SetReturn) == 0 &&
			!report.HasThrownExceptions() &&
			Type::IsSame(function->Type->Return, core.VoidType) == false,
			"The return value was not set after a call (ignored when exceptions are thrown)");
	}

	//***************************************************************************
	template <>
	void Call::Set<Any>(size_t index, const Any& value)
	{
		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, sizeof(Any), ZilchTypeId(Any), CheckPrimitive::Any, Direction::Get);

		// Write the value to the stack
		new (stack)Any(value);
	}

	//***************************************************************************
	template <>
	Any* Call::Get<Any*>(size_t index)
	{
		// Get the stack location and perform checks
		byte* stack = this->GetChecked(index, sizeof(Any), ZilchTypeId(Any), CheckPrimitive::Any, Direction::Get);

		// Read the value from the stack and return it (or convert it)
		return (Any*)stack;
	}

	//***************************************************************************
	template <>       Any  Call::Get<      Any >(size_t index) { return *Get<Any*>(index); }
	template <>       Any& Call::Get<      Any&>(size_t index) { return *Get<Any*>(index); }
	template <> const Any* Call::Get<const Any*>(size_t index) { return  Get<Any*>(index); }
	template <> const Any& Call::Get<const Any&>(size_t index) { return *Get<Any*>(index); }

	//***************************************************************************
	template <>
	Handle* Call::Get<Handle*>(size_t index)
	{
		return &this->GetHandle(index);
	}

	//***************************************************************************
	template <>       Handle  Call::Get<      Handle >(size_t index) { return *Get<Handle*>(index); }
	template <>       Handle& Call::Get<      Handle&>(size_t index) { return *Get<Handle*>(index); }
	template <> const Handle* Call::Get<const Handle*>(size_t index) { return  Get<Handle*>(index); }
	template <> const Handle& Call::Get<const Handle&>(size_t index) { return *Get<Handle*>(index); }

	//***************************************************************************
	template <>
	Delegate* Call::Get<Delegate*>(size_t index)
	{
		return &this->GetDelegate(index);
	}

	//***************************************************************************
	template <>       Delegate  Call::Get<      Delegate >(size_t index) { return *Get<Delegate*>(index); }
	template <>       Delegate& Call::Get<      Delegate&>(size_t index) { return *Get<Delegate*>(index); }
	template <> const Delegate* Call::Get<const Delegate*>(size_t index) { return  Get<Delegate*>(index); }
	template <> const Delegate& Call::Get<const Delegate&>(size_t index) { return *Get<Delegate*>(index); }
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	CodeFormat::CodeFormat() :
		IsTabs(false),
		Identation(2),
		StripWhiteSpaceFromEmptyLines(false),
		IndentGlobalDefault(IndentStyle::Indented),
		IndentClassContents(IndentStyle::UseGlobalDefault),
		IndentEnumContents(IndentStyle::UseGlobalDefault),
		IndentFunctionContents(IndentStyle::UseGlobalDefault),
		IndentPropertyContents(IndentStyle::UseGlobalDefault),
		IndentGetSetContents(IndentStyle::UseGlobalDefault),
		IndentScopeContents(IndentStyle::UseGlobalDefault),
		LineStyleGlobalDefaultScope(LineStyle::NextLine),
		LineStyleClassScope(LineStyle::UseGlobalDefault),
		LineStyleEnumScope(LineStyle::UseGlobalDefault),
		LineStyleFunctionScope(LineStyle::UseGlobalDefault),
		LineStylePropertyScope(LineStyle::UseGlobalDefault),
		LineStyleGetSetScope(LineStyle::UseGlobalDefault),
		LineStyleBlockScope(LineStyle::UseGlobalDefault),
		LineStyleInitializerList(LineStyle::SameLine),
		SpaceStyleGlobalDefaultColon(SpaceStyle::BeforeAndAfter),
		SpaceStyleInheritanceColon(SpaceStyle::UseGlobalDefault),
		SpaceStyleInitializerListColon(SpaceStyle::UseGlobalDefault),
		SpaceStyleTypeColon(SpaceStyle::UseGlobalDefault),
		SpaceStyleNamedArgumentColon(SpaceStyle::UseGlobalDefault),
		SpaceStyleGlobalDefaultComma(SpaceStyle::After),
		SpaceStyleInheritanceComma(SpaceStyle::UseGlobalDefault),
		SpaceStyleInitializerListComma(SpaceStyle::UseGlobalDefault),
		SpaceStyleFunctionDefinitionParameterComma(SpaceStyle::UseGlobalDefault),
		SpaceStyleFunctionCallParameterComma(SpaceStyle::UseGlobalDefault),
		SpaceStyleTemplateDefinitionParameterComma(SpaceStyle::UseGlobalDefault),
		SpaceStyleTemplateInstantiationParameterComma(SpaceStyle::UseGlobalDefault),
		SpaceAfterComment(true)
	{
	}

	//***************************************************************************
	ZilchCodeBuilder::ZilchCodeBuilder() :
		Indentation(0),
		Line(1)
	{
	}

	//***************************************************************************
	void ZilchCodeBuilder::WriteKeywordOrSymbol(Grammar::Enum token)
	{
		this->Write(Grammar::GetKeywordOrSymbol(token));
	}

	//***************************************************************************
	void ZilchCodeBuilder::WriteKeywordOrSymbolSpaceStyle(Grammar::Enum token, SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault)
	{
		// This tells us if we want to place spaces before or after (or around) the token
		SpaceStyle::Enum spaceStyle = GetSpaceStyle(specific, globalDefault);

		// Prepend a space if we require it
		if (spaceStyle == SpaceStyle::BeforeAndAfter || spaceStyle == SpaceStyle::Before)
		{
			this->WriteSpace();
		}

		this->WriteKeywordOrSymbol(token);

		// Append a space if we require it
		if (spaceStyle == SpaceStyle::BeforeAndAfter || spaceStyle == SpaceStyle::After)
		{
			this->WriteSpace();
		}
	}

	//***************************************************************************
	void ZilchCodeBuilder::BeginScope(ScopeType::Enum scope)
	{
		// Scopes are responsible for starting their own line, and the next
		// For that matter, any kind of statement or thing that belongs on
		// its own line is repsonsible for emitting its own line before

		// Technically these should always be set as long as the 'scope' value is valid, however we need
		// to initialize them to defaults so the compiler doesn't complain about 'potentially uninitialized' values
		LineStyle::Enum specificLineStyle = LineStyle::NextLine;
		IndentStyle::Enum specificIndentStyle = IndentStyle::Indented;

		// Depending on the scope type we're adding, we could have different rules
		switch (scope)
		{
			// We're adding scope to a class (contains properties, fields, methods, etc)
		case ScopeType::Class:
			specificLineStyle = this->Format.LineStyleClassScope;
			specificIndentStyle = this->Format.IndentClassContents;
			break;
			// We're adding scope to a class (contains properties, fields, methods, etc)
		case ScopeType::Enumeration:
			specificLineStyle = this->Format.LineStyleEnumScope;
			specificIndentStyle = this->Format.IndentEnumContents;
			break;
			// We're adding scope to a function's statements
		case ScopeType::Function:
			specificLineStyle = this->Format.LineStyleFunctionScope;
			specificIndentStyle = this->Format.IndentFunctionContents;
			break;
			// We're adding scope to a property
		case ScopeType::Property:
			specificLineStyle = this->Format.LineStylePropertyScope;
			specificIndentStyle = this->Format.IndentPropertyContents;
			break;
			// We're adding scope to a get/set
		case ScopeType::GetSet:
			specificLineStyle = this->Format.LineStyleGetSetScope;
			specificIndentStyle = this->Format.IndentGetSetContents;
			break;
			// We're adding scope to any other type of block (if statement, while loop, etc)
		case ScopeType::Block:
			specificLineStyle = this->Format.LineStyleBlockScope;
			specificIndentStyle = this->Format.IndentScopeContents;
			break;
		}

		// For every situation, we could have a specific line or indent style, or we could fall back to the global
		LineStyle::Enum lineStyle = GetLineStyle(specificLineStyle, this->Format.LineStyleGlobalDefaultScope);
		IndentStyle::Enum indentStyle = GetIndentStyle(specificIndentStyle, this->Format.IndentGlobalDefault);

		// It would be nice if scope was just a simple integer, however, because some styles require that certain
		// scopes are indented, and others are not, and in some the braces themselves are indented...
		// We need to push this structure into a stack instead (a stack of scopes)
		ScopeStyle scopeStyle;
		scopeStyle.InnardsIndented = (indentStyle == IndentStyle::Indented);

		// Based on the line style...
		switch (lineStyle)
		{
		case LineStyle::NextLine:
			// Just write out a standard indented line
			this->WriteLineIndented();
			break;

		case LineStyle::NextLineIndented:
			// Just write out a standard indented line with one extra indent
			this->WriteLineIndented();
			this->WriteIndent();

			// In this case, it means that even the ending brace needs to be indented...
			scopeStyle.BracesIndented = true;
			break;

		case LineStyle::SameLine:
			// We always write out a space (this should probably become an option in the future)
			this->Write(" ");
			break;
		}

		// Now write out the 'begin scope' token, typically '{'
		this->WriteKeywordOrSymbol(Grammar::BeginScope);

		// Add the scope to the scope stack so that when we 'EndScope' / pop it off, we know what to do
		this->Scopes.push_back(scopeStyle);

		// If we're indenting the inside, then increase the indentation for the next line
		if (scopeStyle.InnardsIndented)
		{
			++this->Indentation;
		}

		// If the user also requested the braces be indented, our standard behavior is to indent the innards yet again
		if (scopeStyle.BracesIndented)
		{
			++this->Indentation;
		}
	}

	//***************************************************************************
	void ZilchCodeBuilder::EndScope()
	{
		// Make sure we have scopes to end, and we didn't call this one too many times
		ErrorIf(this->Scopes.empty(),
			"Attempting to pop a scope when there we're no scopes present");

		// Get the latest scope
		ScopeStyle& scope = this->Scopes.back();

		// If it's innards were indented, decrease the indent
		if (scope.InnardsIndented)
		{
			--this->Indentation;
		}

		// Note: When emitting anything, we always assume we're on the last line, which means we must emit our own line
		// Note: If you look in BeginScope, having 'BracesIndented' will actually increase the tabbing again
		// At this point in time, we've only decreased the tabbing due to 'InnardsIndented', which means
		// that this line we emit will still have tabbing for braces, which is good for when we emit the end brace
		this->WriteLineIndented();

		// If it's braces were indented, decrease the indent again (see 2nd note above and BeginScope)
		if (scope.BracesIndented)
		{
			--this->Indentation;
		}

		// Now write out the 'end scope' token, typically '}'
		this->WriteKeywordOrSymbol(Grammar::EndScope);

		// We've officially finished this scope off!
		this->Scopes.pop_back();
	}

	//**************************************************************************
	void ZilchCodeBuilder::WriteLine()
	{
		// Invoke the base so we just write a standard newline
		StringBuilderExtended::WriteLine();

		// Also increment our line count
		++this->Line;
	}

	//**************************************************************************
	void ZilchCodeBuilder::WriteLineIndented()
	{
		// Create a new line
		this->WriteLine();

		// Write indents up to the indentation level we're at
		for (size_t i = 0; i < this->Indentation; ++i)
		{
			this->WriteIndent();
		}
	}

	//**************************************************************************
	void ZilchCodeBuilder::WriteLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault)
	{
		// Get the resulting line style
		LineStyle::Enum lineStyle = GetLineStyle(specific, globalDefault);

		// Based on the line style...
		switch (lineStyle)
		{
		case LineStyle::NextLine:
			// Just write out a standard indented line
			this->WriteLineIndented();
			break;

		case LineStyle::NextLineIndented:
			// Just write out a standard indented line with one extra indent
			this->WriteLineIndented();
			this->WriteIndent();
			break;

		case LineStyle::SameLine:
			// We always write out a space (this should probably become an option in the future)
			this->Write(" ");
			break;
		}
	}

	//***************************************************************************
	void ZilchCodeBuilder::WriteIndent()
	{
		// We make constants so we don't keep allocating this
		static const String Tab("\t");
		static const String Space(" ");

		// If we use tabs to format, then indent with tabs
		if (this->Format.IsTabs)
		{
			this->Repeat(this->Format.Identation, Tab);
		}
		else
		{
			this->Repeat(this->Format.Identation, Space);
		}
	}

	//***************************************************************************
	void ZilchCodeBuilder::WriteSpace()
	{
		this->Write(" ");
	}

	//***************************************************************************
	String ZilchCodeBuilder::ToString()
	{
		//HACK need to run post pass to trim trailing space / empty lines
		return StringBuilderExtended::ToString();
	}

	//***************************************************************************
	size_t ZilchCodeBuilder::GetLine()
	{
		return this->Line;
	}

	//***************************************************************************
	ZilchCodeBuilder::ScopeStyle::ScopeStyle() :
		BracesIndented(false),
		InnardsIndented(false)
	{
	}

	//***************************************************************************
	ScopeLastNode::ScopeLastNode() :
		LastNode(nullptr),
		AssociatedScope(nullptr)
	{
	}

	//***************************************************************************
	CodeFormatterContext::CodeFormatterContext()
	{
	}

	//***************************************************************************
	LineStyle::Enum ZilchCodeBuilder::GetLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault)
	{
		ErrorIf(globalDefault == LineStyle::UseGlobalDefault,
			"The global default cannot be set to 'LineStyle::UseGlobalDefault'");

		// Return the specific line style as long as it's not falling back on the default
		if (specific != LineStyle::UseGlobalDefault)
		{
			return specific;
		}

		// Return the default line format
		return globalDefault;
	}

	//***************************************************************************
	IndentStyle::Enum ZilchCodeBuilder::GetIndentStyle(IndentStyle::Enum specific, IndentStyle::Enum globalDefault)
	{
		ErrorIf(globalDefault == IndentStyle::UseGlobalDefault,
			"The global default cannot be set to 'IndentStyle::UseGlobalDefault'");

		// Return the specific indent style as long as it's not falling back on the default
		if (specific != IndentStyle::UseGlobalDefault)
		{
			return specific;
		}

		// Return the default indent format
		return globalDefault;
	}

	//***************************************************************************
	SpaceStyle::Enum ZilchCodeBuilder::GetSpaceStyle(SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault)
	{
		ErrorIf(globalDefault == IndentStyle::UseGlobalDefault,
			"The global default cannot be set to 'SpaceStyle::UseGlobalDefault'");

		// Return the specific space style as long as it's not falling back on the default
		if (specific != SpaceStyle::UseGlobalDefault)
		{
			return specific;
		}

		// Return the default space format
		return globalDefault;
	}

	//***************************************************************************
	CodeFormatter::CodeFormatter()
	{
		this->Walker.RegisterNonLeafBase(&CodeFormatter::FormatCommentsAndLines);

		this->Walker.Register(&CodeFormatter::FormatBinaryOperator);
		this->Walker.Register(&CodeFormatter::FormatUnaryOperator);
		this->Walker.RegisterDerived<PropertyDelegateOperatorNode>(&CodeFormatter::FormatUnaryOperator);
		this->Walker.Register(&CodeFormatter::FormatTypeCast);
		this->Walker.Register(&CodeFormatter::FormatIndexerCall);
		this->Walker.Register(&CodeFormatter::FormatFunctionCall);
		this->Walker.Register(&CodeFormatter::FormatMemberAccess);
		this->Walker.Register(&CodeFormatter::FormatTypeMemberAccess);
		this->Walker.Register(&CodeFormatter::FormatCreationCall);
		this->Walker.Register(&CodeFormatter::FormatLocalVariable);
		this->Walker.Register(&CodeFormatter::FormatParameter);
		this->Walker.Register(&CodeFormatter::FormatMemberVariable);
		this->Walker.Register(&CodeFormatter::FormatValue);
		this->Walker.Register(&CodeFormatter::FormatStringInterpolant);
		this->Walker.Register(&CodeFormatter::FormatDelete);
		this->Walker.Register(&CodeFormatter::FormatReturn);
		this->Walker.Register(&CodeFormatter::FormatIf);
		this->Walker.Register(&CodeFormatter::FormatSendsEvent);
		this->Walker.Register(&CodeFormatter::FormatBreak);
		this->Walker.Register(&CodeFormatter::FormatDebugBreak);
		this->Walker.Register(&CodeFormatter::FormatContinue);
		this->Walker.Register(&CodeFormatter::FormatLoop);
		this->Walker.Register(&CodeFormatter::FormatWhile);
		this->Walker.Register(&CodeFormatter::FormatDoWhile);
		this->Walker.Register(&CodeFormatter::FormatFor);
		// this->Walker.RegisterDerived<ForEachNode>(&CodeFormatter::FormatFor);
		this->Walker.Register(&CodeFormatter::FormatForEach);
		this->Walker.Register(&CodeFormatter::FormatFunction);
		/*Initializer*/
		this->Walker.Register(&CodeFormatter::FormatConstructor);
		this->Walker.Register(&CodeFormatter::FormatDestructor);
		this->Walker.Register(&CodeFormatter::FormatClass);
		//this->Walker.Register(&CodeFormatter::FormatTypeDefine);
		this->Walker.RegisterDerived<LocalVariableReferenceNode>(&CodeFormatter::FormatValue);
		this->Walker.Register(&CodeFormatter::FormatThrow);
		this->Walker.Register(&CodeFormatter::FormatTypeId);
		this->Walker.Register(&CodeFormatter::FormatEnumValue);
		this->Walker.Register(&CodeFormatter::FormatEnum);

		// This must come after all statements and expressions are registered
		this->Walker.RegisterNonLeafBase(&CodeFormatter::FormatStatement);
	}

	//***************************************************************************
	String CodeFormatter::FormatTree(SyntaxTree& syntaxTree, const CodeFormat& format)
	{
		// Create the context and setup the format rules
		CodeFormatterContext context;
		context.Builder.Format = format;

		// Get the nodes in the order they were declared
		NodeList<SyntaxNode>& inOrderNodes = syntaxTree.Root->NonTraversedNonOwnedNodesInOrder;

		// Walk the given syntax tree and emit code for each type of node
		for (size_t i = 0; i < inOrderNodes.size(); ++i)
		{
			// Traverse the current node
			SyntaxNode* childNode = inOrderNodes[i];
			this->Walker.Walk(this, childNode, &context);
		}

		// Finally compact the string builder into a single string
		return context.Builder.ToString();
	}

	//***************************************************************************
	bool CodeFormatter::IsDirectlyWithinScope(SyntaxNode* node)
	{
		// Note: This should be solved with interfaces or virtual functions
		if (TypeBinding::DynamicCast<RootNode*>(node->Parent) != nullptr)
			return true;

		if (TypeBinding::DynamicCast<ClassNode*>(node->Parent) != nullptr)
			return true;

		if (TypeBinding::DynamicCast<EnumNode*>(node->Parent) != nullptr)
			return true;

		return StatementNode::IsNodeUsedAsStatement(node);
	}

	//***************************************************************************
	size_t CodeFormatter::CountAttributes(SyntaxNode* node)
	{
		// Note: This should be solved with interfaces or virtual functions
		if (LocalVariableNode* attributeParent = TypeBinding::DynamicCast<LocalVariableNode*>(node))
		{
			return attributeParent->Attributes.size();
		}

		if (MemberVariableNode* attributeParent = TypeBinding::DynamicCast<MemberVariableNode*>(node))
		{
			return attributeParent->Attributes.size();
		}

		if (GenericFunctionNode* attributeParent = TypeBinding::DynamicCast<GenericFunctionNode*>(node))
		{
			return attributeParent->Attributes.size();
		}

		if (ClassNode* attributeParent = TypeBinding::DynamicCast<ClassNode*>(node))
		{
			return attributeParent->Attributes.size();
		}

		if (EnumNode* attributeParent = TypeBinding::DynamicCast<EnumNode*>(node))
		{
			return attributeParent->Attributes.size();
		}

		return 0;
	}

	//***************************************************************************
	void CodeFormatter::FormatCommentsAndLines(SyntaxNode*& node, CodeFormatterContext* context)
	{
		// This will always run, even if other handlers will handle it

		ZilchCodeBuilder& builder = context->Builder;

		if (IsDirectlyWithinScope(node))
		{
			bool scopeFound = false;

			for (int i = (int)(context->FormatScopes.size() - 1); i >= 0; --i)
			{
				ScopeLastNode& scope = context->FormatScopes[i];

				if (scope.AssociatedScope == node->Parent)
				{
					scopeFound = true;
					break;
				}
			}

			ScopeLastNode* foundScope = nullptr;

			if (scopeFound)
			{
				while (context->FormatScopes.back().AssociatedScope != node->Parent)
				{
					context->FormatScopes.pop_back();
				}

				foundScope = &context->FormatScopes.back();
			}
			else
			{
				foundScope = &context->FormatScopes.push_back();
				foundScope->AssociatedScope = node->Parent;
			}

			int lineDifference = 0;

			if (foundScope->LastNode != nullptr)
			{
				lineDifference = (int)(node->Location.StartLine - foundScope->LastNode->Location.EndLine);
			}

			lineDifference -= (int)node->Comments.size();
			lineDifference -= (int)CountAttributes(node);

			// Since we will always emit one line, we skip one
			for (int i = 1; i < lineDifference; ++i)
			{
				builder.WriteLineIndented();
			}

			foundScope->LastNode = node;
		}

		//if (TypeBinding::DynamicCast<ClassNode*>(node->Parent) != nullptr)
		//{
		//  
		//  if (context->LastMember != nullptr)
		//  {
		//    
		//  }
		//}
		//else if (TypeBinding::DynamicCast<RootNode*>(node->Parent) != nullptr)
		//{
		//  if (context->LastClassOrEnum != nullptr)
		//  {
		//    lineDifference = (int)(node->Location.StartLine - context->LastClassOrEnum->Location.EndLine);
		//  }
		//}
		//else if (StatementNode::IsNodeUsedAsStatement(node))
		//{
		//  if (context->LastStatement != nullptr)
		//  {
		//    lineDifference = node->Location.StartLine - context->LastStatement->Location.EndLine;
		//  }
		//}

		for (size_t i = 0; i < node->Comments.size(); ++i)
		{
			String& comment = node->Comments[i];

			builder.WriteLineIndented();

			builder.WriteKeywordOrSymbol(Grammar::CommentLine);

			size_t trailingSpace = 0;
			StringRange range = comment.all();
			while (range.empty() == false)
			{
				size_t character = range.front();
				range.popFront();

				if (character == ' ')
					++trailingSpace;
				else
					break;
			}

			range = comment.all();

			if (builder.Format.SpaceAfterComment)
			{
				if (trailingSpace == 0)
				{
					builder.WriteSpace();
				}
			}
			else
			{
				if (trailingSpace == 1)
				{
					++range.begin;
				}
			}

			builder.Write(range);
		}

		if (StatementNode::IsNodeUsedAsStatement(node))
		{
			// The only exception we have to the rule of 'you must write a line before you write yourself'
			// is in expressions, which we don't know if they are going to be used as an expression or a statement
			// Therefore we handle newlines before expressions here
			builder.WriteLineIndented();
		}

		// If someone else ends up handling the children, that is fine
		// but we need to explicitly say that we didn't handle any children
		context->Flags = WalkerFlags::ChildrenNotHandled;
	}

	//***************************************************************************
	void CodeFormatter::FormatDelete(DeleteNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		builder.WriteKeywordOrSymbol(Grammar::Delete);
		builder.WriteSpace();
		context->Walker->Walk(this, node->DeletedObject, context);
	}

	//***************************************************************************
	void CodeFormatter::FormatBreak(BreakNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteKeywordOrSymbol(Grammar::Break);
	}

	//***************************************************************************
	void CodeFormatter::FormatDebugBreak(DebugBreakNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteKeywordOrSymbol(Grammar::Debug);
		builder.WriteSpace();
		builder.WriteKeywordOrSymbol(Grammar::Break);
	}

	//***************************************************************************
	void CodeFormatter::FormatThrow(ThrowNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteKeywordOrSymbol(Grammar::Throw);
		builder.WriteSpace();
		context->Walker->Walk(this, node->Exception, context);
	}

	//***************************************************************************
	void CodeFormatter::FormatContinue(ContinueNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteKeywordOrSymbol(Grammar::Continue);
	}

	//***************************************************************************
	void CodeFormatter::FormatForEach(ForEachNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteKeywordOrSymbol(Grammar::ForEach);

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);

		if (node->NonTraversedVariable != nullptr)
		{
			// We don't want to do the standard walk here, because it would treat it as a statement!
			this->FormatLocalVariable(node->NonTraversedVariable, context);
		}

		builder.WriteSpace();
		builder.WriteKeywordOrSymbol(Grammar::In);
		builder.WriteSpace();

		if (node->NonTraversedRange != nullptr)
		{
			context->Walker->Walk(this, node->NonTraversedRange, context);
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

		builder.BeginScope(ScopeType::Block);
		context->Walker->Walk(this, node->Statements, context);
		builder.EndScope();
	}

	//***************************************************************************
	void CodeFormatter::FormatFor(ForNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteKeywordOrSymbol(Grammar::For);

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);

		if (node->Initialization != nullptr)
		{
			context->Walker->Walk(this, node->Initialization, context);
		}

		if (node->ValueVariable != nullptr)
		{
			// We don't want to do the standard walk here, because it would treat it as a statement!
			this->FormatLocalVariable(node->ValueVariable, context);
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::StatementSeparator, SpaceStyle::UseGlobalDefault, SpaceStyle::After);

		if (node->Condition != nullptr)
		{
			context->Walker->Walk(this, node->Condition, context);
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::StatementSeparator, SpaceStyle::UseGlobalDefault, SpaceStyle::After);

		if (node->Iterator != nullptr)
		{
			context->Walker->Walk(this, node->Iterator, context);
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

		builder.BeginScope(ScopeType::Block);
		context->Walker->Walk(this, node->Statements, context);
		builder.EndScope();
	}

	//***************************************************************************
	void CodeFormatter::FormatDoWhile(DoWhileNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		builder.WriteKeywordOrSymbol(Grammar::Do);

		builder.BeginScope(ScopeType::Block);
		context->Walker->Walk(this, node->Statements, context);
		builder.EndScope();

		// HACK, may need line style here...
		builder.WriteLineIndented();
		builder.WriteKeywordOrSymbol(Grammar::While);

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);
		context->Walker->Walk(this, node->Condition, context);
		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
	}

	//***************************************************************************
	void CodeFormatter::FormatLoop(LoopNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		builder.WriteKeywordOrSymbol(Grammar::Loop);
		builder.BeginScope(ScopeType::Block);
		context->Walker->Walk(this, node->Statements, context);
		builder.EndScope();
	}

	//***************************************************************************
	void CodeFormatter::FormatWhile(WhileNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		builder.WriteKeywordOrSymbol(Grammar::While);

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);
		context->Walker->Walk(this, node->Condition, context);
		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

		builder.BeginScope(ScopeType::Block);
		context->Walker->Walk(this, node->Statements, context);
		builder.EndScope();
	}

	//***************************************************************************
	void CodeFormatter::FormatIf(IfNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		if (node->IsFirstPart == false)
		{
			builder.WriteKeywordOrSymbol(Grammar::Else);
		}

		if (node->Condition != nullptr)
		{
			if (node->IsFirstPart == false)
			{
				builder.WriteSpace();
			}

			builder.WriteKeywordOrSymbol(Grammar::If);
			// HACK, this needs a space style!
			builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::Before);
			context->Walker->Walk(this, node->Condition, context);
			// HACK, this needs a space style!
			builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
		}

		builder.BeginScope(ScopeType::Block);
		context->Walker->Walk(this, node->Statements, context);
		builder.EndScope();
	}

	//***************************************************************************
	void CodeFormatter::FormatReturn(ReturnNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		builder.WriteKeywordOrSymbol(Grammar::Return);

		if (node->ReturnValue != nullptr)
		{
			builder.WriteSpace();
			context->Walker->Walk(this, node->ReturnValue, context);
		}
	}

	//***************************************************************************
	void CodeFormatter::FormatTypeId(TypeIdNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteKeywordOrSymbol(Grammar::Typeid);

		// HACK, this needs a space style!
		// NOTE: Probably the same space style as function calling!
		builder.WriteKeywordOrSymbol(Grammar::BeginFunctionCall);

		if (node->Value != nullptr)
		{
			context->Walker->Walk(this, node->Value, context);
		}
		else
		{
			builder.Write(node->CompileTimeSyntaxType->ToString());
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbol(Grammar::EndFunctionCall);
	}

	//***************************************************************************
	void CodeFormatter::FormatStringInterpolant(StringInterpolantNode*& node, CodeFormatterContext* context)
	{
		// The string interpolant doesn't really need to do anything,
		// just walk it's children (which are expressions and string literals)
		ZilchCodeBuilder& builder = context->Builder;
		context->Walker->GenericWalkChildren(this, node, context);
	}

	//***************************************************************************
	void CodeFormatter::FormatValue(ValueNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.Write(node->Value.Token);
	}

	//***************************************************************************
	void CodeFormatter::FormatUnaryOperator(UnaryOperatorNode*& node, CodeFormatterContext* context)
	{
		// Note: Our formatter makes the assumption that all unary operators are to the left
		ZilchCodeBuilder& builder = context->Builder;

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(node->Operator->TokenId, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
		context->Walker->Walk(this, node->Operand, context);
	}

	//***************************************************************************
	void CodeFormatter::FormatTypeCast(TypeCastNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		context->Walker->Walk(this, node->Operand, context);

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::As, SpaceStyle::UseGlobalDefault, SpaceStyle::BeforeAndAfter);

		builder.Write(node->Type->ToString());
	}

	//***************************************************************************
	void CodeFormatter::FormatIndexerCall(IndexerCallNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		context->Walker->Walk(this, node->LeftOperand, context);

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginIndex, SpaceStyle::UseGlobalDefault, SpaceStyle::None);

		for (size_t i = 0; i < node->Arguments.size(); ++i)
		{
			ExpressionNode* argument = node->Arguments[i];

			context->Walker->Walk(this, argument, context);

			bool isNotLast = (i != (node->Arguments.size() - 1));
			if (isNotLast)
			{
				// HACK, this needs a space style!
				builder.WriteKeywordOrSymbolSpaceStyle(Grammar::ArgumentSeparator, SpaceStyle::UseGlobalDefault, builder.Format.SpaceStyleGlobalDefaultComma);
			}
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndIndex, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
	}

	//***************************************************************************
	void CodeFormatter::FormatBinaryOperator(BinaryOperatorNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		// We only need a grouping operator if our parent is another binary operator with a higher precedence
		bool needsGroup = false;

		BinaryOperatorNode* parentBinOp = TypeBinding::DynamicCast<BinaryOperatorNode*>(node->Parent);
		if (parentBinOp != nullptr)
		{
			Shared& shared = Shared::GetInstance();

			UntypedOperator ourPrecedence = shared.GetOperatorPrecedence(node->Operator->TokenId, OperatorArity::Binary);
			UntypedOperator parentPrecedence = shared.GetOperatorPrecedence(parentBinOp->Operator->TokenId, OperatorArity::Binary);

			// If the parent has a higher precedence, then we need to wrap ourselves in a group
			// Note: Higher precedence is denoted by a lower number, which is silly but seems to be how
			// other languages do it (http://en.cppreference.com/w/cpp/language/operator_precedence)
			if (parentPrecedence.Precedence < ourPrecedence.Precedence)
			{
				needsGroup = true;
			}
			// If we have the same level of precedence, then there's a chance we may need parenthesis based on
			else if (parentPrecedence.Precedence == ourPrecedence.Precedence)
			{
				// Technically, if the operator is actually associative (as in math associative) we can ignore
				// grouping when it's parent operator is the same *unless* we allow operator overloading to change that

				// If we have a left to right associativity
				if (parentPrecedence.Associativity == OperatorAssociativity::LeftToRight)
				{
					if (parentBinOp->RightOperand == node)
					{
						needsGroup = true;
					}
				}
				else
				{
					if (parentBinOp->LeftOperand == node)
					{
						needsGroup = true;
					}
				}
			}
		}

		if (needsGroup)
		{
			// HACK, this needs a space style!
			builder.WriteKeywordOrSymbolSpaceStyle(Grammar::BeginGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
		}

		context->Walker->Walk(this, node->LeftOperand, context);

		SpaceStyle::Enum globalOperatorSpaceStyle = SpaceStyle::BeforeAndAfter;

		// HACK, maybe every operator needs it's own spacing, or access operators have a special mode
		if (node->Operator->TokenId == Grammar::Access ||
			node->Operator->TokenId == Grammar::DynamicAccess ||
			node->Operator->TokenId == Grammar::NonVirtualAccess)
		{
			globalOperatorSpaceStyle = SpaceStyle::None;
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbolSpaceStyle(node->Operator->TokenId, SpaceStyle::UseGlobalDefault, globalOperatorSpaceStyle);

		context->Walker->Walk(this, node->RightOperand, context);

		if (needsGroup)
		{
			// HACK, this needs a space style!
			builder.WriteKeywordOrSymbolSpaceStyle(Grammar::EndGroup, SpaceStyle::UseGlobalDefault, SpaceStyle::None);
		}
	}

	//***************************************************************************
	void CodeFormatter::FormatStatement(StatementNode*& node, CodeFormatterContext* context)
	{
		// This will always run, even if other handlers will handle it

		// If this node is not being used as a direct statement
		// For example, an expression is a statement, but isn't always used as a statement
		if (StatementNode::IsNodeUsedAsStatement(node) == false)
			return;

		ZilchCodeBuilder& builder = context->Builder;

		// As long as the statement isn't a scoped based node (if, for, while, etc)
		// then we know it requires delimiting
		if (TypeBinding::DynamicCast<ScopeNode*>(node) == nullptr)
		{
			builder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
		}

		// If someone else ends up handling the children, that is fine
		// but we need to explicitly say that we didn't handle any children
		context->Flags = WalkerFlags::ChildrenNotHandled;
	}

	//***************************************************************************
	void CodeFormatter::FormatClass(ClassNode*& node, CodeFormatterContext* context)
	{
		if (node->TemplateInstantiation != nullptr)
			return;

		ZilchCodeBuilder& builder = context->Builder;

		this->FormatAttributes(node->Attributes, builder);

		builder.WriteLineIndented();

		builder.WriteKeywordOrSymbol(Grammar::Class);

		builder.WriteSpace();
		builder.Write(node->Name);

		if (node->Inheritance.empty() == false)
		{
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::Inheritance,
				builder.Format.SpaceStyleInheritanceColon,
				builder.Format.SpaceStyleGlobalDefaultColon
				);

			for (size_t i = 0; i < node->Inheritance.size(); ++i)
			{
				SyntaxType* syntaxType = node->Inheritance[i];

				builder.Write(syntaxType->ToString());

				bool isNotLast = (i != (node->Inheritance.size() - 1));
				if (isNotLast)
				{
					builder.WriteKeywordOrSymbolSpaceStyle
						(
						Grammar::ArgumentSeparator,
						builder.Format.SpaceStyleInheritanceComma,
						builder.Format.SpaceStyleGlobalDefaultComma
						);
				}
			}
		}

		builder.BeginScope(ScopeType::Class);

		// Get the nodes in the order they were declared
		NodeList<SyntaxNode>& inOrderNodes = node->NonTraversedNonOwnedNodesInOrder;

		// Walk the given syntax tree and emit code for each type of node
		for (size_t i = 0; i < inOrderNodes.size(); ++i)
		{
			// Traverse the current node
			SyntaxNode* childNode = inOrderNodes[i];
			this->Walker.Walk(this, childNode, context);
		}

		builder.EndScope();
	}

	//***************************************************************************
	void CodeFormatter::FormatAttributes(NodeList<AttributeNode>& attributes, ZilchCodeBuilder& builder)
	{
		if (attributes.empty() == false)
		{
			builder.WriteLineIndented();
		}

		for (size_t i = 0; i < attributes.size(); ++i)
		{
			AttributeNode* attribute = attributes[i];
			builder.WriteKeywordOrSymbol(Grammar::BeginIndex);
			builder.Write(attribute->TypeName->Token);
			builder.WriteKeywordOrSymbol(Grammar::EndIndex);
		}
	}

	//***************************************************************************
	void CodeFormatter::FormatEnum(EnumNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		this->FormatAttributes(node->Attributes, builder);

		builder.WriteLineIndented();

		if (node->IsFlags)
		{
			builder.WriteKeywordOrSymbol(Grammar::Flags);
		}
		else
		{
			builder.WriteKeywordOrSymbol(Grammar::Enumeration);
		}

		builder.WriteSpace();
		builder.Write(node->Name);

		if (node->Inheritance != nullptr)
		{
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::Inheritance,
				builder.Format.SpaceStyleInheritanceColon,
				builder.Format.SpaceStyleGlobalDefaultColon
				);

			builder.Write(node->Inheritance->ToString());
		}

		builder.BeginScope(ScopeType::Enumeration);

		// Walk all the values defined in the enum (in order)
		for (size_t i = 0; i < node->Values.size(); ++i)
		{
			EnumValueNode* enumValueNode = node->Values[i];
			this->Walker.Walk(this, enumValueNode, context);
			// HACK, need a style for 'trailing comma'
			builder.WriteKeywordOrSymbol(Grammar::ArgumentSeparator);
		}

		builder.EndScope();
	}

	//***************************************************************************
	void CodeFormatter::FormatEnumValue(EnumValueNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.WriteLineIndented();

		builder.Write(node->Name);
		if (node->Value != nullptr)
		{
			// HACK, needs space style
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::Assignment,
				SpaceStyle::UseGlobalDefault,
				SpaceStyle::BeforeAndAfter
				);
			builder.Write(node->Value->Token);
		}
	}

	//***************************************************************************
	// NodeType is a GenericFunctionNode
	template <typename NodeType, typename FunctionType>
	void CodeFormatter::FormatGenericFunctionHelper(NodeType* node, CodeFormatterContext* context, FunctionType emitPostArgs)
	{
		ZilchCodeBuilder& builder = context->Builder;

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbol(Grammar::BeginFunctionParameters);

		for (size_t i = 0; i < node->Parameters.size(); ++i)
		{
			ParameterNode* parameter = node->Parameters[i];

			builder.Write(parameter->Name);

			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::TypeSpecifier,
				builder.Format.SpaceStyleTypeColon,
				builder.Format.SpaceStyleGlobalDefaultColon
				);

			builder.Write(parameter->ResultSyntaxType->ToString());

			bool isNotLast = (i != (node->Parameters.size() - 1));
			if (isNotLast)
			{
				builder.WriteKeywordOrSymbolSpaceStyle
					(
					Grammar::ArgumentSeparator,
					builder.Format.SpaceStyleFunctionDefinitionParameterComma,
					builder.Format.SpaceStyleGlobalDefaultComma
					);
			}
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbol(Grammar::EndFunctionParameters);

		emitPostArgs(node, builder);

		builder.BeginScope(ScopeType::Function);

		for (size_t i = 0; i < node->Statements.size(); ++i)
		{
			StatementNode* statement = node->Statements[i];
			context->Walker->Walk(this, statement, context);
		}

		builder.EndScope();
	}

	//***************************************************************************
	void FormatFunctionPostArgs(FunctionNode* node, ZilchCodeBuilder& builder)
	{
		if (node->ReturnType != nullptr)
		{
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::TypeSpecifier,
				builder.Format.SpaceStyleTypeColon,
				builder.Format.SpaceStyleGlobalDefaultColon
				);

			builder.Write(node->ReturnType->ToString());
		}
	}

	//***************************************************************************
	void CodeFormatter::FormatFunction(FunctionNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		this->FormatAttributes(node->Attributes, builder);

		builder.WriteLineIndented();

		builder.WriteKeywordOrSymbol(Grammar::Function);

		builder.WriteSpace();
		builder.Write(node->Name);

		this->FormatGenericFunctionHelper(node, context, FormatFunctionPostArgs);
	}

	//***************************************************************************
	void FormatConstructorPostArgs(ConstructorNode* node, ZilchCodeBuilder& builder)
	{
	}

	//***************************************************************************
	void CodeFormatter::FormatConstructor(ConstructorNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		this->FormatAttributes(node->Attributes, builder);

		builder.WriteLineIndented();

		builder.WriteKeywordOrSymbol(Grammar::Constructor);

		this->FormatGenericFunctionHelper(node, context, FormatConstructorPostArgs);
	}

	//***************************************************************************
	void CodeFormatter::FormatSendsEvent(SendsEventNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		builder.WriteLineIndented();
		builder.WriteKeywordOrSymbol(Grammar::Sends);
		builder.WriteSpace();
		builder.Write(node->Name->Token);
		builder.WriteKeywordOrSymbolSpaceStyle
			(
			Grammar::TypeSpecifier,
			builder.Format.SpaceStyleNamedArgumentColon,
			builder.Format.SpaceStyleGlobalDefaultColon
			);
		builder.Write(node->EventType->ToString());
		builder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
	}

	//***************************************************************************
	void FormatDestructorPostArgs(DestructorNode* node, ZilchCodeBuilder& builder)
	{
	}

	//***************************************************************************
	void CodeFormatter::FormatDestructor(DestructorNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		this->FormatAttributes(node->Attributes, builder);

		builder.WriteLineIndented();
		builder.WriteKeywordOrSymbol(Grammar::Destructor);

		this->FormatGenericFunctionHelper(node, context, FormatDestructorPostArgs);
	}

	//***************************************************************************
	void CodeFormatter::FormatFunctionCall(FunctionCallNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		context->Walker->Walk(this, node->LeftOperand, context);

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbol(Grammar::BeginFunctionCall);

		for (size_t i = 0; i < node->Arguments.size(); ++i)
		{
			ExpressionNode* expression = node->Arguments[i];

			if (node->ArgumentNames.empty() == false)
			{
				String& name = node->ArgumentNames[i];
				builder.Write(name);

				builder.WriteKeywordOrSymbolSpaceStyle
					(
					Grammar::TypeSpecifier,
					builder.Format.SpaceStyleNamedArgumentColon,
					builder.Format.SpaceStyleGlobalDefaultColon
					);
			}

			context->Walker->Walk(this, expression, context);

			bool isNotLast = (i != (node->Arguments.size() - 1));
			if (isNotLast)
			{
				builder.WriteKeywordOrSymbolSpaceStyle
					(
					Grammar::ArgumentSeparator,
					builder.Format.SpaceStyleFunctionCallParameterComma,
					builder.Format.SpaceStyleGlobalDefaultComma
					);
			}
		}

		// HACK, this needs a space style!
		builder.WriteKeywordOrSymbol(Grammar::EndFunctionCall);
	}

	//***************************************************************************
	void CodeFormatter::FormatMemberAccess(MemberAccessNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		context->Walker->Walk(this, node->LeftOperand, context);
		builder.Write(node->Operator->Token);
		builder.Write(node->Name);
	}

	//***************************************************************************
	void CodeFormatter::FormatTypeMemberAccess(TypeMemberAccessNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		builder.Write(node->ReferencedSyntaxType->ToString());
		builder.WriteKeywordOrSymbol(node->Operator->TokenId);
		builder.Write(node->Name);
	}

	//***************************************************************************
	void CodeFormatter::FormatMemberVariable(MemberVariableNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		this->FormatAttributes(node->Attributes, builder);

		builder.WriteLineIndented();
		builder.WriteKeywordOrSymbol(Grammar::Variable);
		builder.WriteSpace();
		builder.Write(node->Name);

		if (node->IsInferred() == false)
		{
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::TypeSpecifier,
				builder.Format.SpaceStyleTypeColon,
				builder.Format.SpaceStyleGlobalDefaultColon
				);
			builder.Write(node->ResultSyntaxType->ToString());
		}

		if (node->IsProperty)
		{
			builder.BeginScope(ScopeType::Property);

			// Note: We don't actually want to walk the function nodes,
			// because they will emit function signatures, instead we just walk their statements
			// We also don't want to use 'GenericWalkChildren' because that will walk parameters

			if (node->Get != nullptr)
			{
				builder.WriteLineIndented();
				builder.WriteKeywordOrSymbol(Grammar::Get);
				builder.BeginScope(ScopeType::GetSet);
				context->Walker->Walk(this, node->Get->Statements, context);
				builder.EndScope();
			}

			if (node->Set != nullptr)
			{
				builder.WriteLineIndented();
				builder.WriteKeywordOrSymbol(Grammar::Set);
				builder.BeginScope(ScopeType::GetSet);
				context->Walker->Walk(this, node->Set->Statements, context);
				builder.EndScope();
			}

			builder.EndScope();
		}
		else if (node->InitialValue != nullptr)
		{
			// HACK, this needs a space style! 
			// PROBABLY BINARY OPERATOR SPACE STYLE
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::Assignment,
				SpaceStyle::UseGlobalDefault,
				SpaceStyle::BeforeAndAfter
				);
			context->Walker->Walk(this, node->InitialValue, context);
			builder.WriteKeywordOrSymbol(Grammar::StatementSeparator);
		}
	}

	//***************************************************************************
	void CodeFormatter::FormatParameter(ParameterNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		builder.Write(node->Name);
		builder.WriteKeywordOrSymbolSpaceStyle
			(
			Grammar::TypeSpecifier,
			builder.Format.SpaceStyleTypeColon,
			builder.Format.SpaceStyleGlobalDefaultColon
			);
		builder.Write(node->ResultSyntaxType->ToString());
	}

	//***************************************************************************
	void CodeFormatter::FormatLocalVariable(LocalVariableNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;
		this->FormatAttributes(node->Attributes, builder);

		builder.WriteKeywordOrSymbol(Grammar::Variable);
		builder.WriteSpace();
		builder.Write(node->Name);

		if (node->IsInferred() == false)
		{
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::TypeSpecifier,
				builder.Format.SpaceStyleTypeColon,
				builder.Format.SpaceStyleGlobalDefaultColon
				);
			builder.Write(node->ResultSyntaxType->ToString());
		}

		// Some variable nodes don't have initial values, or defaults
		if (node->InitialValue != nullptr)
		{
			// HACK, this needs a space style! 
			// PROBABLY BINARY OPERATOR SPACE STYLE
			builder.WriteKeywordOrSymbolSpaceStyle
				(
				Grammar::Assignment,
				SpaceStyle::UseGlobalDefault,
				SpaceStyle::BeforeAndAfter
				);
			context->Walker->Walk(this, node->InitialValue, context);
		}
	}

	//***************************************************************************
	void CodeFormatter::FormatCreationCall(CreationCallNode*& node, CodeFormatterContext* context)
	{
		ZilchCodeBuilder& builder = context->Builder;

		// If it's inferred, we don't bother writing anything
		if (node->Mode == CreationMode::New)
		{
			builder.WriteKeywordOrSymbol(Grammar::New);
		}
		else if (node->Mode == CreationMode::Local)
		{
			builder.WriteKeywordOrSymbol(Grammar::Local);
		}

		builder.WriteSpace();
		builder.Write(node->CreatedSyntaxType->ToString());
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	ZilchDefineSimpleType(Function, Core);

	//***************************************************************************
	NativeVirtualInfo::NativeVirtualInfo() :
		Index(NonVirtual),
		Thunk(nullptr),
		Guid(InvalidGuid)
	{
	}

	//***************************************************************************
	bool NativeVirtualInfo::Validate()
	{
		// Error checking for the native virtual calls
		ReturnIf
			(
			(this->Index == NonVirtual && this->Thunk != nullptr) ||
			(this->Index != NonVirtual && this->Thunk == nullptr),
			false,
			"You must provide both the virtual index and thunk, or neither"
			);

		// Error check the guid
		ReturnIf
			(
			this->Index != NonVirtual && this->Guid == InvalidGuid,
			false,
			"The guid provided was not valid"
			);

		// Otherwise, we validated
		return true;
	}

	//***************************************************************************
	Function::Function() :
		BoundFunction(nullptr),
		Type(nullptr),
		RequiredStackSpace(0),
		This(nullptr),
		SourceLibrary(nullptr),
		UserData(nullptr),
		IsPropertyGetOrSet(false),
		IsVirtual(false)
	{
	}

	//***************************************************************************
	Function::~Function()
	{
	}

	//***************************************************************************
	String Function::GetDocumentationKey()
	{
		// If the function is static, it's important to note that
		if (this->This == nullptr)
		{
			return BuildString("[Static] ", this->Name, this->Type->GetSignatureString());
		}
		else
		{
			return BuildString(this->Name, this->Type->GetSignatureString());
		}
	}

	//***************************************************************************
	GuidType Function::Hash() const
	{
		// Store the resulting hash
		GuidType result = 0;

		// If this function has a this pointer
		if (this->This != nullptr)
		{
			// Take the hash of the 'this' type, and hash it with the delegate type hash
			result = this->This->ResultType->Hash();
		}

		// Add in the delegate type hash
		result ^= this->Type->Hash() * 27697;

		// Add in the hash of the function name
		result ^= this->Name.hash() * 13;

		// Hash the owner and add that in
		result ^= this->Owner->Hash() * 4738837;

		// Return the resulting hash
		return result;
	}

	//***************************************************************************
	String Function::ToString() const
	{
		// The string we build for a function is the name of the class, then the name of the function
		// and then the entire signature, ex: Animal.Attack(damage : Integer) : String
		StringBuilder builder;
		builder.Append(this->Owner->Name);
		builder.Append(Grammar::GetKeywordOrSymbol(Grammar::Access));
		builder.Append(this->Name);
		this->Type->BuildSignatureString(builder);
		return builder.ToString();
	}

	//***************************************************************************
	CodeLocation* Function::GetCodeLocationFromProgramCounter(size_t programCounter)
	{
		// We don't know the location of native and non-active program counters
		if (programCounter == ProgramCounterNative || programCounter == ProgramCounterNotActive)
			return nullptr;

		// Now get the code location for the given opcode inside the function
		CodeLocation* codeLocation = this->OpcodeLocationToCodeLocation.findPointer(programCounter);
		if (codeLocation == nullptr)
			return nullptr;

		// Return the code location we found
		return codeLocation;
	}

	//***************************************************************************
	Opcode& Function::AllocateArgumentFreeOpcode(Instruction::Enum instruction, DebugOrigin::Enum debugOrigin, const CodeLocation& debugLocation)
	{
		return AllocateOpcode<Opcode>(instruction, debugOrigin, debugLocation);
	}

	//***************************************************************************
	OperandIndex Function::AllocateRegister(size_t size)
	{
		// Get the last index of the registers array
		size_t index = this->RequiredStackSpace;

		// Allocate the spot in the registers
		this->RequiredStackSpace += AlignToBusWidth(size);

		// Return the index
		return index;
	}

	//***************************************************************************
	size_t Function::GetCurrentOpcodeIndex()
	{
		return this->OpcodeBuilder.RelativeSize();
	}
}/**************************************************************\
 * Author: Trevor Sundberg
 \**************************************************************/

// Includes

namespace Zilch
{
	// The symbols or keywords we use, if available for given grammar symbols
	static String KeywordsOrSymbols[] =
	{
		"Invalid",
		"End",
		"Error",
		"Whitespace",
		"UpperIdentifier",
		"LowerIdentifier",
		"IntegerLiteral",
		"DoubleIntegerLiteral",
		"RealLiteral",
		"DoubleRealLiteral",
		"CharacterLiteral",
		"StringLiteral",
		"BeginStringInterpolate",
		"EndStringInterpolate",
		"EndBeginStringInterpolate",
		"abstract",
		"alias",
		"alignof",
		"assert",
		"auto",
		"case",
		"catch",
		"checked",
		"const",
		"default",
		"dynamic",
		"explicit",
		"export",
		"extern",
		"finally",
		"fixed",
		"friend",
		"global",
		"goto",
		"immutable",
		"implicit",
		"import",
		"in",
		"include",
		"inline",
		"interface",
		"internal",
		"is",
		"local",
		"lock",
		"module",
		"mutable",
		"namespace",
		"operator",
		"out",
		"override",
		"package",
		"params",
		"partial",
		"positional",
		"private",
		"protected",
		"public",
		"readonly",
		"register",
		"require",
		"scope",
		"sealed",
		"signed",
		"sizeof",
		"stackalloc",
		"static",
		"switch",
		"timeout",
		"try",
		"typedef",
		"typename",
		"unchecked",
		"unsafe",
		"unsigned",
		"using",
		"virtual",
		"volatile",
		"where",
		"yield",
		"any",
		"and",
		"as",
		"base",
		"break",
		"class",
		"constructor",
		"continue",
		"debug",
		"delegate",
		"delete",
		"destructor",
		"do",
		"else",
		"enum",
		"false",
		"flags",
		"for",
		"foreach",
		"function",
		"get",
		"if",
		"loop",
		"new",
		"not",
		"null",
		"or",
		"ref",
		"return",
		"sends",
		"set",
		"struct",
		"throw",
		"true",
		"typeid",
		"typeof",
		"var",
		"while",
		".",
		"->",
		"~>",
		":",
		",",
		"=>",
		"=",
		"-=",
		"+=",
		"/=",
		"*=",
		"%=",
		"^=",
		"<<=",
		">>=",
		"$=",
		"|=",
		"&=",
		"==",
		"!=",
		"<",
		"<=",
		">",
		">=",
		"-",
		"+",
		"/",
		"*",
		"%",
		"^",
		"--",
		"++",
		"<<",
		">>",
		"$",
		"|",
		"&",
		"~",
		"@",
		"||",
		"&&",
		"!",
		";",
		"[",
		"]",
		"(",
		")",
		"{",
		"}",
		"//",
		"/*",
		"*/",
	};

	// The human readable names we give to every symbol
	static String Names[] =
	{
		"Invalid",
		"End",
		"Error",
		"Whitespace",
		"UpperIdentifier",
		"LowerIdentifier",
		"IntegerLiteral",
		"DoubleIntegerLiteral",
		"RealLiteral",
		"DoubleRealLiteral",
		"CharacterLiteral",
		"StringLiteral",
		"BeginStringInterpolate",
		"EndStringInterpolate",
		"EndBeginStringInterpolate",
		"Abstract",
		"Alias",
		"Alignof",
		"Assert",
		"Auto",
		"Case",
		"Catch",
		"Checked",
		"Const",
		"Default",
		"Dynamic",
		"Explicit",
		"Export",
		"Extern",
		"Finally",
		"Fixed",
		"Friend",
		"Global",
		"Goto",
		"Immutable",
		"Implicit",
		"Import",
		"In",
		"Include",
		"Inline",
		"Interface",
		"Internal",
		"Is",
		"Local",
		"Lock",
		"Module",
		"Mutable",
		"Namespace",
		"Operator",
		"Out",
		"Override",
		"Package",
		"Params",
		"Partial",
		"Positional",
		"Private",
		"Protected",
		"Public",
		"Readonly",
		"Register",
		"Require",
		"Scope",
		"Sealed",
		"Signed",
		"Sizeof",
		"Stackalloc",
		"Static",
		"Switch",
		"Timeout",
		"Try",
		"Typedef",
		"Typename",
		"Unchecked",
		"Unsafe",
		"Unsigned",
		"Using",
		"Virtual",
		"Volatile",
		"Where",
		"Yield",
		"Any",
		"And",
		"As",
		"Base",
		"Break",
		"Class",
		"Constructor",
		"Continue",
		"Debug",
		"Delegate",
		"Delete",
		"Destructor",
		"Do",
		"Else",
		"Enumeration",
		"False",
		"Flags",
		"For",
		"ForEach",
		"Function",
		"Get",
		"If",
		"Loop",
		"New",
		"Not",
		"Null",
		"Or",
		"Ref",
		"Return",
		"Sends",
		"Set",
		"Struct",
		"Throw",
		"True",
		"Typeid",
		"Typeof",
		"Variable",
		"While",
		"Access",
		"DynamicAccess",
		"NonVirtualAccess",
		"TypeSpecifier / NameSpecifier / Inheritance / InitializerList",
		"ArgumentSeparator",
		"RefersTo",
		"Assignment",
		"AssignmentSubtract",
		"AssignmentAdd",
		"AssignmentDivide",
		"AssignmentMultiply",
		"AssignmentModulo",
		"AssignmentExponent",
		"AssignmentLeftShift",
		"AssignmentRightShift",
		"AssignmentBitwiseXor",
		"AssignmentBitwiseOr",
		"AssignmentBitwiseAnd",
		"Equality",
		"Inequality",
		"LessThan",
		"LessThanOrEqualTo",
		"GreaterThan",
		"GreaterThanOrEqualTo",
		"Negative / Subtract",
		"Positive / Add",
		"Divide",
		"Multiply",
		"Modulo",
		"Exponent",
		"Decrement",
		"Increment",
		"BitshiftLeft",
		"BitshiftRight",
		"BitwiseXor",
		"BitwiseOr",
		"BitwiseAnd",
		"BitwiseNot",
		"PropertyDelegate",
		"LogicalOr",
		"LogicalAnd",
		"LogicalNot",
		"StatementSeparator",
		"BeginIndex / BeginTemplate / BeginInitializer",
		"EndIndex / EndTemplate / EndInitializer",
		"BeginFunctionCall / BeginFunctionParameters / BeginGroup",
		"EndFunctionCall / EndFunctionParameters / EndGroup",
		"BeginScope",
		"EndScope",
		"CommentLine",
		"CommentStart",
		"CommentEnd",
	};

	//***************************************************************************
	const String& Grammar::GetName(Grammar::Enum value)
	{
		// We add one because of the 'Invalid' index
		return Names[value + 1];
	}

	//***************************************************************************
	const String& Grammar::GetKeywordOrSymbol(Grammar::Enum value)
	{
		// We add one because of the 'Invalid' index
		return KeywordsOrSymbols[value + 1];
	}

	//***************************************************************************
	const Array<String>& Grammar::GetUsedKeywords()
	{
		static Array<String> results;
		if (results.empty())
		{
			results.push_back("any");
			results.push_back("and");
			results.push_back("as");
			results.push_back("base");
			results.push_back("break");
			results.push_back("class");
			results.push_back("constructor");
			results.push_back("continue");
			results.push_back("debug");
			results.push_back("delegate");
			results.push_back("delete");
			results.push_back("destructor");
			results.push_back("do");
			results.push_back("else");
			results.push_back("enum");
			results.push_back("false");
			results.push_back("flags");
			results.push_back("for");
			results.push_back("foreach");
			results.push_back("function");
			results.push_back("get");
			results.push_back("if");
			results.push_back("loop");
			results.push_back("new");
			results.push_back("not");
			results.push_back("null");
			results.push_back("or");
			results.push_back("ref");
			results.push_back("return");
			results.push_back("sends");
			results.push_back("set");
			results.push_back("struct");
			results.push_back("throw");
			results.push_back("true");
			results.push_back("typeid");
			results.push_back("typeof");
			results.push_back("var");
			results.push_back("while");
		}
		return results;
	}

	//***************************************************************************
	const Array<String>& Grammar::GetSpecialKeywords()
	{
		static Array<String> results;
		if (results.empty())
		{
			results.push_back("this");
			results.push_back("value");
			results.push_back("event");
		}
		return results;
	}

	//***************************************************************************
	const Array<String>& Grammar::GetReservedKeywords()
	{
		static Array<String> results;
		if (results.empty())
		{
			results.push_back("abstract");
			results.push_back("alias");
			results.push_back("alignof");
			results.push_back("assert");
			results.push_back("auto");
			results.push_back("case");
			results.push_back("catch");
			results.push_back("checked");
			results.push_back("const");
			results.push_back("default");
			results.push_back("dynamic");
			results.push_back("explicit");
			results.push_back("export");
			results.push_back("extern");
			results.push_back("finally");
			results.push_back("fixed");
			results.push_back("friend");
			results.push_back("global");
			results.push_back("goto");
			results.push_back("immutable");
			results.push_back("implicit");
			results.push_back("import");
			results.push_back("in");
			results.push_back("include");
			results.push_back("inline");
			results.push_back("interface");
			results.push_back("internal");
			results.push_back("is");
			results.push_back("local");
			results.push_back("lock");
			results.push_back("module");
			results.push_back("mutable");
			results.push_back("namespace");
			results.push_back("operator");
			results.push_back("out");
			results.push_back("override");
			results.push_back("package");
			results.push_back("params");
			results.push_back("partial");
			results.push_back("positional");
			results.push_back("private");
			results.push_back("protected");
			results.push_back("public");
			results.push_back("readonly");
			results.push_back("register");
			results.push_back("require");
			results.push_back("scope");
			results.push_back("sealed");
			results.push_back("signed");
			results.push_back("sizeof");
			results.push_back("stackalloc");
			results.push_back("static");
			results.push_back("switch");
			results.push_back("timeout");
			results.push_back("try");
			results.push_back("typedef");
			results.push_back("typename");
			results.push_back("unchecked");
			results.push_back("unsafe");
			results.push_back("unsigned");
			results.push_back("using");
			results.push_back("virtual");
			results.push_back("volatile");
			results.push_back("where");
			results.push_back("yield");
		}
		return results;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{

	//***************************************************************************
#ifdef ZILCH_HANDLE_DEBUG
	// Statics implemented for debugging
	Handle* Handle::DebugHead = nullptr;
	Handle* Handle::DebugTail = nullptr;
#endif

	//***************************************************************************
	Handle::Handle()
	{
		ZilchErrorIfNotStarted(Handle);

		// Clear out the handle object to a null handle
		this->Clear();

#ifdef ZILCH_HANDLE_DEBUG
		// Link ourselves to the global list of handles
		this->DebugLink();
#endif
	}

	//***************************************************************************
	Handle::Handle(const Handle& rhs) :
		Type(rhs.Type),
		Manager(rhs.Manager),
		Offset(rhs.Offset),
		Flags(rhs.Flags)
	{
		// The data of a handle type is always memory-copyable
		memcpy(this->Data, rhs.Data, sizeof(this->Data));

#ifdef ZILCH_HANDLE_DEBUG
		// Link ourselves to the global list of handles
		this->DebugLink();
#endif

		// Increment the reference count since we're now referencing the same thing
		this->AddReference();
	}

	//***************************************************************************
	Handle::Handle(ExecutableState* state, BoundType* type, const byte* data) :
		Type(type),
		Offset(0),
		Flags(HandleFlags::None)
	{
		// Grab the handle manager for this type
		HandleManager* manager = state->GetHandleManager(type->HandleManager);
		this->Manager = manager;

		// Zero out the data (this is a gaurantee we make before we ask the manager to initialize the data)
		memset(this->Data, 0, sizeof(this->Data));

		// Construct this handle from the manager
		manager->ObjectToHandle(data, *this);

		// Increment the reference count since we're now referencing the same thing
		this->AddReference();
	}

	//***************************************************************************
	Handle::~Handle()
	{
#ifdef ZILCH_HANDLE_DEBUG
		// Unlink ourselves from the global list of handles
		this->DebugUnlink();
#endif

		// Decrement the reference count for ourselves
		this->ReleaseReference();

#ifdef ZILCH_HANDLE_DEBUG
		// We cannot clear 'Type' because it actually needs to be auto-destructed
		memset(&this->Manager, 0xCD, sizeof(this->Manager));
		memset(&this->Offset, 0xCD, sizeof(this->Offset));
		memset(&this->Data, 0xCD, sizeof(this->Data));
		memset(&this->Flags, 0xCD, sizeof(this->Flags));
#endif
	}

#ifdef ZILCH_HANDLE_DEBUG
	//***************************************************************************
	void Handle::ValidateAllHandles()
	{
		// Loop forwards through the list and validate each handle
		{
			HashSet<Handle*> visited;

			Handle* value = DebugHead;
			Handle* lastHandle = nullptr;
			while (value != nullptr)
			{
				ErrorIf(visited.contains(value),
					"Attempted to visit a link twice");
				visited.insert(value);
				value->Validate();
				lastHandle = value;
				value = value->DebugNext;
			}
		}

		// Loop backwards through the list and validate each handle
	{
		HashSet<Handle*> visited;

		Handle* value = DebugTail;
		Handle* lastHandle = nullptr;
		while (value != nullptr)
		{
			ErrorIf(visited.contains(value),
				"Attempted to visit a link twice");
			visited.insert(value);
			value->Validate();
			lastHandle = value;
			value = value->DebugPrev;
		}
	}
	}

	//***************************************************************************
	void Handle::Validate() const
	{
		// Verify the next and prev values
		ErrorIf(this->DebugNext == nullptr && this->DebugPrev == nullptr && DebugHead != this,
			"A handle was possibly mem-cleared");
		ErrorIf(this->DebugNext != nullptr && this->DebugNext == this->DebugPrev,
			"Possibly corrupted handle");
		ErrorIf(this->DebugNext == (Handle*)0xCDCDCDCD || this->DebugPrev == (Handle*)0xCDCDCDCD,
			"Possibly corrupted handle");

		// Make sure the offset size is ok
		ErrorIf(this->Offset > 0x7777,
			"Possibly corrupted handle based on the large offset size");

		// Clear all flags and see if any other bits were set
		ErrorIf((this->Flags & ~(HandleFlags::NoReferenceCounting | HandleFlags::InitializedByConstructor)) != 0,
			"Possibly corrupted handle (bits set even when we cleared all flags)");

		// See if we have a manager
		if (this->Manager)
		{
			// Verify that we can access the manager
			ErrorIf(this->Manager->GetName().empty(),
				"Possibly corrupted handle (could not get the handle manager name)");

			// Attempt to derefence the handle, see what happens
			this->Manager->HandleToObject(*this);
		}

		// See if we have a type...
		if (this->Type)
		{
			// Check that we can get the type name
			ErrorIf(this->Type->ToString().empty(),
				"Possibly corrupted handle (could not get the type name)");
		}

		// Make sure we either have no type and no manager, or a type and a manager
		//ErrorIf((this->Manager != nullptr) != (this->Type != nullptr),
		//  "Possibly corrupted handle (manager or type incosistently set)");
	}

	//***************************************************************************
	void Handle::DebugLink()
	{
		this->Flags |= HandleFlags::InitializedByConstructor;
		this->DebugNext = nullptr;

		if (DebugTail)
		{
			ErrorIf(DebugTail->DebugNext != nullptr);

			DebugTail->DebugNext = this;
			this->DebugPrev = DebugTail;
			DebugTail = this;
		}
		else
		{
			ErrorIf(DebugHead != nullptr);

			DebugHead = this;
			DebugTail = this;
			this->DebugPrev = nullptr;
		}
	}

	//***************************************************************************
	void Handle::DebugUnlink()
	{
		// We only want to unlink this if it was ever linked in the first place
		if ((this->Flags & HandleFlags::InitializedByConstructor) == 0)
			return;

		// First, just attempt to validate ourselves
		this->Validate();

		// If I am the tail...
		if (this->DebugNext == nullptr)
		{
			ErrorIf(this != DebugTail);
			DebugTail = this->DebugPrev;
		}
		else
		{
			ErrorIf(this == DebugTail);
			this->DebugNext->DebugPrev = this->DebugPrev;
		}

		// If I am the head...
		if (this->DebugPrev == nullptr)
		{
			ErrorIf(this != DebugHead);
			DebugHead = this->DebugNext;
		}
		else
		{
			ErrorIf(this == DebugHead);
			this->DebugPrev->DebugNext = this->DebugNext;
		}

		this->DebugNext = (Handle*)0xCDCDCDCD;
		this->DebugPrev = (Handle*)0xCDCDCDCD;
	}

#endif

	//***************************************************************************
	Handle& Handle::operator=(const Handle& rhs)
	{
		// Check for self assignment (which we ignore)
		if (this == &rhs)
		{
			// Return ourselves for chaining
			return *this;
		}

#ifdef ZILCH_HANDLE_DEBUG
		// Unlink ourselves from the global list of handles
		this->Validate();
		rhs.Validate();
#endif

		// Decrement the reference count for ourselves
		this->ReleaseReference();

		// Copy all the members over
		this->Type = rhs.Type;
		this->Manager = rhs.Manager;
		this->Offset = rhs.Offset;
		this->Flags = rhs.Flags;

		// The data of a handle type is always memory-copyable
		memcpy(this->Data, rhs.Data, sizeof(this->Data));

		// Increment the reference count since we're now referencing the same thing
		this->AddReference();

		// Return ourselves for chaining
		return *this;
	}

	//***************************************************************************
	bool Handle::operator==(const Handle& rhs) const
	{
		// Check whether either handle is null
		byte* objectLhs = this->Dereference();
		byte* objectRhs = rhs.Dereference();
		bool nullLhs = (objectLhs == nullptr);
		bool nullRhs = (objectRhs == nullptr);

		ZilchTodo("There are two dereferences for comparing user handles, we should refactor this code path to make it one");

		// If both are non null, then we need to do more checking
		if (!nullLhs && !nullRhs)
		{
			// First, check that both of them use the same handle manager
			if (this->Manager != rhs.Manager)
			{
				// If they don't use the same handle manager, then at least dereference and check if the memory is the same
				return objectLhs == objectRhs;
			}

			// We can also check if the types are the same
			//if (this->Type != rhs.Type)
			//  return false;

			// We shouldn't need to check if the managers are null since both objects are non-null
			// Now ask the handle manager if these two handles / objects are equal
			return this->Manager->IsEqual(*this, rhs, objectLhs, objectRhs);
		}
		// Otherwise, if either of them is null, or both...
		else
		{
			// If they are both null, then the handles are equal
			// If the left is null but not the right, or the right is null
			// but not the left, then they are not equal
			return nullLhs && nullRhs;
		}
	}

	//***************************************************************************
	bool Handle::operator!=(const Handle& rhs) const
	{
		return !(*this == rhs);
	}

	//***************************************************************************
	int Handle::Hash() const
	{
		// If this handle is the null manager... (this is the trivial case of a cleared handle)
		if (this->Manager == nullptr)
		{
			// We must always return a 0 hash for null handles
			return 0;
		}

		// Otherwise let the manager handle it
		return this->Manager->Hash(*this);
	}

	//***************************************************************************
	bool Handle::IsNull() const
	{
		// Just dereference the handle and see if it's null
		return (this->Dereference() == nullptr);
	}

	//***************************************************************************
	bool Handle::IsReferenceCounted()
	{
		return !(this->Flags & HandleFlags::NoReferenceCounting);
	}

	//***************************************************************************
	void Handle::Clear()
	{
		// Clear out all our members
		this->Flags = HandleFlags::None;
		this->Type = nullptr;
		this->Manager = nullptr;
		this->Offset = 0;

		// Clear out the handle object
		memset(this->Data, 0, sizeof(this->Data));
	}

	//***************************************************************************
	byte* Handle::Dereference() const
	{
		// If this handle is the null manager... (this is the trivial case of a cleared handle)
		if (this->Manager == nullptr)
		{
			return nullptr;
		}

		ZilchTodo("If a handle returns null but is not the 'null handle manager' then it should be an optimization to Clear it");

		// Dereference the handle and get a pointer to the object (or nullptr if it's a null handle)
		return this->Manager->HandleToObject(*this) + this->Offset;
	}

	//***************************************************************************
	void Handle::AddReference()
	{
		// Increment the reference count since we're now referencing the same thing
		if (this->Manager && this->IsReferenceCounted())
		{
			// Add a reference via the manager
			this->Manager->AddReference(*this);
		}
	}

	//***************************************************************************
	void Handle::ReleaseReference()
	{
		// If the handle has a manager...
		if (this->Manager && this->IsReferenceCounted())
		{
			// We could put this responsibility upon the managers themselves, however,
			// we should never call release on a handle to an object that may have been deleted
			// For example, new an object in Zilch, then create a temporary handle, and delete the original
			// The temporary handle will get ref counted up, and after the scope ends down again
			// The ref count down should NOT be applied to then manager since the object was deleted
			if (this->IsNull() == false)
			{
				// Ask the manager to release the reference
				ReleaseResult::Enum result = this->Manager->ReleaseReference(*this);

				// If we're supposed to delete the object...
				if (result == ReleaseResult::DeleteObject)
				{
					// Invoke the destructor and ask the manager to delete the memory
					this->DestructAndDelete();
				}
			}
		}
	}

	//***************************************************************************
	void Handle::DestructAndDelete()
	{
		// Mark the stack copy of the handle as not being reference counted
		// That way, when it runs the destructor it won't attempt to increment the reference count again
		this->Flags |= HandleFlags::NoReferenceCounting;

		// Make sure this only gets called from places where we know we have a manager
		ErrorIf(this->Manager == nullptr,
			"This should only get called from non-null handles");

		// Grab the state from the manager (this could be null!)
		ExecutableState* state = this->Manager->State;

		// Get a pointer to our own object's data
		byte* self = this->Dereference();

		// Error checking
		ErrorIf(self == nullptr,
			"Somehow we're attempting to delete a null object!");

		// If the state is valid (this is not a shared handle...)
		if (state != nullptr)
		{
			// Store the type 
			BoundType* type = this->Type;

			// While we haven't reached the root class
			while (type != nullptr)
			{
				// Invoke the destructor
				if (type->Destructor != nullptr)
				{
					// We currently execute the destructor and basically ignore any exceptions
					// They still get reported, but will be caught here
					ExceptionReport report;
					Call call(type->Destructor, state);
					call.SetHandle(Call::This, *this);
					call.Invoke(report);
				}

				// Invoke the post-destructor
				if (type->PostDestructor != nullptr)
				{
					type->PostDestructor(type, self);
				}

				// Iterate up to the base type
				type = type->BaseType;
			}
		}

		// Delete this handle
		this->Manager->Delete(*this);
	}

	//***************************************************************************
	bool Handle::Delete()
	{
		// If the handle is already null, then don't bother with it!
		// Note for below: this actually checks for 'Null' typed handles
		// Moreover, after this we can assume that the manager is valid
		if (this->IsNull())
			return true;

		// Make sure this only gets called from places where we know we have a manager
		ErrorIf(this->Manager == nullptr,
			"This should only get called from non-null handles");

		// If we have an offset, we cannot be deleted
		if (this->Offset != 0)
		{
			return false;
		}

		// We make a stack copy just in case this handle resides in memory that we are about to delete
		// Note: Leave this up here just in case CanDelete would return false if we made the copy
		Handle stackCopy(*this);

		// If we cannot delete the handle, then early out!
		if (this->Manager->CanDelete(stackCopy) == false)
		{
			return false;
		}

		// Clear this handle to a null handle (for safety)
		// This is safe to do because we're only deleting our stack copy
		this->Clear();

		// Invoke the destructor on the stack copy
		stackCopy.DestructAndDelete();
		return true;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	HandleManagers& HandleManagers::GetInstance()
	{
		static HandleManagers instance;
		return instance;
	}

	//***************************************************************************
	HandleManagers::HandleManagers() :
		UniqueCounter(0),
		Locked(false)
	{
	}

	//***************************************************************************
	HandleManagers::~HandleManagers()
	{
		// Destroy all the shared managers
		for (size_t i = 0; i < this->Shared.size(); ++i)
		{
			// Delete all the shared entries
			delete this->Shared[i];
		}

		// Clear the shared array, as well as the creators
		this->Shared.clear();
		this->Unique.clear();
	}

	//***************************************************************************
	void HandleManagers::AddSharedManager(HandleManagerId id, HandleManager* manager)
	{
		// Error checking
		ReturnIf(this->Locked, ,
			"We cannot add to the handle managers after we've called ZilchStartup");

		this->Shared.insert(id, manager);
	}

	//***************************************************************************
	void HandleManagers::AddUniqueCreator(HandleManagerId id, CreateHandleManagerFn creator)
	{
		// Error checking
		ReturnIf(this->Locked, ,
			"We cannot add to the handle managers after we've called ZilchStartup");

		this->Unique.insert(id, creator);
	}

	//***************************************************************************
	HandleManager* HandleManagers::GetSharedManager(HandleManagerId id)
	{
		return this->Shared.findValue(id, nullptr);
	}

	//***************************************************************************
	CreateHandleManagerFn HandleManagers::GetUniqueCreator(HandleManagerId id)
	{
		return this->Unique.findValue(id, nullptr);
	}

	//***************************************************************************
	HandleManagerId HandleManagers::GetNextId()
	{
		// Error checking
		ReturnIf(this->Locked, (HandleManagerId)-1,
			"We cannot get new unique ids for handle managers after we've called ZilchStartup");

		return this->UniqueCounter++;
	}

	//***************************************************************************
	void HandleManagers::Lock()
	{
		this->Locked = true;
	}

	//***************************************************************************
	HandleManager::~HandleManager()
	{
	}

	//***************************************************************************
	HandleManager::HandleManager(ExecutableState* state) :
		State(state)
	{
	}

	//***************************************************************************
	bool HandleManager::IsEqual
		(
		const Handle& handleLhs,
		const Handle& handleRhs,
		const byte* objectLhs,
		const byte* objectRhs
		)
	{
		// Compare the dereferenced handles
		return objectLhs == objectRhs;
	}

	//***************************************************************************
	void HandleManager::AddReference(const Handle& handle)
	{
	}

	//***************************************************************************
	ReleaseResult::Enum HandleManager::ReleaseReference(const Handle& handle)
	{
		return ReleaseResult::KeepAlive;
	}

	//***************************************************************************
	int HandleManager::Hash(const Handle& handle)
	{
		// Dereference the handle
		byte* pointer = this->HandleToObject(handle);

		// Return the pointer as if it were a hash (works for null to, which would return 0)
		return (int)(size_t)pointer;
	}

	//***************************************************************************
	void HandleManager::Delete(const Handle& handle)
	{
	}

	//***************************************************************************
	bool HandleManager::CanDelete(const Handle& handle)
	{
		return false;
	}

	//***************************************************************************
	HeapManager::HeapManager(ExecutableState* state) :
		HandleManager(state)
	{
		// Resize the object slots so we can hold objects
		this->Objects.resize(100000);

		// Initialize the counter to zero
		this->UidCount = 0;
		this->ObjectCount = 0;

		// The first slot will be the next free slot
		this->NextFreeSlot = this->Objects.data();

		// Loop through all the object slots
		for (size_t index = 0; index < this->Objects.size(); ++index)
		{
			// Grab a reference to the current slot
			ObjectSlot& slot = this->Objects[index];

			// Clear out the object
			slot.Data = nullptr;
			slot.UniqueId = InvalidUid;
			slot.ReferenceCount = 0;

			// If the index is at the end...
			if (index == (this->Objects.size() - 1))
			{
				// There are no more free slots
				slot.NextFreeSlot = nullptr;
			}
			else
			{
				// Set the next free slot to be one ahead
				slot.NextFreeSlot = &slot + 1;
			}
		}
	}

	//***************************************************************************
	HeapManager::~HeapManager()
	{
		// Note: We really don't want to run this destructor code
		// Theoretically all memory from a system should be cleaned up by itself
		// We really need to incorporate leak detection here
		// Leak detection includes the stack frame of who allocated it
		// as well as all those still referencing it

		// Loop through all the object slots
		for (size_t index = 0; index < this->Objects.size(); ++index)
		{
			// Grab a reference to the current slot
			ObjectSlot& slot = this->Objects[index];

			// Always delete the slot's data (safe for nullptr / no data)
			delete[] slot.Data;
		}
	}

	//***************************************************************************
	String HeapManager::GetName()
	{
		static String Name("Heap Object");
		return Name;
	}

	//***************************************************************************
	byte* HeapManager::HandleToObject(const Handle& handle)
	{
		HeapHandleData& data = *(HeapHandleData*)handle.Data;

		// If the slot data has been cleared, then we're also null
		if (data.Slot == nullptr)
			return nullptr;

		// If the unique-ids for that slot don't match (it was reused)
		// then we return null since this handle is no longer valid
		if (data.UniqueId != data.Slot->UniqueId)
			return nullptr;

		// If we were pointing at a valid slot, but the data was cleared...
		if (data.Slot->Data == nullptr)
			return nullptr;

		// The data should be valid allocated memory
		// Since the beginning our memory is actually a pointer to an
		// object slot, we need to offset to get to the actual objects data
		return data.Slot->Data + sizeof(ObjectSlot*);
	}

	//***************************************************************************
	void HeapManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
	{
		// Set the handle to use the next free slot in the object
		ObjectSlot* slot = this->NextFreeSlot;

		// If we didn't get a slot...
		if (slot == nullptr)
		{
			// Clear out the handle and report the error
			Error("Cannot allocate the object of type %s, we ran out of slots / memory!", type->ToString().c_str());
			handleToInitialize.Manager = nullptr;
			return;
		}

		// Set the next free slot on the executable state
		this->NextFreeSlot = slot->NextFreeSlot;

		// Create a buffer that's the size of the object we'd like to allocate
		// At the beginning of the buffer, we put the object slot pointer so that
		// 'ObjectToHandle' can recreate a handle via the slot data pointer
		size_t objectSize = type->GetAllocatedSize();
		size_t fullSize = sizeof(ObjectSlot*) + objectSize;
		byte* memory = new byte[fullSize];

		// All primitives should support being zeroed out
		memset(memory, 0x00, fullSize);

		// Store a pointer back to the slot on the memory itself
		*(ObjectSlot**)memory = slot;

		// Initialize the handle
		// We are pointing at this via the 'handle to initialize' so the reference count is 1
		slot->ReferenceCount = 1;
		slot->Flags = (HeapFlags::Enum)customFlags;
		slot->NextFreeSlot = nullptr;
		slot->Data = memory;
		slot->UniqueId = this->UidCount;

		// Increment the unique ID counter
		++this->UidCount;

		// We allocated an object, increment that too
		++this->ObjectCount;

		// If specified, we won't do reference counting on this handle
		// This means the only way to destroy the handle is via delete
		if (customFlags == HeapFlags::NonReferenceCounted)
			handleToInitialize.Flags = HandleFlags::NoReferenceCounting;

		// We are always guaranteed that the handle data is cleared before we get the user data portion
		HeapHandleData& data = *(HeapHandleData*)handleToInitialize.Data;
		data.Slot = slot;
		data.UniqueId = slot->UniqueId;
	}

	//***************************************************************************
	void HeapManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
	{
		// The first part of the memory is a pointer back to the object slot
		ObjectSlot* slot = *(ObjectSlot**)(object - sizeof(ObjectSlot*));

		// If specified, we won't do reference counting on this handle
		// This means the only way to destroy the handle is via delete
		if (slot->Flags == HeapFlags::NonReferenceCounted)
			handleToInitialize.Flags = HandleFlags::NoReferenceCounting;

		// We are always guaranteed that the handle data is cleared before we get the user data portion
		HeapHandleData& data = *(HeapHandleData*)handleToInitialize.Data;
		data.Slot = slot;
		data.UniqueId = slot->UniqueId;
	}

	//***************************************************************************
	void HeapManager::Delete(const Handle& handle)
	{
		// Get the associated slot
		HeapHandleData& data = *(HeapHandleData*)handle.Data;
		ObjectSlot* slot = data.Slot;

		// Delete the data in the slot and null it out
		delete[] slot->Data;
		slot->Data = nullptr;

		// Set the next free slot on the executable state
		slot->NextFreeSlot = this->NextFreeSlot;
		this->NextFreeSlot = slot;

		// We freed an object, decrement the object count
		--this->ObjectCount;
	}

	//***************************************************************************
	bool HeapManager::CanDelete(const Handle& handle)
	{
		// Currently we can always delete heap handles
		return true;
	}

	//***************************************************************************
	void HeapManager::AddReference(const Handle& handle)
	{
		// Get the associated slot
		HeapHandleData& data = *(HeapHandleData*)handle.Data;
		ObjectSlot* slot = data.Slot;

		++slot->ReferenceCount;
	}

	//***************************************************************************
	ReleaseResult::Enum HeapManager::ReleaseReference(const Handle& handle)
	{
		// Get the associated slot
		HeapHandleData& data = *(HeapHandleData*)handle.Data;
		ObjectSlot* slot = data.Slot;

		--slot->ReferenceCount;

		// If the reference count reached zero, nobody else
		// knows about it so it's time to free this object!
		if (slot->ReferenceCount == 0)
		{
			// Return that the object must be deleted
			return ReleaseResult::DeleteObject;
		}
		else
		{
			// The decrementing of the reference didn't kill the object
			return ReleaseResult::KeepAlive;
		}
	}

	//***************************************************************************
	StackManager::StackManager(ExecutableState* state) :
		HandleManager(state)
	{
	}

	//***************************************************************************
	String StackManager::GetName()
	{
		static String Name("Stack Object");
		return Name;
	}

	//***************************************************************************
	void StackManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
	{
		Error("Allocating an object using a the StackObjectManager is not supported");
	}

	//***************************************************************************
	byte* StackManager::HandleToObject(const Handle& handle)
	{
		StackHandleData& data = *(StackHandleData*)handle.Data;
		ZilchTodo("We need to validate that this stack reference is valid, probably using per-frame data");
		return data.StackLocation;
	}

	//***************************************************************************
	void StackManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
	{
		StackHandleData& data = *(StackHandleData*)handleToInitialize.Data;
		data.StackLocation = const_cast<byte*>(object);
	}

	//***************************************************************************
	PointerManager::PointerManager(ExecutableState* state) :
		HandleManager(state)
	{
	}

	//***************************************************************************
	String PointerManager::GetName()
	{
		static String Name("Global Pointer");
		return Name;
	}

	//***************************************************************************
	byte* PointerManager::HandleToObject(const Handle& handle)
	{
		return *(byte**)handle.Data;
	}

	//***************************************************************************
	void PointerManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
	{
		Error("Allocating an object using a the PointerManager is not supported");
	}

	//***************************************************************************
	void PointerManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
	{
		handleToInitialize.Flags |= HandleFlags::NoReferenceCounting;
		*((const void**)handleToInitialize.Data) = object;
	}

	//***************************************************************************
	StringManager::StringManager(ExecutableState* state) :
		HandleManager(state)
	{
	}

	//***************************************************************************
	String StringManager::GetName()
	{
		static String Name("String");
		return Name;
	}

	//***************************************************************************
	byte* StringManager::HandleToObject(const Handle& handle)
	{
		// Interpret the user data as if it was the 'String' type
		return (byte*)(String*)handle.Data;
	}

	//***************************************************************************
	int StringManager::Hash(const Handle& handle)
	{
		// Every string has it's own hash value
		return (int)((String*)handle.Data)->hash();
	}

	//***************************************************************************
	void StringManager::Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags)
	{
		Error("Allocating an object using a the StringManager is not supported");
	}

	//***************************************************************************
	void StringManager::ObjectToHandle(const byte* object, Handle& handleToInitialize)
	{
		String& str = *(String*)object;
		new (handleToInitialize.Data) String(str);
	}

	//***************************************************************************
	bool StringManager::IsEqual
		(
		const Handle& handleLhs,
		const Handle& handleRhs,
		const byte* objectLhs,
		const byte* objectRhs
		)
	{
		// Get the two string nodes so we can compare them
		String& stringLhs = *(String*)objectLhs;
		String& stringRhs = *(String*)objectRhs;

		// Compare the two nodes, then compare the hash values and lengths, then directly compare the strings
		return stringLhs == stringRhs;
	}

	//***************************************************************************
	void StringManager::AddReference(const Handle& handle)
	{
		// Directly increment a refernece on the string node
		String& str = *(String*)handle.Data;
		String::StringNode* node = str.GetNode();
		node->addRef();
	}

	//***************************************************************************
	ReleaseResult::Enum StringManager::ReleaseReference(const Handle& handle)
	{
		// Directly decrement a refernece on the string node, delete it if it reaches 0
		String& str = *(String*)handle.Data;
		String::StringNode* node = str.GetNode();
		node->release();
		return ReleaseResult::Ignore;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	class HashMapUserData
	{
	public:
		HashMapUserData() :
			KeyType(nullptr),
			ValueType(nullptr)
		{
		}

		Type* KeyType;
		Type* ValueType;
	};

	//***************************************************************************
	void HashMapGetOrDefault(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// The first index is always the key, read that
		byte* keyData = call.GetParameterUnchecked(0);

		// The second index is a default value that gets returned when we fail to find the key
		byte* defaultValueData = call.GetParameterUnchecked(1);

		// Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
		Any key(keyData, userData.KeyType);

		Any* value = (*self).findPointer(key);

		// Get a pointer to the return value data (on the stack)
		byte* returnValue = call.GetReturnUnchecked();
		call.DisableReturnChecks();

		// If we found the value, copy it to the return, otherwise copy the default to the return
		if (value != nullptr)
			value->CopyStoredValueTo(returnValue);
		else
			userData.ValueType->GenericCopyConstruct(returnValue, defaultValueData);
	}

	//***************************************************************************
	void HashMapGetOrError(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// The first index is always the key, read that
		byte* keyData = call.GetParameterUnchecked(0);

		// Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
		Any key(keyData, userData.KeyType);

		Any* value = (*self).findPointer(key);

		if (value == nullptr)
		{
			call.GetState()->ThrowException(report, String::Format("The key '%s' was not found within the map", key.ToString().c_str()));
			return;
		}

		// Get a pointer to the return value data (on the stack)
		byte* returnValue = call.GetReturnUnchecked();
		call.DisableReturnChecks();

		// Generically copy the contained type to the return value
		value->CopyStoredValueTo(returnValue);
	}

	//***************************************************************************
	void HashMapContains(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// The first index is always the key, read that
		byte* keyData = call.GetParameterUnchecked(0);

		// Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
		Any key(keyData, userData.KeyType);

		bool containsKey = self->containsKey(key);
		call.Set(Call::Return, containsKey);
	}

	//***************************************************************************
	// Returns true if it overwrote the value, false otherwise
	void HashMapSetOrOverwrite(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// Read the first parameter as the key, and the second as the value
		byte* keyData = call.GetParameterUnchecked(0);
		byte* valueData = call.GetParameterUnchecked(1);

		// Construct an 'any' for the key and value
		Any key(keyData, userData.KeyType);
		Any value(valueData, userData.ValueType);

		bool keyExisted = (self->findPointer(key) != nullptr);

		// Insert the value into the map under that key
		(*self)[key] = value;

		call.Set<Boolean>(Call::Return, keyExisted);
	}

	//***************************************************************************
	// Returns true if it set the value, false otherwise
	void HashMapSetOrIgnore(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// Read the first parameter as the key, and the second as the value
		byte* keyData = call.GetParameterUnchecked(0);
		byte* valueData = call.GetParameterUnchecked(1);

		// Construct an 'any' for the key and value
		Any key(keyData, userData.KeyType);
		Any value(valueData, userData.ValueType);

		bool noKeyDoInsert = (self->findPointer(key) == nullptr);

		// Insert the value into the map under that key only if one doesn't already exist
		if (noKeyDoInsert)
			(*self)[key] = value;

		call.Set<Boolean>(Call::Return, noKeyDoInsert);
	}

	//***************************************************************************
	void HashMapSetOrError(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// Read the first parameter as the key, and the second as the value
		byte* keyData = call.GetParameterUnchecked(0);
		byte* valueData = call.GetParameterUnchecked(1);

		// Construct an 'any' for the key and value
		Any key(keyData, userData.KeyType);
		Any value(valueData, userData.ValueType);

		// Insert the value into the map under that key only if one doesn't already exist
		if (Any* foundValue = self->findPointer(key))
		{
			String message = String::Format("The key '%s' already existed within the map with a value of '%s'", key.ToString().c_str(), foundValue->ToString().c_str());
			call.GetState()->ThrowException(report, message);
			return;
		}

		// Actually insert the value into the map
		(*self)[key] = value;
	}

	//***************************************************************************
	void HashMapRemoveOrError(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// The first index is always the key, read that
		byte* keyData = call.GetParameterUnchecked(0);

		// Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
		Any key(keyData, userData.KeyType);

		Any* value = (*self).findPointer(key);

		if (value == nullptr)
		{
			call.GetState()->ThrowException(report, String::Format("The key '%s' was not found within the map", key.ToString().c_str()));
			return;
		}

		(*self).erase(key);
	}

	//***************************************************************************
	// Returns true if the key was removed, false otherwise
	void HashMapRemoveOrIgnore(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		HashMapUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<HashMapUserData>(0);

		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// The first index is always the key, read that
		byte* keyData = call.GetParameterUnchecked(0);

		// Construct an 'any' (we can avoid this step if we use a special finder, but who cares for right now)
		Any key(keyData, userData.KeyType);

		Any* value = (*self).findPointer(key);

		bool foundValueToRemove = (value != nullptr);

		if (foundValueToRemove)
			(*self).erase(key);

		call.Set<Boolean>(Call::Return, foundValueToRemove);
	}

	//***************************************************************************
	void HashMapClear(Call& call, ExceptionReport& report)
	{
		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// Just clear the map, pretty simple!
		self->clear();
	}

	//***************************************************************************
	void HashMapGetCount(Call& call, ExceptionReport& report)
	{
		// Get ourselves (the hash map)
		AnyHashMap* self = (AnyHashMap*)call.GetHandle(Call::This).Dereference();

		// Return the size of the hash map (how many elements are in it)
		call.Set(Call::Return, (Integer)self->size());
	}

	//***************************************************************************
	BoundType* Core::InstantiateHashMap
		(
		LibraryBuilder& builder,
		StringParam baseName,
		StringParam fullyQualifiedName,
		const Array<Type*>& templateTypes,
		const void* userData
		)
	{
		// Error checking
		ErrorIf(templateTypes.size() != 2,
			"The HashMap template should only take two template arguments");

		// Get the key and value types for the hash map
		Type* keyType = templateTypes[0];
		Type* valueType = templateTypes[1];

		// We could have put core in our userdata, but no real need
		Core& core = Core::GetInstance();

		//StringBuilder rangeName;
		//rangeName.Append("ArrayRange[");
		//rangeName.Append(containedType->ToString());
		//rangeName.Append("]");

		//String fullyQualifiedRangeName = rangeName.ToString();
		//
		//ZilchTodo("The range type must have a valid destructor the decrements the reference count on the 'array' handle");
		//BoundType* rangeType = builder.AddBoundType(fullyQualifiedRangeName, TypeCopyMode::ReferenceType, sizeof(ArrayRangeTemplate));

		// Create the array type instance (arrays and any other containers should be reference types!)
		BoundType* containerType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(AnyHashMap));

		HashMapUserData containerUserData;
		containerUserData.KeyType = keyType;
		containerUserData.ValueType = valueType;
		containerType->ComplexUserData.WriteObject(containerUserData);

		Function* f = nullptr;
		Property* p = nullptr;

		// Bind the constructor and destructor of that type
		ZilchBindCustomConstructor(builder, containerType, AnyHashMap);
		ZilchBindCustomDestructor(builder, containerType, AnyHashMap);

		ParameterArray keyOnlyParameters = OneParameter(keyType, "key");
		ParameterArray setParameters = TwoParameters(keyType, "key", valueType, "value");

		// Add the constructor
		builder.AddBoundFunction(containerType, "GetOrDefault", HashMapGetOrDefault, TwoParameters(keyType, "key", valueType, "defaultValue"), valueType, FunctionOptions::None);
		builder.AddBoundFunction(containerType, "GetOrError", HashMapGetOrError, keyOnlyParameters, valueType, FunctionOptions::None);

		builder.AddBoundFunction(containerType, "Contains", HashMapContains, keyOnlyParameters, core.BooleanType, FunctionOptions::None);

		builder.AddBoundFunction(containerType, "SetOrOverwrite", HashMapSetOrOverwrite, setParameters, core.BooleanType, FunctionOptions::None);
		builder.AddBoundFunction(containerType, "SetOrIgnore", HashMapSetOrIgnore, setParameters, core.BooleanType, FunctionOptions::None);
		builder.AddBoundFunction(containerType, "SetOrError", HashMapSetOrError, setParameters, core.VoidType, FunctionOptions::None);

		// This is to support the initializer interface
		builder.AddBoundFunction(containerType, "Add", HashMapSetOrError, setParameters, core.VoidType, FunctionOptions::None);

		builder.AddBoundFunction(containerType, "RemoveOrError", HashMapRemoveOrError, keyOnlyParameters, core.VoidType, FunctionOptions::None);
		builder.AddBoundFunction(containerType, "RemoveOrIgnore", HashMapRemoveOrIgnore, keyOnlyParameters, core.BooleanType, FunctionOptions::None);

		builder.AddBoundFunction(containerType, "Clear", HashMapClear, ParameterArray(), core.VoidType, FunctionOptions::None);

		builder.AddBoundProperty(containerType, "Count", core.IntegerType, nullptr, HashMapGetCount, MemberOptions::None);

		//p = builder.AddBoundProperty(arrayType, "All", rangeType, nullptr, ArrayAll, MemberOptions::None);
		//p->Get->ComplexUserData.WriteObject(arrayUserData);

		//builder.AddBoundConstructor(rangeType, ArrayRangeConstructor, ParameterArray());
		//builder.AddBoundDestructor(rangeType, ArrayRangeDestructor);

		//builder.AddBoundFunction(rangeType, "MoveNext", ArrayRangeMoveNext, ParameterArray(), core.VoidType, FunctionOptions::None);
		//builder.AddBoundFunction(rangeType, "Reset", ArrayRangeReset, ParameterArray(), core.VoidType, FunctionOptions::None);

		//p = builder.AddBoundProperty(rangeType, "Current", containedType, nullptr, ArrayRangeCurrent, MemberOptions::None);
		//p->Get->ComplexUserData.WriteObject(arrayUserData);

		//builder.AddBoundProperty(rangeType, "IsEmpty", core.BooleanType, nullptr, ArrayRangeIsEmpty, MemberOptions::None);
		//builder.AddBoundProperty(rangeType, "IsNotEmpty", core.BooleanType, nullptr, ArrayRangeIsNotEmpty, MemberOptions::None);
		//builder.AddBoundProperty(rangeType, "All", rangeType, nullptr, ArrayRangeAll, MemberOptions::None);

		// Return the array type we instantiated
		return containerType;
	}

	//***************************************************************************
	class KeyValueUserData
	{
	public:
		KeyValueUserData() :
			KeyType(nullptr),
			ValueType(nullptr)
		{
		}

		Type* KeyType;
		Type* ValueType;
	};

	//***************************************************************************
	void KeyValueConstructor(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

		// Get ourselves (the key-value pair)
		byte* selfData = call.GetHandle(Call::This).Dereference();

		AnyKeyValue* self = new (selfData)AnyKeyValue();

		self->first.DefaultConstruct(userData.KeyType);
		self->second.DefaultConstruct(userData.ValueType);
	}

	//***************************************************************************
	void KeyValueGetKey(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

		// Get ourselves (the key-value pair)
		AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

		// Get a pointer to the return value data (on the stack)
		byte* returnValue = call.GetReturnUnchecked();
		call.DisableReturnChecks();

		// Copy the key to the stack (in the return place)
		self->first.CopyStoredValueTo(returnValue);
	}

	//***************************************************************************
	void KeyValueSetKey(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

		// Get ourselves (the key-value pair)
		AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

		// Grab the first parameter and set our key to it
		byte* newKeyData = call.GetParameterUnchecked(0);
		self->first.AssignFrom(newKeyData, userData.KeyType);
	}

	//***************************************************************************
	void KeyValueGetValue(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

		// Get ourselves (the key-value pair)
		AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

		// Get a pointer to the return value data (on the stack)
		byte* returnValue = call.GetReturnUnchecked();
		call.DisableReturnChecks();

		// Copy the value to the stack (in the return place)
		self->second.CopyStoredValueTo(returnValue);
	}

	//***************************************************************************
	void KeyValueSetValue(Call& call, ExceptionReport& report)
	{
		// The user data contains information about the types used in the hash map
		KeyValueUserData& userData = call.GetFunction()->Owner->ComplexUserData.ReadObject<KeyValueUserData>(0);

		// Get ourselves (the key-value pair)
		AnyKeyValue* self = (AnyKeyValue*)call.GetHandle(Call::This).Dereference();

		// Grab the first parameter and set our value to it
		byte* newValueData = call.GetParameterUnchecked(0);
		self->second.AssignFrom(newValueData, userData.ValueType);
	}

	//***************************************************************************
	BoundType* Core::InstantiateKeyValue
		(
		LibraryBuilder& builder,
		StringParam baseName,
		StringParam fullyQualifiedName,
		const Array<Type*>& templateTypes,
		const void* userData
		)
	{
		// Error checking
		ErrorIf(templateTypes.size() != 2,
			"The KeyValue template should only take two template arguments");

		// Get the key and value types for the hash map
		Type* keyType = templateTypes[0];
		Type* valueType = templateTypes[1];

		// Create the pair type instance
		BoundType* newType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ReferenceType, sizeof(AnyKeyValue));

		KeyValueUserData newUserData;
		newUserData.KeyType = keyType;
		newUserData.ValueType = valueType;
		newType->ComplexUserData.WriteObject(newUserData);

		// Bind the constructor and destructor of that type
		builder.AddBoundDefaultConstructor(newType, KeyValueConstructor);
		ZilchBindCustomDestructor(builder, newType, AnyKeyValue);

		builder.AddBoundProperty(newType, "Key", keyType, KeyValueSetKey, KeyValueGetKey, MemberOptions::None);
		builder.AddBoundProperty(newType, "Value", valueType, KeyValueSetValue, KeyValueGetValue, MemberOptions::None);

		return newType;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	const BoundFn LibraryBuilder::DoNotGenerate = (BoundFn)0x01;
	const BoundFn LibraryBuilder::NoOperation = (BoundFn)0x02;

	//***************************************************************************
	String InstantiateTemplateInfo::GetFullName(const Array<Type*>& templateArguments)
	{
		// Create a string builder to build the template name
		StringBuilder builder;

		// Start with the base name, eg 'Array'
		builder.Append(this->BaseName);

		// Use the template bracket
		builder.Append('[');

		// Loop through the arguments and append the argument type names
		for (size_t i = 0; i < templateArguments.size(); ++i)
		{
			// Append the argument type name
			builder.Append(templateArguments[i]->ToString());

			// Figure out whether we're at the end of the list or not
			bool isNotAtEnd = (i != templateArguments.size() - 1);

			// As long as we aren't at the end of the list...
			if (isNotAtEnd)
			{
				// Add an argument separator between the template types
				builder.Append(", ");
			}
		}

		// Close the template bracket
		builder.Append(']');

		// Return the name
		return builder.ToString();
	}

	//***************************************************************************
	GuidType DelegateTypePolicy::operator() (DelegateType* type)
	{
		return type->Hash();
	}

	//***************************************************************************
	bool DelegateTypePolicy::equal(DelegateType* a, DelegateType* b)
	{
		// Make sure we have the same number of parameters
		if (a->Parameters.size() != b->Parameters.size())
			return false;

		// Make sure the returns are the same type (or non existant type for none)
		if (a->Return != b->Return)
			return false;

		// Loop through and compare each of the parameters
		for (size_t i = 0; i < a->Parameters.size(); ++i)
		{
			// Grab the two parameters
			const DelegateParameter& aParameter = a->Parameters[i];
			const DelegateParameter& bParameter = b->Parameters[i];

			// Compare the types
			if (aParameter.ParameterType != bParameter.ParameterType)
				return false;

			// Compare the names
			if (aParameter.Name != bParameter.Name)
				return false;
		}

		// If we got here, then it must match!
		return true;
	}

	//***************************************************************************
	LibraryBuilder::LibraryBuilder(String name) :
		UserData(nullptr)
	{
		// Start out by creating a new library that we'll populate
		this->BuiltLibrary = LibraryRef(new Library());
		this->BuiltLibrary->Name = name;
	}

	//***************************************************************************
	String LibraryBuilder::GetName()
	{
		return this->BuiltLibrary->Name;
	}

	//***************************************************************************
	Function* LibraryBuilder::AddBoundFunction
		(
		BoundType* owner,
		String name,
		BoundFn function,
		const ParameterArray& parameters,
		Type* returnType,
		FunctionOptions::Flags options,
		NativeVirtualInfo nativeVirtual
		)
	{
		// First add a raw function to the library
		Function* func = this->CreateRawFunction(owner, name, function, parameters, returnType, options, nativeVirtual);

		// If the function is valid...
		if (func != nullptr)
		{
			// Add the function to the bound type
			owner->AddRawFunction(func);
		}

		// Return the function that was created
		return func;
	}

	//***************************************************************************
	Function* LibraryBuilder::AddExtensionFunction
		(
		BoundType* forType,
		String name,
		BoundFn function,
		const ParameterArray& parameters,
		Type* returnType,
		FunctionOptions::Flags options
		)
	{
		// First add a raw function to the library
		Function* func = this->CreateRawFunction(forType, name, function, parameters, returnType, options);

		// If the function is valid...
		if (func != nullptr)
		{
			// Get the guid for the type that we're extending
			GuidType guid = forType->Hash();

			// Store the extension map (could be static or instance)
			FunctionMultiMap* overloadedFunctionsByName = nullptr;

			// Add the property to the library extension map
			if (options & FunctionOptions::Static)
			{
				overloadedFunctionsByName = &this->BuiltLibrary->StaticExtensionFunctions[guid];
			}
			else
			{
				overloadedFunctionsByName = &this->BuiltLibrary->InstanceExtensionFunctions[guid];
			}

			// Get the array of overloaded functions
			FunctionArray& overloads = (*overloadedFunctionsByName)[name];

			// Add the property to the named map
			overloads.push_back(func);
		}

		// Return the function that was created
		return func;
	}

	//***************************************************************************
	Function* LibraryBuilder::AddBoundPreConstructor(BoundType* owner, BoundFn function)
	{
		// Error checking
		ErrorIf(owner->PreConstructor != nullptr,
			"A type cannot have two pre-constructors! A pre-constructor is a simple "
			"initializer (like memset) that runs before any constructors get run");

		// First add a raw function to the library
		Function* func = this->CreateRawPreConstructor(owner, function);

		// If the function is valid...
		if (func != nullptr)
		{
			// Add the function to the bound type
			owner->PreConstructor = func;
		}

		// Return the function that was created
		return func;
	}

	//***************************************************************************
	Function* LibraryBuilder::AddBoundConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters)
	{
		// First add a raw function to the library
		Function* func = this->CreateRawConstructor(owner, function, parameters);

		// If the function is valid...
		if (func != nullptr)
		{
			// Add the function to the bound type
			owner->Constructors.push_back(func);
		}

		// Return the function that was created
		return func;
	}

	//***************************************************************************
	Function* LibraryBuilder::AddBoundDefaultConstructor(BoundType* owner, BoundFn function)
	{
		// First add a raw function to the library
		Function* func = this->CreateRawDefaultConstructor(owner, function);

		// If the function is valid...
		if (func != nullptr)
		{
			// Add the function to the bound type
			owner->Constructors.push_back(func);
		}

		// Return the function that was created
		return func;
	}

	//***************************************************************************
	Function* LibraryBuilder::AddBoundDestructor(BoundType* owner, BoundFn function)
	{
		// Error checking
		ErrorIf(owner->Destructor != nullptr,
			"A type cannot have two destructors! A destructor is a function "
			"that is responsible for cleaning up after an object.");

		// First add a raw function to the library
		Function* func = this->CreateRawDestructor(owner, function);

		// If the function is valid...
		if (func != nullptr)
		{
			// Make sure the user doesn't define two destructors
			ErrorIf(owner->Destructor != nullptr,
				"A class may only have one destructor");

			// Add the function to the bound type
			owner->Destructor = func;
		}

		// Return the function that was created
		return func;
	}

	//***************************************************************************
	Property* LibraryBuilder::AddBoundProperty(BoundType* owner, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options)
	{
		// First add a raw property to the library
		Property* property = this->CreateRawProperty(owner, name, type, set, get, options);

		// If the property is valid...
		if (property != nullptr)
		{
			// Add the property to the bound type
			owner->AddRawProperty(property);

			// Make sure to add the getter function to the bound functions list
			if (property->Get != nullptr)
				owner->AddRawFunction(property->Get);

			// Make sure to add the setter function to the bound functions list
			if (property->Set != nullptr)
				owner->AddRawFunction(property->Set);
		}

		// Return the property that was created
		return property;
	}

	//***************************************************************************
	InstantiatedTemplate LibraryBuilder::InstantiateTemplate(StringParam baseName, const Array<Type*>& arguments, const LibraryArray& fromLibraries)
	{
		// What we'll return to the user
		InstantiatedTemplate result;

		// Assume we failed because we couldn't find anything of the same name
		result.Result = TemplateResult::FailedNameNotFound;

		// Loop through all of our dependent libraries
		for (size_t i = 0; i < fromLibraries.size(); ++i)
		{
			// Get the current dependent library
			const LibraryRef& library = fromLibraries[i];

			// Get a pointer (or null) to the callback delegate
			InstantiateTemplateInfo* info = library->TemplateHandlers.findPointer(baseName);

			// If there is a template by that name...
			if (info != nullptr)
			{
				// If the number of arguments is valid
				if (arguments.size() != info->TemplateArgumentNames.size())
				{
					// Fail out because the user provided an invalid number of arguments
					result.Result = TemplateResult::FailedInvalidArgumentCount;
					result.ExpectedArguments = info->TemplateArgumentNames.size();
					return result;
				}

				// Get a reference to the delegate for convenience
				InstantiateTemplateDelegate& delegate = info->Delegate;

				// Get the fully qualified name
				String fullyQualifiedTemplateName = info->GetFullName(arguments);

				// Check to see if we already have this type...
				result.Type = this->BoundTypes.findValue(fullyQualifiedTemplateName, nullptr);

				// If we didn't find the type (it was not yet instantiated)
				if (result.Type == nullptr)
				{
					// Invoke the callback to instantiate the type
					result.Type = delegate.Callback(*this, baseName, fullyQualifiedTemplateName, arguments, delegate.UserData);

					// If we found the created type
					if (result.Type != nullptr)
					{
						// We sucessfully instantiated a template
						result.Result = TemplateResult::Success;

						// Error checking
						ErrorIf(result.Type->Name != fullyQualifiedTemplateName,
							"The template instantiator needs to create a type with the given fully qualified name");
					}
					else
					{
						// We performed the callback, but got no type back
						result.Result = TemplateResult::FailedInstantiatorDidNotReturnType;
					}
				}
				else
				{
					// We sucessfully found a template
					result.Result = TemplateResult::Success;
				}

				// We found the instantiator and attempted to use it, so break out!
				break;
			}
		}

		// Return the result with the type or an error
		return result;
	}

	//***************************************************************************
	Property* LibraryBuilder::AddExtensionProperty(BoundType* forType, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options)
	{
		// First add a raw property to the library
		Property* property = this->CreateRawProperty(forType, name, type, set, get, options);

		// If the property is valid...
		if (property != nullptr)
		{
			// Get the guid for the type that we're extending
			GuidType guid = forType->Hash();

			// Store the extension map (could be static or instance)
			PropertyMap* propertiesByName = nullptr;

			// We also need to get the function extension map so we can add the getter and setter functions
			// Technically these functions aren't referencable, except if native code looks them up (just to be proper!)
			FunctionMultiMap* functionsByName = nullptr;

			// Add the property to the library extension map
			if (options & FunctionOptions::Static)
			{
				propertiesByName = &this->BuiltLibrary->StaticExtensionProperties[guid];
				functionsByName = &this->BuiltLibrary->StaticExtensionFunctions[guid];
			}
			else
			{
				propertiesByName = &this->BuiltLibrary->InstanceExtensionProperties[guid];
				functionsByName = &this->BuiltLibrary->InstanceExtensionFunctions[guid];
			}

			// Add the property to the named map
			propertiesByName->insertOrError(name, property,
				String::Format("Another property with the same name (%s) was added to the extension methods map for type (%s), "
				"or two types came out with the same guid (which would be bad)",
				name.c_str(), forType->Name.c_str()).c_str());

			// Make sure to add the getter function to the bound functions list
			if (property->Get != nullptr)
				(*functionsByName)[property->Get->Name].push_back(property->Get);

			// Make sure to add the setter function to the bound functions list
			if (property->Set != nullptr)
				(*functionsByName)[property->Set->Name].push_back(property->Set);
		}

		// Return the property that was created
		return property;
	}

	//***************************************************************************
	Field* LibraryBuilder::AddBoundField(BoundType* owner, String name, Type* type, size_t offset, MemberOptions::Flags options)
	{
		// First add a raw field to the library
		Field* field = this->CreateRawField(owner, name, type, offset, options);

		// If the field is valid...
		if (field != nullptr)
		{
			// Add the field to the bound type
			owner->AddRawField(field);
		}

		// Return the field that was created
		return field;
	}

	//***************************************************************************
	Function* LibraryBuilder::CreateRawFunction
		(
		BoundType* owner,
		String name,
		BoundFn boundFunction,
		const ParameterArray& parameters,
		Type* returnType,
		FunctionOptions::Flags options,
		NativeVirtualInfo nativeVirtual
		)
	{
		// Verify that the name is correct
		//CheckIdentifier(name, TokenCheck::IsUpper | TokenCheck::Asserts);

		// Error checking for our owner type
		ReturnIf(owner == nullptr, nullptr, "The owner must never be null");

		// Error checking for the native virtual calls
		if (nativeVirtual.Validate() == false)
			return nullptr;

		// Create the actual function we use for the compiler
		// Note that we leave the source library as not set,
		// because the library has yet to be built
		Function* function = new Function();
		function->Name = name;
		function->BoundFunction = boundFunction;
		function->Owner = owner;

		// Setup any native virtual behavior
		function->NativeVirtual = nativeVirtual;

		// If the user is creating a native virtual function...
		if (nativeVirtual.Index != NativeVirtualInfo::NonVirtual)
		{
			// Just make sure the user marked this function as virtual, just for consistency
			ErrorIf((options & FunctionOptions::Virtual) == 0,
				"The FunctionOptions::Virtual flag must be set when creating a native virtual function");
			options |= FunctionOptions::Virtual;
		}

		// If the function is virtual...
		if (options & FunctionOptions::Virtual)
		{
			// The function cannot also be static
			ErrorIf((options & FunctionOptions::Static) != 0,
				"Static functions cannot be marked as virtual");

			// Mark the function as being virtual
			function->IsVirtual = true;
		}

		// Create a delegate type for the function
		function->Type = this->GetDelegateType(parameters, returnType);

		// If the function is static (we have no 'this' reference)
		if (options & FunctionOptions::Static)
		{
			// Otherwise, the this pointer is null since it's a static method
			function->This = nullptr;
		}
		else
		{
			// Create a variable for the this pointer
			Variable* thisVariable = this->CreateRawVariable(function, ThisKeyword);
			thisVariable->ResultType = this->ToHandleType(owner);
			function->This = thisVariable;
		}

		// For how we give parameter positions, check CodeGenerator.cpp around line 233
		// Returns go at the beginning, parameters go after returns, and the
		// this handle (if it exists) goes after the parameters

		// Clear the required stack space
		function->RequiredStackSpace = function->Type->TotalStackSizeExcludingThisHandle;

		// If the function has a this handle
		if (function->This != nullptr)
		{
			// The this handle is the last parameter (after the returns and the parameters)
			function->This->Local = (OperandLocal)function->Type->ThisHandleStackOffset;

			// Add the size of the this handle
			function->RequiredStackSpace += function->This->ResultType->GetCopyableSize();
		}

		// Push the function into a list
		this->BuiltLibrary->OwnedFunctions.push_back(function);

		// Return the created function
		return function;
	}

	//***************************************************************************
	Function* LibraryBuilder::CreateRawPreConstructor(BoundType* owner, BoundFn function)
	{
		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// Create the function
		return this->CreateRawFunction(owner, PreConstructorName, function, ParameterArray(), core.VoidType, FunctionOptions::None);
	}

	//***************************************************************************
	Function* LibraryBuilder::CreateRawConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters)
	{
		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// Create the function
		return this->CreateRawFunction(owner, ConstructorName, function, parameters, core.VoidType, FunctionOptions::None);
	}

	//***************************************************************************
	Function* LibraryBuilder::CreateRawDefaultConstructor(BoundType* owner, BoundFn function)
	{
		return this->CreateRawConstructor(owner, function, ParameterArray());
	}

	//***************************************************************************
	Function* LibraryBuilder::CreateRawDestructor(BoundType* owner, BoundFn function)
	{
		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// Create the function
		return this->CreateRawFunction(owner, DestructorName, function, ParameterArray(), core.VoidType, FunctionOptions::None);
	}

	//***************************************************************************
	Property* LibraryBuilder::CreateRawProperty(BoundType* owner, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options)
	{
		// Verify that the name is correct
		CheckIdentifier(name, TokenCheck::IsUpper | TokenCheck::Asserts);

		// Create the property
		Property* property = new Property();
		property->Owner = owner;

		// Pass it to the library so it can delete the property
		this->BuiltLibrary->OwnedProperties.push_back(property);

		// Set the name of the property
		property->Name = name;

		// Set the type of the property
		property->PropertyType = type;

		// The functions are always positional
		FunctionOptions::Flags functionOptions = FunctionOptions::None;

		// If we are adding a static property
		if (options & MemberOptions::Static)
		{
			// Set this property as static (and any functions we generate as static)
			property->IsStatic = true;
			functionOptions |= FunctionOptions::Static;
		}

		// We must have at least a get or a set (or both)
		if (get != nullptr || set != nullptr)
		{
			// Check if we were given a get function
			if (get != nullptr && get != DoNotGenerate)
			{
				// Generate the get function
				property->Get = this->CreateRawFunction
					(
					owner,
					BuildGetterName(name),
					get,
					ParameterArray(),
					type,
					functionOptions
					);
				property->Get->IsHidden = true;
				property->Get->IsPropertyGetOrSet = true;
			}

			// Check if we were given a set function
			if (set != nullptr && set != DoNotGenerate)
			{
				// The set takes a single parameter
				ParameterArray parameters;
				DelegateParameter& value = parameters.push_back();
				value.Name = ValueKeyword;
				value.ParameterType = type;

				// Get a reference to the core so we can get the void type (setters have no return value)
				Core& core = Core::GetInstance();

				// Generate the set function
				property->Set = this->CreateRawFunction
					(
					owner,
					BuildSetterName(name),
					set,
					parameters,
					core.VoidType,
					functionOptions
					);
				property->Set->IsHidden = true;
				property->Set->IsPropertyGetOrSet = true;
			}
		}
		else
		{
			Error("Properties must have at least a getter or a setter (or both).");
		}

		// Return a reference to the property
		return property;
	}

	//***************************************************************************
	const String& LibraryBuilder::AddStringLiteral(cstr text)
	{
		this->BuiltLibrary->StringLiterals.push_back(text);
		return this->BuiltLibrary->StringLiterals.back();
	}

	//***************************************************************************
	const String& LibraryBuilder::AddStringLiteral(const String& text)
	{
		this->BuiltLibrary->StringLiterals.push_back(text);
		return this->BuiltLibrary->StringLiterals.back();
	}

	//***************************************************************************
	const String& LibraryBuilder::AddStringLiteral(StringRange text)
	{
		this->BuiltLibrary->StringLiterals.push_back(text);
		return this->BuiltLibrary->StringLiterals.back();
	}

	//***************************************************************************
	void FieldSetter(Call& call, ExceptionReport& report)
	{
		// Get the field and its offset
		Field* field = (Field*)call.GetFunction()->UserData;

		// Grab a handle to the this object and dereference it
		Handle& handle = call.GetHandle(Call::This);
		byte* memory = handle.Dereference();

		// Get the memory offsetted to the field
		byte* fieldMemory = memory + field->Offset;

		// Get a direct pointer to the parameter (could be a primitive, such as a handle)
		byte* parameterMemory = call.GetParameterUnchecked(0);

		// Generically destruct the existing field (release reference, etc) the current parameter's memory
		field->PropertyType->GenericDestruct(fieldMemory);

		// Now copy construct the parameter they are trying to set over the field memory
		field->PropertyType->GenericCopyConstruct(fieldMemory, parameterMemory);
	}

	//***************************************************************************
	void FieldGetter(Call& call, ExceptionReport& report)
	{
		// Get the field and its offset
		Field* field = (Field*)call.GetFunction()->UserData;

		// Grab a handle to the this object and dereference it
		Handle& handle = call.GetHandle(Call::This);
		byte* memory = handle.Dereference();

		// Get the memory offsetted to the field
		byte* fieldMemory = memory + field->Offset;

		// Get a direct pointer to the return (not initialized yet!)
		byte* returnMemory = call.GetReturnUnchecked();
		call.DisableReturnChecks();

		// Now copy construct the parameter they are trying to set over the field memory
		field->PropertyType->GenericCopyConstruct(returnMemory, fieldMemory);
	}

	//***************************************************************************
	Field* LibraryBuilder::CreateRawField(BoundType* owner, String name, Type* type, size_t offset, MemberOptions::Flags options)
	{
		// Verify that the name is correct
		CheckIdentifier(name, TokenCheck::IsUpper | TokenCheck::Asserts);

		// Create the member
		Field* field = new Field();
		field->Owner = owner;

		// Pass it to the library so it can delete the member
		this->BuiltLibrary->OwnedProperties.push_back(field);

		// Set the name of the member
		field->Name = name;

		// Set the type of the member
		field->PropertyType = type;

		// Set whether or not the member is static (accessed on a class or instance)
		field->IsStatic = (options & MemberOptions::Static) != 0;

		// Set the member's offset to the given offset
		field->Offset = offset;

		// Return a reference to the member
		return field;
	}

	//***************************************************************************
	Variable* LibraryBuilder::CreateRawVariable(Function* function, String name)
	{
		// Create the variable and set it's name
		Variable* variable = new Variable();
		variable->Name = name;

		// Pass it to the library so it can delete the member
		this->BuiltLibrary->OwnedVariables.push_back(variable);

		// Also add it to the function (so it can be debugged easily)
		function->Variables.push_back(variable);

		// Return the created variable
		return variable;
	}

	//***************************************************************************
	void LibraryBuilder::AddTemplateInstantiator(StringParam baseName, InstantiateTemplateCallback callback, StringArray& templateArgumentNames, void* userData)
	{
		// Create the delegate that we will call
		InstantiateTemplateInfo info;
		info.Delegate.Callback = callback;
		info.Delegate.UserData = userData;
		info.TemplateArgumentNames = templateArgumentNames;
		info.BaseName = baseName;

		// Perform the callback
		this->BuiltLibrary->TemplateHandlers.insertOrError(baseName, info,
			String::Format("Another template instantiator of the same name (%s) was added to the Library Builder.",
			baseName.c_str()).c_str());
	}

	//***************************************************************************
	BoundType* LibraryBuilder::AddBoundType(String name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount)
	{
		// Create a new bound type with the given name / size
		BoundType* type = new BoundType(name, copyMode, size, nativeVirtualCount);

		// Add the created type to this library
		this->AddRawBoundType(type);

		// Return the created type
		return type;
	}

	//***************************************************************************
	void LibraryBuilder::AddRawBoundType(BoundType* type)
	{
		// Make sure to store a strong reference, since we now own the type
		this->BuiltLibrary->OwnedTypes.push_back(type);

		// Map the bound type's name to its type object
		this->BoundTypes.insertOrError(type->Name, type,
			String::Format("Another type with the same name (%s) was added to the LibraryBuilder.",
			type->Name.c_str()).c_str());
	}

	//***************************************************************************
	BoundType* LibraryBuilder::FindBoundType(String name)
	{
		return this->BoundTypes.findValue(name, nullptr);
	}

	//***************************************************************************
	void LibraryBuilder::GenerateGetSetFields()
	{
		// Grab a reference to the library for convenience
		LibraryRef library = this->BuiltLibrary;

		// Loop through all the fields
		for (size_t i = 0; i < library->OwnedProperties.size(); ++i)
		{
			// If the current property is a field...
			Field* field = TypeBinding::DynamicCast<Field*>(library->OwnedProperties[i]);
			if (field == nullptr)
				continue;

			// Function options for the getter and setter
			// In the future, this may be virtual too
			FunctionOptions::Enum functionOptions = FunctionOptions::None;

			// If the member is static, then the getter and setter are static too
			if (field->IsStatic)
				functionOptions = FunctionOptions::Static;

			// If we don't have a get function yet...
			if (field->Get == nullptr)
			{
				// Generate the get function
				field->Get = this->CreateRawFunction
					(
					field->Owner,
					BuildGetterName(field->Name),
					FieldGetter,
					ParameterArray(),
					field->PropertyType,
					functionOptions
					);
				field->Get->IsHidden = true;
				field->Get->IsPropertyGetOrSet = true;

				// The userdata for the getter and setter is just the original field
				// This works out well because in the Syntaxer, we defer the computation of offset
				// This way, we don't need to know the offset (the field will be updated!)
				field->Get->UserData = field;
				field->Owner->AddRawFunction(field->Get);
			}

			// If we don't have a get function yet...
			if (field->Set == nullptr)
			{
				// Generate the set function
				field->Set = this->CreateRawFunction
					(
					field->Owner,
					BuildSetterName(field->Name),
					FieldSetter,
					OneParameter(field->PropertyType, ValueKeyword),
					ZilchTypeId(void),
					functionOptions
					);
				field->Set->IsHidden = true;
				field->Set->IsPropertyGetOrSet = true;

				// The userdata for the getter and setter is just the original field
				// This works out well because in the Syntaxer, we defer the computation of offset
				// This way, we don't need to know the offset (the field will be updated!)
				field->Set->UserData = field;
				field->Owner->AddRawFunction(field->Set);
			}
		}
	}

	//***************************************************************************
	bool LibraryBuilder::CheckIdentifier(StringParam identifier, TokenCheck::Flags flags)
	{
		// Should we be asserting in this function?
		bool asserts = (flags & TokenCheck::Asserts) != 0;

		// Check the length of the identifier
		if (identifier.empty())
		{
			// The identifier is too short
			ErrorIf(asserts, "The identifier must be at least one character in length!");
			return false;
		}
		else
		{
			// Get the first and last character
			char first = identifier.front();
			char last = identifier.back();

			// Check if this is a special identifier
			if (first == '[' && last == ']')
			{
				// It doesn't matter what comes in between, this is special (hidden effectively)
				return true;
			}

			// Make sure the first character is alpha uppercase
			if (CharacterUtilities::IsAlpha(first) == false || (flags & TokenCheck::IsUpper && CharacterUtilities::IsUpper(first)) == false)
			{
				// The first character of the identifier was bad
				if (flags & TokenCheck::IsUpper)
				{
					ErrorIf(asserts, "The first character must be uppercase [A-Z]");
				}
				else
				{
					ErrorIf(asserts, "The first character must be lowercase [a-z]");
				}
				return false;
			}

			// Verify that the rest of the characters are valid
			for (size_t i = 1; i < identifier.size(); ++i)
			{
				// Make sure each character is only alpha-numeric
				if (CharacterUtilities::IsAlphaNumeric(identifier[i]) == false && identifier[i] != '_')
				{
					// The identifier contains a bad character
					ErrorIf(asserts, "Every character in the identifier must be either a letter, number, or underscore (no other symbols)");
					return false;
				}
			}
		}

		// We got here, we must have been successful
		return true;
	}

	//***************************************************************************
	bool LibraryBuilder::CheckUpperIdentifier(String identifier)
	{
		return CheckIdentifier(identifier, TokenCheck::IsUpper);
	}

	//***************************************************************************
	bool LibraryBuilder::CheckLowerIdentifier(String identifier)
	{
		return CheckIdentifier(identifier, TokenCheck::None);
	}

	//***************************************************************************
	void LibraryBuilder::SetEntries(const Array<CodeEntry>& entries)
	{
		this->BuiltLibrary->Entries = entries;
	}

	//***************************************************************************
	LibraryRef LibraryBuilder::CreateLibrary()
	{
		// Grab a reference to the library for convenience
		LibraryRef library = this->BuiltLibrary;

		// Generate getters and setters for any field that hasn't already been generated
		this->GenerateGetSetFields();

		// We need to create all the bound functions
		for (size_t i = 0; i < library->OwnedFunctions.size(); ++i)
		{
			// Get the current bound function
			Function* function = this->BuiltLibrary->OwnedFunctions[i];

			// Compact the byte code into a single byte buffer (may be no opcode!)
			function->CompactedOpcode.resize(function->OpcodeBuilder.RelativeSize());
			function->OpcodeBuilder.RelativeCompact(function->CompactedOpcode.data());

			// Add the function to the library so it can be looked up
			function->SourceLibrary = library.Object;
		}

		// Create a range to iterate through all the named types
		BoundTypeRange boundTypes = this->BoundTypes.all();

		// Loop through all the named types in the range
		while (boundTypes.empty() == false)
		{
			// Get a pointer to the current type and iterate to the next
			BoundTypeMap::pair& pair = boundTypes.front();
			BoundType* boundType = pair.second;
			boundTypes.popFront();

			// Insert all the named types into the map
			library->BoundTypes.insertOrError(pair.first, boundType);

			// Set the type's source library to the current library
			boundType->SourceLibrary = library.Object;
		}

		// Get all the qualified types created by this library
		TypeToIndirect::valuerange indirectionTypes = this->IndirectTypes.values();

		// Loop through all the qualified type maps in the range
		while (indirectionTypes.empty() == false)
		{
			// Get the qualified type
			IndirectionType* indirectionType = indirectionTypes.front();
			indirectionTypes.popFront();

			// Set the type's source library to the current library
			indirectionType->SourceLibrary = library.Object;
		}

		// Create a range to iterate through all the delegate types
		DelegateTypeSet::range delegateTypes = this->DelegateTypes.all();

		// Loop through all the delegate types in the range
		while (delegateTypes.empty() == false)
		{
			// Get a pointer to the current type and iterate to the next
			DelegateType* delegateType = delegateTypes.front();
			delegateTypes.popFront();

			// Set the type's source library to the current library
			delegateType->SourceLibrary = library.Object;
		}

		// Clear out our built library so we don't use the this builder anymore
		this->BuiltLibrary = nullptr;
		return library;
	}


	//***************************************************************************
	Type* LibraryBuilder::ToHandleType(BoundType* type)
	{
		// If the type is a reference type...
		if (type->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// The reference type itself is effectively a handle
			return type;
		}
		else
		{
			// Otherwise we need to make a reference to it
			return this->ReferenceOf(type);
		}
	}

	//***************************************************************************
	IndirectionType* LibraryBuilder::ReferenceOf(BoundType* type)
	{
		// If the type is a reference type...
		if (type->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Show an error
			Error("It is not legal to get a reference of a non-value type");
			return nullptr;
		}

		// Now attempt to find the qualified type
		IndirectionType*& indirectionType = this->IndirectTypes[type];

		// If we found the type...
		if (indirectionType != nullptr)
		{
			// Return the type we found
			return indirectionType;
		}
		else
		{
			// Create a newly qualified type
			indirectionType = new IndirectionType();

			// Make sure to store a strong reference, since we now own the type
			this->BuiltLibrary->OwnedTypes.push_back(indirectionType);

			// Setup the qualifiers and the true type that it references
			indirectionType->ReferencedType = type;
			indirectionType->UserData = type->UserData;

			// Return the qualified type
			return indirectionType;
		}
	}

	//***************************************************************************
	BoundType* LibraryBuilder::Dereference(IndirectionType* qualifiedType)
	{
		// Just return the referenced type (there can only be one level of indirection
		return qualifiedType->ReferencedType;
	}

	//***************************************************************************
	DelegateType* LibraryBuilder::GetDelegateType(const ParameterArray& parameters, Type* returnType)
	{
		// Create a delegate type and fill it in
		DelegateType* delegateType = new DelegateType();
		delegateType->Parameters = parameters;
		delegateType->Return = returnType;

		// Make sure all delegates have returns
		ErrorIf(returnType == nullptr,
			"To mark a delegate/function as having no return, use the void type via ZilchTypeId(void)");

		// Attmpt to find a delegate of the same type
		DelegateType* foundType = this->DelegateTypes.findValue(delegateType, nullptr);

		// If we already had that delegate type...
		if (foundType != nullptr)
		{
			// Delete the temporary delegate we created above to find it
			delete delegateType;

			// Return the one that was already in the set
			return foundType;
		}
		else
		{
			// Make sure to store a strong reference, since we now own the type
			this->BuiltLibrary->OwnedTypes.push_back(delegateType);

			// Add the delegate type to the set
			// (we should never overwrite since we JUST checked that above)
			this->DelegateTypes.insertOrError(delegateType);

			// Set the return stack offset, which is always zero
			delegateType->ReturnStackOffset = 0;

			// The cumulative offset of each parameter on the stack
			OperandIndex parameterStackOffset = 0;

			// Move the first parameter forward by the return value's size
			// (void has a size of zero, so this always works!)
			parameterStackOffset += delegateType->Return->GetCopyableSize();

			// Walk through the parameters and assign stack offsets
			for (size_t i = 0; i < delegateType->Parameters.size(); ++i)
			{
				// Grab the current delegate parameter
				DelegateParameter& parameter = delegateType->Parameters[i];

				// Set the parameter's stack offset
				parameter.StackOffset = parameterStackOffset;

				// Push forward the next parameter's stack offset by this parameter's size
				parameterStackOffset += parameter.ParameterType->GetCopyableSize();

				// Get a reference to the core library
				Core& core = Core::GetInstance();

				// Make sure all delegates have returns
				ErrorIf(parameter.ParameterType == nullptr || parameter.ParameterType == core.VoidType,
					"Delegate/function parameters cannot be null or void");
			}

			// Finally, the 'this' handle comes right after all the parameters
			delegateType->ThisHandleStackOffset = parameterStackOffset;
			delegateType->TotalStackSizeExcludingThisHandle = parameterStackOffset;

			// Return the newly created delegate type
			return delegateType;
		}
	}

	//***************************************************************************
	CodeEntry::CodeEntry() :
		CodeUserData(nullptr)
	{
	}

	//***************************************************************************
	size_t CodeEntry::GetHash()
	{
		return this->Code.hash() ^ this->Origin.hash() * 5689;
	}

	//***************************************************************************
	Library::Library() :
		UserData(nullptr)
	{
	}

	//***************************************************************************
	Library::~Library()
	{
		for (size_t i = 0; i < this->OwnedTypes.size(); ++i)
		{
			Type* type = this->OwnedTypes[i];
			delete type;
		}

		for (size_t i = 0; i < this->OwnedFunctions.size(); ++i)
		{
			Function* function = this->OwnedFunctions[i];
			delete function;
		}

		for (size_t i = 0; i < this->OwnedProperties.size(); ++i)
		{
			Property* property = this->OwnedProperties[i];
			delete property;
		}

		for (size_t i = 0; i < this->OwnedVariables.size(); ++i)
		{
			Variable* variable = this->OwnedVariables[i];
			delete variable;
		}
	}

	//***************************************************************************
	Module::Module()
	{
		// Always add the core library (both for the linker, and as a compiler dependence)
		this->push_back(Core::GetInstance().GetLibrary());
	}

	//***************************************************************************
	BoundType* Module::FindType(StringParam name)
	{
		// Loop through all libraries
		for (size_t i = 0; i < this->size(); ++i)
		{
			// Grab the current library
			LibraryRef& library = (*this)[i];

			// Attempt to find the type in this library
			BoundType* type = library->BoundTypes.findValue(name, nullptr);

			// If we found the type...
			if (type != nullptr)
				return type;
		}

		// Otherwise we found nothing
		return nullptr;
	}

	//***************************************************************************
	ExecutableState* Module::Link() const
	{
		// Create an executable state to link everything together into
		ExecutableState* state = new ExecutableState();

		// Store references to the dependent libraries we were compiled from
		state->Dependencies = *this;

		// Loop through all dependent libraries
		for (size_t i = 0; i < this->size(); ++i)
		{
			// Grab the current library
			const LibraryRef& library = (*this)[i];

			// Loop through all code entries
			for (size_t j = 0; j < library->Entries.size(); ++j)
			{
				// Grab the current code entry
				CodeEntry* entry = &library->Entries[j];

				// Map the code entry id to the entry itself on the state (we should never collide here!)
				state->CodeHashToCodeEntry.insertNoOverwrite(entry->GetHash(), entry);
			}
		}

		return state;
	}

	//***************************************************************************
	void Module::BuildTypeDocumentation(BoundType* type, DocumentationType* docType)
	{
		// Add the type to the docs
		docType->Name = type->Name;

		// Set the description and remarks
		docType->Description = type->Description;
		docType->Remarks = type->Remarks;

		// If we have a base class, make sure we set it
		if (type->BaseType != nullptr)
		{
			// Set the base type name (we should be able to look it up later)
			docType->BaseName = type->BaseType->Name;
		}

		// If the type is a value type...
		if (type->GetCopyMode() == TypeCopyMode::ValueType)
		{
			docType->IsValueType = true;
		}

		// Get the constructor functions
		this->BuildFunctionDocumentation(docType->Constructors, type->Constructors);

		// Add all instance and static functions to the documentation
		this->BuildFunctionDocumentation(docType->InstanceMethods, type->InstanceFunctions);
		this->BuildFunctionDocumentation(docType->StaticMethods, type->StaticFunctions);

		// Add all the properties and members
		this->BuildPropertyDocumentation(docType->InstanceProperties, type->InstanceFields);
		this->BuildPropertyDocumentation(docType->InstanceProperties, type->InstanceProperties);
		this->BuildPropertyDocumentation(docType->StaticProperties, type->StaticFields);
		this->BuildPropertyDocumentation(docType->StaticProperties, type->StaticProperties);
	}

	//***************************************************************************
	bool DocumentationFunctionSorter(DocumentationFunction* left, DocumentationFunction* right)
	{
		// Compare the names with each other
		return left->Name < right->Name;
	}

	//***************************************************************************
	void Module::BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionMultiMap& functions)
	{
		// Get the instance functions
		FunctionMultiValueRange functionArrays = functions.values();

		// Normally it's a map of strings to overloaded functions, so we need to loop through all arrays
		while (functionArrays.empty() == false)
		{
			// Grab the current instance function array and move to the next
			FunctionArray& functionArray = functionArrays.front();
			functionArrays.popFront();

			// Build documentation for those functions
			this->BuildFunctionDocumentation(addTo, functionArray);
		}

		// Sort the methods by name
		sort(addTo.all(), DocumentationFunctionSorter);
	}

	//***************************************************************************
	void Module::BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionArray& functions)
	{
		// Loop through all the functions in an array
		for (size_t i = 0; i < functions.size(); ++i)
		{
			// Grab the current function
			Function* function = functions[i];

			// Skip the special getter and setter functions (those are documented by properties)
			if (function->IsPropertyGetOrSet)
				continue;

			// Create the function's documentation
			DocumentationFunction* docFunction = new DocumentationFunction();
			docFunction->Name = function->Name;

			// Set the description and remarks
			docFunction->Description = function->Description;
			docFunction->Remarks = function->Remarks;

			// Add the doc function to the array
			addTo.push_back(docFunction);

			// Create the signature for the function
			docFunction->Signature = function->Type->GetSignatureString();

			// Get the return type of the function
			docFunction->ReturnType = function->Type->Return->ToString();

			// Get the parameters for the function we're binding
			ParameterArray& parameters = function->Type->Parameters;

			// Loop through all the parameters
			for (size_t j = 0; j < parameters.size(); ++j)
			{
				// Grab the current parameter
				DelegateParameter& parameter = parameters[j];

				// Create a documentation mirrored parameter to describe it
				DocumentationParameter* docParameter = new DocumentationParameter();
				docParameter->Name = parameter.Name;
				docParameter->Type = parameter.ParameterType->ToString();

				// Add it to the documentation function
				docFunction->Parameters.push_back(docParameter);
			}

			// If this function is a constructor, it has no description, and it takes no arguments (defaulted)...
			if (function->Name == ConstructorName && docFunction->Description.empty() && docFunction->Parameters.empty())
			{
				// Set the description to something special
				docFunction->Description = "*Default constructor*";
			}
		}
	}

	//***************************************************************************
	void Module::BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const FieldMap& members)
	{
		// Get a range of all the properties
		FieldMapValueRange range = members.values();

		// Walk through all the properties
		while (range.empty() == false)
		{
			// Get the current property and move forward
			Field* field = range.front();
			range.popFront();

			// Build documentation for the property
			this->BuildPropertyDocumentation(addTo, field);
		}
	}

	//***************************************************************************
	bool DocumentationPropertySorter(DocumentationProperty* left, DocumentationProperty* right)
	{
		// Compare the names with each other
		return left->Name < right->Name;
	}

	//***************************************************************************
	void Module::BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const PropertyMap& properties)
	{
		// Get a range of all the properties
		PropertyMapValueRange range = properties.values();

		// Walk through all the properties
		while (range.empty() == false)
		{
			// Get the current property and move forward
			Property* property = range.front();
			range.popFront();

			// Build documentation for the property
			this->BuildPropertyDocumentation(addTo, property);
		}

		// Sort the instance properties by name
		sort(addTo.all(), DocumentationPropertySorter);
	}

	//***************************************************************************
	void Module::BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const Property* property)
	{
		// Create the documentation property to represent the property
		DocumentationProperty* docProperty = new DocumentationProperty();
		docProperty->Name = property->Name;
		docProperty->IsGettable = (property->Get != nullptr);
		docProperty->IsSettable = (property->Set != nullptr);
		docProperty->IsField = (TypeBinding::DynamicCast<const Field*>(property) != nullptr);
		docProperty->Type = property->PropertyType->ToString();

		// Set the description and remarks
		docProperty->Description = property->Description;
		docProperty->Remarks = property->Remarks;

		// Add the property to the array
		addTo.push_back(docProperty);
	}

	//***************************************************************************
	bool DocumentationTypeSorter(DocumentationType* left, DocumentationType* right)
	{
		// Compare the names with each other
		return left->Name < right->Name;
	}

	//***************************************************************************
	DocumentationModule* Module::BuildDocumentation()
	{
		// Create the documentation module object
		DocumentationModule* docs = new DocumentationModule();

		// Loop through all the libraries
		for (size_t i = 0; i < this->size(); ++i)
		{
			// Grab the current library
			LibraryRef& library = (*this)[i];

			// Create a documentation object that represents a library
			DocumentationLibrary* docLibrary = new DocumentationLibrary();
			docLibrary->Name = library->Name;

			// Add the library to the docs
			docs->Libraries.push_back(docLibrary);

			// Loop through all the types in the library
			BoundTypeValueRange typeRange = library->BoundTypes.values();
			while (typeRange.empty() == false)
			{
				// Grab the current type
				BoundType* type = typeRange.front();
				typeRange.popFront();

				// Add the type to the docs
				DocumentationType* docType = new DocumentationType();

				// Add the type to the documentation for the library
				docLibrary->TypesSorted.push_back(docType);
				docLibrary->TypesByName.insert(type->Name, docType);

				// Build the documentation for this type
				this->BuildTypeDocumentation(type, docType);
			}

			// Create a temporary library builder to build templates
			LibraryBuilder builder("Documenation");

			// Loop through all template handlers, instantiate them as templates that take the 'Any' type
			HashMap<String, InstantiateTemplateInfo>::valuerange templates = library->TemplateHandlers.values();
			while (templates.empty() == false)
			{
				// Get the current template and move to the next one
				InstantiateTemplateInfo& templateInfo = templates.front();
				templates.popFront();

				// We attempt to instantiate the template using fake types
				// TODO: Create full typedefs of the Any type
				Array<Type*> arguments;
				for (size_t i = 0; i < templateInfo.TemplateArgumentNames.size(); ++i)
				{
					String argumentName = templateInfo.TemplateArgumentNames[i];
					BoundType* fakeType = builder.BoundTypes.findValue(argumentName, nullptr);

					if (fakeType == nullptr)
						fakeType = builder.AddBoundType(templateInfo.TemplateArgumentNames[i], TypeCopyMode::ReferenceType, 0);

					arguments.push_back(fakeType);
				}

				InstantiatedTemplate finalTemplate = builder.InstantiateTemplate(templateInfo.BaseName, arguments, *this);

				if (finalTemplate.Result == TemplateResult::Success)
				{
					BoundType* type = finalTemplate.Type;

					// Add the type to the docs
					DocumentationType* docType = new DocumentationType();

					// Add the type to the documentation for the library
					docLibrary->TypesSorted.push_back(docType);
					docLibrary->TypesByName.insert(type->Name, docType);

					// Build the documentation for this type
					this->BuildTypeDocumentation(type, docType);
				}
			}

			// Sort the types by name
			sort(docLibrary->TypesSorted.all(), DocumentationTypeSorter);
		}

		// Return the newly created documentation module
		return docs;
	}

	//***************************************************************************
	void Module::BuildJsonConstructors(JsonBuilder& json, const Array<DocumentationFunction*>& constructors, StringParam name)
	{
		// Early out if we have no functions
		if (constructors.empty())
			return;

		json.Key(name);
		json.Begin(JsonType::Object);
		{
			json.Key("columns");
			json.Begin(JsonType::ArraySingleLine);
			json.Value("Signature");
			json.Value("Description");
			json.End();

			json.Key("rows");
			json.Begin(JsonType::ArrayMultiLine);
			for (size_t i = 0; i < constructors.size(); ++i)
			{
				DocumentationFunction* constructor = constructors[i];

				json.Begin(JsonType::ArraySingleLine);
				json.Value(BuildString("constructor", constructor->Signature));
				json.Value(constructor->Description);
				json.End();
			}
			json.End();
		}
		json.End();
	}

	//***************************************************************************
	void Module::BuildJsonMethods(JsonBuilder& json, const Array<DocumentationFunction*>& functions, StringParam name)
	{
		// Early out if we have no functions
		if (functions.empty())
			return;

		json.Key(name);
		json.Begin(JsonType::Object);
		{
			json.Key("columns");
			json.Begin(JsonType::ArraySingleLine);
			json.Value("Name / Signature");
			json.Value("Description");
			json.End();

			json.Key("rows");
			json.Begin(JsonType::ArrayMultiLine);
			for (size_t i = 0; i < functions.size(); ++i)
			{
				DocumentationFunction* function = functions[i];

				json.Begin(JsonType::ArraySingleLine);
				json.Value(BuildString(function->Name, function->Signature));
				json.Value(function->Description);
				json.End();
			}
			json.End();
		}
		json.End();
	}

	//***************************************************************************
	void Module::BuildJsonProperties(JsonBuilder& json, const Array<DocumentationProperty*>& properties, StringParam name)
	{
		// Early out if we have no functions
		if (properties.empty())
			return;

		json.Key(name);
		json.Begin(JsonType::Object);

		{
			json.Key("columns");
			json.Begin(JsonType::ArraySingleLine);
			json.Value("Name");
			json.Value("Type");
			json.Value("Description");
			json.End();

			json.Key("rows");
			json.Begin(JsonType::ArrayMultiLine);
			for (size_t i = 0; i < properties.size(); ++i)
			{
				DocumentationProperty* property = properties[i];

				json.Begin(JsonType::ArraySingleLine);
				json.Value(property->Name);
				json.Value(property->Type);
				json.Value(property->Description);
				json.End();
			}
			json.End();
		}
		json.End();
	}

	//***************************************************************************
	void BuildBaseChain(StringBuilderExtended& builder, DocumentationLibrary* library, DocumentationType* type)
	{
		if (type->BaseName.empty())
			return;

		DocumentationType* baseType = library->TypesByName[type->BaseName];

		BuildBaseChain(builder, library, baseType);

		builder.Write(baseType->Name);
		builder.Write(" |rarr| ");
	}

	//***************************************************************************
	void Module::BuildDocumentationRst(StringParam directory)
	{
		DocumentationModule* docs = this->BuildDocumentation();

		for (size_t i = 0; i < docs->Libraries.size(); ++i)
		{
			DocumentationLibrary* library = docs->Libraries[i];

			for (size_t j = 0; j < library->TypesSorted.size(); ++j)
			{
				RstBuilder builder;

				builder.WriteLine(".. include:: <isonum.txt>");
				builder.WriteLine();

				DocumentationType* type = library->TypesSorted[j];

				BuildBaseChain(builder, library, type);
				builder.WriteLine();
				builder.WriteLine();

				builder.WriteLineHeading(type->Name, RstHeadingType::Section);

				builder.Write("  ");
				builder.Write(type->Description);

				if (type->Description.empty() == false)
					builder.Write(" ");

				if (type->IsValueType)
					builder.WriteLine("(struct)");
				else
					builder.WriteLine("(class)");

				builder.WriteLine();

				if (type->Remarks.empty() == false)
				{
					builder.WriteLineHeading("Remarks", RstHeadingType::SubSection);

					for (size_t i = 0; i < type->Remarks.size(); ++i)
					{
						builder.Write("  ");
						builder.WriteLine(type->Remarks[i]);
					}
					builder.WriteLine();
				}

				if (type->Constructors.empty() == false)
				{
					builder.WriteLineHeading("Constructors", RstHeadingType::SubSection);

					RstTable table;
					table.Resize(2, type->Constructors.size() + 1);
					table.HeaderRows = 1;
					table.SetCell("Signature", 0, 0);
					table.SetCell("Row", 1, 0);

					for (size_t i = 0; i < type->Constructors.size(); ++i)
					{
						DocumentationFunction* function = type->Constructors[i];

						table.SetCell(function->Signature, 0, i + 1);
						table.SetCell(function->Description, 1, i + 1);
					}

					builder.WriteLine(table);
					builder.WriteLine();
				}

				if (type->InstanceProperties.empty() == false)
				{
					builder.WriteLineHeading("Instance Properties", RstHeadingType::SubSection);

					RstTable table;
					table.Resize(3, type->InstanceProperties.size() + 1);
					table.HeaderRows = 1;
					table.SetCell("Name", 0, 0);
					table.SetCell("Type", 1, 0);
					table.SetCell("Description", 2, 0);

					for (size_t i = 0; i < type->InstanceProperties.size(); ++i)
					{
						DocumentationProperty* property = type->InstanceProperties[i];

						String typeLink = BuildString(":doc:`", property->Type, "`");

						table.SetCell(property->Name, 0, i + 1);
						table.SetCell(typeLink, 1, i + 1);
						table.SetCell(property->Description, 2, i + 1);
					}

					builder.WriteLine(table);
					builder.WriteLine();
				}

				if (type->StaticProperties.empty() == false)
				{
					builder.WriteLineHeading("Static Properties", RstHeadingType::SubSection);

					RstTable table;
					table.Resize(3, type->StaticProperties.size() + 1);
					table.HeaderRows = 1;
					table.SetCell("Name", 0, 0);
					table.SetCell("Type", 1, 0);
					table.SetCell("Description", 2, 0);

					for (size_t i = 0; i < type->StaticProperties.size(); ++i)
					{
						DocumentationProperty* property = type->StaticProperties[i];

						String typeLink = BuildString(":doc:`", property->Type, "`");

						table.SetCell(property->Name, 0, i + 1);
						table.SetCell(typeLink, 1, i + 1);
						table.SetCell(property->Description, 2, i + 1);
					}

					builder.WriteLine(table);
					builder.WriteLine();
				}


				if (type->InstanceMethods.empty() == false)
				{
					builder.WriteLineHeading("Instance Methods", RstHeadingType::SubSection);

					RstTable table;
					table.Resize(2, type->InstanceMethods.size() + 1);
					table.HeaderRows = 1;
					table.SetCell("Name / Signature", 0, 0);
					table.SetCell("Description", 1, 0);

					for (size_t i = 0; i < type->InstanceMethods.size(); ++i)
					{
						DocumentationFunction* function = type->InstanceMethods[i];

						String nameAndSignature = BuildString(function->Name, function->Signature);

						table.SetCell(nameAndSignature, 0, i + 1);
						table.SetCell(function->Description, 1, i + 1);
					}

					builder.WriteLine(table);
					builder.WriteLine();
				}

				if (type->StaticMethods.empty() == false)
				{
					builder.WriteLineHeading("Static Methods", RstHeadingType::SubSection);

					RstTable table;
					table.Resize(2, type->StaticMethods.size() + 1);
					table.HeaderRows = 1;
					table.SetCell("Name / Signature", 0, 0);
					table.SetCell("Description", 1, 0);

					for (size_t i = 0; i < type->StaticMethods.size(); ++i)
					{
						DocumentationFunction* function = type->StaticMethods[i];

						String nameAndSignature = BuildString(function->Name, function->Signature);

						table.SetCell(nameAndSignature, 0, i + 1);
						table.SetCell(function->Description, 1, i + 1);
					}

					builder.WriteLine(table);
					builder.WriteLine();
				}

				String typeRst = builder.ToString();

				//HACK should be using file path stuff (platform agnostic!)
				String rstFileName = BuildString(directory, "\\", type->Name, ".rst");

				Zero::WriteToFile(rstFileName.c_str(), (byte*)typeRst.c_str(), typeRst.size());
			}
		}
	}

	//***************************************************************************
	String Module::BuildDocumentationHtml()
	{
		JsonBuilder json;

		DocumentationModule* docs = this->BuildDocumentation();

		json.Begin(JsonType::Object);

		json.Key("start");
		json.Value("GettingStarted");

		{
			json.Key("libraries");
			json.Begin(JsonType::Object);

			for (size_t i = 0; i < docs->Libraries.size(); ++i)
			{
				DocumentationLibrary* library = docs->Libraries[i];

				json.Key(library->Name);
				json.Begin(JsonType::Object);

				{
					json.Key("types");
					json.Begin(JsonType::Object);

					for (size_t j = 0; j < library->TypesSorted.size(); ++j)
					{
						DocumentationType* type = library->TypesSorted[j];

						json.Key(type->Name);
						json.Begin(JsonType::Object);

						{
							json.Key("base");
							json.Value(type->BaseName);
							json.Key("description");
							json.Value(type->Description);
							json.Key("isValueType");
							json.Value(type->IsValueType);
							json.Key("remarks");
							json.Begin(JsonType::ArrayMultiLine);

							{
								for (size_t k = 0; k < type->Remarks.size(); ++k)
								{
									String& remark = type->Remarks[k];

									json.Value(remark);
								}
							}

							json.End();

							json.Key("tables");
							json.Begin(JsonType::Object);
							{
								this->BuildJsonConstructors(json, type->Constructors, "Constructors");

								this->BuildJsonMethods(json, type->InstanceMethods, "Instance Methods");
								this->BuildJsonMethods(json, type->StaticMethods, "Static Methods");

								this->BuildJsonProperties(json, type->InstanceProperties, "Instance Properties");
								this->BuildJsonProperties(json, type->StaticProperties, "Static Properties");
							}
							json.End();
						}

						json.End();
					}

					json.End();
				}

				json.End();
			}

			// End the libraries
			json.End();
		}

		// End the module
		json.End();

		return json.ToString();
	}

	//***************************************************************************
	InstantiatedTemplate::InstantiatedTemplate() :
		Type(nullptr),
		Result(TemplateResult::FailedInstantiatorDidNotReturnType),
		ExpectedArguments(0)
	{
	}

	//***************************************************************************
	ParameterArray OneParameter(Type* type)
	{
		ParameterArray parameters;
		parameters.push_back(type);
		return parameters;
	}

	//***************************************************************************
	ParameterArray OneParameter(Type* type, StringParam name)
	{
		ParameterArray parameters;

		DelegateParameter& a = parameters.push_back();
		a.Name = name;
		a.ParameterType = type;

		return parameters;
	}

	//***************************************************************************
	ParameterArray TwoParameters(Type* type)
	{
		ParameterArray parameters;
		parameters.push_back(type);
		parameters.push_back(type);
		return parameters;
	}

	//***************************************************************************
	ParameterArray TwoParameters(Type* type, StringParam name1, StringParam name2)
	{
		ParameterArray parameters;

		DelegateParameter& a = parameters.push_back();
		a.Name = name1;
		a.ParameterType = type;

		DelegateParameter& b = parameters.push_back();
		b.Name = name2;
		b.ParameterType = type;

		return parameters;
	}

	//***************************************************************************
	ParameterArray TwoParameters(Type* type1, Type* type2)
	{
		ParameterArray parameters;
		parameters.push_back(type1);
		parameters.push_back(type2);
		return parameters;
	}

	//***************************************************************************
	ParameterArray TwoParameters(Type* type1, StringParam name1, Type* type2, StringParam name2)
	{
		ParameterArray parameters;

		DelegateParameter& a = parameters.push_back();
		a.Name = name1;
		a.ParameterType = type1;

		DelegateParameter& b = parameters.push_back();
		b.Name = name2;
		b.ParameterType = type2;

		return parameters;
	}

	//***************************************************************************
	ParameterArray ThreeParameters(Type* type)
	{
		ParameterArray parameters;
		parameters.push_back(type);
		parameters.push_back(type);
		parameters.push_back(type);
		return parameters;
	}

	//***************************************************************************
	ParameterArray ThreeParameters(Type* type1, StringParam name1, Type* type2, StringParam name2, Type* type3, StringParam name3)
	{
		ParameterArray parameters;

		DelegateParameter& a = parameters.push_back();
		a.Name = name1;
		a.ParameterType = type1;

		DelegateParameter& b = parameters.push_back();
		b.Name = name2;
		b.ParameterType = type2;

		DelegateParameter& c = parameters.push_back();
		c.Name = name3;
		c.ParameterType = type3;

		return parameters;
	}

	//***************************************************************************
	ParameterArray ThreeParameters(Type* type, StringParam name1, StringParam name2, StringParam name3)
	{
		ParameterArray parameters;

		DelegateParameter& a = parameters.push_back();
		a.Name = name1;
		a.ParameterType = type;

		DelegateParameter& b = parameters.push_back();
		b.Name = name2;
		b.ParameterType = type;

		DelegateParameter& c = parameters.push_back();
		c.Name = name3;
		c.ParameterType = type;

		return parameters;
	}

	//***************************************************************************
	ParameterArray ThreeParameters(Type* type1, Type* type2, Type* type3)
	{
		ParameterArray parameters;
		parameters.push_back().ParameterType = type1;
		parameters.push_back().ParameterType = type2;
		parameters.push_back().ParameterType = type3;
		return parameters;
	}

	////***************************************************************************
	//ExtensionPropertyMapRange::ExtensionPropertyMapRange(LibraryArray& libraries, bool isStatic, Type* type) :
	//  CurrentMap(nullptr),
	//  LibraryIndex(0),
	//  BaseIterator(type),
	//  Libraries(libraries),
	//  IsStatic(isStatic),
	//  ExtensionType(type)
	//{
	//}

	////***************************************************************************
	//void ExtensionPropertyMapRange::popFront()
	//{

	//}

	////***************************************************************************
	//void ExtensionPropertyMapRange::UpdateCurrentMap()
	//{
	//  LibraryRef& library = this->Libraries[this->LibraryIndex];

	//  // Get the guid of the type (this should be legal here since we've collected all members)
	//  GuidType guid = this->BaseIterator->Hash();
	//  
	//  // Get the array of properties (may be empty)
	//  PropertyMap* properties = nullptr;
	//      
	//  // If we're resolving a static member
	//  if (this->IsStatic)
	//  {
	//    properties = library->StaticExtensionProperties.findPointer(guid);
	//  }
	//  else
	//  {
	//    properties = library->InstanceExtensionProperties.findPointer(guid);
	//  }

	//  // If we got a valid array of properties...
	//  if (properties != nullptr)
	//  {
	//    return properties;
	//  }
	//}

	////***************************************************************************
	//PropertyMap* ExtensionPropertyMapRange::front()
	//{

	//    // We need to look up the entire heirarchy (the property could be on any base classes)
	//    Type* baseIterator = type;
	//    while (baseIterator != nullptr)
	//    {

	//      
	//        
	//      // Iterate to the next type
	//      baseIterator = Type::GetBaseType(baseIterator);
	//    }
	//}
}
/**************************************************************\
* Author: Joshua Davis
* Copyright 2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	// Helper functions to Index into a matrix while allowing them to be row or column basis
	byte* IndexIntoMatrix(byte* memory, size_t indexX, size_t indexY, size_t sizeX, size_t sizeY, size_t elementSize)
	{
#if ColumnBasis == 1
		return memory + (indexX + indexY * sizeX) * elementSize;
#else
		return memory + (indexY + indexX * sizeY) * elementSize;
#endif
	}

	const byte* IndexIntoMatrix(const byte* memory, size_t indexX, size_t indexY, size_t sizeX, size_t sizeY, size_t elementSize)
	{
#if ColumnBasis == 1
		return memory + (indexX + indexY * sizeX) * elementSize;
#else
		return memory + (indexY + indexX * sizeY) * elementSize;
#endif
	}

	//***************************************************************************
	bool ValidateMatrixIndices(size_t x, size_t y, size_t sizeX, size_t sizeY, Call& call, ExceptionReport& report)
	{
		// Make sure the indices are within range
		if (y >= sizeY)
		{
			call.GetState()->ThrowException(report, String::Format("The y index used to access a component of a matrix was out of range [0-%d]", sizeY - 1));
			return false;
		}
		if (x >= sizeX)
		{
			call.GetState()->ThrowException(report, String::Format("The x index used to access a component of a matrix was out of range [0-%d]", sizeX - 1));
			return false;
		}

		return true;
	}

	//***************************************************************************
	void MultiplyAddReal(byte* outData, byte* inputA, byte* inputB)
	{
		Real& out = *(Real*)outData;
		Real& a = *(Real*)inputA;
		Real& b = *(Real*)inputB;
		out += a * b;
	}

	//***************************************************************************
	void MultiplyAddInteger(byte* outData, byte* inputA, byte* inputB)
	{
		Integer& out = *(Integer*)outData;
		Integer& a = *(Integer*)inputA;
		Integer& b = *(Integer*)inputB;
		out += a * b;
	}

	//***************************************************************************
	void MultiplyAddBoolean(byte* outData, byte* inputA, byte* inputB)
	{
		Boolean& out = *(Boolean*)outData;
		Boolean& a = *(Boolean*)inputA;
		Boolean& b = *(Boolean*)inputB;
		out = out || (a && b);
	}

	//***************************************************************************
	String MatrixToString(const BoundType* type, const byte* data)
	{
		MatrixUserData& userData = type->ComplexUserData.ReadObject<MatrixUserData>(0);
		Core& core = Core::GetInstance();
		//get the type of the matrix (Real, etc...)
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		StringBuilder builder;
		builder.Append("[");
		for (size_t y = 0; y < userData.SizeY; ++y)
		{
			builder.Append("(");
			for (size_t x = 0; x < userData.SizeX; ++x)
			{
				const byte* item = IndexIntoMatrix(data, x, y, userData.SizeX, userData.SizeY, elementType->Size);

				builder.Append(elementType->GenericToString(item));

				//don't add a comma after the last item
				if (x != userData.SizeX - 1)
					builder.Append(", ");
			}

			builder.Append(")");
			//don't add a comma after the last item
			if (y != userData.SizeY - 1)
				builder.Append(", ");
		}
		builder.Append("]");
		return builder.ToString();
	}

	//***************************************************************************
	void MatrixDefaultConstructor(Call& call, ExceptionReport& report)
	{
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		// Get ourselves (the matrix)
		byte* memory = call.GetHandle(Call::This).Dereference();
		// Zero out the matrix memory
		memset(memory, 0, userData.SizeX * userData.SizeY * elementType->Size);
	}

	//***************************************************************************
	void MatrixConstructor(Call& call, ExceptionReport& report)
	{
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		// Get ourselves (the matrix)
		byte* matrixData = call.GetHandle(Call::This).Dereference();
		byte* parameters = call.GetParametersUnchecked();
		for (size_t y = 0; y < userData.SizeY; ++y)
		{
			for (size_t x = 0; x < userData.SizeX; ++x)
			{
				byte* matrixItem = IndexIntoMatrix(matrixData, x, y, userData.SizeX, userData.SizeY, elementType->Size);
				byte* parameterItem = parameters + (x + y * userData.SizeX) * elementType->Size;

				memcpy(matrixItem, parameterItem, elementType->Size);
			}
		}
	}

	//***************************************************************************
	void MatrixGet(Call& call, ExceptionReport& report)
	{
		call.DisableReturnChecks();
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

		// Read the index off the stack
		Integer indexY = call.Get<Integer>(0);
		Integer indexX = call.Get<Integer>(1);

		// Make sure the indices are correct
		if (ValidateMatrixIndices(indexX, indexY, userData.SizeX, userData.SizeY, call, report) == false)
			return;

		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		// Get ourselves (the matrix)
		byte* memory = call.GetHandle(Call::This).Dereference();

		// Index to the item we are getting and set the return to that
		byte* item = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);
		byte* returnData = call.GetReturnUnchecked();
		elementType->GenericCopyConstruct(returnData, item);
	}

	//***************************************************************************
	void MatrixSet(Call& call, ExceptionReport& report)
	{
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

		// Read the index off the stack
		Integer indexY = call.Get<Integer>(0);
		Integer indexX = call.Get<Integer>(1);

		// Make sure the indices are correct
		if (ValidateMatrixIndices(indexX, indexY, userData.SizeX, userData.SizeY, call, report) == false)
			return;

		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		// Get ourselves (the matrix)
		byte* memory = call.GetHandle(Call::This).Dereference();

		// Index to the item in the matrix and set it to the passed in value
		byte* setData = call.GetParameterUnchecked(2);
		byte* item = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);
		elementType->GenericCopyConstruct(item, setData);
	}

	//***************************************************************************
	void MatrixGetVector(Call& call, ExceptionReport& report)
	{
		call.DisableReturnChecks();
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

		// Read the index off the stack
		Integer indexY = call.Get<Integer>(0);

		if (indexY < 0 || indexY >= (Integer)userData.SizeY)
		{
			call.GetState()->ThrowException(report, String::Format("The y index used to access a component of a matrix was out of range [0-%d]", userData.SizeY - 1));
			return;
		}

		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		// Get ourselves (the matrix)
		byte* memory = call.GetHandle(Call::This).Dereference();
		byte* returnData = call.GetReturnUnchecked();

		for (size_t indexX = 0; indexX < userData.SizeX; ++indexX)
		{
			// Index to the item we are getting and set the return to that
			byte* matrixItem = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);
			byte* returnItem = returnData + indexX * elementType->Size;

			memcpy(returnItem, matrixItem, elementType->Size);
		}
	}

	//***************************************************************************
	void MatrixSetVector(Call& call, ExceptionReport& report)
	{
		call.DisableReturnChecks();
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);

		// Read the index off the stack
		Integer indexY = call.Get<Integer>(0);

		if (indexY < 0 || indexY >= (Integer)userData.SizeY)
		{
			call.GetState()->ThrowException(report, String::Format("The y index used to access a component of a matrix was out of range [0-%d]", userData.SizeY - 1));
			return;
		}

		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		// Get ourselves (the matrix)
		byte* memory = call.GetHandle(Call::This).Dereference();
		byte* vectorData = call.GetParameterUnchecked(1);

		for (size_t indexX = 0; indexX < userData.SizeX; ++indexX)
		{
			// Index to the item we are getting and set the return to that
			byte* vectorItem = vectorData + indexX * elementType->Size;
			byte* matrixItem = IndexIntoMatrix(memory, indexX, indexY, userData.SizeX, userData.SizeY, elementType->Size);

			memcpy(matrixItem, vectorItem, elementType->Size);
		}
	}

	//***************************************************************************
	void MatrixCountX(Call& call, ExceptionReport& report)
	{
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
		call.Set(Call::Return, (Integer)userData.SizeX);
	}

	//***************************************************************************
	void MatrixCountY(Call& call, ExceptionReport& report)
	{
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
		call.Set(Call::Return, (Integer)userData.SizeY);
	}

	//***************************************************************************
	void MatrixTranspose(Call& call, ExceptionReport& report)
	{
		call.DisableReturnChecks();
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		byte* inMatrix = call.GetParameterUnchecked(0);
		byte* outMatrix = call.GetReturnUnchecked();

		// Swap the x and y elements
		for (size_t y = 0; y < userData.SizeY; ++y)
		{
			for (size_t x = 0; x < userData.SizeX; ++x)
			{
				byte* inputElement = IndexIntoMatrix(inMatrix, x, y, userData.SizeX, userData.SizeY, elementType->Size);
				byte* outputElement = IndexIntoMatrix(outMatrix, y, x, userData.SizeY, userData.SizeX, elementType->Size);

				elementType->GenericCopyConstruct(outputElement, inputElement);
			}
		}
	}

	//***************************************************************************
	// Only doing the determinant for RealNxN matrices
	// (by just calling the math library's matrix functions)
	template <typename MatrixType>
	void RealMatrixDeterminant(Call& call, ExceptionReport& report)
	{
		call.DisableReturnChecks();

		byte* inMatrix = call.GetParameterUnchecked(0);
		Real* output = (Real*)call.GetReturnUnchecked();

		MatrixType mat((Real*)inMatrix);
		*output = mat.Determinant();
	}

	//***************************************************************************
	void MatrixEqual(Call& call, ExceptionReport& report)
	{
		// This should eventually be the innards of operator== and return a bool matrix,
		// but for usage in unit tests this is implemented to verify results
		MatrixUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixUserData>(0);
		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		Handle& selfHandle = call.GetHandle(Call::This);
		byte* matrixA = (byte*)selfHandle.Dereference();
		byte* matrixB = call.GetParameterUnchecked(0);

		// See if all the elements in the matrices are equal
		bool IsEqual = true;
		for (size_t y = 0; y < userData.SizeY; ++y)
		{
			for (size_t x = 0; x < userData.SizeX; ++x)
			{
				byte* elementA = IndexIntoMatrix(matrixA, x, y, userData.SizeX, userData.SizeY, elementType->Size);
				byte* elementB = IndexIntoMatrix(matrixB, x, y, userData.SizeX, userData.SizeY, elementType->Size);

				bool result = memcmp(elementA, elementB, elementType->Size) == 0;
				IsEqual &= result;
			}
		}

		call.Set(Call::Return, IsEqual);
	}

	//***************************************************************************
	// Special user data for the transform function. This needs the
	// dimensionality of both matrices as well as the data type.
	class MatrixTransformUserData
	{
	public:
		MatrixTransformUserData(size_t matrix0SizeX, size_t matrix0SizeY,
			size_t matrix1SizeX, size_t matrix1SizeY,
			size_t elementTypeIndex) :
			Matrix0SizeX(matrix0SizeX),
			Matrix0SizeY(matrix0SizeY),
			Matrix1SizeX(matrix1SizeX),
			Matrix1SizeY(matrix1SizeY),
			ElementTypeIndex(elementTypeIndex)
		{
		}

		size_t Matrix0SizeX;
		size_t Matrix0SizeY;
		size_t Matrix1SizeX;
		size_t Matrix1SizeY;
		size_t ElementTypeIndex;
	};

	//***************************************************************************
	void MatrixTransform(Call& call, ExceptionReport& report)
	{
		call.DisableReturnChecks();
		MatrixTransformUserData& userData = call.GetFunction()->ComplexUserData.ReadObject<MatrixTransformUserData>(0);
		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[userData.ElementTypeIndex];

		// We flip the matrix order in the function so it reads nicer (Transform(the, by))
		// but to do the math we need to flip them back to the right order
		byte* matrix0 = call.GetParameterUnchecked(0);
		byte* matrix1 = call.GetParameterUnchecked(1);
		byte* returnMatrix = call.GetReturnUnchecked();

		for (size_t matrix0Y = 0; matrix0Y < userData.Matrix0SizeY; ++matrix0Y)
		{
			for (size_t matrix1X = 0; matrix1X < userData.Matrix1SizeX; ++matrix1X)
			{
				byte* returnElement = IndexIntoMatrix(returnMatrix, matrix1X, matrix0Y, userData.Matrix1SizeX, userData.Matrix1SizeY, elementType->Size);
				// To properly accumulate the multiplications the initial value first needs to be zeroed out
				memset(returnElement, 0, elementType->Size);

				for (size_t matrix1Y = 0; matrix1Y < userData.Matrix1SizeY; ++matrix1Y)
				{
					// The x of matrix 0 and the y of matrix 1 are the
					// same (just make this variable for clarity)
					size_t matrix0X = matrix1Y;

					byte* matrix0Element = IndexIntoMatrix(matrix0, matrix0X, matrix0Y, userData.Matrix0SizeX, userData.Matrix0SizeY, elementType->Size);
					byte* matrix1Element = IndexIntoMatrix(matrix1, matrix1X, matrix1Y, userData.Matrix1SizeX, userData.Matrix1SizeY, elementType->Size);

					// We need to accumulate the multiplications of matrix0 and matrix1 but
					// we don't know what the inner type is or how to perform add or multiply,
					// so call a function that knows how to add our current type
					core.TypeMultiplyAddFunctions[userData.ElementTypeIndex](returnElement, matrix0Element, matrix1Element);
				}
			}
		}
	}

	//***************************************************************************
	void GenerateMatrixMembers(LibraryBuilder& builder, BoundType* type, MatrixUserData& matrixUserData)
	{
		Core& core = Core::GetInstance();
		BoundType* elementType = core.MatrixElementTypes[matrixUserData.ElementTypeIndex];

		char componentNames[] = { '0', '1', '2', '3' };

		for (size_t sizeY = 0; sizeY < matrixUserData.SizeY; ++sizeY)
		{
			for (size_t sizeX = 0; sizeX < matrixUserData.SizeX; ++sizeX)
			{
				StringBuilder nameBuilder;
				nameBuilder.Append("M");
				nameBuilder.Append(componentNames[sizeY]);
				nameBuilder.Append(componentNames[sizeX]);

				// Get the offset into the matrix structure for the current member (by offsetting from 0)
				size_t offset = (size_t)IndexIntoMatrix((byte*)nullptr, sizeX, sizeY, matrixUserData.SizeX, matrixUserData.SizeY, elementType->Size);
				builder.AddBoundField(type, nameBuilder.ToString(), elementType, offset, MemberOptions::None);
			}
		}
	}

	//***************************************************************************
	void CreateMatrixTypes(LibraryBuilder& builder)
	{
		Core& core = Core::GetInstance();
		// For now don't make 1xN or Nx1 matrices

		// Setup functions needed for Transform that'll tell us
		// how to perform the madd intrinsic on a matrix element
		core.TypeMultiplyAddFunctions[0] = MultiplyAddReal;
		core.TypeMultiplyAddFunctions[1] = MultiplyAddInteger;
		core.TypeMultiplyAddFunctions[2] = MultiplyAddBoolean;

		// Some later operations need to operate on different dimensions/typed
		// matrices so store them all locally here for a second pass
		BoundType* matrixTypes[Core::MaxMatrixElementTypes][Core::MaxMatrixComponents][Core::MaxMatrixComponents];

		for (size_t typeIndex = 0; typeIndex < Core::MaxMatrixElementTypes; ++typeIndex)
		{
			for (size_t sizeY = Core::MinMatrixComponents; sizeY <= Core::MaxMatrixComponents; ++sizeY)
			{
				for (size_t sizeX = Core::MinMatrixComponents; sizeX <= Core::MaxMatrixComponents; ++sizeX)
				{
					// The indices into the matrix types 3d array
					size_t indexX = sizeX - 1;
					size_t indexY = sizeY - 1;

					BoundType* elementType = core.MatrixElementTypes[typeIndex];

					// Build up the matrices's names (Real3x3, Integer3x3, etc...)
					StringBuilder typeNameBuilder;
					typeNameBuilder.Append(elementType->ToString());
					typeNameBuilder << sizeY;
					typeNameBuilder.Append('x');
					typeNameBuilder << sizeX;

					// Add the bound type for the matrix and store it for later use
					String fullyQualifiedName = typeNameBuilder.ToString();
					size_t matrixSize = elementType->Size * sizeX * sizeY;
					BoundType* matrixType = builder.AddBoundType(fullyQualifiedName, TypeCopyMode::ValueType, matrixSize);
					matrixTypes[typeIndex][indexY][indexX] = matrixType;

					// Create complex user data to store information needed to
					// generically handle matrix operations independently of size and type
					MatrixUserData matrixUserData(sizeX, sizeY, typeIndex);
					matrixType->ComplexUserData.WriteObject(matrixUserData);

					matrixType->ToStringFunction = MatrixToString;

					// Bind all of the functions that are only for the matrix with its own type
					Function* f = builder.AddBoundDefaultConstructor(matrixType, MatrixDefaultConstructor);
					f->ComplexUserData.WriteObject(matrixUserData);
					ParameterArray constructorParameters;
					for (size_t y = 0; y < sizeY; ++y)
					{
						for (size_t x = 0; x < sizeX; ++x)
						{
							DelegateParameter& param = constructorParameters.push_back();
							param.Name = String::Format("m%d%d", y, x);
							param.ParameterType = elementType;
						}
					}
					f = builder.AddBoundConstructor(matrixType, MatrixConstructor, constructorParameters);
					f->ComplexUserData.WriteObject(matrixUserData);

					f = builder.AddBoundFunction(matrixType, "Get", MatrixGet, TwoParameters(core.IntegerType, "y", "x"), elementType, FunctionOptions::None);
					f->ComplexUserData.WriteObject(matrixUserData);
					f = builder.AddBoundFunction(matrixType, "Set", MatrixSet, ThreeParameters(core.IntegerType, "y", core.IntegerType, "x", elementType, "value"), core.VoidType, FunctionOptions::None);
					f->ComplexUserData.WriteObject(matrixUserData);
					f = builder.AddBoundFunction(matrixType, "Get", MatrixGetVector, OneParameter(core.IntegerType, "y"), core.RealTypes[indexX], FunctionOptions::None);
					f->ComplexUserData.WriteObject(matrixUserData);
					f = builder.AddBoundFunction(matrixType, "Set", MatrixSetVector, TwoParameters(core.IntegerType, "y", core.RealTypes[indexX], "value"), core.VoidType, FunctionOptions::None);
					f->ComplexUserData.WriteObject(matrixUserData);
					// Don't actually want to have this equal function bound, but for unit testing it can be nice
					//f = builder.AddBoundFunction(matrixType, "Equal", MatrixEqual, OneParameter(matrixType), core.BooleanType, FunctionOptions::None);
					//f->ComplexUserData.WriteObject(matrixUserData);

					// Bind properties
					Property* p = builder.AddBoundProperty(matrixType, "CountX", core.IntegerType, nullptr, MatrixCountX, FunctionOptions::None);
					p->Get->ComplexUserData.WriteObject(matrixUserData);
					p = builder.AddBoundProperty(matrixType, "CountY", core.IntegerType, nullptr, MatrixCountY, FunctionOptions::None);
					p->Get->ComplexUserData.WriteObject(matrixUserData);

					// Generate all of the M00, M01, etc... members
					GenerateMatrixMembers(builder, matrixType, matrixUserData);
				}
			}
		}

		// Add the Real and Integer matrix types to an array of all of those types
		for (size_t sizeY = Core::MinMatrixComponents; sizeY <= Core::MaxMatrixComponents; ++sizeY)
		{
			for (size_t sizeX = Core::MinMatrixComponents; sizeX <= Core::MaxMatrixComponents; ++sizeX)
			{
				// Get the two matrix types (as a transpose can have different dimensions)
				BoundType* realMatrixType = matrixTypes[0][sizeY - 1][sizeX - 1];
				BoundType* integerMatrixType = matrixTypes[1][sizeY - 1][sizeX - 1];
				BoundType* booleanMatrixType = matrixTypes[2][sizeY - 1][sizeX - 1];

				core.AllRealTypes.push_back(realMatrixType);
				core.AllIntegerTypes.push_back(integerMatrixType);
				core.AllBooleanTypes.push_back(booleanMatrixType);
			}
		}

		// Add the determinant functions (only for real because that's all hlsl has)
		Function* fn = builder.AddBoundFunction(core.MathType, "Determinant", RealMatrixDeterminant<Math::Matrix2>, OneParameter(matrixTypes[0][1][1]), core.RealType, FunctionOptions::Static);
		fn = builder.AddBoundFunction(core.MathType, "Determinant", RealMatrixDeterminant<Math::Matrix3>, OneParameter(matrixTypes[0][2][2]), core.RealType, FunctionOptions::Static);
		fn = builder.AddBoundFunction(core.MathType, "Determinant", RealMatrixDeterminant<Math::Matrix4>, OneParameter(matrixTypes[0][3][3]), core.RealType, FunctionOptions::Static);

		// Operations on one matrix that need to reference different matrix
		// types (only need a loop over x and y dimensions plus types)
		for (size_t typeIndex = 0; typeIndex < Core::MaxMatrixElementTypes; ++typeIndex)
		{
			for (size_t sizeY = Core::MinMatrixComponents; sizeY <= Core::MaxMatrixComponents; ++sizeY)
			{
				for (size_t sizeX = Core::MinMatrixComponents; sizeX <= Core::MaxMatrixComponents; ++sizeX)
				{
					// Get the two matrix types (as a transpose can have different dimensions)
					BoundType* matrixType = matrixTypes[typeIndex][sizeY - 1][sizeX - 1];
					BoundType* resultType = matrixTypes[typeIndex][sizeX - 1][sizeY - 1];

					MatrixUserData matrixUserData(sizeX, sizeY, typeIndex);
					Function* f = builder.AddBoundFunction(core.MathType, "Transpose", MatrixTranspose, OneParameter(matrixType), resultType, FunctionOptions::Static);
					f->ComplexUserData.WriteObject(matrixUserData);
				}
			}
		}

		// Iterate over matrices that share one common dimension for multiplication
		// (but skip bools because boolean matrix multiplication is weird...)
		for (size_t typeIndex = 0; typeIndex < Core::MaxMatrixElementTypes - 1; ++typeIndex)
		{
			for (size_t matrixASizeY = Core::MinMatrixComponents; matrixASizeY <= Core::MaxMatrixComponents; ++matrixASizeY)
			{
				for (size_t matrixASizeX = Core::MinMatrixComponents; matrixASizeX <= Core::MaxMatrixComponents; ++matrixASizeX)
				{
					BoundType* matrixA = matrixTypes[typeIndex][matrixASizeY - 1][matrixASizeX - 1];

					for (size_t matrixBSizeX = Core::MinMatrixComponents; matrixBSizeX <= Core::MaxMatrixComponents; ++matrixBSizeX)
					{
						size_t matrixBSizeY = matrixASizeX;
						BoundType* matrixB = matrixTypes[typeIndex][matrixBSizeY - 1][matrixBSizeX - 1];
						BoundType* resultMatrix = matrixTypes[typeIndex][matrixASizeY - 1][matrixBSizeX - 1];

						MatrixTransformUserData transformUserData(matrixASizeX, matrixASizeY, matrixBSizeX, matrixBSizeY, typeIndex);
						Function* f = builder.AddBoundFunction(core.MathType, "Multiply", MatrixTransform, TwoParameters(matrixA, "by", matrixB, "the"), resultMatrix, FunctionOptions::Static);
						f->ComplexUserData.WriteObject(transformUserData);
					}

					// Also generate the matrix * vector versions
					MatrixTransformUserData transformUserData(matrixASizeX, matrixASizeY, 1, matrixASizeX, typeIndex);
					BoundType* inVectorType = core.RealTypes[matrixASizeX - 1];
					BoundType* resultVectorType = core.RealTypes[matrixASizeY - 1];
					Function* f = builder.AddBoundFunction(core.MathType, "Multiply", MatrixTransform, TwoParameters(matrixA, "by", inVectorType, "the"), resultVectorType, FunctionOptions::Static);
					f->ComplexUserData.WriteObject(transformUserData);
				}
			}
		}
	}

}//namespace Zilch
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	ZilchDefineSimpleType(Property, Core);
	ZilchDefineSimpleType(Field, Core);

	//***************************************************************************
	AttributeParameter::AttributeParameter() :
		Type(AttributeType::Null),
		NumberValue(0.0),
		BooleanValue(false)
	{
	}

	//***************************************************************************
	DocumentedObject::DocumentedObject() :
		IsHidden(false)
	{
	}

	//***************************************************************************
	bool DocumentedObject::HasAttribute(StringParam name)
	{
		// Walk through the array of attributes (usually small)
		for (size_t i = 0; i < this->Attributes.size(); ++i)
		{
			// If we found a matching name, then we do have that attribue
			if (this->Attributes[i].Name == name)
				return true;
		}

		// If we got here, we didn't find the attribute
		return false;
	}

	//***************************************************************************
	Member::Member() :
		Owner(nullptr)
	{
	}

	//***************************************************************************
	Property::Property() :
		PropertyType(nullptr),
		IsStatic(false),
		Get(nullptr),
		Set(nullptr),
		IsHiddenWhenNull(false)
	{
	}

	//***************************************************************************
	Property::~Property()
	{
	}

	//***************************************************************************
	String Property::GetDocumentationKey()
	{
		// If this is static, we should include that in the key
		if (this->IsStatic)
		{
			return BuildString("[Static] ", this->Name, " : ", this->PropertyType->ToString());
		}
		else
		{
			return BuildString(this->Name, " : ", this->PropertyType->ToString());
		}
	}

	//***************************************************************************
	Field::Field() :
		Offset(0)
	{
	}

	//***************************************************************************
	Variable::Variable() :
		Local(0),
		ResultType(Core::GetInstance().ErrorType)
	{
	}

	//***************************************************************************
	SendsEvent::SendsEvent() :
		ResultType(Core::GetInstance().ErrorType)
	{
	}
}/**************************************************************\
 * Author: Trevor Sundberg
 * Copyright 2012-2014, DigiPen Institute of Technology
 \**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	const char* Instruction::Names[] =
	{
#define ZilchEnumValue(value) #value,
		/**************************************************************\
		* Author: Trevor Sundberg
		* Copyright 2012-2014, DigiPen Institute of Technology
		\**************************************************************/

		// Note: These macros mirror those inside of Shared and VirtualMachine (for generation of instructions)

		// Copy
#define ZilchCopyInstructions(Type)               \
  ZilchEnumValue(Copy##Type)

		// Equality and inequality
#define ZilchEqualityInstructions(Type)           \
  ZilchEnumValue(TestInequality##Type)            \
  ZilchEnumValue(TestEquality##Type)

		// Less and greater comparison
#define ZilchComparisonInstructions(Type)         \
  ZilchEnumValue(TestLessThan##Type)              \
  ZilchEnumValue(TestLessThanOrEqualTo##Type)     \
  ZilchEnumValue(TestGreaterThan##Type)           \
  ZilchEnumValue(TestGreaterThanOrEqualTo##Type)

		// Generic numeric operators, copy, equality
#define ZilchNumericInstructions(Type)            \
  ZilchCopyInstructions(Type)                     \
  ZilchEqualityInstructions(Type)                 \
  /* No instruction for unary plus */             \
  ZilchEnumValue(Negate##Type)                    \
  ZilchEnumValue(Increment##Type)                 \
  ZilchEnumValue(Decrement##Type)                 \
  ZilchEnumValue(Add##Type)                       \
  ZilchEnumValue(Subtract##Type)                  \
  ZilchEnumValue(Multiply##Type)                  \
  ZilchEnumValue(Divide##Type)                    \
  ZilchEnumValue(Modulo##Type)                    \
  ZilchEnumValue(Pow##Type)                       \
  ZilchEnumValue(AssignmentAdd##Type)             \
  ZilchEnumValue(AssignmentSubtract##Type)        \
  ZilchEnumValue(AssignmentMultiply##Type)        \
  ZilchEnumValue(AssignmentDivide##Type)          \
  ZilchEnumValue(AssignmentModulo##Type)          \
  ZilchEnumValue(AssignmentPow##Type)

		// Generic numeric operators, copy, equality, comparison
#define ZilchScalarInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)

		// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)               \
  ZilchEnumValue(ScalarMultiply##Type)            \
  ZilchEnumValue(ScalarDivide##Type)              \
  ZilchEnumValue(ScalarModulo##Type)              \
  ZilchEnumValue(ScalarPow##Type)                 \
  ZilchEnumValue(AssignmentScalarMultiply##Type)  \
  ZilchEnumValue(AssignmentScalarDivide##Type)    \
  ZilchEnumValue(AssignmentScalarModulo##Type)    \
  ZilchEnumValue(AssignmentScalarPow##Type)

		// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralInstructions(Type)           \
  ZilchEnumValue(BitwiseNot##Type)                \
  ZilchEnumValue(BitshiftLeft##Type)              \
  ZilchEnumValue(BitshiftRight##Type)             \
  ZilchEnumValue(BitwiseOr##Type)                 \
  ZilchEnumValue(BitwiseXor##Type)                \
  ZilchEnumValue(BitwiseAnd##Type)                \
  ZilchEnumValue(AssignmentBitshiftLeft##Type)    \
  ZilchEnumValue(AssignmentBitshiftRight##Type)   \
  ZilchEnumValue(AssignmentBitwiseOr##Type)       \
  ZilchEnumValue(AssignmentBitwiseXor##Type)      \
  ZilchEnumValue(AssignmentBitwiseAnd##Type)

		// Core instructions
		ZilchEnumValue(InvalidInstruction)

		ZilchEnumValue(InternalDebugBreakpoint)
		ZilchEnumValue(ThrowException)
		ZilchEnumValue(PropertyDelegate)

		ZilchEnumValue(BeginTimeout)
		ZilchEnumValue(EndTimeout)

		ZilchEnumValue(BeginScope)
		ZilchEnumValue(EndScope)

		ZilchEnumValue(ToHandle)

		ZilchEnumValue(BeginStringBuilder)
		ZilchEnumValue(EndStringBuilder)
		ZilchEnumValue(AddToStringBuilder)

		ZilchEnumValue(CreateInstanceDelegate)
		ZilchEnumValue(CreateStaticDelegate)

		ZilchEnumValue(IfFalseRelativeGoTo)
		ZilchEnumValue(IfTrueRelativeGoTo)
		ZilchEnumValue(RelativeGoTo)

		ZilchEnumValue(Return)
		ZilchEnumValue(PrepForFunctionCall)
		ZilchEnumValue(FunctionCall)

		ZilchEnumValue(NewObject)
		ZilchEnumValue(LocalObject)
		ZilchEnumValue(DeleteObject)

		// Primitive type instructions
		ZilchIntegralInstructions(Integer)
		ZilchScalarInstructions(Integer)
		ZilchVectorInstructions(Integer2)
		ZilchVectorInstructions(Integer3)
		ZilchVectorInstructions(Integer4)
		ZilchIntegralInstructions(Integer2)
		ZilchIntegralInstructions(Integer3)
		ZilchIntegralInstructions(Integer4)
		ZilchScalarInstructions(Real)
		ZilchVectorInstructions(Real2)
		ZilchVectorInstructions(Real3)
		ZilchVectorInstructions(Real4)
		ZilchScalarInstructions(DoubleReal)
		ZilchIntegralInstructions(DoubleInteger)
		ZilchScalarInstructions(DoubleInteger)

		ZilchEqualityInstructions(Boolean)
		ZilchEqualityInstructions(Handle)
		ZilchEqualityInstructions(Delegate)
		ZilchEqualityInstructions(Any)
		ZilchEqualityInstructions(Value)

		ZilchCopyInstructions(Boolean)
		ZilchCopyInstructions(Any)
		ZilchCopyInstructions(Handle)
		ZilchCopyInstructions(Delegate)
		ZilchCopyInstructions(Value)

		ZilchEnumValue(LogicalNotBoolean)

		ZilchEnumValue(ConvertIntegerToReal)
		ZilchEnumValue(ConvertIntegerToBoolean)
		ZilchEnumValue(ConvertRealToInteger)
		ZilchEnumValue(ConvertRealToBoolean)
		ZilchEnumValue(ConvertBooleanToInteger)
		ZilchEnumValue(ConvertBooleanToReal)

		ZilchEnumValue(ConvertInteger2ToReal2)
		ZilchEnumValue(ConvertInteger2ToBoolean2)
		ZilchEnumValue(ConvertReal2ToInteger2)
		ZilchEnumValue(ConvertReal2ToBoolean2)
		ZilchEnumValue(ConvertBoolean2ToInteger2)
		ZilchEnumValue(ConvertBoolean2ToReal2)

		ZilchEnumValue(ConvertInteger3ToReal3)
		ZilchEnumValue(ConvertInteger3ToBoolean3)
		ZilchEnumValue(ConvertReal3ToInteger3)
		ZilchEnumValue(ConvertReal3ToBoolean3)
		ZilchEnumValue(ConvertBoolean3ToInteger3)
		ZilchEnumValue(ConvertBoolean3ToReal3)

		ZilchEnumValue(ConvertInteger4ToReal4)
		ZilchEnumValue(ConvertInteger4ToBoolean4)
		ZilchEnumValue(ConvertReal4ToInteger4)
		ZilchEnumValue(ConvertReal4ToBoolean4)
		ZilchEnumValue(ConvertBoolean4ToInteger4)
		ZilchEnumValue(ConvertBoolean4ToReal4)

		ZilchEnumValue(ConvertDowncast)
		ZilchEnumValue(ConvertToAny)
		ZilchEnumValue(ConvertFromAny)
		ZilchEnumValue(AnyDynamicMemberGet)
		ZilchEnumValue(AnyDynamicMemberSet)

#undef ZilchEnumValue
	};

	//***************************************************************************
	Operand::Operand() :
		HandleConstantLocal(0),
		Field(0),
		Type(OperandType::NotSet)
	{
	}

	//***************************************************************************
	Operand::Operand(OperandIndex local) :
		HandleConstantLocal(local),
		Field(0),
		Type(OperandType::Local)
	{
	}

	//***************************************************************************
	Operand::Operand(OperandIndex handleConstantLocal, size_t field, OperandType::Enum type) :
		HandleConstantLocal(handleConstantLocal),
		Field(field),
		Type(type)
	{
	}

	//***************************************************************************
	DebugOperand::DebugOperand()
	{
		this->OperandOffset = (size_t)-1;
		this->Primitive = DebugPrimitive::Memory;
		this->IsLocalOnly = false;
	}

	//***************************************************************************
	DebugOperand::DebugOperand(size_t offset, DebugPrimitive::Enum primitive, bool isLocal, StringParam name)
	{
		this->OperandOffset = offset;
		this->Primitive = primitive;
		this->IsLocalOnly = isLocal;
		this->Name = name;
	}

	//***************************************************************************
	DebugInstruction::DebugInstruction() :
		IsCopy(false)
	{
	}

#define ZilchOperand(array, type, member, primitive, isLocal) \
  array.push_back(DebugOperand(offsetof(type, member), primitive, isLocal, #member));

	//***************************************************************************
	void GenerateDebugInstructionInfo(Array<DebugInstruction>& debugOut)
	{
		debugOut.resize(Instruction::Count);

		// ToHandle
		{
			DebugInstruction& info = debugOut[Instruction::ToHandle];
			ZilchOperand(info.ReadOperands, ToHandleOpcode, ToHandle, DebugPrimitive::Memory, false);
			ZilchOperand(info.WriteOperands, ToHandleOpcode, SaveLocal, DebugPrimitive::Memory, true);
		}

		// CreateStaticDelegate
	{
		DebugInstruction& info = debugOut[Instruction::CreateStaticDelegate];
		info.FunctionPointers.push_back(offsetof(CreateStaticDelegateOpcode, BoundFunction));
		ZilchOperand(info.WriteOperands, CreateStaticDelegateOpcode, SaveLocal, DebugPrimitive::Delegate, true);
	}

	// CreateInstanceDelegate
	{
		DebugInstruction& info = debugOut[Instruction::CreateInstanceDelegate];
		info.FunctionPointers.push_back(offsetof(CreateInstanceDelegateOpcode, BoundFunction));
		ZilchOperand(info.ReadOperands, CreateInstanceDelegateOpcode, ThisHandle, DebugPrimitive::Handle, false);
		ZilchOperand(info.WriteOperands, CreateInstanceDelegateOpcode, SaveLocal, DebugPrimitive::Delegate, true);
	}


	// IfFalseRelativeGoTo / IfTrueRelativeGoTo
	{
		Instruction::Enum instructions[] =
		{
			Instruction::IfFalseRelativeGoTo,
			Instruction::IfTrueRelativeGoTo
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, IfOpcode, Condition, DebugPrimitive::Boolean, false);
			info.OpcodeOffsets.push_back(offsetof(IfOpcode, JumpOffset));
		}
	}

	// IfTrueRelativeGoTo
	{
		DebugInstruction& info = debugOut[Instruction::IfTrueRelativeGoTo];
		ZilchOperand(info.ReadOperands, IfOpcode, Condition, DebugPrimitive::Boolean, false);
		info.OpcodeOffsets.push_back(offsetof(IfOpcode, JumpOffset));
	}


	// RelativeGoTo
	{
		DebugInstruction& info = debugOut[Instruction::RelativeGoTo];
		info.OpcodeOffsets.push_back(offsetof(RelativeJumpOpcode, JumpOffset));
	}

	// PrepForFunctionCall
	{
		DebugInstruction& info = debugOut[Instruction::PrepForFunctionCall];
		ZilchOperand(info.ReadOperands, PrepForFunctionCallOpcode, Delegate, DebugPrimitive::Delegate, false);
		info.OpcodeOffsets.push_back(offsetof(PrepForFunctionCallOpcode, JumpOffsetIfStatic));
	}

	// NewObject
	{
		DebugInstruction& info = debugOut[Instruction::NewObject];
		info.TypePointers.push_back(offsetof(CreateTypeOpcode, CreatedType));
		ZilchOperand(info.WriteOperands, CreateTypeOpcode, SaveHandleLocal, DebugPrimitive::Handle, true);
	}

	// LocalObject
	{
		DebugInstruction& info = debugOut[Instruction::LocalObject];
		info.TypePointers.push_back(offsetof(CreateLocalTypeOpcode, CreatedType));
		ZilchOperand(info.WriteOperands, CreateLocalTypeOpcode, SaveHandleLocal, DebugPrimitive::Handle, true);
		ZilchOperand(info.WriteOperands, CreateLocalTypeOpcode, StackLocal, DebugPrimitive::Memory, true);
	}

	// DeleteObject
	{
		DebugInstruction& info = debugOut[Instruction::DeleteObject];
		ZilchOperand(info.WriteOperands, DeleteObjectOpcode, Object, DebugPrimitive::Handle, false);
	}


	// [UnaryRValueOpcode]
	{
		Instruction::Enum instructions[] =
		{
			Instruction::NegateInteger,
			Instruction::NegateReal,
			Instruction::NegateReal2,
			Instruction::NegateReal3,
			Instruction::NegateReal4,
			Instruction::LogicalNotBoolean,
			Instruction::BitwiseNotInteger
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Boolean,
			DebugPrimitive::Integer
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, UnaryRValueOpcode, SingleOperand, primitive, false);
			ZilchOperand(info.WriteOperands, UnaryRValueOpcode, Output, primitive, true);
		}
	}

	// [UnaryLValueOpcode]
	{
		Instruction::Enum instructions[] =
		{
			Instruction::IncrementInteger,
			Instruction::IncrementReal,
			Instruction::DecrementInteger,
			Instruction::DecrementReal,
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Integer,
			DebugPrimitive::Real
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.WriteOperands, UnaryLValueOpcode, SingleOperand, primitive, false);
		}
	}

	// [BinaryRValueOpcode] (Result + Operands all the same type)
	{
		Instruction::Enum instructions[] =
		{
			Instruction::BitshiftLeftInteger,
			Instruction::BitshiftRightInteger,
			Instruction::BitwiseOrInteger,
			Instruction::BitwiseXorInteger,
			Instruction::BitwiseAndInteger,
			Instruction::AddInteger,
			Instruction::AddReal,
			Instruction::AddReal2,
			Instruction::AddReal3,
			Instruction::AddReal4,
			Instruction::SubtractInteger,
			Instruction::SubtractReal,
			Instruction::SubtractReal2,
			Instruction::SubtractReal3,
			Instruction::SubtractReal4,
			Instruction::MultiplyInteger,
			Instruction::MultiplyReal,
			Instruction::MultiplyReal2,
			Instruction::MultiplyReal3,
			Instruction::MultiplyReal4,
			Instruction::DivideInteger,
			Instruction::DivideReal,
			Instruction::DivideReal2,
			Instruction::DivideReal3,
			Instruction::DivideReal4,
			Instruction::ModuloInteger,
			Instruction::ModuloReal,
			Instruction::ModuloReal2,
			Instruction::ModuloReal3,
			Instruction::ModuloReal4,
			Instruction::PowInteger,
			Instruction::PowReal,
			Instruction::PowReal2,
			Instruction::PowReal3,
			Instruction::PowReal4
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Boolean,
			DebugPrimitive::Boolean,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Left, primitive, false);
			ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Right, primitive, false);
			ZilchOperand(info.WriteOperands, BinaryRValueOpcode, Output, primitive, true);
		}
	}

	// [BinaryRValueOpcode] (Operands all the same type, Result is a Boolean)
	{
		Instruction::Enum instructions[] =
		{
			Instruction::TestLessThanInteger,
			Instruction::TestLessThanReal,
			Instruction::TestLessThanOrEqualToInteger,
			Instruction::TestLessThanOrEqualToReal,
			Instruction::TestGreaterThanInteger,
			Instruction::TestGreaterThanReal,
			Instruction::TestGreaterThanOrEqualToInteger,
			Instruction::TestGreaterThanOrEqualToReal,
			Instruction::TestInequalityInteger,
			Instruction::TestInequalityReal,
			Instruction::TestInequalityBoolean,
			Instruction::TestInequalityHandle,
			Instruction::TestInequalityReal2,
			Instruction::TestInequalityReal3,
			Instruction::TestInequalityReal4,
			Instruction::TestEqualityInteger,
			Instruction::TestEqualityReal,
			Instruction::TestEqualityBoolean,
			Instruction::TestEqualityHandle,
			Instruction::TestEqualityReal2,
			Instruction::TestEqualityReal3,
			Instruction::TestEqualityReal4
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Boolean,
			DebugPrimitive::Handle,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Boolean,
			DebugPrimitive::Handle,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Left, primitive, false);
			ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Right, primitive, false);
			ZilchOperand(info.WriteOperands, BinaryRValueOpcode, Output, DebugPrimitive::Boolean, true);
		}
	}

	// [BinaryRValueOpcode] (Scalar + Vector operations)
	{
		Instruction::Enum instructions[] =
		{
			Instruction::ScalarMultiplyReal2,
			Instruction::ScalarMultiplyReal3,
			Instruction::ScalarMultiplyReal4,
			Instruction::ScalarDivideReal2,
			Instruction::ScalarDivideReal3,
			Instruction::ScalarDivideReal4,
			Instruction::ScalarModuloReal2,
			Instruction::ScalarModuloReal3,
			Instruction::ScalarModuloReal4,
			Instruction::ScalarPowReal2,
			Instruction::ScalarPowReal3,
			Instruction::ScalarPowReal4
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Left, primitive, false);
			ZilchOperand(info.ReadOperands, BinaryRValueOpcode, Right, DebugPrimitive::Real, false);
			ZilchOperand(info.WriteOperands, BinaryRValueOpcode, Output, primitive, true);
		}
	}

	// [BinaryLValueOpcode] (Operands all the same type)
	{
		Instruction::Enum instructions[] =
		{
			Instruction::AssignmentBitshiftLeftInteger,
			Instruction::AssignmentBitshiftRightInteger,
			Instruction::AssignmentBitwiseOrInteger,
			Instruction::AssignmentBitwiseXorInteger,
			Instruction::AssignmentBitwiseAndInteger,
			Instruction::AssignmentAddInteger,
			Instruction::AssignmentAddReal,
			Instruction::AssignmentAddReal2,
			Instruction::AssignmentAddReal3,
			Instruction::AssignmentAddReal4,
			Instruction::AssignmentSubtractInteger,
			Instruction::AssignmentSubtractReal,
			Instruction::AssignmentSubtractReal2,
			Instruction::AssignmentSubtractReal3,
			Instruction::AssignmentSubtractReal4,
			Instruction::AssignmentMultiplyInteger,
			Instruction::AssignmentMultiplyReal,
			Instruction::AssignmentMultiplyReal2,
			Instruction::AssignmentMultiplyReal3,
			Instruction::AssignmentMultiplyReal4,
			Instruction::AssignmentDivideInteger,
			Instruction::AssignmentDivideReal,
			Instruction::AssignmentDivideReal2,
			Instruction::AssignmentDivideReal3,
			Instruction::AssignmentDivideReal4,
			Instruction::AssignmentModuloInteger,
			Instruction::AssignmentModuloReal,
			Instruction::AssignmentModuloReal2,
			Instruction::AssignmentModuloReal3,
			Instruction::AssignmentModuloReal4,
			Instruction::AssignmentPowInteger,
			Instruction::AssignmentPowReal,
			Instruction::AssignmentPowReal2,
			Instruction::AssignmentPowReal3,
			Instruction::AssignmentPowReal4
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, BinaryLValueOpcode, Right, primitive, false);
			ZilchOperand(info.WriteOperands, BinaryLValueOpcode, Output, primitive, false);
		}
	}

	// [BinaryLValueOpcode] (Scalar + Vector assignment operations)
	{
		Instruction::Enum instructions[] =
		{
			Instruction::AssignmentScalarMultiplyReal2,
			Instruction::AssignmentScalarMultiplyReal3,
			Instruction::AssignmentScalarMultiplyReal4,
			Instruction::AssignmentScalarDivideReal2,
			Instruction::AssignmentScalarDivideReal3,
			Instruction::AssignmentScalarDivideReal4,
			Instruction::AssignmentScalarModuloReal2,
			Instruction::AssignmentScalarModuloReal3,
			Instruction::AssignmentScalarModuloReal4,
			Instruction::AssignmentScalarPowReal2,
			Instruction::AssignmentScalarPowReal3,
			Instruction::AssignmentScalarPowReal4
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, BinaryLValueOpcode, Right, DebugPrimitive::Real, false);
			ZilchOperand(info.WriteOperands, BinaryLValueOpcode, Output, primitive, false);
		}
	}

	// [ConversionOpcode]
	{
		Instruction::Enum instructions[] =
		{
			Instruction::ConvertIntegerToReal,
			Instruction::ConvertIntegerToBoolean,
			Instruction::ConvertRealToInteger,
			Instruction::ConvertRealToBoolean,
			Instruction::ConvertBooleanToInteger,
			Instruction::ConvertBooleanToReal
		};

		DebugPrimitive::Enum fromTypes[] =
		{
			DebugPrimitive::Integer,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real,
			DebugPrimitive::Boolean,
			DebugPrimitive::Boolean,
		};

		DebugPrimitive::Enum toTypes[] =
		{
			DebugPrimitive::Real,
			DebugPrimitive::Boolean,
			DebugPrimitive::Integer,
			DebugPrimitive::Boolean,
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum fromPrimitive = fromTypes[i];
			DebugPrimitive::Enum toPrimitive = toTypes[i];
			DebugInstruction& info = debugOut[instruction];
			ZilchOperand(info.ReadOperands, ConversionOpcode, ToConvert, fromPrimitive, false);
			ZilchOperand(info.WriteOperands, ConversionOpcode, Output, toPrimitive, true);
		}
	}

	// [CopyOpcode]
	{
		Instruction::Enum instructions[] =
		{
			Instruction::CopyInteger,
			Instruction::CopyReal,
			Instruction::CopyReal2,
			Instruction::CopyReal3,
			Instruction::CopyReal4,
			Instruction::CopyBoolean,
			Instruction::CopyHandle,
			Instruction::CopyDelegate,
			Instruction::CopyValue
		};

		DebugPrimitive::Enum types[] =
		{
			DebugPrimitive::Integer,
			DebugPrimitive::Real,
			DebugPrimitive::Real2,
			DebugPrimitive::Real3,
			DebugPrimitive::Real4,
			DebugPrimitive::Boolean,
			DebugPrimitive::Handle,
			DebugPrimitive::Delegate,
			DebugPrimitive::Memory,
		};

		for (size_t i = 0; i < ZilchCArrayCount(instructions); ++i)
		{
			Instruction::Enum instruction = instructions[i];
			DebugPrimitive::Enum primitive = types[i];
			DebugInstruction& info = debugOut[instruction];
			info.IsCopy = true;
			ZilchOperand(info.ReadOperands, CopyOpcode, Source, primitive, false);
			ZilchOperand(info.WriteOperands, CopyOpcode, Destination, primitive, false);
			info.Sizes.push_back(offsetof(CopyOpcode, Size));
			info.Options.push_back(offsetof(CopyOpcode, Mode));
		}
	}
	}
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	bool Overload::ResolveAndImplicitConvert
		(
		const FunctionArray* functions,
		Function*& resolvedFunction,
		FunctionCallNode& functionCallNode
		)
	{
		// Loop through all the overload passes
		for (size_t passIndex = OverloadPass::NoImplicitConversion; passIndex <= OverloadPass::AnyImplicitConversion; ++passIndex)
		{
			// Get the current pass as an enum
			OverloadPass::Enum pass = (OverloadPass::Enum)passIndex;

			// Loop through all the function overloads that we have to choose from
			for (size_t i = 0; i < functions->size(); ++i)
			{
				// Get the current function
				Function* function = (*functions)[i];

				// Check the current function type against the call
				if (TestDelegateTypeVsCall(function->Type, functionCallNode, pass))
				{
					// If we're on the last pass, then we need to generate implicit conversion code
					if (pass == OverloadPass::AnyImplicitConversion)
						GenerateImplicitCasts(function->Type, functionCallNode);

					// Set the resolved function, and return a success
					resolvedFunction = function;
					return true;
				}
			}
		}

		// Since we got here, the overload was not resolved
		return false;
	}

	//***************************************************************************
	void Overload::GetFunctionCallSignatureString(StringBuilder& builder, const FunctionCallNode& functionCallNode)
	{
		// Add on the beginning call parentheses
		builder.Append("(");

		// Store the number of arguments we need to print
		size_t count = functionCallNode.Arguments.size();

		// Loop through all the arguments
		for (size_t i = 0; i < count; ++i)
		{
			// If the call uses named arguments...
			if (functionCallNode.IsNamed)
			{
				// Write the name of the argument
				builder.Append(functionCallNode.ArgumentNames[i]);
				builder.Append(" : ");
			}

			// Grab the current type
			Type* type = functionCallNode.Arguments[i]->ResultType;

			// Always make sure the type is valid / resolved
			if (type != nullptr)
			{
				// Write the type of the argument
				builder.Append(type->ToString());
			}
			else
			{
				Error("Attempting to print a signature where one of the argument types is invalid!");
			}

			// If we're not at the end
			if (i != count - 1)
			{
				// Add commas to separate out the arguments
				builder.Append(", ");
			}
		}

		// Add on the ending call parentheses
		builder.Append(")");
	}

	//***************************************************************************
	void Overload::ReportSingleError
		(
		CompilationErrors& errors,
		const CodeLocation& location,
		const DelegateType* type,
		const FunctionCallNode& functionCallNode
		)
	{
		// Get the calling signature
		StringBuilder call;
		call.Append("\n\n  delegate");
		GetFunctionCallSignatureString(call, functionCallNode);
		call.Append("\n\n");

		// Build a string to enumerate all possible overloads
		StringBuilder options;
		options.Append("\n\n  delegate");
		type->BuildSignatureString(options);

		// Now report the error
		return errors.Raise(location, ErrorCode::UnableToResolveFunction,
			"delegate",
			call.ToString().c_str(),
			options.ToString().c_str());
	}

	//***************************************************************************
	void Overload::ReportError
		(
		CompilationErrors& errors,
		const CodeLocation& location,
		const FunctionArray* functions,
		const FunctionCallNode& functionCallNode
		)
	{
		// Error checking
		ErrorIf(functions == nullptr || functions->empty(),
			"We cannot report overloading errors when no functions were provided");

		// Get the name of one of the functions (we know there is at least one function in this array)
		String name = (*functions)[0]->Name;

		// Get the calling signature
		StringBuilder call;
		call.Append("\n\n  ");
		call.Append(name);
		GetFunctionCallSignatureString(call, functionCallNode);
		call.Append("\n\n");

		// Build a string to enumerate all possible overloads
		StringBuilder options;
		options.Append("\n");

		// Loop through all the function choices we have
		for (size_t i = 0; i < functions->size(); ++i)
		{
			// Get the current function
			Function* function = (*functions)[i];

			// Add each function signature to the output
			options.Append("\n  ");
			options.Append(name);
			function->Type->BuildSignatureString(options);
		}

		// Now report the error
		return errors.Raise(location, ErrorCode::UnableToResolveFunction,
			name.c_str(),
			call.ToString().c_str(),
			options.ToString().c_str());
	}

	//***************************************************************************
	bool Overload::TestCallAndImplicitConvert(DelegateType* delegateType, FunctionCallNode& functionCallNode)
	{
		// Perform each pass one at a time (early out as soon as we get a hit)
		if (TestDelegateTypeVsCall(delegateType, functionCallNode, OverloadPass::NoImplicitConversion))
			return true;
		if (TestDelegateTypeVsCall(delegateType, functionCallNode, OverloadPass::RawImplicitConversion))
			return true;
		if (TestDelegateTypeVsCall(delegateType, functionCallNode, OverloadPass::AnyImplicitConversion))
		{
			// In the last phase, we need to actually generate implicit casts (TypeCastNodes)
			GenerateImplicitCasts(delegateType, functionCallNode);
			return true;
		}

		// If we got here, the signature did not match at all
		return false;
	}

	//***************************************************************************
	void Overload::GenerateImplicitCasts(DelegateType* delegateType, FunctionCallNode& functionCallNode)
	{
		// Grab the list of arguments and parameters for convenience
		NodeList<ExpressionNode>& arguments = functionCallNode.Arguments;
		ParameterArray& parameters = delegateType->Parameters;

		// Get the number of arguments
		size_t argumentCount = functionCallNode.Arguments.size();
		ErrorIf(parameters.size() != argumentCount, "We should have already verified that that the parameter count matched");

		// First check to see that the overload has all the same argument names
		for (size_t i = 0; i < argumentCount; ++i)
		{
			// Get the current delegate parameter and expression argument
			const DelegateParameter& delegateParameter = parameters[i];
			ExpressionNode* argument = arguments[i];

			// Store the types in a more human readable format
			Type* fromType = argument->ResultType;
			Type* toType = delegateParameter.ParameterType;

			// Generate the implicit conversion
			Syntaxer::ImplicitConvertAfterWalkAndIo(arguments[i], toType);
		}
	}

	//***************************************************************************
	bool Overload::TestDelegateTypeVsCall(DelegateType* delegateType, FunctionCallNode& functionCallNode, OverloadPass::Enum pass)
	{
		// Get the number of arguments
		size_t argumentCount = functionCallNode.Arguments.size();

		// Get the arguments for the function call
		NodeList<ExpressionNode>::range arguments = functionCallNode.Arguments.all();

		// First, check that the call has the same number of arguments as the type's parameters
		// NOTE: This is important that we do this first, since the positional check below
		// test is there are no parameters (and assumes both have the same number)
		if (delegateType->Parameters.size() != argumentCount)
			return false;

		// First check to see that the overload has all the same argument names
		for (size_t i = 0; i < delegateType->Parameters.size(); ++i)
		{
			// Get the current delegate parameter
			const DelegateParameter& delegateParameter = delegateType->Parameters[i];

			// In a positional call, the argument index is just the current index (they must match exactly)
			size_t index = i;

			// If we are calling with named arguments...
			if (functionCallNode.IsNamed)
			{
				// Attempt to find the argument by name (it's a non positional call!)
				index = functionCallNode.ArgumentNames.findIndex(delegateParameter.Name);

				// If we didn't find anything...
				if (index == (size_t)-1)
				{
					// The overload did not match...
					return false;
				}
			}

			// Grab the current argument
			ExpressionNode* argument = arguments.front();

			// We really need to make sure that all argument types are resolved
			ReturnIf
				(
				argument->ResultType == nullptr,
				false,
				"Failed to find a type for a given argument"
				);

			// Store the types in a more human readable format
			Type* fromType = argument->ResultType;
			Type* toType = delegateParameter.ParameterType;

			// Figure out what type of cast this is...
			Shared& shared = Shared::GetInstance();
			switch (pass)
			{
			case OverloadPass::NoImplicitConversion:
			{
				// In this phase, the types must match *exactly*
				if (Type::IsSame(fromType, toType) == false)
					return false;
				break;
			}

			case OverloadPass::RawImplicitConversion:
			{
				// In this phase the types can be different but must be implicitly raw convertable
				// Ex: Conversion from NullType to Animal (does no work because NullType is also a handle)
				CastOperator cast = shared.GetCastOperator(fromType, toType);
				if (cast.IsValid == false || cast.CanBeImplicit == false || cast.RequiresCodeGeneration)
					return false;
				break;
			}

			case OverloadPass::AnyImplicitConversion:
			{
				// In this phase the types can be different but must be implicitly convertable (code generation may occur)
				// Ex: Conversion from an Integer to a Real
				CastOperator cast = shared.GetCastOperator(fromType, toType);
				if (cast.IsValid == false || cast.CanBeImplicit == false)
					return false;
				break;
			}

			default:
				Error("Invalid overload pass!");
				break;
			}

			// Move the argument forward
			arguments.popFront();
		}

		// We must have matched if we got here!
		return true;
	}

	////***************************************************************************
	//void Overload::DetectAmbiguities(FunctionArray& functions, Function* function)
	//{
	//}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

// Defines
#define ZilchSaveAndVerifyTokenPosition()                   \
  TokenPositionVerifier __verifier(&this->TokenPositions);  \
  this->SaveTokenPosition();

namespace Zilch
{
	//***************************************************************************
	// Structure that helps us to verify that our parser is working properly
	class TokenPositionVerifier
	{
	public:
		PodArray<size_t>* Positions;
		size_t Count;

		TokenPositionVerifier(PodArray<size_t>* positions) :
			Positions(positions),
			Count(positions->size())
		{
		}

		~TokenPositionVerifier()
		{
			ErrorIf(this->Count != this->Positions->size(),
				"Token count was not equal when we left the stack as when we started");
		}
	};

	//***************************************************************************
	Parser::Parser(CompilationErrors& errors) :
		TokenIndex(0),
		Errors(errors)
	{
		ZilchErrorIfNotStarted(Parser);
	}

	//***************************************************************************
	void Parser::ParseIntoTree(const Array<UserToken>& tokens, SyntaxTree& syntaxTree, EvaluationMode::Enum evaluation)
	{
		// If we have no tokens, don't do anything
		if (IsTokenStreamEmpty(tokens))
			return;

		// Clear all token positions, just incase we reuse this parser
		this->TokenIndex = 0;
		this->TokenPositions.clear();

		// Store the tokenizer
		this->TokenStream = &tokens;

		// If we're evaluating an entire project, parse all the classes
		if (evaluation == EvaluationMode::Project)
		{
			// Get the root node for convenience
			RootNode* root = syntaxTree.Root;

			// Specifies if we parsed anything inside the script
			bool parsedSomething;

			// Parse the things that can show up inside a script (the outer most scope)
			do
			{
				// We haven't parsed anything yet this iteration...
				parsedSomething = false;

				// Attempt to parse a class definition
				parsedSomething |= root->NonTraversedNonOwnedNodesInOrder.Add(root->Classes.Add(this->Class())) != nullptr;

				// Attempt to parse an enum definition
				parsedSomething |= root->NonTraversedNonOwnedNodesInOrder.Add(root->Enums.Add(this->Enum())) != nullptr;
			} while (parsedSomething == true);
		}
		// Otherwise, we're just evaluating a single expression
		else
		{
			// Get the location where the expression is occuring
			CodeLocation location = tokens.front().Location;

			// We create a fake class node to hold the expression, since all expressions
			// must be inside functions, and all functions must be inside classes
			ClassNode* classNode = new ClassNode();
			classNode->Location = location;

			// All static classes are by choice a reference class (even if it cannot be allocated0
			classNode->CopyMode = TypeCopyMode::ReferenceType;

			// The class has a special generated name that cannot be accessed from within code
			classNode->Name = ExpressionProgram;

			// Now we need to generate a special function to put the expression within
			FunctionNode* functionNode = new FunctionNode();
			functionNode->Location = location;

			// The function will have a special name that cannot be accessed from within code
			functionNode->Name = ExpressionMain;

			// The function is going to be static so that it can be invoked without a context
			functionNode->IsStatic = true;

			// Parse just one expression from the tokens (this may fail and return null!)
			syntaxTree.SingleExpression = this->Expression();

			// Add the expression as a single statement to the function
			functionNode->Statements.Add(syntaxTree.SingleExpression);

			// Add the psuedo function to the class
			classNode->Functions.Add(functionNode);
			classNode->NonTraversedNonOwnedNodesInOrder.Add(functionNode);

			// Finally, attach the class (and therefore function / expression) to the root
			syntaxTree.Root->Classes.Add(classNode);
			syntaxTree.Root->NonTraversedNonOwnedNodesInOrder.Add(classNode);
		}

		// If we somehow parsed everything, but didn't get to the end, we should throw an error
		if (this->TokenIndex != this->TokenStream->size() - 1)
		{
			// Grab the last token we hit
			UserToken token = (*this->TokenStream)[this->TokenIndex];

			// Show an error message that prints out the token we hit
			return this->Errors.Raise(token.Location, ErrorCode::ParsingNotComplete, token.Token.c_str(), Grammar::GetName(token.TokenId).c_str());
		}

		// If we parsed everything but there were attributes that never got attached to anything...
		if (this->LastAttributes.empty() == false)
		{
			// Show an error message to tell the user that attributes never got attached
			return this->Errors.Raise(this->LastAttributes.back()->Location, ErrorCode::AttributesNotAttached);
		}
	}

	//***************************************************************************
	bool Parser::IsTokenStreamEmpty(const Array<UserToken>& tokens)
	{
		// If it's strictly empty, just return
		if (tokens.empty())
			return true;

		// Otherwise, check if the size is one and the front element is end
		if (tokens.size() == 1 && tokens.front().TokenId == Grammar::End)
			return true;

		// If we got here, it must not be empty
		return false;
	}

	//***************************************************************************
	void Parser::ParseExpressionInFunctionAndClass(const Array<UserToken>& expression, const Array<UserToken>& function, const Array<UserToken>& classTokensWithoutFunction, SyntaxTree& syntaxTree)
	{
		// If we have no expression tokens, don't do anything
		if (IsTokenStreamEmpty(expression))
			return;

		// Get the location where the expression is occuring
		CodeLocation location = expression.front().Location;

		// The resulting class node (either partially parsed or generaed)
		ClassNode* classNode = nullptr;

		// If we have the ability to parse a class...
		if (IsTokenStreamEmpty(function) == false)
		{
			// Clear all token positions and set the token stream to the class tokens
			this->TokenIndex = 0;
			this->TokenPositions.clear();
			this->TokenStream = &classTokensWithoutFunction;

			// Attempt to parse the class (remember, this class is guaranteed to not have the function within it)
			classNode = this->Class();
		}

		// If we either didn't have the ability to parse a class, or we failed on every attempt...
		if (classNode == nullptr)
		{
			// We create a fake class node to hold the expression, since all expressions
			// must be inside functions, and all functions must be inside classes
			classNode = new ClassNode();
			classNode->Location = location;

			// All static classes are by choice a reference class (even if it cannot be allocated0
			classNode->CopyMode = TypeCopyMode::ReferenceType;

			// The class has a special generated name that cannot be accessed from within code
			classNode->Name = ExpressionProgram;
		}

		// Parse the given tokens as a function
		GenericFunctionNode* functionNode = nullptr;

		// If we have the ability to parse a function...
		if (IsTokenStreamEmpty(function) == false)
		{
			// To figure out what to do, just read the first token
			const UserToken& firstToken = function.front();

			// Clear all token positions and set the token stream to the function tokens
			this->TokenIndex = 0;
			this->TokenPositions.clear();
			this->TokenStream = &function;

			switch (firstToken.TokenId)
			{
			case Grammar::Function:
			{
				FunctionNode* node = this->Function();
				if (node != nullptr)
				{
					functionNode = node;

					// Add the psuedo function to the class
					classNode->Functions.Add(node);
					classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
				}
				break;
			}

			case Grammar::Constructor:
			{
				ConstructorNode* node = this->Constructor();
				if (node != nullptr)
				{
					functionNode = node;

					// Add the psuedo function to the class
					classNode->Constructors.Add(node);
					classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
				}
				break;
			}

			case Grammar::Destructor:
			{
				DestructorNode* node = this->Destructor();
				if (node != nullptr)
				{
					functionNode = node;

					// Add the psuedo function to the class
					classNode->Destructor = node;
					classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
				}
				break;
			}

			case Grammar::Get:
			{
				// We're supposed to have read the get/set token, so advance by 1
				++this->TokenIndex;
				BoundSyntaxType* type = new BoundSyntaxType();
				type->TypeName = "Integer";
				MemberVariableNode* memberVariable = new MemberVariableNode();
				memberVariable->IsProperty = true;
				memberVariable->Name = "[Generated]";
				memberVariable->ResultSyntaxType = type;
				FunctionNode* node = this->GetSetFunctionBody(memberVariable, true);
				if (node != nullptr)
				{
					functionNode = node;

					// Add the psuedo function to the class via member variable
					classNode->Variables.Add(memberVariable);
					classNode->NonTraversedNonOwnedNodesInOrder.Add(memberVariable);
				}
				break;
			}

			case Grammar::Set:
			{
				// We're supposed to have read the get/set token, so advance by 1
				++this->TokenIndex;
				BoundSyntaxType* type = new BoundSyntaxType();
				type->TypeName = "Integer";
				MemberVariableNode* memberVariable = new MemberVariableNode();
				memberVariable->IsProperty = true;
				memberVariable->Name = "[Generated]";
				memberVariable->ResultSyntaxType = type;
				FunctionNode* node = this->GetSetFunctionBody(memberVariable, false);
				if (node != nullptr)
				{
					functionNode = node;

					// Add the psuedo function to the class via member variable
					classNode->Variables.Add(memberVariable);
					classNode->NonTraversedNonOwnedNodesInOrder.Add(memberVariable);
				}
				break;
			}
			}
		}

		// If we either didn't have the ability to parse a function, or we failed on every attempt...
		if (functionNode == nullptr)
		{
			// Now we need to generate a special function to put the expression within
			FunctionNode* node = new FunctionNode();
			functionNode = node;
			node->Location = location;

			// The function will have a special name that cannot be accessed from within code
			node->Name = ExpressionMain;

			// The function is going to be static so that it can be invoked without a context
			node->IsStatic = true;

			// Add the psuedo function to the class
			classNode->Functions.Add(node);
			classNode->NonTraversedNonOwnedNodesInOrder.Add(node);
		}

		// Again, clear all token positions and set the token stream to the expression tokens
		this->TokenIndex = 0;
		this->TokenPositions.clear();
		this->TokenStream = &expression;

		// Parse just one expression from the tokens (this may fail and return null!)
		syntaxTree.SingleExpression = this->Expression();

		// As long as we got a valid single expression...
		if (syntaxTree.SingleExpression != nullptr)
		{
			// Find the scope that the expression probably exists within
			// (the latest scope before the expression's location)
			// Even if this cannot find a scope, it should always return the function node itself
			ScopeNode* latestScope = FindNearestScope(functionNode, syntaxTree.SingleExpression->Location);

			// We really don't want to crash doing auto-complete, but this is a serious error
			if (latestScope == nullptr)
			{
				return;
			}

			// Add the expression as a single statement to the latest scope (at the end of it)
			// so it will be evaluated in the context of that scope
			// Note that the found scope could just be the function itself
			latestScope->Statements.Add(syntaxTree.SingleExpression);
		}

		// Finally, attach the class (and therefore function / expression) to the root
		syntaxTree.Root->Classes.Add(classNode);
		syntaxTree.Root->NonTraversedNonOwnedNodesInOrder.Add(classNode);
	}

	//***************************************************************************
	ScopeNode* Parser::FindNearestScope(SyntaxNode* node, const CodeLocation& location)
	{
		// If this node that we're testing happens to come before the location...
		// Technically we should be testing if the location's end is within the node's end,
		// however it's slightly more tolerant to just check if the location's start is before the end
		// This should never happen, but we'll handle it anyways
		bool isLocationInsideNode =
			location.StartLine >= node->Location.StartLine &&
			(location.StartLine != node->Location.StartLine || location.StartCharacter >= node->Location.StartCharacter) &&
			location.StartLine <= node->Location.EndLine &&
			(location.StartLine != node->Location.EndLine || location.StartCharacter <= node->Location.EndCharacter);

		// We only want to consider nodes that we're inside of
		if (isLocationInsideNode == false)
		{
			return nullptr;
		}

		// We know that child nodes always come after our own node in a script
		// Therefore, we test ourself first, and then test children (to get the latest scope)
		ScopeNode* lastScope = TypeBinding::DynamicCast<ScopeNode*>(node);

		// Get all the children of this current node, as they could also be scopes
		NodeChildren children;
		node->PopulateChildren(children);

		// Loop through all the child nodes, some of which could be scopes
		for (size_t i = 0; i < children.size(); ++i)
		{
			// Grab the current child
			SyntaxNode* child = (*children[i]);

			// Recursively find any scopes in that node
			ScopeNode* found = FindNearestScope(child, location);

			// If we found anything....
			if (found != nullptr)
			{
				// We know here that the found scope must come after any previously found scopes, so replace it!
				lastScope = found;
			}
		}

		// Return whatever we found (this could be null!)
		return lastScope;
	}

	//***************************************************************************
	SyntaxType* Parser::ParseType(const Array<UserToken>& type)
	{
		// Clear all token positions and set the token stream to the type tokens
		this->TokenIndex = 0;
		this->TokenPositions.clear();
		this->TokenStream = &type;

		// Now attempt to read the type and see what we find
		return this->ReadTypeInfo();
	}

	//***************************************************************************
	void Parser::ErrorHere(ErrorCode::Enum errorCode, ...)
	{
		// Start a variadic argument list
		va_list argList;
		va_start(argList, errorCode);

		// Call the other error function
		ErrorHereArgs(errorCode, argList);

		// End the argument list
		va_end(argList);
	}

	//***************************************************************************
	void Parser::ErrorHereArgs(ErrorCode::Enum errorCode, StringParam extra, va_list argList)
	{
		// When raising an error 'here', we don't actually want the current token,
		// but rather the last token since our token index always points at the next token
		int previousIndex = (int)this->TokenIndex;
		--previousIndex;

		// Make sure we weren't at the first token, and if so cap our index at 0
		if (previousIndex < 0)
		{
			previousIndex = 0;
		}

		// Get the previous token
		const UserToken& previousToken = (*this->TokenStream)[(size_t)previousIndex];
		const UserToken& nextToken = (*this->TokenStream)[this->TokenIndex];

		// If we have a difference in lines...
		if (nextToken.Location.PrimaryLine != previousToken.Location.PrimaryLine)
		{
			// Invoke the error as if it was on the previous one
			this->Errors.RaiseArgs(previousToken.Location, extra, LocationArray(), errorCode, argList);
		}
		else
		{
			// Since it's on the same line, show the error at the next token
			this->Errors.RaiseArgs(nextToken.Location, extra, LocationArray(), errorCode, argList);
		}
	}

	//***************************************************************************
	void Parser::ErrorHereArgs(ErrorCode::Enum errorCode, va_list argList)
	{
		return ErrorHereArgs(errorCode, String(), argList);
	}

	//***************************************************************************
	void Parser::SetNodeLocationStartHere(SyntaxNode* node)
	{
		// Get the token where the last saved position was
		SetNodeLocationStartToToken(node, (*this->TokenStream)[this->TokenIndex]);
	}

	//***************************************************************************
	void Parser::SetNodeLocationPrimaryHere(SyntaxNode* node)
	{
		// Get the token where the last saved position was
		SetNodeLocationPrimaryToToken(node, (*this->TokenStream)[this->TokenIndex]);
	}

	//***************************************************************************
	void Parser::SetNodeLocationEndHere(SyntaxNode* node)
	{
		// When setting the end, we don't actually want the current token, but rather the last token
		// since our token index always points at the next token (which would be correct if we were starting)
		int previousIndex = (int)this->TokenIndex;
		--previousIndex;

		// Make sure we weren't at the first token, and if so cap our index at 0
		if (previousIndex < 0)
		{
			previousIndex = 0;
		}

		// Get the token where the last saved position was
		SetNodeLocationEndToToken(node, (*this->TokenStream)[(size_t)previousIndex]);
	}

	//***************************************************************************
	void Parser::SetNodeLocationStartToLastSave(SyntaxNode* node)
	{
		// Get the token where the last saved position was
		SetNodeLocationStartToToken(node, (*this->TokenStream)[this->TokenPositions.back()]);
	}

	//***************************************************************************
	void Parser::SetNodeLocationPrimaryToLastSave(SyntaxNode* node)
	{
		// Get the token where the last saved position was
		SetNodeLocationPrimaryToToken(node, (*this->TokenStream)[this->TokenPositions.back()]);
	}

	//***************************************************************************
	void Parser::SetNodeLocationEndToLastSave(SyntaxNode* node)
	{
		// Get the token where the last saved position was
		SetNodeLocationEndToToken(node, (*this->TokenStream)[this->TokenPositions.back()]);
	}

	//***************************************************************************
	void Parser::SetNodeLocationStartToToken(SyntaxNode* node, const UserToken& token)
	{
		// Set the line and character
		// Note that here we set the entire token, not just the start
		node->Location = token.Location;
	}

	//***************************************************************************
	void Parser::SetNodeLocationPrimaryToToken(SyntaxNode* node, const UserToken& token)
	{
		// Set the line and character
		node->Location.PrimaryCharacter = token.Location.PrimaryCharacter;
		node->Location.PrimaryLine = token.Location.PrimaryLine;
	}

	//***************************************************************************
	void Parser::SetNodeLocationEndToToken(SyntaxNode* node, const UserToken& token)
	{
		// Set the line and character
		node->Location.EndCharacter = token.Location.EndCharacter;
		node->Location.EndLine = token.Location.EndLine;
	}

	//***************************************************************************
	void Parser::SaveTokenPosition()
	{
		// Push the current token index onto the stack
		this->TokenPositions.push_back(this->TokenIndex);
	}

	//***************************************************************************
	void Parser::RecallTokenPosition()
	{
		// Pop the token index and revert the current one
		this->TokenIndex = this->TokenPositions.back();
		this->TokenPositions.pop_back();
	}

	//***************************************************************************
	void Parser::AcceptTokenPosition()
	{
		// Simply just pop the token position from the stack
		this->TokenPositions.pop_back();
	}

	//***************************************************************************
	bool Parser::AcceptAnyArgs(size_t parameters, const UserToken** out_token, va_list vl)
	{
		// Loop through all the extra arguments
		for (size_t i = 0; i < parameters; ++i)
		{
			// Retreive the symbol argument
			// We use int here because technically an enum can have any size (1, 2, etc)
			// but the va-args list will auto-promote the enum to int
			Grammar::Enum symbol = (Grammar::Enum)va_arg(vl, int /*Grammar::Enum*/);

			// Retreive the current token
			const UserToken* token = &(*this->TokenStream)[this->TokenIndex];

			// If the next token in the token stream was that same symbol...
			if (token->TokenId == symbol)
			{
				// We found one of them! Close the args list, increment the token index, output the value, and return success
				++this->TokenIndex;
				*out_token = token;
				return true;
			}
		}

		// Otherwise, if we got here we didn't find it :<
		return false;
	}

	//***************************************************************************
	bool Parser::AcceptAny(size_t parameters, const UserToken** out_token, ...)
	{
		// Create a variadic argument list to read the extra arguments
		va_list vl;
		va_start(vl, out_token);

		// Run the accept any that takes a va_list
		bool result = AcceptAnyArgs(parameters, out_token, vl);

		// Close the va_list and return the result
		va_end(vl);
		return result;
	}

	//***************************************************************************
	bool Parser::Expect(Grammar::Enum grammarConstant, ErrorCode::Enum errorCode, ...)
	{
		// Create a variadic argument list to read the extra arguments
		va_list vl;
		va_start(vl, errorCode);

		// Invoke the argument list version
		const UserToken* ignoredToken = nullptr;
		bool result = this->ExpectAndRetrieveArgs(grammarConstant, ignoredToken, errorCode, vl);

		// Finalize the argument list and return what we got back
		va_end(vl);
		return result;
	}

	//***************************************************************************
	bool Parser::ExpectAndRetrieveArgs(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, va_list vl)
	{
		// Retreive the next token from the stream and store it
		const UserToken* userToken = &(*this->TokenStream)[this->TokenIndex];

		// If the next token in the token stream was not the same symbol...
		if (userToken->TokenId != grammarConstant)
		{
			// Anything extra we decide to append to the error
			String extra;

			bool foundWasKeyword = (userToken->TokenId >= Grammar::Abstract && userToken->TokenId <= Grammar::While);

			if (grammarConstant == Grammar::LowerIdentifier || grammarConstant == Grammar::UpperIdentifier)
			{
				if (foundWasKeyword)
				{
					extra = String::Format(" Note: '%s' is a keyword and cannot be used as a name.",
						userToken->Token.c_str());
				}
				// If we expected an upper identifier, but we got a lower one...
				else if (userToken->TokenId == Grammar::LowerIdentifier)
				{
					String expectedIdentifier = ToUpperCamelCase(userToken->Token);
					extra = String::Format(" Upper-camel case names are required here (use '%s' instead of '%s').",
						expectedIdentifier.c_str(), userToken->Token.c_str());
				}
				// If we expected a lower identifier, but we got an upper one...
				else if (userToken->TokenId == Grammar::UpperIdentifier)
				{
					String expectedIdentifier = ToLowerCamelCase(userToken->Token);
					extra = String::Format(" Lower-camel case names are required here (use '%s' instead of '%s').",
						expectedIdentifier.c_str(), userToken->Token.c_str());
				}
			}
			else
			{
				// Get string representations of the two tokens so we can display info to the user
				String foundSymbol = Grammar::GetKeywordOrSymbol(userToken->TokenId);
				String expectedSymbol = Grammar::GetKeywordOrSymbol(grammarConstant);

				// Because we are expecting a particular token, format extra information so
				// that the error always says what we found and what we expected to find
				extra = String::Format(" We found '%s' but we expected to find '%s'.",
					foundSymbol.c_str(), expectedSymbol.c_str());
			}

			// Report an error here
			ErrorHereArgs(errorCode, extra, vl);

			// We found a token that wasn't what we were looking for, return failure
			va_end(vl);
			return false;
		}

		// Otherwise, if the out-token is not null, output the found token
		outToken = userToken;

		// We found all the given tokens! Push the token index out to the end of the list and return success
		++this->TokenIndex;
		return true;
	}

	//***************************************************************************
	bool Parser::ExpectAndRetrieve(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, ...)
	{
		// Create a variadic argument list to read the extra arguments
		va_list vl;
		va_start(vl, errorCode);

		// Invoke the argument list version
		bool result = this->ExpectAndRetrieveArgs(grammarConstant, outToken, errorCode, vl);

		// Finalize the argument list and return what we got back
		va_end(vl);
		return result;
	}

	//***************************************************************************
	bool Parser::Accept(size_t parameters, ...)
	{
		// Create a variadic argument list to read the extra arguments
		va_list vl;
		va_start(vl, parameters);

		// Compute the end token that we'll stop at
		const size_t end = parameters + this->TokenIndex;

		// Loop through all the tokens we were given (and loop over the tokens in the tokenizer)
		for (size_t i = this->TokenIndex; i < end; ++i)
		{
			// Retreive the symbol argument
			// We use int here because technically an enum can have any size (1, 2, etc)
			// but the va-args list will auto-promote the enum to int
			Grammar::Enum symbol = (Grammar::Enum)va_arg(vl, int /*Grammar::Enum*/);

			// If the next token in the token stream was not the same symbol...
			if ((*this->TokenStream)[i].TokenId != symbol)
			{
				// We found a token that wasn't what we were looking for, return failure
				va_end(vl);
				return false;
			}
		}

		// We found all the given tokens! Push the token index out to the end of the list and return success
		va_end(vl);
		this->TokenIndex = end;
		return true;
	}

	//***************************************************************************
	bool Parser::AcceptAndRetrieve(size_t parameters, ...)
	{
		// Create a variadic argument list to read the extra arguments
		va_list vl;
		va_start(vl, parameters);

		// Compute the end token that we'll stop at
		const size_t end = parameters + this->TokenIndex;

		// Loop through all the tokens we were given (and loop over the tokens in the tokenizer)
		for (size_t i = this->TokenIndex; i < end; ++i)
		{
			// Retreive the symbol argument and a pointer to the out token pointer
			// We use int here because technically an enum can have any size (1, 2, etc)
			// but the va-args list will auto-promote the enum to int
			Grammar::Enum symbol = (Grammar::Enum)va_arg(vl, int /*Grammar::Enum*/);

			// A pointer to a constant user token
			const UserToken** out_token = va_arg(vl, const UserToken**);

			// Retreive the next token from the stream and store it
			const UserToken* user_token = &(*this->TokenStream)[i];

			// If the next token in the token stream was not the same symbol...
			if (user_token->TokenId != symbol)
			{
				// We found a token that wasn't what we were looking for, return failure
				va_end(vl);
				return false;
			}

			// Otherwise, if the out-token is not null, output the found token
			if (out_token != nullptr)
				*out_token = user_token;
		}

		// We found all the given tokens! Push the token index out to the end of the list and return success
		va_end(vl);
		this->TokenIndex = end;
		return true;
	}

	//***************************************************************************
	bool Parser::ReadDelegateTypeContents(DelegateSyntaxType* delegateSyntaxType)
	{
		//// Is this a template type?
		//if (Accept(1, Grammar::BeginTemplate))
		//{
		//  // Parse arguments to the indexer until there are no more
		//  ZilchLoop
		//  {
		//    // Attempt to read another type
		//    SyntaxType* argumentType = this->ReadTypeInfo();

		//    // If the argument was valid...
		//    if (argumentType == nullptr)
		//    {
		//      // The argument was not found!
		//      ErrorHere(ErrorCode::TemplateArgumentNotFound);
		//    }
		//    else
		//    {
		//      // Add it to the arguments list
		//      dataSyntaxType->TemplateArguments.Add(argumentType);
		//    }

		//    // Attempt to read an argument separator, and if we don't find one, break out
		//    if (Accept(1, Grammar::ArgumentSeparator) == false)
		//    {
		//      break;
		//    }
		//  }

		//  // We now expect to close the template argument
		//  if (Expect(Grammar::EndTemplate, ErrorCode::TemplateTypeArgumentsNotComplete) == false)
		//  {
		//    // We didn't successfully parse a the type definition, so return a failure
		//    delete dataSyntaxType;
		//    RecallTokenPosition();
		//    return nullptr;
		//  }
		//}

		// Get the name of the function
		if (Expect(Grammar::BeginFunctionParameters, ErrorCode::FunctionArgumentListNotFound, "delegate"))
		{
			// Get all the parameters for the delegate
			do
			{
				// Store a temporary copy of the current parameter that we're reading in
				DelegateSyntaxParameter parameter;

				// Look for an identifier
				if (AcceptAndRetrieve(1, Grammar::LowerIdentifier, &parameter.Name))
				{
					// Look for a type specifier (followed by the parameter's type)
					if (Expect(Grammar::TypeSpecifier, ErrorCode::ParameterTypeSpecifierNotFound, parameter.Name->Token.c_str()))
					{
						// Attempt to read the type after the parameter
						if ((parameter.Type = this->ReadTypeInfo()) != nullptr)
						{
							// Add this parameter to the list of parameters
							delegateSyntaxType->Parameters.push_back(parameter);
						}
						else
						{
							// Show an error
							ErrorHere(ErrorCode::ParameterTypeNotFound, parameter.Name->Token.c_str());
							return false;
						}
					}
					else
					{
						// We didn't read the type specifier
						return false;
					}
				}
			} while (Accept(1, Grammar::ArgumentSeparator));

			// Look for the end parenthasis
			if (Expect(Grammar::EndFunctionParameters, ErrorCode::FunctionArgumentListNotComplete, "delegate"))
			{
				// Return if we successfully parsed the type at the end or not
				return AcceptOptionalTypeSpecifier(delegateSyntaxType->Return, ErrorCode::DelegateReturnTypeNotFound);
			}
		}

		// If we got down here, we must have failed...
		return false;
	}

	//***************************************************************************
	BoundSyntaxType* Parser::ReadBoundTypeInfo()
	{
		ZilchSaveAndVerifyTokenPosition();

		// Grab the user token for the identifier
		const UserToken* typeToken;

		// Look for the type identifier
		if (AcceptAndRetrieve(1, Grammar::UpperIdentifier, &typeToken) == true)
		{
			// Create a new data syntax type
			BoundSyntaxType* boundSyntaxType = new BoundSyntaxType();

			// Store away the type string
			boundSyntaxType->TypeName = typeToken->Token;

			// Is this a template type?
			if (Accept(1, Grammar::BeginTemplate))
			{
				// Parse arguments to the template there are no more
				ZilchLoop
				{
					// Attempt to read another type
					SyntaxType* argumentType = this->ReadTypeInfo();

					// If the argument was valid...
					if (argumentType == nullptr)
					{
						// The argument was not found!
						ErrorHere(ErrorCode::TemplateArgumentNotFound);

						// We didn't successfully parse a the type definition, so return a failure
						delete boundSyntaxType;
						RecallTokenPosition();
						return nullptr;
					}
					else
					{
						// Add it to the arguments list
						boundSyntaxType->TemplateArguments.Add(argumentType);
					}

					// Attempt to read an argument separator, and if we don't find one, break out
					if (Accept(1, Grammar::ArgumentSeparator) == false)
					{
						break;
					}
				}

					// We now expect to close the template argument
					if (Expect(Grammar::EndTemplate, ErrorCode::TemplateTypeArgumentsNotComplete) == false)
					{
						// We didn't successfully parse a the type definition, so return a failure
						delete boundSyntaxType;
						RecallTokenPosition();
						return nullptr;
					}
			}

			// Accept the token position and return the data type
			AcceptTokenPosition();

			// We'll return the data syntax type
			return boundSyntaxType;
		}

		// Return nothing since we failed to parse
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	SyntaxType* Parser::ReadTypeInfo()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// If this type represents the any type...
		if (this->Accept(1, Grammar::Any))
		{
			// There's nothing else to read about the any type, just return a new one
			this->AcceptTokenPosition();
			return new AnySyntaxType();
		}
		// If this type represents a delegate type...
		else if (this->Accept(1, Grammar::Delegate))
		{
			// Create a new delegate syntax type
			DelegateSyntaxType* delegateSyntaxType = new DelegateSyntaxType();

			// Read the delegate type
			if (this->ReadDelegateTypeContents(delegateSyntaxType))
			{
				// Accept the token position and return the delegate type
				this->AcceptTokenPosition();

				// We'll return the delegate syntax type
				return delegateSyntaxType;
			}
			else
			{
				// We didn't successfully parse a the deligate definition, so return a failure
				delete delegateSyntaxType;
				this->RecallTokenPosition();
				return nullptr;
			}
		}
		else
		{
			// Store whether or not this type is a reference (uses the ref keyword)
			bool isIndirectionRef = false;
			if (Accept(1, Grammar::Ref))
			{
				// This is an indirection
				isIndirectionRef = true;
			}

			// Attempt to read a named type...
			BoundSyntaxType* boundSyntaxType = this->ReadBoundTypeInfo();

			// If we failed to read the named syntax type, return nothing
			if (boundSyntaxType == nullptr)
			{
				this->RecallTokenPosition();
				return nullptr;
			}

			// If this is an indirection of a type (ref)
			if (isIndirectionRef)
			{
				// Create a qualified syntax type
				IndirectionSyntaxType* indirectionSyntaxType = new IndirectionSyntaxType();

				// Set the true type for the qualified type...
				indirectionSyntaxType->ReferencedType = boundSyntaxType;

				// Return the qualified syntax type
				this->AcceptTokenPosition();
				return indirectionSyntaxType;
			}
			else
			{
				// Return the true syntax type that we parsed
				this->AcceptTokenPosition();
				return boundSyntaxType;
			}
		}
	}

	//***************************************************************************
	LocalVariableNode* Parser::LocalVariable(bool initialized)
	{
		// Parse any optional attribute
		this->ParseAllOptionalAttributes();

		// If any errors occurred in parsing attributes, error here
		if (this->Errors.WasError)
			return nullptr;

		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// First look for the "var" keyword
		if (Accept(1, Grammar::Variable))
		{
			// Create a variable node
			LocalVariableNode* node = new LocalVariableNode();
			this->SetNodeLocationStartToLastSave(node);

			// Attach any attributes we parsed for this member variable
			this->AttachLastAttributeToNode(node->Attributes);

			// If this is a static variable...
			if (IsAttributePresent(node->Attributes, StaticAttribute))
			{
				node->IsStatic = true;
			}

			// Get the name of the variable
			const UserToken* variableName = nullptr;
			if (ExpectAndRetrieve(Grammar::LowerIdentifier, variableName, ErrorCode::VariableNameNotFound))
			{
				// Store the name of the node
				node->Name = variableName->Token;

				// Return if we successfully parsed the type at the end or not
				if (AcceptOptionalTypeSpecifier(node->ResultSyntaxType, ErrorCode::VariableTypeNotFound, node->Name.c_str()))
				{
					// If we don't need to be initialized, skip this next part
					if (initialized == false)
					{
						// Accept the token position, and return the variable node
						this->SetNodeLocationEndHere(node);
						this->AcceptTokenPosition();
						return node;
					}

					// Now make sure we are assigning to the variable
					if (Expect(Grammar::Assignment, ErrorCode::VariableMustBeInitialized, node->Name.c_str()))
					{
						// Now attempt to read an expression in
						node->InitialValue = Expression();

						// If we parsed an initial value...
						if (node->InitialValue != nullptr)
						{
							// Accept the token position, and return the variable node
							this->SetNodeLocationEndHere(node);
							this->AcceptTokenPosition();
							return node;
						}
						else
						{
							// Show an error message
							this->ErrorHere(ErrorCode::VariableInitialValueNotFound, node->Name.c_str());
						}
					}
				}
			}

			// We must have failed, so delete the node
			delete node;
		}

		// We didn't successfully parse a variable definition, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	template <typename Node>
	void Parser::ApplyVirtualAndStaticAttributes(Node* node)
	{
		// If this is a static function...
		if (IsAttributePresent(node->Attributes, StaticAttribute))
		{
			node->IsStatic = true;
		}

		// If this is a virtual function...
		if (IsAttributePresent(node->Attributes, VirtualAttribute))
		{
			// If the node is static, then we cannot be marked as virtual
			if (node->IsStatic)
			{
				this->ErrorHere(ErrorCode::StaticCannotBeVirtual, node->Name.c_str());
				return;
			}

			// Mark the node as being virtual
			node->Virtualized = VirtualMode::Virtual;
		}

		// If this is a virtual function...
		if (IsAttributePresent(node->Attributes, OverrideAttribute))
		{
			ErrorIf(node->Virtualized == VirtualMode::Overriding,
				"It is not possible to already be overriding");

			// If the node is non-virtual, then mark it as overriding
			if (node->Virtualized == VirtualMode::NonVirtual)
			{
				// If the node is static, then we cannot be marked as virtual or overriding
				if (node->IsStatic)
				{
					this->ErrorHere(ErrorCode::StaticCannotBeOverriding, node->Name.c_str());
					return;
				}

				// Mark the node as being overriding
				node->Virtualized = VirtualMode::Overriding;
			}
			else
			{
				// The node is both overriding and virtual, this is unnecessary
				this->ErrorHere(ErrorCode::UnnecessaryVirtualAndOverride, node->Name.c_str());
				return;
			}
		}
	}

	//***************************************************************************
	MemberVariableNode* Parser::MemberVariable()
	{
		// Parse any optional attribute
		this->ParseAllOptionalAttributes();

		// If any errors occurred in parsing attributes, error here
		if (this->Errors.WasError)
			return nullptr;

		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// First look for the "var" keyword
		if (Accept(1, Grammar::Variable))
		{
			// Create a variable node
			MemberVariableNode* node = new MemberVariableNode();
			this->SetNodeLocationStartToLastSave(node);

			// Attach any attributes we parsed for this member variable
			this->AttachLastAttributeToNode(node->Attributes);

			// The name token we attempt to read
			const UserToken* nameToken = nullptr;

			// Get the name of the variable
			if (ExpectAndRetrieve(Grammar::UpperIdentifier, nameToken, ErrorCode::VariableNameNotFound))
			{
				// Store the name of the node
				node->Name = nameToken->Token;

				// Look for any virtual and static attributes
				this->ApplyVirtualAndStaticAttributes(node);

				// If any errors occurred from the virtual/static parsing
				if (this->Errors.WasError)
				{
					// We didn't successfully parse the static/virtual/override attributes
					this->RecallTokenPosition();
					delete node;
					return nullptr;
				}

				// Look for a type after the member variable
				if (AcceptOptionalTypeSpecifier(node->ResultSyntaxType, ErrorCode::VariableTypeNotFound, node->Name.c_str()))
				{
					// As long as we got a valid type...
					if (node->ResultSyntaxType != nullptr)
					{
						// Accept the beginning scope
						if (Accept(1, Grammar::BeginScope))
						{
							// This is a property, thus we expect to find a get or a set, or both
							// They must always come in the order of 'get' first, then set
							node->IsProperty = true;

							// Check if we have a getter
							if (Accept(1, Grammar::Get))
							{
								// Read in the get function body
								node->Get = this->GetSetFunctionBody(node, true);
							}

							// Check if we have a setter
							if (Accept(1, Grammar::Set))
							{
								// Read in the set function body
								node->Set = this->GetSetFunctionBody(node, false);
							}

							// Error checking, we don't want to find a get after a set
							if (Accept(1, Grammar::Get))
							{
								// Show an error message
								this->ErrorHere(ErrorCode::GetFoundAfterSet, node->Name.c_str());
							}
							// We expect to see the end of the scope
							else if (Expect(Grammar::EndScope, ErrorCode::PropertyDeclarationNotComplete, node->Name.c_str()))
							{
								// Accept the token position, and return the variable node
								this->SetNodeLocationEndHere(node);
								this->AcceptTokenPosition();
								return node;
							}
							// If we're doing auto-complete or something like it...
							else if (this->Errors.TolerantMode)
							{
								// Since we're being tolerant, just eat tokens until we hit the end of our scope
								// This is just an approximation, as there may be actual scope errors
								// This will return true if it finds the scope and will advance the token forward automatically
								if (this->MoveToScopeEnd())
								{
									// Accept the token position, and return the variable node
									this->SetNodeLocationEndHere(node);
									this->AcceptTokenPosition();
									return node;
								}
							}
						}
						// We are not a property, so make sure the user is initializing the variable
						else if (this->Accept(1, Grammar::Assignment))
						{
							// Note: It is actually legal for a member variable to Overriding or Virtual
							// In the case that we're overriding, we'll still be a raw member when directly accessed, but
							// if we're accessed through an interface it will use the generated get/set
							// In the case that we're virtual, the member itself basically becomes a property
							// This needs to be handled specially, because in the PreInitialize we still wan't to assign
							// a value to the raw field data, but then anyone who accessing the member after that goes
							// through a property get/set

							// Now attempt to read the initialization expression in
							node->InitialValue = Expression();

							// If we failed to parsed an initial value...
							if (node->InitialValue == nullptr)
							{
								// Show an error message
								this->ErrorHere(ErrorCode::VariableInitialValueNotFound, node->Name.c_str());

								// We didn't successfully parse a variable definition, so just recall the token position and return null
								RecallTokenPosition();
								delete node;
								return nullptr;
							}

							// Attempt to read the statement separator
							if (this->Expect(Grammar::StatementSeparator, ErrorCode::VariableInitializationNotComplete, node->Name.c_str()))
							{
								// Accept the token position, and return the variable node
								this->SetNodeLocationEndHere(node);
								this->AcceptTokenPosition();
								return node;
							}
						}
						else
						{
							// Show an error message
							this->ErrorHere(ErrorCode::VariableMustBeInitialized, node->Name.c_str());
						}
					}
					else
					{
						// Show an error message
						this->ErrorHere(ErrorCode::MemberVariableTypesCannotBeInferred, node->Name.c_str());
					}
				}
			}

			// We must have failed, so delete the node
			delete node;
		}

		// We didn't successfully parse a variable definition, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	void Parser::ParseAllOptionalAttributes()
	{
		// Parse all the optional atrtibutes
		while (ParseOneOptionalAttribute());
	}

	//***************************************************************************
	bool Parser::ParseOneOptionalAttribute()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting an attribute
		if (Accept(1, Grammar::BeginIndex))
		{
			// Every attribute starts with a type name
			const UserToken* typeName;

			// Read the attribute name
			if (ExpectAndRetrieve(Grammar::UpperIdentifier, typeName, ErrorCode::AttributeTypeNotFound))
			{
				// Create an attribute node that we'll fill in below
				AttributeNode* node = new AttributeNode();
				this->SetNodeLocationStartToLastSave(node);

				// Save the type name on the node
				node->TypeName = typeName;

				// Read an optional function call after the attribute node
				node->AttributeCall = this->FunctionCall();

				// If there was any sort of error, bail out
				if (this->Errors.WasError)
				{
					// We didn't successfully parse the function call, so just recall the token position and return false
					delete node;
					RecallTokenPosition();
					return false;
				}

				// Look for the ending of the attribute
				if (Expect(Grammar::EndIndex, ErrorCode::AttributeNotComplete, typeName->Token.c_str()))
				{
					// Add this node to the list of attributes which
					// we will attach to the next valid node we find
					this->LastAttributes.Add(node);

					// Accept the token position, and return the attributes
					this->SetNodeLocationEndHere(node);
					AcceptTokenPosition();
					return true;
				}
				else
				{
					delete node;
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return false;
	}

	//***************************************************************************
	void Parser::AttachLastAttributeToNode(NodeList<AttributeNode>& attributes)
	{
		// Output the list of attributes
		attributes = this->LastAttributes;

		// Clear out the last attributes
		this->LastAttributes.clear();
	}

	//***************************************************************************
	EnumValueNode* Parser::EnumValue()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Stores the initializer type (reused variable)
		const UserToken* valueName;

		// Attempt to read the enum value name
		if (this->AcceptAndRetrieve(1, Grammar::UpperIdentifier, &valueName))
		{
			// Create a return node since this is a valid return statement
			EnumValueNode* node = new EnumValueNode();
			this->SetNodeLocationStartToLastSave(node);

			// Set the name of the enum
			node->Name = valueName->Token;

			// It's optional to set a specific integral value
			if (this->Accept(1, Grammar::Assignment))
			{
				// Read the custom value we want to give this enum entry
				if (this->ExpectAndRetrieve(Grammar::IntegerLiteral, node->Value, ErrorCode::EnumValueRequiresIntegerLiteral, node->Name.c_str()) == false)
				{
					// We didn't successfully parse an enum, so just recall the token position and return null
					this->RecallTokenPosition();
					delete node;
					return nullptr;
				}
			}

			// Accept the token position, and return the "return node"
			this->AcceptTokenPosition();
			this->SetNodeLocationEndHere(node);
			return node;
		}

		// We didn't successfully parse en enum, so just recall the token position and return null
		this->RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	EnumNode* Parser::Enum()
	{
		// Parse any optional attribute
		this->ParseAllOptionalAttributes();

		// If any errors occurred in parsing attributes, error here
		if (this->Errors.WasError)
			return nullptr;

		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// This will store the keyword we used to star this object (class or struct)
		const UserToken* enumType;

		// First look for the "enum" or "flags" keyword
		if (this->AcceptAny(2, &enumType, Grammar::Enumeration, Grammar::Flags))
		{
			// We must be inside a class, so allocate a node for it
			EnumNode* node = new EnumNode();
			this->SetNodeLocationStartToLastSave(node);

			// We read the class or struct keyword, it's safe to assume no other node type could be here
			// Attach the attributes we read above to the class node
			this->AttachLastAttributeToNode(node->Attributes);

			// Mark if this is considered a flags enum or not...
			node->IsFlags = (enumType->TokenId == Grammar::Flags);

			// Get the name of the enum
			const UserToken* name;
			if (this->ExpectAndRetrieve(Grammar::UpperIdentifier, name, ErrorCode::EnumNameNotFound))
			{
				// Set the name of the class node
				node->Name = name->Token;

				// Are we inheriting from a type (or implementing an interface?)
				if (this->Accept(1, Grammar::Inheritance))
				{
					// Attempt to read a parent type for this enum
					node->Inheritance = this->ReadTypeInfo();

					// If we had an error reading a type...
					if (this->Errors.WasError)
					{
						// We didn't successfully parse a class definition, so just recall the token position and return null
						delete node;
						RecallTokenPosition();
						return nullptr;
					}
				}

				// Now dive into the scope...
				if (this->Expect(Grammar::BeginScope, ErrorCode::EnumBodyNotFound, node->Name.c_str()))
				{
					// Parse the things that can show up inside a class until we run out of those
					ZilchLoop
					{
						// Attempt to add an enum value
						if (node->Values.Add(this->EnumValue()))
						{
							// If we don't find a comma, break out since there should be nothing more
							// Note that we allow a trailing comma after the last enum value
							if (this->Accept(1, Grammar::ArgumentSeparator) == false)
							{
								break;
							}
						}
						// We didn't parse an enum value, so break out
						else
						{
							break;
						}
					}

						// If we hit the end of the class scope...
					bool finishedNode = Expect(Grammar::EndScope, ErrorCode::EnumBodyNotComplete, node->Name.c_str());

					// As long as we finished this node (either via correct parsing or tolerance)
					if (finishedNode == false && this->Errors.TolerantMode)
					{
						// Since we're being tolerant, just eat tokens until we hit the end of our scope
						// This is just an approximation, as there may be actual scope errors
						// This will return true if it finds the scope and will advance the token forward automatically
						finishedNode = this->MoveToScopeEnd();
					}

					// As long as we finished this node (either via correct parsing or tolerance)
					if (finishedNode)
					{
						// We read the entire class defintion
						// Accept the token position, and return the class node
						this->AcceptTokenPosition();
						this->SetNodeLocationEndHere(node);
						return node;
					}
				}
			}

			// We must have failed, so delete the node
			delete node;
		}

		// We didn't successfully parse a class definition, so just recall the token position and return null
		this->RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ClassNode* Parser::Class()
	{
		// Parse any optional attribute
		this->ParseAllOptionalAttributes();

		// If any errors occurred in parsing attributes, error here
		if (this->Errors.WasError)
			return nullptr;

		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// This will store the keyword we used to star this object (class or struct)
		const UserToken* objectType;

		// First look for the "class" or "struct" keyword
		if (AcceptAny(2, &objectType, Grammar::Class, Grammar::Struct))
		{
			// We must be inside a class, so allocate a node for it
			ClassNode* node = new ClassNode();
			this->SetNodeLocationStartToLastSave(node);

			// We read the class or struct keyword, it's safe to assume no other node type could be here
			// Attach the attributes we read above to the class node
			this->AttachLastAttributeToNode(node->Attributes);

			// Set if we are a value type or not
			if (objectType->TokenId == Grammar::Struct)
			{
				// It was declared as a struct, therefore it is a value type!
				node->CopyMode = TypeCopyMode::ValueType;
			}
			else
			{
				node->CopyMode = TypeCopyMode::ReferenceType;
			}

			// Get the name of the class
			const UserToken* name;
			if (ExpectAndRetrieve(Grammar::UpperIdentifier, name, ErrorCode::ClassNameNotFound))
			{
				// Set the name of the class node
				node->Name = name->Token;

				// Is this a template type?
				if (Accept(1, Grammar::BeginTemplate))
				{
					// Parse arguments to the template until there are no more
					ZilchLoop
					{
						// Get the name of the argument
						const UserToken* argumentName;

						// Look for an identifier...
						if (ExpectAndRetrieve(Grammar::UpperIdentifier, argumentName, ErrorCode::TemplateArgumentNotFound))
						{
							// Add it to the arguments list
							node->TemplateArguments.push_back(argumentName);
						}
						else
						{
							// We didn't successfully parse a class definition, so just recall the token position and return null
							delete node;
							this->RecallTokenPosition();
							return nullptr;
						}

						// Attempt to read an argument separator, and if we don't find one, break out
						if (Accept(1, Grammar::ArgumentSeparator) == false)
						{
							break;
						}
					}

						// We now expect to close the template argument
						if (Expect(Grammar::EndTemplate, ErrorCode::TemplateTypeArgumentsNotComplete) == false)
						{
							// We didn't successfully parse a class definition, so just recall the token position and return null
							delete node;
							RecallTokenPosition();
							return nullptr;
						}
				}

				// Are we inheriting from a type (or implementing an interface?)
				if (Accept(1, Grammar::Inheritance))
				{
					// Parse all the interfaces / base class
					ZilchLoop
					{
						// Look for an identifier...
						if (SyntaxType* argumentType = this->ReadTypeInfo())
						{
							// Add it to the arguments list
							node->Inheritance.Add(argumentType);
						}
						else
						{
							// We didn't successfully parse a class definition, so just recall the token position and return null
							delete node;
							RecallTokenPosition();
							return nullptr;
						}

						// Attempt to read an argument separator, and if we don't find one, break out
						if (Accept(1, Grammar::ArgumentSeparator) == false)
						{
							break;
						}
					}
				}

				// Now dive into the scope...
				if (Expect(Grammar::BeginScope, ErrorCode::ClassBodyNotFound, node->Name.c_str()))
				{
					// Specifies if we parsed anything inside the current scope
					bool parsedSomething;

					// Clear the destructor first
					node->Destructor = nullptr;

					// Parse the things that can show up inside a class until we run out of those
					do
					{
						// We haven't parsed anything yet this iteration...
						parsedSomething = false;

						// Attempt to parse a variable
						parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->Variables.Add(this->MemberVariable())) != nullptr;

						// Attempt to parse a function definition
						parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->Functions.Add(this->Function())) != nullptr;

						// Attempt to parse a constructor definition
						parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->Constructors.Add(this->Constructor())) != nullptr;

						// Attempt to parse a 'sends' statement
						parsedSomething |= node->NonTraversedNonOwnedNodesInOrder.Add(node->SendsEvents.Add(this->SendsEvent())) != nullptr;

						// Attempt to parse a destructor definition
						DestructorNode* destructor = this->Destructor();
						if (destructor != nullptr)
						{
							if (node->Destructor == nullptr)
							{
								// Set the destructor
								node->NonTraversedNonOwnedNodesInOrder.Add(destructor);
								node->Destructor = destructor;
								parsedSomething = true;
							}
							else
							{
								// Show an error
								ErrorHere(ErrorCode::OnlyOneDestructorAllowed);

								// We didn't successfully parse a class definition, so just recall the token position and return null
								delete node;
								delete destructor;
								RecallTokenPosition();
								return nullptr;
							}
						}
					} while (parsedSomething == true);

					// If we hit the end of the class scope...
					bool finishedNode = Expect(Grammar::EndScope, ErrorCode::ClassBodyNotComplete, node->Name.c_str());

					// As long as we finished this node (either via correct parsing or tolerance)
					if (finishedNode == false && this->Errors.TolerantMode)
					{
						// Since we're being tolerant, just eat tokens until we hit the end of our scope
						// This is just an approximation, as there may be actual scope errors
						// This will return true if it finds the scope and will advance the token forward automatically
						finishedNode = this->MoveToScopeEnd();
					}

					// As long as we finished this node (either via correct parsing or tolerance)
					if (finishedNode)
					{
						// We read the entire class defintion
						// Accept the token position, and return the class node
						AcceptTokenPosition();
						this->SetNodeLocationEndHere(node);
						return node;
					}
				}
			}

			// We must have failed, so delete the node
			delete node;
		}

		// We didn't successfully parse a class definition, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	bool Parser::AcceptOptionalTypeSpecifier(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, ...)
	{
		// Start a variadic argument list
		va_list vl;
		va_start(vl, notFound);

		// Forward the arguments to the accept function
		bool result = this->AcceptOptionalTypeSpecifierArgs(outSyntaxType, notFound, vl);

		// We're done with the variadic list
		va_end(vl);
		return result;
	}

	//***************************************************************************
	bool Parser::AcceptOptionalTypeSpecifierArgs(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, va_list args)
	{
		// Look for the type specifier for the return types
		if (Accept(1, Grammar::TypeSpecifier))
		{
			// This will store the return types in a function
			outSyntaxType = this->ReadTypeInfo();

			// Check if we did not parse a return type (but we were expecting one)
			if (outSyntaxType == nullptr)
			{
				// Throw an error
				this->ErrorHereArgs(notFound, args);
				return false;
			}
		}
		else
		{
			// We have no return type
			outSyntaxType = nullptr;
		}

		// We got here, successfull!
		return true;
	}

	//***************************************************************************
	bool Parser::ExpectArgumentList(GenericFunctionNode* node, String functionName)
	{
		// Get the name of the function
		if (Expect(Grammar::BeginFunctionParameters, ErrorCode::FunctionArgumentListNotFound, functionName.c_str()))
		{
			// Store the parameter index
			size_t parameterIndex = 0;

			// Get all the arguments for the function
			do
			{
				// Parse a parameter node
				ParameterNode* parameter = Parameter();

				// If the parameter is null
				if (parameter == nullptr)
				{
					// If we've already parsed one argument (meaning we have a comma)
					if (parameterIndex > 0)
					{
						// Throw an error
						ErrorHere(ErrorCode::FunctionParameterNotFound);
						return false;
					}
				}
				else
				{
					// Fill in which parameter this is
					parameter->ParameterIndex = parameterIndex;
				}

				// Add the parameter parameter to the parameter list, and pass in its index
				node->Parameters.Add(parameter);

				// Increment the parameter index
				++parameterIndex;
			} while (Accept(1, Grammar::ArgumentSeparator));

			// Look for the end parenthasis
			if (Expect(Grammar::EndFunctionParameters, ErrorCode::FunctionArgumentListNotComplete, functionName.c_str()))
			{
				// We succeeded at parsing
				return true;
			}
		}

		// Otherwise, we failed at parsing
		return false;
	}

	//***************************************************************************
	bool Parser::ExpectScopeBody(GenericFunctionNode* node, String functionName)
	{
		// Now look for the start scope
		if (Expect(Grammar::BeginScope, ErrorCode::FunctionBodyNotFound, functionName.c_str()))
		{
			// Parse all the statements in the function
			while (node->Statements.Add(Statement()));

			// Now look for the end scope.
			if (Expect(Grammar::EndScope, ErrorCode::FunctionBodyNotComplete, functionName.c_str()))
			{
				// We succeeded in parsing the body
				this->SetNodeLocationEndHere(node);
				return true;
			}
			// If we're in tolerant mode...
			else if (this->Errors.TolerantMode)
			{
				// Since we're being tolerant, just eat tokens until we hit the end of our scope
				// This is just an approximation, as there may be actual scope errors
				// This will return true if it finds the scope and will advance the token forward automatically
				bool result = this->MoveToScopeEnd();
				this->SetNodeLocationEndHere(node);
				return result;
			}
		}

		// Otherwise, we failed at parsing
		return false;
	}

	//***************************************************************************
	bool Parser::MoveToScopeEnd()
	{
		// We probably failed to parse a statement, and therefore we didn't hit the end of the scope
		// Alternatively, the scope could just be missing

		// We're going to parse until we hit a scope (skipping all remaining statements)
		// We could try to parse the rest of the statements, but generally they don't affect code completion
		// Note: This could be entirely incorrect in the case that the end scope is missing!
		// For example, in parsing a scope for a function if the end scope is missing, it will not stop until
		// it reaches the end scope for the class!

		// We're currently in a scope (we started above)
		// When this hits zero, we'll know we reached the end of our scope
		size_t scopeCounter = 1;

		// Loop through all the rest of the tokens
		for (size_t index = this->TokenIndex; index < this->TokenStream->size(); ++index)
		{
			// Retreive the current token
			const UserToken* token = &(*this->TokenStream)[index];

			// Based on the current token type...
			switch (token->TokenId)
			{
				// If we reach the end of a file, or another function, or another class...
				// In the future, this may break if we add sub-classes or anonymous/nested functions
			case Grammar::End:
			case Grammar::Function:
			case Grammar::Class:
			{
				// Leave the token index right at this position so this token will be the next thing parsed
				this->TokenIndex = index;
				return true;
			}

			case Grammar::BeginScope:
			{
				// Increment the scope counter since we just encountered another scope
				++scopeCounter;
				break;
			}
			case Grammar::EndScope:
			{
				// Decrement the scope counter until it reaches 0
				--scopeCounter;

				// If we hit the end of our current scope
				if (scopeCounter == 0)
				{
					// Move the token forward so that the next token is whatever is after the end scope
					this->TokenIndex = index + 1;

					// Return that we accepted this entire scope!
					return true;
				}
				break;
			}
			}
		}

		// If we got here, we were unable to find the ending scope!
		return false;
	}

	//***************************************************************************
	FunctionNode* Parser::GenerateGetSetFunctionNode(MemberVariableNode* variable, bool isGet)
	{
		// Create a function node
		FunctionNode* node = new FunctionNode();
		this->SetNodeLocationStartToLastSave(node);

		// We create a clone of the type because, in both get/set cases
		// the node is responsible for cleaning up syntax types, and we
		// want to avoid any double delete situations
		SyntaxType* typeClone = variable->ResultSyntaxType->Clone();

		// If this is a getter...
		if (isGet)
		{
			// Generate the name for the getter
			node->Name = BuildGetterName(variable->Name);

			// Getters don't take any parameters, but return the type of the property
			node->ReturnType = typeClone;
		}
		// Otherwise it's a setter!
		else
		{
			// Generate the name for the setter
			node->Name = BuildSetterName(variable->Name);

			// Create a parameter node since all setters take in the value being set
			ParameterNode* value = new ParameterNode();
			this->SetNodeLocationStartToLastSave(value);

			// The parameter is never defaulted
			value->InitialValue = nullptr;

			// The value's type is the same as the variable's type
			value->ResultSyntaxType = typeClone;

			// The name of the parameter is simply just 'value'
			value->Name = ValueKeyword;

			// Add the parameter to our get function
			node->Parameters.Add(value);
		}

		// The function is static based entirely off whether the member is static
		node->IsStatic = variable->IsStatic;
		node->Virtualized = variable->Virtualized;

		// Return the function node we created
		return node;
	}

	//***************************************************************************
	FunctionNode* Parser::GetSetFunctionBody(MemberVariableNode* variable, bool isGet)
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Generate the function node
		FunctionNode* node = GenerateGetSetFunctionNode(variable, isGet);

		// Now look for the start scope
		if (ExpectScopeBody(node, node->Name))
		{
			// Accept the token position, and return the variable node
			AcceptTokenPosition();
			return node;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		delete node;
		return nullptr;
	}

	//***************************************************************************
	FunctionNode* Parser::Function()
	{
		// Parse any optional attribute
		this->ParseAllOptionalAttributes();

		// If any errors occurred in parsing attributes, error here
		if (this->Errors.WasError)
			return nullptr;

		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Look for the function keyword
		if (Accept(1, Grammar::Function))
		{
			// Create a function node
			FunctionNode* node = new FunctionNode();
			this->SetNodeLocationStartToLastSave(node);

			// Attach any attributes to this function node
			this->AttachLastAttributeToNode(node->Attributes);

			// Get the name of the function
			const UserToken* functionName;
			if (this->ExpectAndRetrieve(Grammar::UpperIdentifier, functionName, ErrorCode::FunctionNameNotFound))
			{
				// Store the name on the function
				node->Name = functionName->Token;

				// Look for any virtual and static attributes
				this->ApplyVirtualAndStaticAttributes(node);

				// If any errors occurred from the virtual/static parsing
				if (this->Errors.WasError)
				{
					// We didn't successfully parse the static/virtual/override attributes
					this->RecallTokenPosition();
					delete node;
					return nullptr;
				}

				// Parse the argument list
				if (this->ExpectArgumentList(node, node->Name))
				{
					// Attempt to read the type specifier
					this->AcceptOptionalTypeSpecifier(node->ReturnType, ErrorCode::FunctionReturnTypeNotFound, node->Name.c_str());

					// If an error occurred reading the type specifier
					if (this->Errors.WasError)
					{
						// We didn't successfully parse the return type, so just recall the token position and return null
						this->RecallTokenPosition();
						delete node;
						return nullptr;
					}

					// Now look for the start scope
					if (ExpectScopeBody(node, node->Name))
					{
						// Accept the token position, and return the variable node
						this->SetNodeLocationEndHere(node);
						this->AcceptTokenPosition();

						// Return the node now that we've parsed it
						return node;
					}
				}
			}

			// We failed if we got here
			delete node;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		this->RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	bool Parser::IsAttributePresent(NodeList<AttributeNode>& attributes, StringParam name)
	{
		// Loop through all the attributes
		for (size_t i = 0; i < attributes.size(); ++i)
		{
			// Grab the current attribute
			AttributeNode* attribute = attributes[i];

			// If this is a the attribute we were looking for...
			if (attribute->TypeName->Token == name)
			{
				return true;
			}
		}

		// Otherwise, we didn't find it
		return false;
	}

	//***************************************************************************
	template <typename FunctionNodeType>
	FunctionNodeType* Parser::SpecializedFunction
		(
		Grammar::Enum type,
		String functionName,
		bool (Parser::*postArgs)(FunctionNodeType* node)
		)
	{
		// Parse any optional attribute
		this->ParseAllOptionalAttributes();

		// If any errors occurred in parsing attributes, error here
		if (this->Errors.WasError)
			return nullptr;

		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Look for the given grammar keyword
		if (Accept(1, type))
		{
			// Create a specialized function node
			FunctionNodeType* node = new FunctionNodeType();
			this->SetNodeLocationStartToLastSave(node);

			// Parse the argument list
			if (this->ExpectArgumentList(node, functionName))
			{
				// If we have a post arguments parser function...
				if (postArgs != nullptr)
				{
					// Apply the post arguments function
					if ((this->*postArgs)(node) == false)
					{
						// We failed the post arguments function, so recall and free the node
						delete node;
						RecallTokenPosition();
						return nullptr;
					}
				}

				// Now look for the start scope
				if (this->ExpectScopeBody(node, functionName))
				{
					// Accept the token position, and return the variable node
					this->SetNodeLocationEndHere(node);
					this->AcceptTokenPosition();

					// Attach any attributes to this function node
					this->AttachLastAttributeToNode(node->Attributes);
					return node;
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ConstructorNode* Parser::Constructor()
	{
		return SpecializedFunction<ConstructorNode>(Grammar::Constructor, "Constructor", &Parser::ConstructorInitializerList);
	}

	//***************************************************************************
	bool Parser::ConstructorInitializerList(ConstructorNode* node)
	{
		// If we have an initializer list...
		if (Accept(1, Grammar::InitializerList))
		{
			// Stores the initializer type (reused variable)
			const UserToken* initializerType;

			// The first thing we expect is a base class initializer
			if (AcceptAndRetrieve(1, Grammar::Base, &initializerType))
			{
				// Create an initializer node to represent the base class
				InitializerNode* initializer = new InitializerNode();
				initializer->InitializerType = initializerType;
				this->SetNodeLocationStartHere(initializer);

				// Let the constructor know that it actually has a base initializer
				node->BaseInitializer = initializer;

				// Parse the function call for the current initializer
				FunctionCallNode* call = FunctionCall();

				// If we did not parse the base initializer function call...
				if (call == nullptr)
				{
					// We can't just have 'base' or 'this' sitting there
					this->ErrorHere(ErrorCode::FunctionCallExpectedAfterInitializer);
					return false;
				}
				else
				{
					// The left hand operand is the base class initializer
					call->LeftOperand = initializer;

					// Add the call to the statements
					node->Statements.Add(call);
				}
			}

			// Look for a comma delimiter
			if (Accept(1, Grammar::ArgumentSeparator))
			{
				// Grab the 'this' token (we don't parse it as a special keyword!)
				const UserToken* thisToken;

				// Look for a local base class initializer
				if (AcceptAndRetrieve(1, Grammar::LowerIdentifier, &thisToken))
				{
					// If we found the 'this' keyword...
					if (thisToken->Token == ThisKeyword)
					{
						// Create an initializer node to represent the base class
						InitializerNode* initializer = new InitializerNode();
						initializer->InitializerType = thisToken;
						node->ThisInitializer = initializer;
						this->SetNodeLocationStartHere(initializer);

						// Parse the function call for the current initializer
						FunctionCallNode* call = this->FunctionCall();

						// If we did not parse the base initializer function call...
						if (call == nullptr)
						{
							// We can't just have 'base' or 'this' sitting there
							this->ErrorHere(ErrorCode::FunctionCallExpectedAfterInitializer);
							return false;
						}
						else
						{
							// The left hand operand is the base class initializer
							call->LeftOperand = initializer;

							// Add the call to the statements
							node->Statements.Add(call);
						}
					}
				}
			}

			// Check for a late base initializer...
			if (Accept(2, Grammar::ArgumentSeparator, Grammar::Base))
			{
				this->ErrorHere(ErrorCode::BaseClassInitializerMustComeFirst);
				return false;
			}
		}

		// If we got here, either we did not have an initializer 
		// list or we did have one and parsed it properly
		return true;
	}

	//***************************************************************************
	DestructorNode* Parser::Destructor()
	{
		return SpecializedFunction<DestructorNode>(Grammar::Destructor, "Destructor", nullptr);
	}

	//***************************************************************************
	SendsEventNode* Parser::SendsEvent()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// First look for the "sends" keyword
		if (Accept(1, Grammar::Sends))
		{
			// Create a sends statement node
			SendsEventNode* node = new SendsEventNode();
			this->SetNodeLocationStartToLastSave(node);

			// Get the name of the variable
			if (ExpectAndRetrieve(Grammar::UpperIdentifier, node->Name, ErrorCode::SendsEventStatementNameNotFound))
			{
				// Grab the string name for convenience
				String name = node->Name->Token;

				// Look for a type after the member variable
				if (AcceptOptionalTypeSpecifier(node->EventType, ErrorCode::SendsEventStatementTypeNotFound, name.c_str()))
				{
					// As long as we got a valid type...
					if (node->EventType != nullptr)
					{
						// Attempt to read the statement separator
						if (Expect(Grammar::StatementSeparator, ErrorCode::SendsEventStatementNotComplete, name.c_str()))
						{
							// Accept the token position, and return the variable node
							this->SetNodeLocationEndHere(node);
							AcceptTokenPosition();
							return node;
						}
					}
					else
					{
						// Show an error message
						ErrorHere(ErrorCode::SendsEventStatementTypeSpecifierNotFound, name.c_str());
					}
				}
			}

			// We must have failed, so delete the node
			delete node;
		}

		// We didn't successfully parse a variable definition, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ParameterNode* Parser::Parameter()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Attempt to read the name before continuing...
		const UserToken* name;

		// Look for an identifier
		if (AcceptAndRetrieve(1, Grammar::LowerIdentifier, &name))
		{
			// Look for a type specifier (followed by the parameter's type)
			if (Expect(Grammar::TypeSpecifier, ErrorCode::ParameterTypeSpecifierNotFound, name->Token.c_str()))
			{
				// Create a parameter node
				ParameterNode* node = new ParameterNode();
				this->SetNodeLocationStartToLastSave(node);

				// Assume the parameter is not yet defaulted
				node->InitialValue = nullptr;

				// Attempt to read the type after the parameter
				if ((node->ResultSyntaxType = this->ReadTypeInfo()) != nullptr)
				{
					// Store the name and type on the parameter node
					node->Name = name->Token;

					// Accept the token position, and return the variable node
					AcceptTokenPosition();
					this->SetNodeLocationEndHere(node);
					return node;
				}
				else
				{
					// Delete the node and show an error
					delete node;
					ErrorHere(ErrorCode::ParameterTypeNotFound, name->Token.c_str());
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::BinaryOperatorRightToLeftAssociative(ExpressionFn currentPrecedence, ExpressionFn nextPrecedence, int parameters, ...)
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Attempt to parse the left operand (look for a higher precedence expression)
		ExpressionNode* leftOperand = (this->*nextPrecedence)();

		// As long as we parced a left operand...
		if (leftOperand != nullptr)
		{
			// This will hold the operator that we parse below
			const UserToken* acceptedOperator;

			// Start a variadic argument list
			va_list vl;
			va_start(vl, parameters);

			// If we found the operator...
			if (AcceptAnyArgs(parameters, &acceptedOperator, vl))
			{
				// Attempt to parse the right operand as if it was another expression of the same precedence
				ExpressionNode* rightOperand = (this->*currentPrecedence)();

				// If we properly parsed the right operand...
				if (rightOperand != nullptr)
				{
					// Allocate an expression node that encapsulates the operator and operands
					BinaryOperatorNode* node = new BinaryOperatorNode();
					node->Location = leftOperand->Location;
					SetNodeLocationPrimaryToToken(node, *acceptedOperator);

					// Initialize the node
					node->Operator = acceptedOperator;

					// Add the left and right operands explicitly to the node
					node->LeftOperand = leftOperand;
					node->RightOperand = rightOperand;

					// Accept the token position, close the va_list, and return the expression node
					this->AcceptTokenPosition();
					this->SetNodeLocationEndHere(node);
					va_end(vl);
					return node;
				}
				else
				{
					// We have an improper right operand to an expression, so delete the left argument and close the va_list
					delete leftOperand;
					va_end(vl);

					// Show an error message
					this->ErrorHere
						(
						ErrorCode::BinaryOperatorRightOperandNotFound,
						Grammar::GetName(acceptedOperator->TokenId).c_str(),
						acceptedOperator->Token.c_str()
						);
					RecallTokenPosition();
					return nullptr;
				}
			}
			else
			{
				// Otherwise, we didn't find an operator, but the left-argument could still be a valid expression
				AcceptTokenPosition();
				return leftOperand;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::BinaryOperatorLeftToRightAssociative(ExpressionFn nextPrecedence, int parameters, ...)
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Attempt to parse the left operand (look for a higher precedence expression)
		ExpressionNode* leftOperand = (this->*nextPrecedence)();

		// As long as we parced a left operand...
		if (leftOperand != nullptr)
		{
			ZilchLoop
			{
				// This will hold the operator that we parse below
				const UserToken* acceptedOperator;

				// Start a variadic argument list
				va_list vl;
				va_start(vl, parameters);

				// If we found the operator...
				if (AcceptAnyArgs(parameters, &acceptedOperator, vl))
				{
					// Attempt to parse the right operand as if it was another expression of lower precedence
					ExpressionNode* rightOperand = (this->*nextPrecedence)();

					// If we properly parsed the right operand...
					if (rightOperand != nullptr)
					{
						// Allocate an expression node that encapsulates the operator and operands
						BinaryOperatorNode* node = new BinaryOperatorNode();
						node->Location = leftOperand->Location;
						SetNodeLocationPrimaryToToken(node, *acceptedOperator);

						// Initialize the node
						node->Operator = acceptedOperator;

						// Add the left and right operands explicitly to the node
						node->LeftOperand = leftOperand;
						node->RightOperand = rightOperand;

						// Close the va_list and continue the iteration to find more operands
						va_end(vl);
						leftOperand = node;
						this->SetNodeLocationEndHere(node);
					}
					else
					{
						// We have an improper right operand to an expression, so delete the left argument and close the va_list
						delete leftOperand;
						va_end(vl);

						// Show an error message
						this->ErrorHere
							(
							ErrorCode::BinaryOperatorRightOperandNotFound,
							Grammar::GetName(acceptedOperator->TokenId).c_str(),
							acceptedOperator->Token.c_str()
							);

						// We didn't successfully parse an expression, so just recall the token position and return null
						RecallTokenPosition();
						return nullptr;
					}
				}
				else
				{
					// Otherwise, we didn't find an operator, but the left-argument could still be a valid expression
					AcceptTokenPosition();
					return leftOperand;
				}
			}

				// Technically unreachable (all paths above handled properly)
				// If we somehow got here, we failed
				//delete leftOperand;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression()
	{
		// Note: See the top of 'Shared.cpp' for a reference on precedence
		return Expression00();
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression00()
	{
		// Parse the assignment and compound assignment operators
		return BinaryOperatorRightToLeftAssociative(&Parser::Expression00, &Parser::Expression01, 12, Grammar::Assignment, Grammar::AssignmentAdd, Grammar::AssignmentSubtract, Grammar::AssignmentMultiply, Grammar::AssignmentDivide, Grammar::AssignmentModulo, Grammar::AssignmentExponent, Grammar::AssignmentLeftShift, Grammar::AssignmentRightShift, Grammar::AssignmentBitwiseAnd, Grammar::AssignmentBitwiseXor, Grammar::AssignmentBitwiseOr);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression01()
	{
		// Parse the logical or operator
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression02, 1, Grammar::LogicalOr);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression02()
	{
		// Parse the logical and operator
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression03, 1, Grammar::LogicalAnd);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression03()
	{
		// Parse the bitwise or operator
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression04, 1, Grammar::BitwiseOr);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression04()
	{
		// Parse the bitwise xor operator
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression05, 1, Grammar::BitwiseXor);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression05()
	{
		// Parse the bitwise and operator
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression06, 1, Grammar::BitwiseAnd);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression06()
	{
		// Parse the equality and inequality operators
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression07, 2, Grammar::Equality, Grammar::Inequality);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression07()
	{
		// Parse the comparison operators
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression08, 4, Grammar::LessThan, Grammar::LessThanOrEqualTo, Grammar::GreaterThan, Grammar::GreaterThanOrEqualTo);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression08()
	{
		// Parse the bitshift operators
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression09, 2, Grammar::BitshiftLeft, Grammar::BitshiftRight);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression09()
	{
		// Parse the additive operators
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression10, 2, Grammar::Add, Grammar::Subtract);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression10()
	{
		// Parse the multaplicative operators and the modulo operator
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression11, 3, Grammar::Multiply, Grammar::Divide, Grammar::Modulo);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression11()
	{
		// Parse the exponent operator
		return BinaryOperatorLeftToRightAssociative(&Parser::Expression12, 1, Grammar::Exponent);
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression12()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// This will store the unary left hand operator
		const UserToken* acceptedOperator;

		// Attempt to parse the unary left hand operator
		if (AcceptAny(7, &acceptedOperator, Grammar::Positive, Grammar::Negative, Grammar::Increment, Grammar::Decrement, Grammar::LogicalNot, Grammar::BitwiseNot, Grammar::PropertyDelegate))
		{
			// Attempt to read in the unary operand
			ExpressionNode* operand = Expression13();

			// If we found an operand...
			if (operand != nullptr)
			{
				// The node we're creating...
				UnaryOperatorNode* node = nullptr;

				// If this is a property delegate node, then this operator is slightly different
				if (acceptedOperator->TokenId == Grammar::PropertyDelegate)
				{
					// Create a unary node (property delegate operator) to represent the operation
					node = new PropertyDelegateOperatorNode();
				}
				else
				{
					// Create a unary node to represent the operation
					node = new UnaryOperatorNode();
				}

				// Initialize the node so we know it's location
				this->SetNodeLocationStartToToken(node, *acceptedOperator);

				// Setup the node
				node->Operator = acceptedOperator;

				// Add the operand expression explicitly to the node
				node->Operand = operand;

				// Accept the token position, and return the expression node
				AcceptTokenPosition();
				this->SetNodeLocationEndHere(node);
				return node;
			}
			else
			{
				// Show an error message
				this->ErrorHere
					(
					ErrorCode::UnaryOperatorOperandNotFound,
					Grammar::GetName(acceptedOperator->TokenId).c_str(),
					acceptedOperator->Token.c_str()
					);
			}
		}
		else
		{
			// Just attempt to read the next level of precedence
			ExpressionNode* nextLevel = Expression13();

			// If the next precedence level returned us a node, we'll use that one
			if (nextLevel != nullptr)
			{
				// Accept the token position, and return the next-level expression node
				AcceptTokenPosition();
				return nextLevel;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression13()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Attempt to parse the left operand (look for a higher precedence expression)
		ExpressionNode* leftOperand = Expression14();

		// As long as we parced a left operand...
		if (leftOperand != nullptr)
		{
			ZilchLoop
			{
				// If we found the "as" operator...
				if (Accept(1, Grammar::As))
				{
					// Allocate a type-cast node that represents the casting operation
					TypeCastNode* node = new TypeCastNode();
					this->SetNodeLocationStartToLastSave(node);
					this->SetNodeLocationPrimaryHere(node);

					// Now attempt to grab the type that we're casting to
					if ((node->Type = this->ReadTypeInfo()) != nullptr)
					{
						// Add the left operand explicitly to the node
						node->Operand = leftOperand;

						// Close the va_list and continue the iteration to find more operands
						leftOperand = node;
						this->SetNodeLocationEndHere(node);
					}
					else
					{
						// We have an improper right operand to an expression, so delete the left argument and close the va_list
						delete node;
						delete leftOperand;
						ErrorHere(ErrorCode::CastTypeNotFound);

						// We didn't successfully parse an expression, so just recall the token position and return null
						RecallTokenPosition();
						return nullptr;
					}
				}
				else
				{
					// Otherwise, we didn't find an operator, but the left-argument could still be a valid expression
					AcceptTokenPosition();
					return leftOperand;
				}
			}

				// Technically unreachable (all paths above handled properly)
				// If we got down here, we failed
				//delete leftOperand;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::Expression14()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Attempt to read a value node
		ExpressionNode* value = Value();

		// If the value node parsed successfully...
		if (value != nullptr)
		{
			// This node will store any nodes we get from the post-expression call
			PostExpressionNode* node = PostExpression();

			// If we found a valid post-expression node...
			if (node != nullptr)
			{
				// Collect all the post-expressions
				ZilchLoop
				{
					// Add the left operand as a child and set the left
					// operand explicitly for the post expression operator
					node->LeftOperand = value;

					// To chain post expressions, make the node we found into the "value"
					value = node;

					// Attempt to read another post expression node
					PostExpressionNode* nextNode = PostExpression();

					// If we successfully parsed the next expression node...
					if (nextNode != nullptr)
					{
						// Store it away to be used in the next iteration...
						node = nextNode;
					}
					else
					{
						// Exit since we no longer have a node
						break;
					}
				}

					// Accept the token position, and return the special operator node
				AcceptTokenPosition();
				return node;
			}

			// Accept the token position, and return the value node
			AcceptTokenPosition();
			return value;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	PostExpressionNode* Parser::PostExpression()
	{
		// First, check if we're at an indexer call
		PostExpressionNode* node = IndexerCall();

		// If so, return the node
		if (node != nullptr)
			return node;

		// Now check to see if we're at a function call
		node = FunctionCall();

		// If so, return the node
		if (node != nullptr)
			return node;

		// Now check to see if we're at a member access
		node = MemberAccess();

		// If so, return the node
		if (node != nullptr)
			return node;

		// We failed to find anything...
		return nullptr;
	}

	//***************************************************************************
	IndexerCallNode* Parser::IndexerCall()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting an index
		if (Accept(1, Grammar::BeginIndex))
		{
			// We started an index, so allocate an indexer node
			IndexerCallNode* node = new IndexerCallNode();
			this->SetNodeLocationStartToLastSave(node);

			// Parse arguments to the indexer until there are no more
			ZilchLoop
			{
				// Attempt to parse an argument to the indexer
				if (node->Arguments.Add(Expression()) == nullptr)
				{
					// Show an error
					ErrorHere(ErrorCode::IndexerIndicesNotFound);

					// We didn't successfully parse an expression, so just recall the token position and return null
					RecallTokenPosition();
					delete node;
					return nullptr;
				}

				// Attempt to read an argument separator, and if we don't find one, break out
				if (Accept(1, Grammar::ArgumentSeparator) == false)
				{
					break;
				}
			}

				// Now that we parsed all the arguments, we need to parse the end of the index call
				if (Accept(1, Grammar::EndIndex))
				{
					// Accept the token position, and return the indexer node
					AcceptTokenPosition();
					this->SetNodeLocationEndHere(node);
					return node;
				}
				else
				{
					// Show an error message
					ErrorHere(ErrorCode::IndexerNotComplete);
					delete node;
				}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	FunctionCallNode* Parser::FunctionCall()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a function call
		if (Accept(1, Grammar::BeginFunctionCall))
		{
			// We started a function call, so allocate an function call node
			FunctionCallNode* node = new FunctionCallNode();
			this->SetNodeLocationStartToLastSave(node);

			// Assume by default that we will not use named arguments
			// Note that if the function call has no arguments, it will not matter
			node->IsNamed = false;

			// Did we already parse the first argument
			bool parsedFirstArgument = false;

			// Parse arguments to the function call until there are no more
			ZilchLoop
			{
				// This will hold the argument name as we parse it
				const UserToken* argumentName = nullptr;

				// Look for an identifier and the named argument symbol
				if (AcceptAndRetrieve(2, Grammar::LowerIdentifier, &argumentName, Grammar::NameSpecifier, (void*)nullptr))
				{
					// Add the name to the list of function call names
					node->ArgumentNames.push_back(argumentName->Token);

					// Attempt to parse an argument to the indexer
					if (node->Arguments.Add(Expression()) == nullptr)
					{
						// Show an error message
						ErrorHere(ErrorCode::FunctionCallNamedArgumentNotFound, argumentName->Token.c_str());

						// We didn't successfully parse an expression, so just recall the token position and return null
						RecallTokenPosition();
						delete node;
						return nullptr;
					}

					// We parsed the first argument
					parsedFirstArgument = true;

					// Since we parsed the named argument we must be using named calling
					node->IsNamed = true;

					// Attempt to read an argument separator, and if we don't find one, break out
					if (Accept(1, Grammar::ArgumentSeparator) == false)
					{
						break;
					}
				}
				// As long as we didn't yet parse the first argument...
				else if (parsedFirstArgument == false)
				{
					break;
				}
				else
				{
					// Show an error message
					ErrorHere(ErrorCode::FunctionCallNotComplete);

					// We didn't successfully parse an expression, so just recall the token position and return null
					RecallTokenPosition();
					delete node;
					return nullptr;
				}
			}

				// If we did not parse any arguments (which could be ok...)
				// We need to try parsing as if they were positional arguments
				if (parsedFirstArgument == false)
				{
					// Parse arguments to the function call until there are no more
					ZilchLoop
					{
						// Attempt to parse an argument to the indexer
						if (node->Arguments.Add(Expression()))
						{
							// We parsed the first argument
							parsedFirstArgument = true;

							// Attempt to read an argument separator, and if we don't find one, break out
							if (Accept(1, Grammar::ArgumentSeparator) == false)
							{
								break;
							}
						}
						// As long as we didn't yet parse the first argument...
						else if (parsedFirstArgument == false)
						{
							break;
						}
						else
						{
							// Show an error message
							ErrorHere(ErrorCode::FunctionCallNotComplete);

							// We didn't successfully parse an expression, so just recall the token position and return null
							RecallTokenPosition();
							delete node;
							return nullptr;
						}
					}
				}

			// Now that we parsed all the arguments, we need to parse the end of the function call
			if (Accept(1, Grammar::EndFunctionCall))
			{
				// Accept the token position, and return the function call node
				AcceptTokenPosition();
				this->SetNodeLocationEndHere(node);
				return node;
			}
			else
			{
				// Show an error message
				this->ErrorHere(ErrorCode::FunctionCallNotComplete);
				delete node;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	MemberAccessNode* Parser::MemberAccess()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Hold the access operator type
		const UserToken* accessOperator;

		// Check to see if we're starting a member access
		if (AcceptAny(2, &accessOperator, Grammar::Access, Grammar::NonVirtualAccess))
		{
			// Hold the member we attempted to access
			const UserToken* member;

			// Get the member name that we're trying to access
			if (ExpectAndRetrieve(Grammar::UpperIdentifier, member, ErrorCode::MemberAccessNameNotFound))
			{
				// We started a member access, so allocate the corresponding node
				MemberAccessNode* node = new MemberAccessNode();
				this->SetNodeLocationStartToLastSave(node);

				// Set the operator
				node->Operator = accessOperator;

				// Set the name
				node->Name = member->Token;

				// Accept the token position, and return the function call node
				AcceptTokenPosition();
				this->SetNodeLocationEndHere(node);
				return node;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Delete()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a delete statement
		if (Accept(1, Grammar::Delete))
		{
			// Parse the expression which we are deleting
			ExpressionNode* deletedObject = Expression();

			// If we parsed an expression
			if (deletedObject != nullptr)
			{
				// Create a delete node since this is a valid return statement
				DeleteNode* node = new DeleteNode();
				this->SetNodeLocationStartToLastSave(node);

				// Set the deleted object, then add the expression as a child
				node->DeletedObject = deletedObject;

				// Accept the token position, and return the "return node"
				AcceptTokenPosition();
				this->SetNodeLocationEndHere(node);
				return node;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Return()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Checks whether this return ignores flow control errors
		bool isDebugReturn = false;

		// Check to see if we're starting a debug statement (could be other debug statements)
		if (Accept(1, Grammar::Debug))
		{
			// This is a debug return, which means it ignores flow control
			isDebugReturn = true;
		}

		// Check to see if we're starting a return statement
		if (Accept(1, Grammar::Return))
		{
			// Create a return node since this is a valid return statement
			ReturnNode* node = new ReturnNode();
			this->SetNodeLocationStartToLastSave(node);

			// Set the debug return flag depending upon what we read above
			node->IsDebugReturn = isDebugReturn;

			// Attempt to parse an expression (this expression can be missing, that is OK!)
			node->ReturnValue = Expression();

			// Accept the token position, and return the "return node"
			AcceptTokenPosition();
			this->SetNodeLocationEndHere(node);
			return node;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Break()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a break statement
		if (Accept(1, Grammar::Break))
		{
			// Create a break node since this is a valid break statement
			BreakNode* node = new BreakNode();
			this->SetNodeLocationStartToLastSave(node);

			// Grab the user token for the identifier
			const UserToken* scopeCount = nullptr;

			// Read an optional integer that tells us how many loop scopes to break out of
			if (AcceptAndRetrieve(1, Grammar::IntegerLiteral, &scopeCount))
			{
				// Read the break count
				node->ScopeCount = atoi(scopeCount->Token.c_str());

				// If the scope count is not valid
				if (node->ScopeCount <= 0)
				{
					// Throw an error
					ErrorHere(ErrorCode::BreakCountMustBeGreaterThanZero);

					// We didn't successfully parse an expression, so just recall the token position and return null
					RecallTokenPosition();
					delete node;
					return nullptr;
				}
			}
			else
			{
				// Otherwise, the scope count is assumed to be 1
				node->ScopeCount = 1;
			}

			// Accept the token position, and return the "break node"
			AcceptTokenPosition();
			this->SetNodeLocationEndHere(node);
			return node;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::DebugBreak()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a debug break statement
		if (Accept(2, Grammar::Debug, Grammar::Break))
		{
			// Create a break node since this is a valid break statement
			DebugBreakNode* node = new DebugBreakNode();
			this->SetNodeLocationStartToLastSave(node);

			// Accept the token position, and return the "debug break node"
			AcceptTokenPosition();
			this->SetNodeLocationEndHere(node);
			return node;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Continue()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a continue statement
		if (Accept(1, Grammar::Continue))
		{
			// Create a continue node since this is a valid continue statement
			ContinueNode* node = new ContinueNode();
			this->SetNodeLocationStartToLastSave(node);

			// Accept the token position, and return the "return node"
			AcceptTokenPosition();
			this->SetNodeLocationEndHere(node);
			return node;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Throw()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a continue statement
		if (this->Accept(1, Grammar::Throw))
		{
			// Read the expression (we'll validate that it's an exception type in the syntaxer)
			ExpressionNode* exception = this->Expression();

			// As long as we read the exception expression (typically new Exception...)
			if (exception != nullptr)
			{
				// Create a throw node since we know everything we need
				ThrowNode* node = new ThrowNode();
				this->SetNodeLocationStartToLastSave(node);

				// Set the exception expression on the node
				node->Exception = exception;

				// Accept the token position, and return the "throw node"
				this->AcceptTokenPosition();
				this->SetNodeLocationEndHere(node);
				return node;
			}
			else
			{
				// Show an error and let us be recalled below
				this->ErrorHere(ErrorCode::ThrowExceptionExpressionNotFound);
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		this->RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Statement()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// First parse to see if we found a delimited statement
		if (StatementNode* node = DelimitedStatement())
		{
			// Check to see that the statement was properly delimited
			if (this->Expect(Grammar::StatementSeparator, ErrorCode::StatementSeparatorNotFound))
			{
				// Accept the token position, and return the node
				AcceptTokenPosition();
				return node;
			}
			else
			{
				// We failed to find the ending semicolon, delete the node and unroll
				delete node;
			}
		}
		else if (StatementNode* node = FreeStatement())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}

		// Otherwise, recall the old token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::DelimitedStatement()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Look for a variable (don't check for delimiting because it will be automatically checked for later)
		if (StatementNode* node = this->LocalVariable())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		// Look for a return statement
		else if (StatementNode* node = this->Return())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		// Look for a delete statement
		else if (StatementNode* node = this->Delete())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		// Look for a break statement
		else if (StatementNode* node = this->Break())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		// Look for a debug break statement
		else if (StatementNode* node = this->DebugBreak())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		// Look for a continue statement
		else if (StatementNode* node = this->Continue())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		// Look for a throw exception statement
		else if (StatementNode* node = this->Throw())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		// Look for an expression
		else if (ExpressionNode* node = this->Expression())
		{
			// Mark that this expression is being used as a statement
			node->IsUsedAsStatement = true;

			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}

		// Otherwise, recall the old token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::FreeStatement()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Look for an if statement
		if (StatementNode* node = If())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		else if (StatementNode* node = For())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		else if (StatementNode* node = ForEach())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		else if (StatementNode* node = While())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		else if (StatementNode* node = DoWhile())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		else if (StatementNode* node = Loop())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		else if (StatementNode* node = Scope())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}
		else if (StatementNode* node = Timeout())
		{
			// Accept the token position, and return the node
			AcceptTokenPosition();
			return node;
		}

		// Otherwise, recall the old token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	void Parser::IfBody(ExpressionNode* condition, IfRootNode* root)
	{
		// Look for the end parenthesis and beginning of the if-statement scope
		if (Expect(Grammar::BeginScope, ErrorCode::IfBodyNotFound))
		{
			// Create an if node since this is a valid if statement
			IfNode* node = new IfNode();
			this->SetNodeLocationStartToLastSave(node);

			// Parse all the statements inside the if-statement
			while (node->Statements.Add(Statement()));

			// Now look for the end scope
			bool finishedNode = Expect(Grammar::EndScope, ErrorCode::IfBodyNotComplete);

			// As long as we finished this node (either via correct parsing or tolerance)
			if (finishedNode == false && this->Errors.TolerantMode)
			{
				// Since we're being tolerant, just eat tokens until we hit the end of our scope
				// This is just an approximation, as there may be actual scope errors
				// This will return true if it finds the scope and will advance the token forward automatically
				finishedNode = this->MoveToScopeEnd();
			}

			// As long as we finished this node (either via correct parsing or tolerance)
			if (finishedNode)
			{
				// Set the conditional expression on the if-node
				node->Condition = condition;

				// End the node here and attach it to the if parts
				this->SetNodeLocationEndHere(node);
				root->IfParts.Add(node);

				// As long as we have a condition, we can continue parsing else statements
				if (condition != nullptr)
				{
					// Parse the else statement (if it exists)
					this->Else(root);
				}

				// We're done by this point
				return;
			}

			// Delete the if-node if we got here
			delete node;
		}
	}

	//***************************************************************************
	ExpressionNode* Parser::IfCondition()
	{
		// Check to see if we're starting an if statement
		if (this->Accept(1, Grammar::If))
		{
			// Look for the beginning parenthasis
			if (this->Expect(Grammar::BeginGroup, ErrorCode::IfConditionalExpressionNotFound))
			{
				// Attempt to parse the conditional expression
				ExpressionNode* condition = Expression();

				// If we properly parsed the conditional expression...
				if (condition != nullptr)
				{
					// Look for the end parenthasis and beginning of the if-statement scope
					if (this->Expect(Grammar::EndGroup, ErrorCode::IfConditionalExpressionNotComplete))
					{
						return condition;
					}

					// Delete the conditional expression node if we got here
					delete condition;
				}
				else
				{
					// We couldn't read the conditional expression
					this->ErrorHere(ErrorCode::IfConditionalExpressionNotFound);
				}
			}
		}

		// Otherwise, no condition was parsed
		return nullptr;
	}

	//***************************************************************************
	void Parser::Else(IfRootNode* root)
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting an else statement
		if (Accept(1, Grammar::Else))
		{
			// Parse the condition (it's ok if this is null)
			ExpressionNode* condition = IfCondition();

			// Now parse the body of the else statement
			this->IfBody(condition, root);

			// As long as we got a valid node back
			if (this->Errors.WasError == false)
			{
				// Return the node
				this->AcceptTokenPosition();
				return;
			}
		}

		// Otherwise, no else was parsed (that's ok!)
		this->RecallTokenPosition();
	}

	//***************************************************************************
	StatementNode* Parser::Timeout()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a timeout statement
		if (this->Accept(1, Grammar::Timeout))
		{
			// Look for the beginning of a conditional expression
			if (this->Expect(Grammar::BeginGroup, ErrorCode::TimeoutSecondsNotFound))
			{
				// The timeout always takes an integer, just to ensure that users don't try to go to
				// a precision that's lower than our timer (typically the standard C clock function)
				const UserToken* secondsToken = nullptr;
				if (this->ExpectAndRetrieve(Grammar::IntegerLiteral, secondsToken, ErrorCode::TimeoutSecondsExpectedIntegerLiteral))
				{
					// Look for the end parenthasis
					if (this->Expect(Grammar::EndGroup, ErrorCode::TimeoutSecondsNotComplete))
					{
						// Look for the beginning of the timeout-statement scope
						if (this->Expect(Grammar::BeginScope, ErrorCode::TimeoutBodyNotFound))
						{
							// Set the number of seconds on the node
							int seconds = atoi(secondsToken->Token.c_str());

							// If the user specified a zero or negative time...
							if (seconds <= 0)
							{
								// Inform the user, recall the token position back and return out
								this->ErrorHere(ErrorCode::TimeoutSecondsMustBeNonZeroPositive);
								this->RecallTokenPosition();
								return nullptr;
							}

							// We've parsed everything we need to ensure this is a timeout statement, so create it
							TimeoutNode* node = new TimeoutNode();
							this->SetNodeLocationStartToLastSave(node);

							// We've verified it can't be negative, so cast it to an unsigned and store it on the node
							node->Seconds = (size_t)seconds;

							// Parse all the statements inside the timeout-statement
							while (node->Statements.Add(Statement()));

							// Now look for the end scope
							bool finishedNode = Expect(Grammar::EndScope, ErrorCode::TimeoutBodyNotComplete);

							// If we didn't find the end of the scope, but we're in tolerant mode...
							if (finishedNode == false && this->Errors.TolerantMode)
							{
								// Since we're being tolerant, just eat tokens until we hit the end of our scope
								// This is just an approximation, as there may be actual scope errors
								// This will return true if it finds the scope and will advance the token forward automatically
								finishedNode = this->MoveToScopeEnd();
							}

							// As long as we finished this node (either via correct parsing or tolerance)
							if (finishedNode)
							{
								// Accept the token position, and return the "return node"
								this->AcceptTokenPosition();
								this->SetNodeLocationEndHere(node);
								return node;
							}

							// Delete the while-node
							delete node;
							node = nullptr;
						}
					}
				}
				else
				{
					// Show an error message
					this->ErrorHere(ErrorCode::TimeoutSecondsNotFound);
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		this->RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Scope()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a scope statement
		if (Accept(1, Grammar::Scope))
		{
			// Look for the beginning of the scope
			if (Expect(Grammar::BeginScope, ErrorCode::ScopeBodyNotFound))
			{
				// Create a loop node since this is a valid loop statement
				ScopeNode* node = new ScopeNode();
				this->SetNodeLocationStartToLastSave(node);

				// Parse all the statements inside the if-statement
				while (node->Statements.Add(Statement()));

				// Now look for the end scope
				bool finishedNode = Expect(Grammar::EndScope, ErrorCode::ScopeBodyNotComplete);

				// If we didn't find the end of the scope, but we're in tolerant mode...
				if (finishedNode == false && this->Errors.TolerantMode)
				{
					// Since we're being tolerant, just eat tokens until we hit the end of our scope
					// This is just an approximation, as there may be actual scope errors
					// This will return true if it finds the scope and will advance the token forward automatically
					finishedNode = this->MoveToScopeEnd();
				}

				// As long as we finished this node (either via correct parsing or tolerance)
				if (finishedNode)
				{
					// Accept the token position, and return the "return node"
					AcceptTokenPosition();
					this->SetNodeLocationEndHere(node);
					return node;
				}

				// Delete the while-node
				delete node;
				node = nullptr;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	IfRootNode* Parser::If()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Parse the if condition (including the if keyword)
		ExpressionNode* condition = IfCondition();

		// If a condition and keyword was read...
		if (condition != nullptr)
		{
			// The root of the if statement, which makes traversing the parts of the if statement more straightforward
			IfRootNode* ifRoot = new IfRootNode();

			// Parse the body of the if statement, from { to }
			this->IfBody(condition, ifRoot);

			// As long as the body was properly read...
			if (this->Errors.WasError == false)
			{
				// We didn't have an error, so we should have one child
				if (ifRoot->IfParts.empty() == false)
				{
					// The first part of the if statement is the 
					ifRoot->IfParts.front()->IsFirstPart = true;
				}

				// Accept the token position, and return the "return node"
				this->AcceptTokenPosition();
				this->SetNodeLocationEndHere(ifRoot);
				return ifRoot;
			}

			// If we got here, we failed
			delete condition;
			condition = nullptr;
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::ForEach()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// This is effectively what this below code is translating a foreach loop to:
		//*
		//* foreach (var animal in farm.All)
		//* {
		//*   animal.Speak();
		//* }
		//* 
		//* for (var [animalRange] = farm.All.All; [animalRange].IsNotEmpty; [animalRange].MoveNext())
		//* {
		//*   var animal = [animalRange].Current;
		//*   animal.Speak();
		//* }
		//*

		// Check to see if we're starting a foreach statement
		if (Accept(1, Grammar::ForEach))
		{
			// Look for the beginning of the for loop declaration
			if (Expect(Grammar::BeginGroup, ErrorCode::ForLoopExpressionsNotFound))
			{
				// Attempt to parse the variable
				LocalVariableNode* valueVariable = this->LocalVariable(false);

				// If we didn't parse a variable...
				if (valueVariable == nullptr)
				{
					// Show an error since we failed to parse the condition
					ErrorHere(ErrorCode::ForEachVariableDeclarationNotFound);

					// We didn't successfully parse an expression, so just recall the token position and return null
					RecallTokenPosition();
					return nullptr;
				}

				// Look for the 'in' keyword
				if (Expect(Grammar::In, ErrorCode::ForEachInKeywordNotFound))
				{
					// Attempt to parse the range expression
					ExpressionNode* range = Expression();

					// If we parsed an expression...
					if (range != nullptr)
					{
						// Look for the end parenthasis
						if (Expect(Grammar::EndGroup, ErrorCode::ForLoopExpressionsNotComplete))
						{
							// Look for the beginning of the if-statement scope
							if (Expect(Grammar::BeginScope, ErrorCode::ForLoopBodyNotFound))
							{
								// Create a for node since this is a valid for statement
								ForEachNode* node = new ForEachNode();
								this->SetNodeLocationStartToLastSave(node);

								// Let any users know the original variable/range that came from the foreach
								node->NonTraversedVariable = valueVariable->Clone();
								node->NonTraversedRange = (ExpressionNode*)range->Clone();

								// Access the 'All' element of the range expression
								// Note that even ranges have a subsequent 'All' which returns itself
								MemberAccessNode* allAccessNode = new MemberAccessNode();
								allAccessNode->Location = range->Location;
								allAccessNode->Name = "All";
								allAccessNode->Operator = Tokenizer::GetAccessToken();
								allAccessNode->LeftOperand = range;

								// Create a variable that will store the range
								LocalVariableNode* rangeVariable = new LocalVariableNode();
								rangeVariable->Location = range->Location;
								rangeVariable->Name = BuildString("[", valueVariable->Name, "Range]");
								rangeVariable->InitialValue = allAccessNode;
								node->RangeVariable = rangeVariable;

								// Create a local variable reference to the range variable
								LocalVariableReferenceNode* rangeLocal = new LocalVariableReferenceNode();
								rangeLocal->Value.Token = rangeVariable->Name;
								rangeLocal->Value.TokenId = Grammar::LowerIdentifier;

								// We need to access the 'MoveNext' function on the range
								MemberAccessNode* moveNextAccessNode = new MemberAccessNode();
								moveNextAccessNode->Location = range->Location;
								moveNextAccessNode->Name = "MoveNext";
								moveNextAccessNode->Operator = Tokenizer::GetAccessToken();
								moveNextAccessNode->LeftOperand = rangeLocal;

								// We want to call the 'MoveNext' function
								FunctionCallNode* moveNextCallNode = new FunctionCallNode();
								moveNextCallNode->Location = range->Location;
								moveNextCallNode->LeftOperand = moveNextAccessNode;

								// For iteration, we call the 'MoveNext' functoin on the range
								node->Iterator = moveNextCallNode;

								// Access the 'IsNotEmpty' element of the range expression
								MemberAccessNode* isNotEmptyAccessNode = new MemberAccessNode();
								isNotEmptyAccessNode->Location = range->Location;
								isNotEmptyAccessNode->Name = "IsNotEmpty";
								isNotEmptyAccessNode->Operator = Tokenizer::GetAccessToken();
								isNotEmptyAccessNode->LeftOperand = rangeLocal->Clone();

								// Our condition is if we're empty
								node->Condition = isNotEmptyAccessNode;

								// Access the 'Current' element of the range expression
								MemberAccessNode* currentAccessNode = new MemberAccessNode();
								currentAccessNode->Location = range->Location;
								currentAccessNode->Name = "Current";
								currentAccessNode->Operator = Tokenizer::GetAccessToken();
								currentAccessNode->LeftOperand = rangeLocal->Clone();

								// We create this variable and initialize it as the first statement in the for loop
								valueVariable->InitialValue = currentAccessNode;
								node->Statements.Add(valueVariable);

								// Parse all the statements inside the scope
								while (node->Statements.Add(Statement()));

								// Now look for the end scope
								bool finishedNode = Expect(Grammar::EndScope, ErrorCode::ForLoopBodyNotComplete);

								// As long as we finished this node (either via correct parsing or tolerance)
								if (finishedNode == false && this->Errors.TolerantMode)
								{
									// Since we're being tolerant, just eat tokens until we hit the end of our scope
									// This is just an approximation, as there may be actual scope errors
									// This will return true if it finds the scope and will advance the token forward automatically
									finishedNode = this->MoveToScopeEnd();
								}

								// As long as we finished this node (either via correct parsing or tolerance)
								if (finishedNode)
								{
									// Accept the token position, and return the "return node"
									AcceptTokenPosition();
									this->SetNodeLocationEndHere(node);
									return node;
								}

								// We didn't successfully parse an expression, so just recall the token position and return null
								RecallTokenPosition();
								delete node;
								node = nullptr;
								return nullptr;
							}
						}

						// We failed, so delete anything we've created up to this point
						delete range;
						range = nullptr;
					}
					else
					{
						// Show an error since we failed to parse the condition
						ErrorHere(ErrorCode::ForEachRangeExpressionNotFound);
					}

					// We failed, so delete anything we've created up to this point
					delete valueVariable;
					valueVariable = nullptr;
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::For()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a for statement
		if (Accept(1, Grammar::For))
		{
			// Look for the beginning of the for loop declaration
			if (Expect(Grammar::BeginGroup, ErrorCode::ForLoopExpressionsNotFound))
			{
				// Attempt to parse the variable
				LocalVariableNode* variable = this->LocalVariable();

				// Alternatively, we could have an initialization expression (assume we don't for now)
				ExpressionNode* initialization = nullptr;

				// If we didn't parse a variable...
				if (variable == nullptr)
				{
					// Attempt to parse the initialization expression
					initialization = Expression();

					// If we do not have an initialization expression...
					if (initialization == nullptr)
					{
						// Show an error since we failed to parse the condition
						ErrorHere(ErrorCode::ForLoopExpressionsNotFound);

						// We didn't successfully parse an expression, so just recall the token position and return null
						RecallTokenPosition();
						return nullptr;
					}
				}

				// Look for the semicolon that separates initialization and condition
				if (Expect(Grammar::StatementSeparator, ErrorCode::ForLoopExpressionsNotComplete))
				{
					// Attempt to parse the condition expression
					ExpressionNode* condition = Expression();

					// If we parsed an expression...
					if (condition != nullptr)
					{
						// Look for the semicolon that separates initialization and condition
						if (Expect(Grammar::StatementSeparator, ErrorCode::ForLoopExpressionsNotComplete))
						{
							// Attempt to parse the iterator expression
							ExpressionNode* iterator = Expression();

							// If we parsed an expression...
							if (iterator != nullptr)
							{
								// Look for the end parenthasis
								if (Expect(Grammar::EndGroup, ErrorCode::ForLoopExpressionsNotComplete))
								{
									// Look for the beginning of the if-statement scope
									if (Expect(Grammar::BeginScope, ErrorCode::ForLoopBodyNotFound))
									{
										// Create a for node since this is a valid for statement
										ForNode* node = new ForNode();
										this->SetNodeLocationStartToLastSave(node);

										// Parse all the statements inside the scope
										while (node->Statements.Add(Statement()));

										// Now look for the end scope
										bool finishedNode = Expect(Grammar::EndScope, ErrorCode::ForLoopBodyNotComplete);

										// If we didn't find the end of the scope, but we're in tolerant mode...
										if (finishedNode == false && this->Errors.TolerantMode)
										{
											// Since we're being tolerant, just eat tokens until we hit the end of our scope
											// This is just an approximation, as there may be actual scope errors
											// This will return true if it finds the scope and will advance the token forward automatically
											finishedNode = this->MoveToScopeEnd();
										}

										// As long as we finished this node (either via correct parsing or tolerance)
										if (finishedNode)
										{
											// Set the variable (it could be null)
											node->ValueVariable = variable;

											// Set the initialization expression (it could be null)
											node->Initialization = initialization;

											// Set the conditional expression
											node->Condition = condition;

											// Set the iterator expression
											node->Iterator = iterator;

											// Accept the token position, and return the "return node"
											AcceptTokenPosition();
											this->SetNodeLocationEndHere(node);
											return node;
										}

										// Delete the node since we failed
										delete node;
										node = nullptr;
									}
								}
							}
							else
							{
								// Show an error since we failed to parse the iterator
								ErrorHere(ErrorCode::ForLoopExpressionsNotFound);
							}

							// We failed, so delete anything we've created up to this point
							delete iterator;
							iterator = nullptr;
						}

						// We failed, so delete anything we've created up to this point
						delete condition;
						condition = nullptr;
					}
					else
					{
						// Show an error since we failed to parse the condition
						ErrorHere(ErrorCode::ForLoopExpressionsNotFound);
					}

					// We failed, so delete anything we've created up to this point
					delete variable;
					delete initialization;
					variable = nullptr;
					initialization = nullptr;
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::While()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a while statement
		if (Accept(1, Grammar::While))
		{
			// Look for the beginning of a conditional expression
			if (Expect(Grammar::BeginGroup, ErrorCode::WhileConditionalExpressionNotFound))
			{
				// Attempt to parse the conditional expression
				ExpressionNode* condition = Expression();

				// If we properly parsed the conditional expression...
				if (condition != nullptr)
				{
					// Look for the end parenthasis
					if (Expect(Grammar::EndGroup, ErrorCode::WhileConditionalExpressionNotComplete))
					{
						// Look for the beginning of the if-statement scope
						if (Expect(Grammar::BeginScope, ErrorCode::WhileBodyNotFound))
						{
							// Create a while node since this is a valid while statement
							WhileNode* node = new WhileNode();
							this->SetNodeLocationStartToLastSave(node);

							// Parse all the statements inside the if-statement
							while (node->Statements.Add(Statement()));

							// Now look for the end scope
							bool finishedNode = Expect(Grammar::EndScope, ErrorCode::WhileBodyNotComplete);

							// If we didn't find the end of the scope, but we're in tolerant mode...
							if (finishedNode == false && this->Errors.TolerantMode)
							{
								// Since we're being tolerant, just eat tokens until we hit the end of our scope
								// This is just an approximation, as there may be actual scope errors
								// This will return true if it finds the scope and will advance the token forward automatically
								finishedNode = this->MoveToScopeEnd();
							}

							// As long as we finished this node (either via correct parsing or tolerance)
							if (finishedNode)
							{
								// Set the conditional expression on the if-node
								node->Condition = condition;

								// Accept the token position, and return the "return node"
								AcceptTokenPosition();
								this->SetNodeLocationEndHere(node);
								return node;
							}

							// Delete the while-node
							delete node;
							node = nullptr;
						}
					}

					// Delete the conditional expression node
					delete condition;
					condition = nullptr;
				}
				else
				{
					// Show an error message
					ErrorHere(ErrorCode::WhileConditionalExpressionNotFound);
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::DoWhile()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a do while statement
		if (Accept(1, Grammar::Do))
		{
			// Look for the beginning of the do-while scope
			if (Expect(Grammar::BeginScope, ErrorCode::DoWhileBodyNotFound))
			{
				// Create a do-while node since this is a valid while statement
				DoWhileNode* node = new DoWhileNode();
				this->SetNodeLocationStartToLastSave(node);

				// Parse all the statements inside the if-statement
				while (node->Statements.Add(Statement()));

				// Now look for the end scope
				bool foundEndScope = Expect(Grammar::EndScope, ErrorCode::DoWhileBodyNotComplete);

				// If we didn't find the end of the scope, but we're in tolerant mode...
				if (foundEndScope == false && this->Errors.TolerantMode)
				{
					// Since we're being tolerant, just eat tokens until we hit the end of our scope
					// This is just an approximation, as there may be actual scope errors
					// This will return true if it finds the scope and will advance the token forward automatically
					foundEndScope = this->MoveToScopeEnd();
				}

				// As long as we found the ending scope (either via correct parsing or tolerance)
				if (foundEndScope)
				{
					// Now parse the while statement
					if (Accept(1, Grammar::While))
					{
						// Look for the beginning of a conditional expression
						if (Expect(Grammar::BeginGroup, ErrorCode::DoWhileConditionalExpressionNotFound))
						{
							// Attempt to parse the conditional expression
							ExpressionNode* condition = Expression();

							// If we properly parsed the conditional expression...
							if (condition != nullptr)
							{
								// Look for the end parenthasis
								if (Expect(Grammar::EndGroup, ErrorCode::DoWhileConditionalExpressionNotComplete))
								{
									// Set the conditional expression on the if-node
									node->Condition = condition;

									// Accept the token position, and return the "return node"
									AcceptTokenPosition();
									this->SetNodeLocationEndHere(node);
									return node;
								}

								// Delete the conditional expression node
								delete condition;
								condition = nullptr;
							}
							else
							{
								// We failed to find the conditional expression
								ErrorHere(ErrorCode::DoWhileConditionalExpressionNotFound);
							}
						}
					}
				}

				// Delete the while-node
				delete node;
				node = nullptr;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	StatementNode* Parser::Loop()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// Check to see if we're starting a loop statement
		if (Accept(1, Grammar::Loop))
		{
			// Look for the beginning of the if-statement scope
			if (Expect(Grammar::BeginScope, ErrorCode::LoopBodyNotFound))
			{
				// Create a loop node since this is a valid loop statement
				LoopNode* node = new LoopNode();
				this->SetNodeLocationStartToLastSave(node);

				// Parse all the statements inside the if-statement
				while (node->Statements.Add(Statement()));

				// Now look for the end scope
				bool finishedNode = Expect(Grammar::EndScope, ErrorCode::LoopBodyNotComplete);

				// If we didn't find the end of the scope, but we're in tolerant mode...
				if (finishedNode == false && this->Errors.TolerantMode)
				{
					// Since we're being tolerant, just eat tokens until we hit the end of our scope
					// This is just an approximation, as there may be actual scope errors
					// This will return true if it finds the scope and will advance the token forward automatically
					finishedNode = this->MoveToScopeEnd();
				}

				// As long as we finished this node (either via correct parsing or tolerance)
				if (finishedNode)
				{
					// Accept the token position, and return the "return node"
					AcceptTokenPosition();
					this->SetNodeLocationEndHere(node);
					return node;
				}

				// Delete the while-node
				delete node;
				node = nullptr;
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}


	//***************************************************************************
	TypeMemberAccessNode* Parser::TypeMemberAccess()
	{
		// Read the type information for the type member access
		SyntaxType* type = this->ReadTypeInfo();

		// As long as we read a type...
		if (type != nullptr)
		{
			// Hold the access operator type
			const UserToken* accessOperator;

			// Check to see if we're starting a member access
			if (this->AcceptAny(1, &accessOperator, Grammar::Access))
			{
				// Hold the member we attempted to access
				const UserToken* member;

				// Get the member name that we're trying to access
				if (this->AcceptAndRetrieve(1, Grammar::UpperIdentifier, &member))
				{
					// We started a member access, so allocate the corresponding node
					TypeMemberAccessNode* node = new TypeMemberAccessNode();
					this->SetNodeLocationStartToLastSave(node);

					ZilchTodo
						(
						"Because the node is both acting as the type reference and the member access, "
						"errors that occur with just the member will appear to point at the type, find a way to resolve this"
						);

					// Setup the node
					node->ReferencedSyntaxType = type;
					node->Operator = accessOperator;
					node->Name = member->Token;

					// Accept the token position, and return the function call node
					this->SetNodeLocationEndHere(node);
					return node;
				}
				else
				{
					// Show an error message
					this->ErrorHere(ErrorCode::MemberAccessNameNotFound);
				}
			}
			else
			{
				// Show an error message
				this->ErrorHere(ErrorCode::LoneTypeShouldOnlyAppearInAccessingStatics, type->ToString().c_str());
			}

			// We allocated the type, free it now since we failed
			delete type;
			type = nullptr;
		}

		// We did not parse it
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::CreationCall()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// We handle both 'new' and 'local' calls here
		// Start by assuming we read neither...
		CreationMode::Enum creationMode = CreationMode::Inferred;

		// Lets see if it's a new creation call
		if (Accept(1, Grammar::New))
		{
			// Create a new call node
			creationMode = CreationMode::New;
		}
		// Lets see if it's a local creation call
		else if (Accept(1, Grammar::Local))
		{
			// Create a local call node
			creationMode = CreationMode::Local;
		}

		// Now lets attempt to get the type used in the new-call
		BoundSyntaxType* type = this->ReadBoundTypeInfo();
		if (type != nullptr)
		{
			// Read a constructor call
			FunctionCallNode* constructorCall = this->FunctionCall();

			// If we properly read a constructor call...
			if (constructorCall != nullptr)
			{
				// Create the node that we'll attach to the tree
				CreationCallNode* node = new CreationCallNode();
				node->Mode = creationMode;
				node->CreatedSyntaxType = type;

				// Let the node know where it was started
				this->SetNodeLocationStartToLastSave(node);

				// Set the left operand of the constructor to be our creation node
				// (the constructor call is just a function call node, which is a post expression)
				constructorCall->LeftOperand = node;

				// Attempt to parse the initializer now (initializes members and adds values to containers AFTER construction)
				if (Accept(1, Grammar::BeginInitializer))
				{
					CreationInitializerNode* initializer = new CreationInitializerNode();
					this->SetNodeLocationStartHere(initializer);
					initializer->LeftOperand = constructorCall;

					// First check to see if this is an entirely empty list...
					if (Accept(1, Grammar::EndInitializer) == false)
					{
						// Loop until we have no more expressions to parse
						do
						{
							// If we read in an add node (two forms, just an expression, and also a block [expressions])
							CreationAddInitializerNode* addNode = nullptr;

							// Save the name of the member we're initializing
							const UserToken* memberName;

							// If we're initializing a member...
							if (this->AcceptAndRetrieve(2, Grammar::UpperIdentifier, &memberName, Grammar::Assignment, nullptr))
							{
								// Create the member initializer node
								CreationMemberInitializerNode* memberNode = new CreationMemberInitializerNode();
								this->SetNodeLocationStartHere(memberNode);
								initializer->InitailizeMembers.Add(memberNode);

								// Set the name of the member we're accessing
								memberNode->MemberName = *memberName;

								// Now read the value we want to initialize this member to
								if (ExpressionNode* initialValue = this->Expression())
								{
									// Store the initial value, we've read the entire member initializer!
									memberNode->Value = initialValue;

									// End the member node here
									this->SetNodeLocationEndHere(memberNode);

									// Now create fake nodes to actually invoke the initializer (statements)
									// Forward access to the creation node
									UnnamedOperandNode* accessCreation = new UnnamedOperandNode();
									accessCreation->Location = memberNode->Location;
									accessCreation->ToBeForwarded = node;

									// Access the 'Add' method on the container
									MemberAccessNode* memberAccess = new MemberAccessNode();
									memberAccess->Location = memberNode->Location;
									memberAccess->Name = memberName->Token;
									memberAccess->Operator = Tokenizer::GetAccessToken();
									memberAccess->LeftOperand = accessCreation;

									// Call the add method with the arguments we parsed
									BinaryOperatorNode* assignment = new BinaryOperatorNode();
									assignment->Location = memberNode->Location;
									assignment->LeftOperand = memberAccess;
									assignment->Operator = Tokenizer::GetAssignmentToken();
									assignment->RightOperand = (ExpressionNode*)memberNode->Value->Clone();

									// Lastly, add the assignment to the initialization statements
									initializer->InitializerStatements.Add(assignment);
								}
								else
								{
									// Show an error and recall back to the saved position
									this->ErrorHere(ErrorCode::CreationInitializeMemberExpectedInitialValue,
										memberName->Token.c_str(), memberName->Token.c_str());
									this->RecallTokenPosition();

									// Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
									delete initializer;
									initializer = nullptr;
									return nullptr;
								}
							}
							// Look for another 'add' element initializer
							else if (Accept(1, Grammar::BeginInitializer))
							{
								// We're reading another value (could be an argument list)
								addNode = new CreationAddInitializerNode();
								this->SetNodeLocationStartHere(addNode);
								initializer->AddValues.Add(addNode);

								// First check to see if this is an entirely empty list...
								if (Accept(1, Grammar::EndInitializer) == false)
								{
									// Loop until we have no more expressions to parse
									do
									{
										// Parse each expression and add it
										ExpressionNode* addValue = this->Expression();

										// We got in here, but we didn't expect another expression
										// We make an exception for the first expression
										if (addValue == nullptr)
										{
											// Show an error and recall back to the saved position
											this->ErrorHere(ErrorCode::CreationInitializerNotComplete);
											this->RecallTokenPosition();

											// Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
											delete initializer;
											initializer = nullptr;
											return nullptr;
										}

										// Add the next expression to our arguments list...
										addNode->Arguments.Add(addValue);
									}
									// While we read comma separators (which means we read the next expression)
									while (Accept(1, Grammar::ArgumentSeparator));

									// If we expect another expression...
									if (Expect(Grammar::EndInitializer, ErrorCode::CreationInitializerExpectedExpression) == false)
									{
										// Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
										delete initializer;
										initializer = nullptr;
										this->RecallTokenPosition();
										return nullptr;
									}
								}
							}
							// If we're adding just one expression...
							else if (ExpressionNode* singleAddValue = this->Expression())
							{
								// We're reading another value (could be an argument list)
								addNode = new CreationAddInitializerNode();
								this->SetNodeLocationStartHere(addNode);
								initializer->AddValues.Add(addNode);

								// Add the expression we read to the add node
								addNode->Arguments.Add(singleAddValue);
							}
							else
							{
								// Show an error and recall back to the saved position
								this->ErrorHere(ErrorCode::CreationInitializerExpectedSubElement);
								this->RecallTokenPosition();

								// Deleting the initializer should delete the constructor call and the creation node, and the type we parsed
								delete initializer;
								initializer = nullptr;
								return nullptr;
							}

							// If we read in an add node, then generate an actual 'Add' statement
							if (addNode != nullptr)
							{
								// End the add node here
								this->SetNodeLocationEndHere(addNode);

								// Forward access to the creation node
								UnnamedOperandNode* accessCreation = new UnnamedOperandNode();
								accessCreation->Location = addNode->Location;
								accessCreation->ToBeForwarded = node;

								// Access the 'Add' method on the container
								MemberAccessNode* addMember = new MemberAccessNode();
								addMember->Location = addNode->Location;
								addMember->Name = ContainerAdd;
								addMember->Operator = Tokenizer::GetAccessToken();
								addMember->LeftOperand = accessCreation;

								// Call the add method with the arguments we parsed
								FunctionCallNode* addCall = new FunctionCallNode();
								addCall->Location = addNode->Location;
								addCall->LeftOperand = addMember;

								// Copy over the arguments to the function call
								for (size_t i = 0; i < addNode->Arguments.size(); ++i)
								{
									// Clone the same expression arguments to appear in the add call arguments
									addCall->Arguments.Add((ExpressionNode*)addNode->Arguments[i]->Clone());
								}

								// Lastly, add the call to the initialization statements
								initializer->InitializerStatements.Add(addCall);
							}
						}
						// While we read comma separators (which means we read the next expression)
						while (Accept(1, Grammar::ArgumentSeparator));

						// If we expect another expression...
						if (Expect(Grammar::EndInitializer, ErrorCode::CreationInitializerExpectedExpression) == false)
						{
							// Deleting the constructor call should delete the creation node, all initializers, and the type we parsed
							delete initializer;
							initializer = nullptr;
							this->RecallTokenPosition();
							return nullptr;
						}
					}

					// The initializer ends here
					this->SetNodeLocationEndHere(initializer);

					// Return the parsed initializer list, which holds the constructor call and creation call node
					this->SetNodeLocationEndHere(node);
					this->AcceptTokenPosition();
					return initializer;
				}
				else
				{
					// Return the parsed constructor call (every new/local requires a constructor call)
					this->SetNodeLocationEndHere(node);
					this->AcceptTokenPosition();
					return constructorCall;
				}
			}

			// If we had the new/local actually specified
			if (creationMode != CreationMode::Inferred)
				this->ErrorHere(ErrorCode::ConstructorCallNotFound);

			// We allocated the type, free it now since we didn't parse
			delete type;
			type = nullptr;
		}
		// If we didn't read a type, but we did have a new/local...
		else if (creationMode != CreationMode::Inferred)
		{
			// Show an error message
			this->ErrorHere(ErrorCode::CreatedTypeNotFound);
		}

		// Return null since we didn't parse anything
		this->RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::TypeId()
	{
		// We only need to get the type-id token because we need to know its location
		// so that we can tell the node where it started from
		const UserToken* typeIdToken;

		// Lets see if it's a type-id
		if (this->AcceptAndRetrieve(1, Grammar::Typeid, &typeIdToken))
		{
			// Check for the first parenthesis
			if (this->Expect(Grammar::BeginGroup, ErrorCode::TypeIdExpressionNotFound))
			{
				// Below is a little bit of a wonky piece of logic
				// We may want to introduce a 'static type id' instead
				// Basically we need to attempt to read a type, and then if that fails
				// we need to recall back and read an expression
				// We know that we properly read the type when it parses and we also read
				// an ending parenthesis ')'. Note that the user could be inputting
				// an expression, but the expression could start with a type (TypeMemberAccess...)
				this->SaveTokenPosition();

				// We may alternatively try to get the typeid of a type
				// NOTE: This is critical that we read the type first!
				// The error 'LoneTypeShouldOnlyAppearInAccessingStatics' will be raised
				// if we attempt to parse an expression first, but the user wrote a type instead
				SyntaxType* type = this->ReadTypeInfo();

				// Read the value we want to get the type of
				ExpressionNode* value = nullptr;

				// If we read the type, and we know it's the whole type because we hit the ending parentheses...
				if (type != nullptr && this->Accept(1, Grammar::EndGroup))
				{
					// Accept the read so we can move on
					this->AcceptTokenPosition();
				}
				// If no type was read, or we didn't read the end parentheses
				// then attempt to read a value expression...
				else
				{
					// First attempt to delete the type that was read (nullptr safe to delete)
					delete type;
					type = nullptr;

					// Recall the position back so we can read the expression
					this->RecallTokenPosition();

					// Read the value expression that we want to get rtti for
					value = this->Expression();
				}

				// As long as we read the type-id expression / type
				if (type != nullptr || value != nullptr)
				{
					// Make sure we read the ending parenthesis (note, if we read a type, then that already happened!)
					if (type != nullptr || this->Expect(Grammar::EndGroup, ErrorCode::TypeIdExpressionNotComplete))
					{
						// Create a new call node
						TypeIdNode* node = new TypeIdNode();
						this->SetNodeLocationStartToToken(node, *typeIdToken);

						// Set the value expression or type that we want to get rtti for
						node->CompileTimeSyntaxType = type;
						node->Value = value;

						// Return the node we just parsed
						this->SetNodeLocationEndHere(node);
						return node;
					}
				}
				else
				{
					// Show an error since we didn't parse the expression
					this->ErrorHere(ErrorCode::TypeIdExpressionNotFound);
				}
			}
		}

		// Return null since we didn't parse anything
		return nullptr;
	}

	//***************************************************************************
	ValueNode* Parser::CreateStringLiteral(const UserToken* token)
	{
		// Just allocate a standard value-node
		ValueNode* node = new ValueNode();

		// Let the node know where it started and ended (line / character, etc)
		this->SetNodeLocationStartHere(node);

		// Point the node's value to the parsed value
		node->Value = *token;
		node->Value.TokenId = Grammar::StringLiteral;

		// Return the value node
		return node;
	}

	//***************************************************************************
	StringInterpolantNode* Parser::StringInterpolant()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// This will hold the token that we try and parse
		const UserToken* interpolantStart;

		// Check to see if we're starting a string interpolant
		if (this->AcceptAny(1, &interpolantStart, Grammar::BeginStringInterpolate))
		{
			// Create a string interpolant node
			StringInterpolantNode* node = new StringInterpolantNode();
			this->SetNodeLocationStartToLastSave(node);

			// Add the string value node
			node->Elements.Add(this->CreateStringLiteral(interpolantStart));

			ZilchLoop
			{
				// Now we should be able to parse an expression, since we started an interpolation
				if (node->Elements.Add(this->Expression()) == nullptr)
				{
					// Show an error and recall back to the saved position
					ErrorHere(ErrorCode::StringInterpolantExpectedExpression);
					RecallTokenPosition();
					delete node;
					node = nullptr;
					return nullptr;
				}

				// Attempt to read the end of the interpolant
				const UserToken* interpolantEnd;
				if (this->AcceptAny(2, &interpolantEnd, Grammar::EndStringInterpolate, Grammar::EndBeginStringInterpolate))
				{
					// Add the string value node
					node->Elements.Add(this->CreateStringLiteral(interpolantEnd));

					// If we reached the true end of the interpolant
					if (interpolantEnd->TokenId == Grammar::EndStringInterpolate)
					{
						// Accept the token position, and return the node
						AcceptTokenPosition();
						this->SetNodeLocationEndHere(node);
						return node;
					}
				}
				else
				{
					// Show an error and recall back to the saved position
					ErrorHere(ErrorCode::StringInterpolantNotComplete);
					RecallTokenPosition();
					delete node;
					node = nullptr;
					return nullptr;
				}
			}
		}

		// We didn't successfully parse an expression, so just recall the token position and return null
		RecallTokenPosition();
		return nullptr;
	}

	//***************************************************************************
	ExpressionNode* Parser::Value()
	{
		// Save the token position
		ZilchSaveAndVerifyTokenPosition();

		// This will hold the token that we try and parse
		const UserToken* value;

		// Attempt to parse any value (including literals and identifiers) and retreive the associated token
		if (this->AcceptAny(10, &value, Grammar::LowerIdentifier, Grammar::IntegerLiteral, Grammar::DoubleIntegerLiteral, Grammar::RealLiteral, Grammar::DoubleRealLiteral, Grammar::StringLiteral, Grammar::CharacterLiteral, Grammar::Null, Grammar::True, Grammar::False))
		{
			// We found a value, so make room for it
			ValueNode* node;

			// If the value is an lower-case identifier, then it must be a variable reference
			if (value->TokenId == Grammar::LowerIdentifier)
			{
				// Allocate an identifier node (which is also a value node)
				node = new LocalVariableReferenceNode();
			}
			// Otherwise, it's just a standard value
			else
			{
				// Just allocate a standard value-node
				node = new ValueNode();
			}

			// Let the node know where it started (line / character, etc)
			this->SetNodeLocationStartToLastSave(node);

			// Point the node's value to the parsed value
			node->Value = *value;

			// Accept the token position, and return the value node
			AcceptTokenPosition();
			this->SetNodeLocationEndHere(node);
			return node;
		}
		// Lets see if it's a string interpolant
		else if (StringInterpolantNode* node = this->StringInterpolant())
		{
			// Accept the token position, and return the value node
			AcceptTokenPosition();
			return node;
		}
		// Otherwise, lets see if it's a constructor call (new or local)
		// Note: This MUST come before 'TypeMemberAccess' because of a refactor where we made new/local optional
		// Creation call can read a type now, and so does 'TypeMemberAccess', except if 'TypeMemberAccess' reads a type and no '.'
		// then it will throw an error saying a type should never appear in that context
		else if (ExpressionNode* node = this->CreationCall())
		{
			// Accept the token position, and return the value node
			AcceptTokenPosition();
			return node;
		}
		// See if we parse a type
		else if (TypeMemberAccessNode* node = this->TypeMemberAccess())
		{
			// Accept the token position, and return the value node
			AcceptTokenPosition();
			return node;
		}
		// It might be a type-id, lets check that
		else if (ExpressionNode* node = this->TypeId())
		{
			// Accept the token position, and return the value node
			AcceptTokenPosition();
			return node;
		}
		// Lastly, try and see if we're just in a grouping operator
		else if (Accept(1, Grammar::BeginGroup))
		{
			// Attempt to read the expression inside the grouping
			ExpressionNode* expression = this->Expression();

			// If the expression was found...
			if (expression != nullptr)
			{
				// Look for the closing parenthasis
				if (Expect(Grammar::EndGroup, ErrorCode::GroupingOperatorNotComplete))
				{
					// Accept the token position, and return the expression node
					this->AcceptTokenPosition();
					return expression;
				}

				// If we got here, we failed to finish the grouping operator
				delete expression;
				expression = nullptr;
			}
		}

		// Otherwise, recall the old token position and return null
		this->RecallTokenPosition();
		return nullptr;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	AutoCompleteInfo::AutoCompleteInfo() :
		IsStatic(false),
		NearestType(nullptr),
		IsLiteral(false)
	{
	}

	//***************************************************************************
	Project::Project(CompilationErrors& errors) :
		Errors(errors),
		CursorPosition(NoCursor),
		UserData(nullptr)
	{
		ZilchErrorIfNotStarted(Project);
	}

	//***************************************************************************
	void Project::AddTypeParsedCallback(TypeParsedCallback callback, void* userData)
	{
		// Create a delegate out of the callback and userdata
		TypeParsedDelegate delegate;
		delegate.Callback = callback;
		delegate.UserData = userData;

		// Add the delegate to the handlers
		this->TypeParsedHandlers.push_back(delegate);
	}

	//***************************************************************************
	void Project::AddCodeFromString(StringParam code, StringParam origin, void* codeUserData)
	{
		// Add an entry to the list of all entries
		CodeEntry& entry = this->Entries.push_back();
		entry.Code = code;
		entry.Origin = origin;
		entry.CodeUserData = codeUserData;
	}

	//***************************************************************************
	bool Project::ReadTextFile(StringParam fileName, String& textOut)
	{
		// Attempt to open the file for text reading
		FILE* fp = fopen(fileName.c_str(), "r");

		// If the file pointer is valid...
		if (fp)
		{
			// Create a string builder to concatenate all read in chunks together
			StringBuilder builder;

			// While we haven't reached the end of the file and have no errors...
			while (!feof(fp))
			{
				// Create a temporary buffer to store read in chunks
				const size_t BufferSize = 1024;
				char buffer[BufferSize];

				// Read a chunk of the file into the buffer
				size_t amountRead = fread(buffer, 1, BufferSize, fp);

				// If we had any kind of error, early out...
				if (ferror(fp))
				{
					// Return that we failed to read the file
					return false;
				}

				// Add the amount read into the string range
				builder.Append(StringRange(buffer, amountRead));
			}

			// Close the file handle
			fclose(fp);

			// Output the string that we read and return a success
			textOut = builder.ToString();
			return true;
		}

		// Otherwise, we failed to open the file
		Error("Unable to load file: %s", fileName.c_str());
		return false;
	}

	//***************************************************************************
	bool Project::AddCodeFromFile(StringParam fileName, void* codeUserData)
	{
		// Read all the file into a string
		String code;
		bool result = ReadTextFile(fileName, code);

		// If we successfully read in the file...
		if (result)
		{
			// Add the code to the project
			this->AddCodeFromString(code, fileName, codeUserData);
		}

		// Return whether or not we successfully read the file
		return result;
	}

	//***************************************************************************
	void Project::Clear()
	{
		this->Entries.clear();
	}

	//***************************************************************************
	bool Project::Tokenize(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut)
	{
		// Reset whether there was an error or not
		this->Errors.WasError = false;

		// The tokenizer that parses the input stream into a list of tokens
		Tokenizer tokenizer(this->Errors);

		// Loop through all the project entries
		for (size_t i = 0; i < this->Entries.size(); ++i)
		{
			// Grab the current project entry
			CodeEntry& entry = this->Entries[i];

			// Keep parsing all code into the same token stream
			tokenizer.Parse(entry, tokensOut, commentsOut);
		}

		// Finalize the token stream
		tokenizer.Finalize(tokensOut);

		// Return true if it succeeded, or false if there was an error in tokenizing
		return !this->Errors.WasError;
	}

	//***************************************************************************
	// This simple struct is used to define information about which syntax nodes came from which lines
	class OriginInfo
	{
	public:
		// Constructor
		OriginInfo() :
			MaxLine(0)
		{
		}

		// The max line reachable in the file (actually it's the last node we saw)
		size_t MaxLine;

		// The lines that map to a syntax node (some lines will be empty)
		HashMap<size_t, SyntaxNode*> LineToNode;
	};

	//***************************************************************************
	// Maps the line that a node occurs on to the node itself
	void MapLinesToNodes(HashMap<String, OriginInfo>& info, SyntaxNode* node)
	{
		// Skip attribute nodes, they are attached in a similar fashion to comments
		if (TypeBinding::DynamicCast<AttributeNode*>(node) != nullptr)
			return;

		// Populate all the children of the current node
		NodeChildren children;
		node->PopulateChildren(children);

		// Get the origin information by name
		OriginInfo& origin = info[node->Location.Origin];

		// Map the current node's line to the node itself
		// If another node exists under that same line, keep the first one
		// This is so that comments get attached to the highest parent node occuring on that line
		// (eg for 'var i = 5;' to the 'var' statement instead of the '5' expression);
		origin.LineToNode.insertNoOverwrite(node->Location.StartLine, node);

		// If this is the furthest node we've encountered in the file...
		if (node->Location.StartLine > origin.MaxLine)
		{
			// Push out the max line so we know how far to look when attaching comments
			origin.MaxLine = node->Location.StartLine;
		}

		// Loop through the children and map the lines again
		for (size_t i = 0; i < children.size(); ++i)
		{
			// Recursively invoke the map lines function
			MapLinesToNodes(info, (*children[i]));
		}
	}

	//***************************************************************************
	void Project::AttachCommentsToNodes(SyntaxTree& syntaxTree, Array<UserToken>& comments)
	{
		// Setup the map that we use to associate lines with nodes
		HashMap<String, OriginInfo> info;

		// Perform the actual line to node association, starting at the root going down
		MapLinesToNodes(info, syntaxTree.Root);

		// Loop through all the comments we parsed
		for (size_t i = 0; i < comments.size(); ++i)
		{
			// Get the current comment
			UserToken& comment = comments[i];

			// We need to start by looking in the file/origin where the comment existed
			OriginInfo& origin = info[comment.Location.Origin];

			// Now start at the comment line and loop downward until we find a node to attach it to (stop at the last line)
			for (size_t j = comment.Location.StartLine; j <= origin.MaxLine; ++j)
			{
				// Attempt to find a node at the current line
				SyntaxNode* node = origin.LineToNode.findValue(j, nullptr);

				// If we found a node...
				if (node != nullptr)
				{
					// Append the comment to the node and move on to the next comment!
					node->Comments.push_back(comment.Token);
					break;
				}
			}
		}
	}

	//***************************************************************************
	bool Project::CompileUncheckedSyntaxTree(SyntaxTree& syntaxTreeOut, Array<UserToken>& tokensOut, EvaluationMode::Enum evaluation)
	{
		// Store all the parsed comment tokens
		Array<UserToken> comments;

		// Start by tokenizing the stream
		if (this->Tokenize(tokensOut, comments) == false)
			return false;

		// The parser parses the list of tokens into a syntax tree
		Parser parser(this->Errors);

		// Apply the parser to the token stream, which should output a syntax tree!
		parser.ParseIntoTree(tokensOut, syntaxTreeOut, evaluation);

		// Make sure to attach all the comments we parsed to
		// any nodes, so we can collect them for documentation
		this->AttachCommentsToNodes(syntaxTreeOut, comments);

		// Fix up any parent pointers
		SyntaxNode::FixParentPointers(syntaxTreeOut.Root, nullptr);

		// Return true if it succeeded, or false if there was an error in parsing
		return !this->Errors.WasError;
	}

	//***************************************************************************
	bool Project::CompileCheckedSyntaxTree
		(
		SyntaxTree& syntaxTreeOut,
		LibraryBuilder& builder,
		Array<UserToken>& tokensOut,
		const Module& dependencies,
		EvaluationMode::Enum evaluation
		)
	{
		// The syntaxer holds information about all the internal and parsed types
		// It is also responsible for checking syntax for things like scope, etc
		Syntaxer syntaxer(this->Errors);

		// Start by compiling the code into an unchecked tree
		if (this->CompileUncheckedSyntaxTree(syntaxTreeOut, tokensOut, evaluation) == false)
			return false;

		// Collect all the types, assign types where they are needed, and perform syntax checking
		syntaxer.ApplyToTree(syntaxTreeOut, builder, this->TypeParsedHandlers, dependencies);

		// Fix up any parent pointers (in case anything gets moved around)
		// This may be unnecessary... but we'd still like to do it
		SyntaxNode::FixParentPointers(syntaxTreeOut.Root, nullptr);

		// Return true if it succeeded, or false if there was a syntax error
		return !this->Errors.WasError;
	}

	//***************************************************************************
	LibraryRef Project::Compile(StringParam libraryName, const Module& dependencies, EvaluationMode::Enum evaluation)
	{
		// The syntax tree holds a more intuitive representation of the parsed program and is easy to traverse
		SyntaxTree syntaxTree;

		// We're about to generate a library so we need a builder
		LibraryBuilder builder(libraryName);

		// Let the library know what source was used to build it
		builder.SetEntries(this->Entries);

		// Store the array of tokens that we generate
		Array<UserToken> tokens;

		// Compile the code into a checked syntax tree
		if (this->CompileCheckedSyntaxTree(syntaxTree, builder, tokens, dependencies, evaluation) == false)
			return nullptr;

		// The code generator uses the syntax tree to generate opcode for each function
		CodeGenerator codeGenerator;
		LibraryRef library = codeGenerator.Generate(syntaxTree, builder);

		// Check that the library was valid
		ErrorIf(library == nullptr, "Somehow the library returned from code generation was not valid!");

		// The library should have fully compiled!
		return library;
	}

	//***************************************************************************
	void Project::GetAutoCompleteInfo(const Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, AutoCompleteInfo& resultOut)
	{
		// Always assume we're parsing an instance/expression
		// Later on if we fail, we'll try to parse a type and therefore it may be a static
		resultOut.IsStatic = false;

		// Store the array of tokens that we generate
		Array<UserToken> tokens;
		Array<UserToken> comments;
		this->Tokenize(tokens, comments);

		const size_t InvalidIndex = (size_t)-1;
		size_t closestTokenIndex = InvalidIndex;

		for (size_t i = 0; i < tokens.size(); ++i)
		{
			UserToken& token = tokens[i];

			if (token.Location.Origin == cursorOrigin)
			{
				if (token.Start >= cursorPosition)
				{
					break;
				}

				closestTokenIndex = i;
			}
		}

		// If there's a dot right where the cursor is, backup until we hit no dots or function calls
		if (closestTokenIndex != InvalidIndex)
		{
			while (closestTokenIndex != InvalidIndex)
			{
				Grammar::Enum tokenId = tokens[closestTokenIndex].TokenId;
				if (tokenId != Grammar::Access && tokenId != Grammar::BeginFunctionCall)
				{
					break;
				}

				--closestTokenIndex;
			}
		}

		// If we still have a valid cursor token
		if (closestTokenIndex == InvalidIndex)
		{
			return;
		}

		Array<UserToken> expressionTokens;

		int parenthesesCount = 0;
		int bracketsCount = 0;
		bool done = false;

		size_t end = closestTokenIndex;
		size_t i = end;
		while (i != InvalidIndex)
		{
			UserToken& token = tokens[i];

			switch (token.TokenId)
			{
			case Grammar::Access:
			case Grammar::As:
			case Grammar::New:
			case Grammar::Local:
			case Grammar::LowerIdentifier:
			case Grammar::UpperIdentifier:
			case Grammar::RealLiteral:
			case Grammar::DoubleRealLiteral:
			case Grammar::IntegerLiteral:
			case Grammar::DoubleIntegerLiteral:
			case Grammar::StringLiteral:
			case Grammar::True:
			case Grammar::False:
			case Grammar::Typeid:
				break;

			case Grammar::EndGroup: /* also EndFunctionCall */
				++parenthesesCount;
				break;

			case Grammar::BeginGroup: /* also BeginFunctionCall */
				--parenthesesCount;

				if (parenthesesCount == -1)
					done = true;
				break;

			case Grammar::EndIndex:
				++bracketsCount;
				break;

			case Grammar::BeginIndex:
				--bracketsCount;

				if (bracketsCount == -1)
					done = true;
				break;

			default:
				if (parenthesesCount == 0 && bracketsCount == 0)
				{
					done = true;
				}
				break;
			}

			if (done)
				break;

			--i;
		}

		size_t start = i + 1;

		for (size_t j = start; j <= end; ++j)
		{
			expressionTokens.push_back(tokens[j]);
		}

		if (expressionTokens.empty())
		{
			return;
		}


		Array<UserToken> functionTokens;
		Array<UserToken> classTokensWithoutFunction;
		{
			int functionStart = -1;
			int functionEnd = -1;
			for (int j = (int)closestTokenIndex; j >= 0 && functionStart == -1; --j)
			{
				UserToken& token = tokens[j];

				switch (token.TokenId)
				{
				case Grammar::Get:
				case Grammar::Set:
				case Grammar::Function:
				case Grammar::Constructor:
				case Grammar::Destructor:
					functionStart = j;
					break;
				}
			}

			if (functionStart != -1)
			{
				size_t scopeCount = 0;

				for (int j = functionStart; j < (int)tokens.size(); ++j)
				{
					UserToken& token = tokens[j];

					if (token.TokenId == Grammar::BeginScope)
					{
						++scopeCount;
					}
					else if (token.TokenId == Grammar::EndScope)
					{
						--scopeCount;

						if (scopeCount == 0)
						{
							functionEnd = j;
							break;
						}
					}
					else if (j != functionStart &&
						(token.TokenId == Grammar::Function ||
						token.TokenId == Grammar::Constructor ||
						token.TokenId == Grammar::Destructor ||
						token.TokenId == Grammar::Get ||
						token.TokenId == Grammar::Set ||
						token.TokenId == Grammar::Class ||
						token.TokenId == Grammar::Struct))
					{
						functionEnd = j - 1;
						break;
					}
				}
			}

			if (functionEnd != -1 && functionEnd > functionStart)
			{
				for (int j = functionStart; j <= functionEnd; ++j)
				{
					UserToken& token = tokens[j];
					functionTokens.push_back(token);
				}

				// Lets handle getting all the class tokens (without this function inside)
		{
			int classStart = -1;
			int classEnd = -1;

			for (int j = functionStart; j >= 0; --j)
			{
				UserToken& token = tokens[j];

				if (token.TokenId == Grammar::Class || token.TokenId == Grammar::Struct)
				{
					classStart = j;
					break;
				}
			}

			if (classStart != -1)
			{
				size_t scopeCount = 0;

				for (int j = classStart; j < (int)tokens.size(); ++j)
				{
					UserToken& token = tokens[j];

					if (token.TokenId == Grammar::BeginScope)
					{
						++scopeCount;
					}
					else if (token.TokenId == Grammar::EndScope)
					{
						--scopeCount;

						if (scopeCount == 0)
						{
							classEnd = j;
							break;
						}
					}
					else if (j != classStart && (token.TokenId == Grammar::Class || token.TokenId == Grammar::Struct))
					{
						functionEnd = j - 1;
						break;
					}
				}
			}

			if (classEnd != -1 && classEnd > classStart)
			{
				for (int j = classStart; j <= classEnd; ++j)
				{
					// If we're not within the function...
					if (j < functionStart || j > functionEnd)
					{
						UserToken& token = tokens[j];
						classTokensWithoutFunction.push_back(token);
					}
				}
			}
		}
			}
		}

		Tokenizer tokenizer(this->Errors);
		tokenizer.Finalize(expressionTokens);
		tokenizer.Finalize(functionTokens);
		tokenizer.Finalize(classTokensWithoutFunction);

		// The syntax tree holds a more intuitive representation of the parsed program and is easy to traverse
		SyntaxTree syntaxTree;

		// We're about to generate a library so we need a builder
		LibraryBuilder builder("CodeCompletion");

		// The parser parses the list of tokens into a syntax tree
		Parser parser(this->Errors);

		// Apply the parser to the token stream, which should output a syntax tree!
		parser.ParseExpressionInFunctionAndClass(expressionTokens, functionTokens, classTokensWithoutFunction, syntaxTree);

		// The syntaxer holds information about all the internal and parsed types
		// It is also responsible for checking syntax for things like scope, etc
		Syntaxer syntaxer(this->Errors);

		// We need to check if we actually parsed an expression
		if (syntaxTree.SingleExpression)
		{
			// Make sure to attach all the comments we parsed to
			// any nodes, so we can collect them for documentation
			this->AttachCommentsToNodes(syntaxTree, comments);

			// After the tree is generated, the child to parent pointers are not set so do that now
			// These can get used if anyone wants to traverse the tree upward
			SyntaxNode::FixParentPointers(syntaxTree.Root, nullptr);

			// Collect all the types, assign types where they are needed, and perform syntax checking
			syntaxer.ApplyToTree(syntaxTree, builder, this->TypeParsedHandlers, dependencies);

			// Fix up any parent pointers (in case anything gets moved around)
			// This may be unnecessary... but we'd still like to do it
			SyntaxNode::FixParentPointers(syntaxTree.Root, nullptr);

			// The result type may be null if it was unable to resolve... return whatever we found
			resultOut.NearestType = syntaxTree.SingleExpression->ResultType;

			// Create the library so it will keep references to types
			resultOut.IncompleteLibrary = builder.CreateLibrary();

			// If the value we're accessing is a value node, then it's a literal
			resultOut.IsLiteral = (TypeBinding::DynamicCast<ValueNode*>(syntaxTree.SingleExpression) != nullptr);

			// If the expression is a member access...
			MemberAccessNode* memberAccess = TypeBinding::DynamicCast<MemberAccessNode*>(syntaxTree.SingleExpression);
			if (memberAccess)
			{
				// If we resolved to an overload group... (but did not pick one yet)
				if (memberAccess->OverloadedFunctions != nullptr)
				{
					// Also let the user know what the overloads are
					resultOut.Overloads = *memberAccess->OverloadedFunctions;
				}
				// If we just resolved a single function...
				else if (memberAccess->AccessedFunction != nullptr)
				{
					// Add the single function (so that the user can get more documentation from it)
					resultOut.Overloads.push_back(memberAccess->AccessedFunction);
				}
			}
			else
			{
				// If the expression is a delegate type...
				DelegateType* delegateType = TypeBinding::DynamicCast<DelegateType*>(syntaxTree.SingleExpression->ResultType);
				if (delegateType != nullptr)
				{
					// Generate a fake function with this type
					Function& fakeFunction = resultOut.FakeDelegateFunctions.push_back();
					fakeFunction.Type = delegateType;
					fakeFunction.Name = Grammar::GetKeywordOrSymbol(Grammar::Delegate);

					// We don't really have overloads, but at least we can put the delegate in the list
					resultOut.Overloads.push_back(&fakeFunction);
				}
			}
		}
		else
		{
			// We might have been trying to access a static property/function/variable on a class
			SyntaxType* syntaxType = parser.ParseType(expressionTokens);

			// We may have parsed a syntax type, but we still need to resolve it into a real type
			if (syntaxType != nullptr)
			{
				resultOut.IsStatic = true;
				resultOut.NearestType = syntaxer.RetrieveType(syntaxType, expressionTokens.front().Location, dependencies);
			}
		}
	}
}
/**************************************************************\
* Author: Joshua Davis
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

namespace Zilch
{
	// Seeds the the random number generator
	void Random::Seed(uint seed)
	{
		this->Generator = Math::Random(seed);
	}

	// Returns the max integer value that can be returned
	int Random::GetMaxInt()
	{
		return this->Generator.cRandMax;
	}

	// Returns a random boolean value
	bool Random::Boolean()
	{
		return this->Generator.IntRangeInIn(0, 1) == 1;
	}

	// Returns a random integer in the range of [0, MaxInt]
	int Random::Integer()
	{
		return this->Generator.Next();
	}

	// Returns a random real in the range [0,1]
	float Random::Real()
	{
		return this->Generator.Float();
	}

	// Generates a unit length Real2
	Math::Vector2 Random::UnitReal2()
	{
		return this->Generator.PointOnUnitCircle();
	}

	// Randomly generates a Real2 with its length between min and max
	Math::Vector2 Random::Real2(float minLength, float maxLength)
	{
		float cubeRoot = 1.0f / 3.0f;
		float length = this->Generator.FloatRange(minLength, maxLength);
		return this->Generator.PointOnUnitCircle() * Math::Pow(length, cubeRoot);
	}

	// Generates a unit length Real3
	Math::Vector3 Random::UnitReal3()
	{
		return this->Generator.PointOnUnitSphere();
	}

	// Randomly generates a Real3 with its length between min and max
	Math::Vector3 Random::Real3(float minLength, float maxLength)
	{
		float cubeRoot = 1.0f / 3.0f;
		float length = this->Generator.FloatRange(minLength, maxLength);
		return this->Generator.PointOnUnitSphere() * Math::Pow(length, cubeRoot);
	}

	// Random unit length quaternion. This is also a unit quaternion
	Zilch::Quaternion Random::Quaternion()
	{
		return this->Generator.RotationQuaternion();
	}

	// Integer in the range [min, max)
	int Random::RangeInclusiveMax(int min, int max)
	{
		return this->Generator.IntRangeInIn(min, max);
	}

	// Integer in the range [min, max]
	int Random::RangeExclusiveMax(int min, int max)
	{
		return this->Generator.IntRangeInEx(min, max);
	}

	// Integer in the range [base - variance, base + variance]
	int Random::Variance(int base, int variance)
	{
		return this->Generator.IntVariance(base, variance);
	}

	// A random Real in the range [min,max]
	float Random::Range(float min, float max)
	{
		return this->Generator.FloatRange(min, max);
	}

	// Returns a number in the range [base - variance, base + variance]
	float Random::Variance(float base, float variance)
	{
		return this->Generator.FloatVariance(base, variance);
	}

	// Randomly rolls a number in the range [1, sides]
	uint Random::DieRoll(uint sides)
	{
		return this->Generator.DieRoll(sides);
	}

	// Takes a given probability that we get a true value
	bool Random::Probability(float probOfTrue)
	{
		return this->Generator.Float() < probOfTrue;
	}

	// Returns true if the coin flips heads
	bool Random::CoinFlip()
	{
		return this->Generator.IntRangeInIn(0, 1) == 1;
	}

	// Random rotation quaternion. This is the same as calling Quaternion()
	Zilch::Quaternion Random::Rotation()
	{
		return this->Generator.RotationQuaternion();
	}

	// Samples a bell curve with standard normal distribution in the range [0,1]
	// This is equivalent to a Gaussian distribution with standard deviation of 1
	float Random::BellCurve()
	{
		return this->Generator.BellCurve(0.5f, 0.5f, 1.0f);
	}

	// Samples a bell curve with in the range [center - range, center + range]
	// This uses a standard deviation of 1.
	float Random::BellCurve(float center, float range)
	{
		return this->Generator.BellCurve(center, range, 1.0f);
	}

	// Samples a bell curve in the range [center - range, center + range] with the
	// given standard deviation. Around 68% will lie within the 1st standard deviation
	float Random::BellCurve(float center, float range, float standardDeviation)
	{
		return this->Generator.BellCurve(center, range, standardDeviation);
	}

	ZilchDefineType(Random, Core)
	{
		ZilchBindConstructor();

		ZilchBindDestructor();

		// Change to a property later
		ZilchBindMethod(GetMaxInt);
		ZilchBindMethod(Seed);

		// Basic type randoms
		ZilchBindMethod(Boolean);
		ZilchBindMethod(Integer);
		ZilchBindMethod(Real);
		ZilchBindMethod(UnitReal2);
		ZilchBindMethod(Real2);
		ZilchBindMethod(UnitReal3);
		ZilchBindMethod(Real3);
		ZilchBindMethod(Quaternion);

		// Range/variance helpers
		ZilchBindMethod(RangeInclusiveMax);
		ZilchBindMethod(RangeExclusiveMax);
		ZilchBindMethodOverload(Variance, int, int, int);
		ZilchBindMethod(Range);
		ZilchBindMethodOverload(Variance, float, float, float);

		// Some more "user friendly" functions for designers
		ZilchBindMethod(DieRoll);
		ZilchBindMethod(Probability);
		ZilchBindMethod(CoinFlip);
		ZilchBindMethod(Rotation);

		// Bell curve (Gaussian) distribution
		ZilchBindMethodOverload(BellCurve, float);
		ZilchBindMethodOverload(BellCurve, float, float, float);
		ZilchBindMethodOverload(BellCurve, float, float, float, float);
	}
}
/*
SHA-1 in C
By Steve Reid <sreid@sea-to-sky.net>
100% Public Domain

-----------------
Modified 7/98
By James H. Brown <jbrown@burgoyne.com>
Still 100% Public Domain

Corrected a problem which generated improper hash values on 16 bit machines
Routine SHA1Update changed from
void SHA1Update(SHA1_CTX* context, unsigned char* data, unsigned int
len)
to
void SHA1Update(SHA1_CTX* context, unsigned char* data, unsigned
long len)

The 'len' parameter was declared an int which works fine on 32 bit machines.
However, on 16 bit machines an int is too small for the shifts being done
against
it.  This caused the hash function to generate incorrect values if len was
greater than 8191 (8K - 1) due to the 'len << 3' on line 3 of SHA1Update().

Since the file IO in main() reads 16K at a time, any file 8K or larger would
be guaranteed to generate the wrong hash (e.g. Test Vector #3, a million
"a"s).

I also changed the declaration of variables i & j in SHA1Update to
unsigned long from unsigned int for the same reason.

These changes should make no difference to any 32 bit implementations since
an
int and a long are the same size in those environments.

--
I also corrected a few compiler warnings generated by Borland C.
1. Added #include <process.h> for exit() prototype
2. Removed unused variable 'j' in SHA1Final
3. Changed exit(0) to return(0) at end of main.

ALL changes I made can be located by searching for comments containing 'JHB'
-----------------
Modified 8/98
By Steve Reid <sreid@sea-to-sky.net>
Still 100% public domain

1- Removed #include <process.h> and used return() instead of exit()
2- Fixed overwriting of finalcount in SHA1Final() (discovered by Chris Hall)
3- Changed email address from steve@edmweb.com to sreid@sea-to-sky.net

-----------------
Modified 4/01
By Saul Kravitz <Saul.Kravitz@celera.com>
Still 100% PD
Modified to run on Compaq Alpha hardware.

-----------------
Modified 07/2002
By Ralph Giles <giles@ghostscript.com>
Still 100% public domain
modified for use with stdint types, autoconf
code cleanup, removed attribution comments
switched SHA1Final() argument order for consistency
use SHA1_ prefix for public api
move public api to sha1.h
*/

/*
Test Vectors (from FIPS PUB 180-1)
"abc"
A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
A million repetitions of "a"
34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
*/

/* #define SHA1HANDSOFF  */

#include <stdio.h>
#include <string.h>

/* public api for steve reid's public domain SHA-1 implementation */
/* this file is in the public domain */

#ifndef __SHA1_H
#define __SHA1_H

typedef u32 uint32_t;
typedef u8 uint8_t;

#ifdef __cplusplus
extern "C" {
#endif

	typedef struct {
		uint32_t state[5];
		uint32_t count[2];
		uint8_t  buffer[64];
	} SHA1_CTX;

#define SHA1_DIGEST_SIZE 20

	void SHA1_Init(SHA1_CTX* context);
	void SHA1_Update(SHA1_CTX* context, const uint8_t* data, const size_t len);
	void SHA1_Final(SHA1_CTX* context, uint8_t digest[SHA1_DIGEST_SIZE]);

#ifdef __cplusplus
}
#endif

#endif /* __SHA1_H */

void SHA1_Transform(uint32_t state[5], const uint8_t buffer[64]);

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

/* blk0() and blk() perform the initial expand. */
/* I got the idea of expanding during the round function from SSLeay */
/* FIXME: can we do this in an endian-proof way? */
#ifdef WORDS_BIGENDIAN
#define blk0(i) block->l[i]
#else
#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
    |(rol(block->l[i],8)&0x00FF00FF))
#endif
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
    ^block->l[(i+2)&15]^block->l[i&15],1))

/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);

#ifdef VERBOSE  /* SAK */
void SHAPrintContext(SHA1_CTX *context, char *msg){
	printf("%s (%d,%d) %x %x %x %x %x\n",
		msg,
		context->count[0], context->count[1],
		context->state[0],
		context->state[1],
		context->state[2],
		context->state[3],
		context->state[4]);
}
#endif /* VERBOSE */

/* Hash a single 512-bit block. This is the core of the algorithm. */
void SHA1_Transform(uint32_t state[5], const uint8_t buffer[64])
{
	uint32_t a, b, c, d, e;
	typedef union {
		uint8_t c[64];
		uint32_t l[16];
	} CHAR64LONG16;
	CHAR64LONG16* block;

#ifdef SHA1HANDSOFF
	static uint8_t workspace[64];
	block = (CHAR64LONG16*)workspace;
	memcpy(block, buffer, 64);
#else
	block = (CHAR64LONG16*)buffer;
#endif

	/* Copy context->state[] to working vars */
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];

	/* 4 rounds of 20 operations each. Loop unrolled. */
	R0(a, b, c, d, e, 0); R0(e, a, b, c, d, 1); R0(d, e, a, b, c, 2); R0(c, d, e, a, b, 3);
	R0(b, c, d, e, a, 4); R0(a, b, c, d, e, 5); R0(e, a, b, c, d, 6); R0(d, e, a, b, c, 7);
	R0(c, d, e, a, b, 8); R0(b, c, d, e, a, 9); R0(a, b, c, d, e, 10); R0(e, a, b, c, d, 11);
	R0(d, e, a, b, c, 12); R0(c, d, e, a, b, 13); R0(b, c, d, e, a, 14); R0(a, b, c, d, e, 15);
	R1(e, a, b, c, d, 16); R1(d, e, a, b, c, 17); R1(c, d, e, a, b, 18); R1(b, c, d, e, a, 19);
	R2(a, b, c, d, e, 20); R2(e, a, b, c, d, 21); R2(d, e, a, b, c, 22); R2(c, d, e, a, b, 23);
	R2(b, c, d, e, a, 24); R2(a, b, c, d, e, 25); R2(e, a, b, c, d, 26); R2(d, e, a, b, c, 27);
	R2(c, d, e, a, b, 28); R2(b, c, d, e, a, 29); R2(a, b, c, d, e, 30); R2(e, a, b, c, d, 31);
	R2(d, e, a, b, c, 32); R2(c, d, e, a, b, 33); R2(b, c, d, e, a, 34); R2(a, b, c, d, e, 35);
	R2(e, a, b, c, d, 36); R2(d, e, a, b, c, 37); R2(c, d, e, a, b, 38); R2(b, c, d, e, a, 39);
	R3(a, b, c, d, e, 40); R3(e, a, b, c, d, 41); R3(d, e, a, b, c, 42); R3(c, d, e, a, b, 43);
	R3(b, c, d, e, a, 44); R3(a, b, c, d, e, 45); R3(e, a, b, c, d, 46); R3(d, e, a, b, c, 47);
	R3(c, d, e, a, b, 48); R3(b, c, d, e, a, 49); R3(a, b, c, d, e, 50); R3(e, a, b, c, d, 51);
	R3(d, e, a, b, c, 52); R3(c, d, e, a, b, 53); R3(b, c, d, e, a, 54); R3(a, b, c, d, e, 55);
	R3(e, a, b, c, d, 56); R3(d, e, a, b, c, 57); R3(c, d, e, a, b, 58); R3(b, c, d, e, a, 59);
	R4(a, b, c, d, e, 60); R4(e, a, b, c, d, 61); R4(d, e, a, b, c, 62); R4(c, d, e, a, b, 63);
	R4(b, c, d, e, a, 64); R4(a, b, c, d, e, 65); R4(e, a, b, c, d, 66); R4(d, e, a, b, c, 67);
	R4(c, d, e, a, b, 68); R4(b, c, d, e, a, 69); R4(a, b, c, d, e, 70); R4(e, a, b, c, d, 71);
	R4(d, e, a, b, c, 72); R4(c, d, e, a, b, 73); R4(b, c, d, e, a, 74); R4(a, b, c, d, e, 75);
	R4(e, a, b, c, d, 76); R4(d, e, a, b, c, 77); R4(c, d, e, a, b, 78); R4(b, c, d, e, a, 79);

	/* Add the working vars back into context.state[] */
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;

	/* Wipe variables */
	a = b = c = d = e = 0;
}

/* SHA1Init - Initialize new context */
void SHA1_Init(SHA1_CTX* context)
{
	/* SHA1 initialization constants */
	context->state[0] = 0x67452301;
	context->state[1] = 0xEFCDAB89;
	context->state[2] = 0x98BADCFE;
	context->state[3] = 0x10325476;
	context->state[4] = 0xC3D2E1F0;
	context->count[0] = context->count[1] = 0;
}

/* Run your data through this. */
void SHA1_Update(SHA1_CTX* context, const uint8_t* data, const size_t len)
{
	size_t i, j;

#ifdef VERBOSE
	SHAPrintContext(context, "before");
#endif

	j = (context->count[0] >> 3) & 63;
	if ((context->count[0] += (uint32_t)(len << 3)) < (len << 3)) context->count[1]++;
	context->count[1] += (uint32_t)(len >> 29);
	if ((j + len) > 63) {
		memcpy(&context->buffer[j], data, (i = 64 - j));
		SHA1_Transform(context->state, context->buffer);
		for (; i + 63 < len; i += 64) {
			SHA1_Transform(context->state, data + i);
		}
		j = 0;
	}
	else i = 0;
	memcpy(&context->buffer[j], &data[i], len - i);

#ifdef VERBOSE
	SHAPrintContext(context, "after ");
#endif
}

/* Add padding and return the message digest. */
void SHA1_Final(SHA1_CTX* context, uint8_t digest[SHA1_DIGEST_SIZE])
{
	uint32_t i;
	uint8_t  finalcount[8];

	for (i = 0; i < 8; i++) {
		finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
			>> ((3 - (i & 3)) * 8)) & 255);  /* Endian independent */
	}
	SHA1_Update(context, (uint8_t *)"\200", 1);
	while ((context->count[0] & 504) != 448) {
		SHA1_Update(context, (uint8_t *)"\0", 1);
	}
	SHA1_Update(context, finalcount, 8);  /* Should cause a SHA1_Transform() */
	for (i = 0; i < SHA1_DIGEST_SIZE; i++) {
		digest[i] = (uint8_t)
			((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
	}

	/* Wipe variables */
	i = 0;
	memset(context->buffer, 0, 64);
	memset(context->state, 0, 20);
	memset(context->count, 0, 8);
	memset(finalcount, 0, 8);	/* SWR */

#ifdef SHA1HANDSOFF  /* make SHA1Transform overwrite its own static vars */
	SHA1_Transform(context->state, context->buffer);
#endif
}

/*************************************************************/

#if 0
int main(int argc, char** argv)
{
	int i, j;
	SHA1_CTX context;
	unsigned char digest[SHA1_DIGEST_SIZE], buffer[16384];
	FILE* file;

	if (argc > 2) {
		puts("Public domain SHA-1 implementation - by Steve Reid <sreid@sea-to-sky.net>");
		puts("Modified for 16 bit environments 7/98 - by James H. Brown <jbrown@burgoyne.com>");	/* JHB */
		puts("Produces the SHA-1 hash of a file, or stdin if no file is specified.");
		return(0);
	}
	if (argc < 2) {
		file = stdin;
	}
	else {
		if (!(file = fopen(argv[1], "rb"))) {
			fputs("Unable to open file.", stderr);
			return(-1);
		}
	}
	SHA1_Init(&context);
	while (!feof(file)) {  /* note: what if ferror(file) */
		i = fread(buffer, 1, 16384, file);
		SHA1_Update(&context, buffer, i);
	}
	SHA1_Final(&context, digest);
	fclose(file);
	for (i = 0; i < SHA1_DIGEST_SIZE / 4; i++) {
		for (j = 0; j < 4; j++) {
			printf("%02X", digest[i * 4 + j]);
		}
		putchar(' ');
	}
	putchar('\n');
	return(0);	/* JHB */
}
#endif

/* self test */

#ifdef TEST

static char *test_data[] = {
	"abc",
	"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
	"A million repetitions of 'a'" };
static char *test_results[] = {
	"A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D",
	"84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1",
	"34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F" };

void digest_to_hex(const uint8_t digest[SHA1_DIGEST_SIZE], char *output)
{
	int i, j;
	char *c = output;

	for (i = 0; i < SHA1_DIGEST_SIZE / 4; i++) {
		for (j = 0; j < 4; j++) {
			sprintf(c, "%02X", digest[i * 4 + j]);
			c += 2;
		}
		sprintf(c, " ");
		c += 1;
	}
	*(c - 1) = '\0';
}

int main(int argc, char** argv)
{
	int k;
	SHA1_CTX context;
	uint8_t digest[20];
	char output[80];

	fprintf(stdout, "verifying SHA-1 implementation... ");

	for (k = 0; k < 2; k++){
		SHA1_Init(&context);
		SHA1_Update(&context, (uint8_t*)test_data[k], strlen(test_data[k]));
		SHA1_Final(&context, digest);
		digest_to_hex(digest, output);

		if (strcmp(output, test_results[k])) {
			fprintf(stdout, "FAIL\n");
			fprintf(stderr, "* hash of \"%s\" incorrect:\n", test_data[k]);
			fprintf(stderr, "\t%s returned\n", output);
			fprintf(stderr, "\t%s is correct\n", test_results[k]);
			return (1);
		}
	}
	/* million 'a' vector we feed separately */
	SHA1_Init(&context);
	for (k = 0; k < 1000000; k++)
		SHA1_Update(&context, (uint8_t*)"a", 1);
	SHA1_Final(&context, digest);
	digest_to_hex(digest, output);
	if (strcmp(output, test_results[2])) {
		fprintf(stdout, "FAIL\n");
		fprintf(stderr, "* hash of \"%s\" incorrect:\n", test_data[2]);
		fprintf(stderr, "\t%s returned\n", output);
		fprintf(stderr, "\t%s is correct\n", test_results[2]);
		return (1);
	}

	/* success */
	fprintf(stdout, "ok\n");
	return(0);
}
#endif /* TEST */
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	// Operator Precedence:
	// Left to right:
	//  0. As
	//     BeginFunctionCall & EndFunctionCall
	//     BeginIndex & EndIndex
	//     Access
	// Right to left:
	//  1. Positive
	//     Negative
	//     Increment
	//     Decrement
	//     LogicalNot
	//     BitwiseNot
	//     PropertyDelegate
	// Left to right:
	//  2. Exponent
	//  3. Multiply
	//     Divide
	//     Modulo
	//  4. Add
	//     Subtract
	//  5. BitshiftLeft
	//     BitshiftRight
	//  6. LessThan
	//     LessThanOrEqualTo
	//     GreaterThan
	//     GreaterThanOrEqualTo
	//  7. Equality
	//     Inequality
	//  8. BitwiseAnd
	//  9. BitwiseXor
	// 10. BitwiseOr
	// 11. LogicalAnd
	// 12. LogicalOr
	// Right to left:
	// 13. Assignment
	//     AssignmentAdd
	//     AssignmentSubtract
	//     AssignmentMultiply
	//     AssignmentDivide
	//     AssignmentModulo
	//     AssignmentExponent
	//     AssignmentLeftShift
	//     AssignmentRightShift
	//     AssignmentBitwiseAnd
	//     AssignmentBitwiseXor
	//     AssignmentBitwiseOr

	//***************************************************************************
	BinaryOperator::BinaryOperator() :
		IsValid(false),
		Lhs(nullptr),
		Rhs(nullptr),
		Result(nullptr),
		Operator(Grammar::Invalid),
		Instruction(Instruction::InvalidInstruction),
		FlipArguments(false),
		Io(IoMode::NotSet),
		CastLhsTo(nullptr),
		CastRhsTo(nullptr)
	{
	}

	//***************************************************************************
	size_t BinaryOperator::Hash() const
	{
		// Start off with a cleared out hash
		size_t result = 0;

		// Hash both the left and right (add a random prime because they could be the same)
		result ^= (size_t)(this->Lhs->Hash());
		result ^= (size_t)(this->Rhs->Hash() * 1276478784635841471);

		// Now hash the operator and include that 
		result ^= (size_t)(this->Operator * 5463458053);

		// Return the resulting hash
		return result;
	}

	//***************************************************************************
	bool BinaryOperator::operator==(const BinaryOperator& rhs) const
	{
		// Compare the operators
		if (this->Operator != rhs.Operator)
			return false;

		// Compare the left and right operands
		return (this->Lhs == rhs.Lhs) && (this->Rhs == rhs.Rhs);
	}

	//***************************************************************************
	UnaryOperator::UnaryOperator() :
		IsValid(false),
		Operand(nullptr),
		Result(nullptr),
		Operator(Grammar::Invalid),
		Instruction(Instruction::InvalidInstruction),
		Io(IoMode::NotSet)
	{
	}

	//***************************************************************************
	size_t UnaryOperator::Hash() const
	{
		// Start off with a cleared out hash
		size_t result = 0;

		// Hash the operand and add that to the result
		result ^= (size_t)this->Operand->Hash();

		// Now hash the operator and include that 
		result ^= (size_t)(this->Operator * 5463458053);

		// Return the resulting hash
		return result;
	}

	//***************************************************************************
	bool UnaryOperator::operator==(const UnaryOperator& rhs) const
	{
		// Compare the operators
		if (this->Operator != rhs.Operator)
			return false;

		// Compare the operands
		return this->Operand == rhs.Operand;
	}

	//***************************************************************************
	UntypedOperator::UntypedOperator() :
		IsValid(false),
		Operator(Grammar::Invalid),
		Precedence(0),
		Associativity(OperatorAssociativity::LeftToRight)
	{
	}

	//***************************************************************************
	CastOperator::CastOperator() :
		IsValid(false),
		From(nullptr),
		To(nullptr),
		Operation(CastOperation::Invalid),
		PrimitiveInstruction(Instruction::InvalidInstruction),
		CanBeImplicit(false),
		RequiresCodeGeneration(false)
	{
	}

	//***************************************************************************
	size_t CastOperator::Hash() const
	{
		return (size_t)(this->From->Hash() ^ this->To->Hash() * 33679033);
	}

	//***************************************************************************
	bool CastOperator::operator==(const CastOperator& rhs) const
	{
		return this->From == rhs.From && this->To == rhs.To;
	}

	//***************************************************************************
	Shared::Shared()
	{
		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Reserve room for operators
		this->PrecedenceToOperators.reserve(32);

		// Add all generic information about operator precedence and associativity
		size_t precedence = 1;
		OperatorAssociativity::Enum associativity = OperatorAssociativity::LeftToRight;
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::BeginFunctionCall);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::EndFunctionCall);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::BeginIndex);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::EndIndex);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Access);
		precedence = 2;
		associativity = OperatorAssociativity::RightToLeft;
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Positive);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Negative);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Increment);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::Decrement);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::LogicalNot);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::BitwiseNot);
		this->AddPrecedence(precedence, associativity, OperatorArity::Unary, Grammar::PropertyDelegate);
		precedence = 3;
		associativity = OperatorAssociativity::LeftToRight;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Exponent);
		precedence = 4;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Multiply);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Divide);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Modulo);
		precedence = 5;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Add);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Subtract);
		precedence = 6;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitshiftLeft);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitshiftRight);
		precedence = 7;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LessThan);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LessThanOrEqualTo);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::GreaterThan);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::GreaterThanOrEqualTo);
		precedence = 8;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Equality);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Inequality);
		precedence = 9;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitwiseAnd);
		precedence = 10;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitwiseXor);
		precedence = 11;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::BitwiseOr);
		precedence = 12;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LogicalAnd);
		precedence = 13;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::LogicalOr);
		precedence = 14;
		associativity = OperatorAssociativity::RightToLeft;
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::Assignment);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentAdd);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentSubtract);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentMultiply);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentDivide);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentModulo);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentExponent);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentLeftShift);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentRightShift);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentBitwiseAnd);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentBitwiseXor);
		this->AddPrecedence(precedence, associativity, OperatorArity::Binary, Grammar::AssignmentBitwiseOr);

		// HandleAssignment
		{
			BinaryOperator& info = this->HandleAssignment;
			info.Result = core.VoidType;
			info.Operator = Grammar::Assignment;
			info.Instruction = Instruction::CopyHandle;
			info.Io = IoMode::WriteLValue;
			info.IsValid = true;
		}
		// HandleEquality
	{
		BinaryOperator& info = this->HandleEquality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Equality;
		info.Instruction = Instruction::TestEqualityHandle;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}
	// HandleInequality
	{
		BinaryOperator& info = this->HandleInequality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Inequality;
		info.Instruction = Instruction::TestInequalityHandle;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}
	// DelegateAssignment
	{
		BinaryOperator& info = this->DelegateAssignment;
		info.Result = core.VoidType;
		info.Operator = Grammar::Assignment;
		info.Instruction = Instruction::CopyDelegate;
		info.Io = IoMode::WriteLValue;
		info.IsValid = true;
	}
	// DelegateEquality
	{
		BinaryOperator& info = this->DelegateEquality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Equality;
		info.Instruction = Instruction::TestEqualityDelegate;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}
	// DelegateInequality
	{
		BinaryOperator& info = this->DelegateInequality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Inequality;
		info.Instruction = Instruction::TestInequalityDelegate;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}
	// AnyAssignment
	{
		BinaryOperator& info = this->AnyAssignment;
		info.Result = core.VoidType;
		info.Operator = Grammar::Assignment;
		info.Instruction = Instruction::CopyAny;
		info.Io = IoMode::WriteLValue;
		info.IsValid = true;
	}
	// AnyEquality
	{
		BinaryOperator& info = this->AnyEquality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Equality;
		info.Instruction = Instruction::TestEqualityAny;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}
	// AnyInequality
	{
		BinaryOperator& info = this->AnyInequality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Inequality;
		info.Instruction = Instruction::TestInequalityAny;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}
	// ValueAssignment
	{
		BinaryOperator& info = this->ValueAssignment;
		info.Result = core.VoidType;
		info.Operator = Grammar::Assignment;
		info.Instruction = Instruction::CopyValue;
		info.Io = IoMode::WriteLValue;
		info.IsValid = true;
	}
	// ValueEquality
	{
		BinaryOperator& info = this->ValueEquality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Equality;
		info.Instruction = Instruction::TestEqualityValue;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}
	// ValueInequality
	{
		BinaryOperator& info = this->ValueInequality;
		info.Result = core.BooleanType;
		info.Operator = Grammar::Inequality;
		info.Instruction = Instruction::TestInequalityValue;
		info.Io = IoMode::ReadRValue;
		info.IsValid = true;
	}

	// RawImplicitCast, (same-cast, up-cast, null-cast, any-delegate-cast)
	{
		CastOperator& info = this->RawImplicitCast;
		info.Operation = CastOperation::Raw;
		info.CanBeImplicit = true;
		info.RequiresCodeGeneration = false;
		info.IsValid = true;
	}
	// DynamicDownCast
	{
		CastOperator& info = this->DynamicDownCast;
		info.Operation = CastOperation::DynamicDown;
		info.CanBeImplicit = false;
		info.RequiresCodeGeneration = true;
		info.IsValid = true;
	}
	// ToAnyCast
	{
		CastOperator& info = this->ToAnyCast;
		info.Operation = CastOperation::ToAny;
		info.CanBeImplicit = true;
		info.RequiresCodeGeneration = true;
		info.IsValid = true;
	}
	// FromAnyCast
	{
		CastOperator& info = this->FromAnyCast;
		info.Operation = CastOperation::FromAny;
		info.CanBeImplicit = true;
		info.RequiresCodeGeneration = true;
		info.IsValid = true;
	}
	// EnumIntegerCast
	{
		CastOperator& info = this->EnumIntegerCast;
		info.Operation = CastOperation::Raw;
		info.CanBeImplicit = true;
		info.RequiresCodeGeneration = false;
		info.IsValid = true;
	}
	// IntegerEnumCast
	{
		CastOperator& info = this->IntegerEnumCast;
		info.Operation = CastOperation::Raw;
		info.CanBeImplicit = false;
		info.RequiresCodeGeneration = false;
		info.IsValid = true;
	}
	// NullToDelegate
	{
		CastOperator& info = this->NullToDelegate;
		info.Operation = CastOperation::NullToDelegate;
		info.CanBeImplicit = true;
		info.RequiresCodeGeneration = false;
		info.IsValid = true;
		//this->CastOperatorsFrom[core.NullType].push_back(info);
	}

	// Handle our built in primitive casts
	// The 1-dimensional cases
	this->AddPrimitiveCast(core.IntegerType, core.RealType, Instruction::ConvertIntegerToReal, true);
	this->AddPrimitiveCast(core.IntegerType, core.BooleanType, Instruction::ConvertIntegerToBoolean, false);
	this->AddPrimitiveCast(core.RealType, core.IntegerType, Instruction::ConvertRealToInteger, false);
	this->AddPrimitiveCast(core.RealType, core.BooleanType, Instruction::ConvertRealToBoolean, false);
	this->AddPrimitiveCast(core.BooleanType, core.IntegerType, Instruction::ConvertBooleanToInteger, false);
	this->AddPrimitiveCast(core.BooleanType, core.RealType, Instruction::ConvertBooleanToReal, false);

	// The 2-dimensional cases
	this->AddPrimitiveCast(core.Integer2Type, core.Real2Type, Instruction::ConvertInteger2ToReal2, true);
	this->AddPrimitiveCast(core.Integer2Type, core.Boolean2Type, Instruction::ConvertInteger2ToBoolean2, false);
	this->AddPrimitiveCast(core.Real2Type, core.Integer2Type, Instruction::ConvertReal2ToInteger2, false);
	this->AddPrimitiveCast(core.Real2Type, core.Boolean2Type, Instruction::ConvertReal2ToBoolean2, false);
	this->AddPrimitiveCast(core.Boolean2Type, core.Integer2Type, Instruction::ConvertBoolean2ToInteger2, false);
	this->AddPrimitiveCast(core.Boolean2Type, core.Real2Type, Instruction::ConvertBoolean2ToReal2, false);

	// The 3-dimensional cases
	this->AddPrimitiveCast(core.Integer3Type, core.Real3Type, Instruction::ConvertInteger3ToReal3, true);
	this->AddPrimitiveCast(core.Integer3Type, core.Boolean3Type, Instruction::ConvertInteger3ToBoolean3, false);
	this->AddPrimitiveCast(core.Real3Type, core.Integer3Type, Instruction::ConvertReal3ToInteger3, false);
	this->AddPrimitiveCast(core.Real3Type, core.Boolean3Type, Instruction::ConvertReal3ToBoolean3, false);
	this->AddPrimitiveCast(core.Boolean3Type, core.Integer3Type, Instruction::ConvertBoolean3ToInteger3, false);
	this->AddPrimitiveCast(core.Boolean3Type, core.Real3Type, Instruction::ConvertBoolean3ToReal3, false);

	// The 4-dimensional cases
	this->AddPrimitiveCast(core.Integer4Type, core.Real4Type, Instruction::ConvertInteger4ToReal4, true);
	this->AddPrimitiveCast(core.Integer4Type, core.Boolean4Type, Instruction::ConvertInteger4ToBoolean4, false);
	this->AddPrimitiveCast(core.Real4Type, core.Integer4Type, Instruction::ConvertReal4ToInteger4, false);
	this->AddPrimitiveCast(core.Real4Type, core.Boolean4Type, Instruction::ConvertReal4ToBoolean4, false);
	this->AddPrimitiveCast(core.Boolean4Type, core.Integer4Type, Instruction::ConvertBoolean4ToInteger4, false);
	this->AddPrimitiveCast(core.Boolean4Type, core.Real4Type, Instruction::ConvertBoolean4ToReal4, false);

	// Note: These macros mirror those inside of InstructionEnum and VirtualMachine (for generation of instructions)

	// Copy
#define ZilchCopyOperators(WithType)                                                                                                                                                                                \
	      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddBinary(type, core.VoidType, Grammar::Assignment, Instruction::Copy##WithType, IoMode::WriteLValue);                                                                                                    \
	      }

	// Equality and inequality
#define ZilchEqualityOperators(WithType)                                                                                                                                                                            \
	      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddBinary(type, core.BooleanType, Grammar::Inequality, Instruction::TestInequality##WithType, IoMode::ReadRValue);                                                                                        \
        this->AddBinary(type, core.BooleanType, Grammar::Equality, Instruction::TestEquality##WithType, IoMode::ReadRValue);                                                                                            \
	      }

	// Less and greater comparison
#define ZilchComparisonOperators(WithType, ResultType)                                                                                                                                                              \
	      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddBinary(type, core.ResultType##Type, Grammar::LessThan, Instruction::TestLessThan##WithType, IoMode::ReadRValue);                                                                                       \
        this->AddBinary(type, core.ResultType##Type, Grammar::LessThanOrEqualTo, Instruction::TestLessThanOrEqualTo##WithType, IoMode::ReadRValue);                                                                     \
        this->AddBinary(type, core.ResultType##Type, Grammar::GreaterThan, Instruction::TestGreaterThan##WithType, IoMode::ReadRValue);                                                                                 \
        this->AddBinary(type, core.ResultType##Type, Grammar::GreaterThanOrEqualTo, Instruction::TestGreaterThanOrEqualTo##WithType, IoMode::ReadRValue);                                                               \
	      }

	// Generic numeric operators, copy, equality
#define ZilchNumericOperators(WithType)                                                                                                                                                                             \
      ZilchCopyOperators(WithType)                                                                                                                                                                                      \
      ZilchEqualityOperators(WithType)                                                                                                                                                                                  \
	      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddUnary(type, type, Grammar::Positive, Instruction::InvalidInstruction, IoMode::ReadRValue);                                                                                                             \
        this->AddUnary(type, type, Grammar::Negative, Instruction::Negate##WithType, IoMode::ReadRValue);                                                                                                               \
        this->AddUnary(type, core.VoidType, Grammar::Increment, Instruction::Increment##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                                            \
        this->AddUnary(type, core.VoidType, Grammar::Decrement, Instruction::Decrement##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                                            \
        this->AddBinary(type, type, Grammar::Add, Instruction::Add##WithType, IoMode::ReadRValue);                                                                                                                      \
        this->AddBinary(type, type, Grammar::Subtract, Instruction::Subtract##WithType, IoMode::ReadRValue);                                                                                                            \
        this->AddBinary(type, type, Grammar::Multiply, Instruction::Multiply##WithType, IoMode::ReadRValue);                                                                                                            \
        this->AddBinary(type, type, Grammar::Divide, Instruction::Divide##WithType, IoMode::ReadRValue);                                                                                                                \
        this->AddBinary(type, type, Grammar::Modulo, Instruction::Modulo##WithType, IoMode::ReadRValue);                                                                                                                \
        this->AddBinary(type, type, Grammar::Exponent, Instruction::Pow##WithType, IoMode::ReadRValue);                                                                                                                 \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentAdd, Instruction::AssignmentAdd##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                                   \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentSubtract, Instruction::AssignmentSubtract##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                         \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentMultiply, Instruction::AssignmentMultiply##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                         \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentDivide, Instruction::AssignmentDivide##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                             \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentModulo, Instruction::AssignmentModulo##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                             \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentExponent, Instruction::AssignmentPow##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                              \
	      }

	// Generic numeric operators, copy, equality, comparison
#define ZilchScalarOperators(WithType)                                                                                                                                                                              \
      ZilchNumericOperators(WithType)                                                                                                                                                                                   \
      ZilchComparisonOperators(WithType, Boolean)

	// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorOperators(VectorType, ScalarType, ComparisonType)                                                                                                                                                \
      ZilchNumericOperators(VectorType)                                                                                                                                                                                 \
      ZilchComparisonOperators(VectorType, ComparisonType)                                                                                                                                                              \
	      {                                                                                                                                                                                                                 \
        BoundType* vectorType = core.VectorType##Type;                                                                                                                                                                  \
        BoundType* scalarType = core.ScalarType##Type;                                                                                                                                                                  \
        this->AddBinaryCommunative(vectorType, scalarType, vectorType, Grammar::Multiply, Instruction::ScalarMultiply##VectorType, IoMode::ReadRValue);                                                                 \
        this->AddBinaryNonCommunative(vectorType, scalarType, vectorType, Grammar::Divide, Instruction::ScalarDivide##VectorType, IoMode::ReadRValue);                                                                  \
        this->AddBinaryNonCommunative(vectorType, scalarType, vectorType, Grammar::Modulo, Instruction::ScalarModulo##VectorType, IoMode::ReadRValue);                                                                  \
        this->AddBinaryNonCommunative(vectorType, scalarType, vectorType, Grammar::Exponent, Instruction::ScalarPow##VectorType, IoMode::ReadRValue);                                                                   \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentMultiply, Instruction::AssignmentScalarMultiply##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue)); \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentDivide, Instruction::AssignmentScalarDivide##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));     \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentModulo, Instruction::AssignmentScalarModulo##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));     \
        this->AddBinaryNonCommunative(vectorType, scalarType, core.VoidType, Grammar::AssignmentExponent, Instruction::AssignmentScalarPow##VectorType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));      \
	      }

	// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralOperators(WithType)                                                                                                                                                                            \
	      {                                                                                                                                                                                                                 \
        BoundType* type =  core.WithType##Type;                                                                                                                                                                         \
        this->AddUnary(type, type, Grammar::BitwiseNot, Instruction::BitwiseNot##WithType, IoMode::ReadRValue);                                                                                                         \
        this->AddBinary(type, type, Grammar::BitshiftLeft, Instruction::BitshiftLeft##WithType, IoMode::ReadRValue);                                                                                                    \
        this->AddBinary(type, type, Grammar::BitshiftRight, Instruction::BitshiftRight##WithType, IoMode::ReadRValue);                                                                                                  \
        this->AddBinary(type, type, Grammar::BitwiseOr, Instruction::BitwiseOr##WithType, IoMode::ReadRValue);                                                                                                          \
        this->AddBinary(type, type, Grammar::BitwiseXor, Instruction::BitwiseXor##WithType, IoMode::ReadRValue);                                                                                                        \
        this->AddBinary(type, type, Grammar::BitwiseAnd, Instruction::BitwiseAnd##WithType, IoMode::ReadRValue);                                                                                                        \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentLeftShift, Instruction::AssignmentBitshiftLeft##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                    \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentRightShift, Instruction::AssignmentBitshiftRight##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                  \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentBitwiseOr, Instruction::AssignmentBitwiseOr##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                       \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentBitwiseXor, Instruction::AssignmentBitwiseXor##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                     \
        this->AddBinary(type, core.VoidType, Grammar::AssignmentBitwiseAnd, Instruction::AssignmentBitwiseAnd##WithType, (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue));                                     \
	      }

	ZilchIntegralOperators(Integer);
	ZilchScalarOperators(Integer);
	ZilchVectorOperators(Integer2, Integer, Boolean2);
	ZilchVectorOperators(Integer3, Integer, Boolean3);
	ZilchVectorOperators(Integer4, Integer, Boolean4);
	ZilchIntegralOperators(Integer2);
	ZilchIntegralOperators(Integer3);
	ZilchIntegralOperators(Integer4);
	ZilchScalarOperators(Real);
	ZilchVectorOperators(Real2, Real, Boolean2);
	ZilchVectorOperators(Real3, Real, Boolean3);
	ZilchVectorOperators(Real4, Real, Boolean4);
	ZilchScalarOperators(DoubleReal);
	ZilchIntegralOperators(DoubleInteger);
	ZilchScalarOperators(DoubleInteger);

	ZilchEqualityOperators(Boolean);
	// Handle, Delegate, and Value equality operators are handled specially above

	ZilchCopyOperators(Boolean);
	// Handle, Delegate, and Value copy (assignment) operators are handled specially above

	// Boolean operators
	this->AddUnary(core.BooleanType, core.BooleanType, Grammar::LogicalNot, Instruction::LogicalNotBoolean, IoMode::ReadRValue);

	// Note: These operators have instructions marked as invalid because short circuit is handled specially
	// There is not actually an opcode/instruction that performs logical or/and
	this->AddBinary(core.BooleanType, core.BooleanType, Grammar::LogicalAnd, Instruction::InvalidInstruction, IoMode::ReadRValue);
	this->AddBinary(core.BooleanType, core.BooleanType, Grammar::LogicalOr, Instruction::InvalidInstruction, IoMode::ReadRValue);
	}

	//***************************************************************************
	void Shared::AddBinary(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io, bool flip)
	{
		// Generate the operator information
		BinaryOperator info;
		info.Lhs = lhs;
		info.Rhs = rhs;
		info.Result = result;
		info.Operator = oper;
		info.Instruction = instruction;
		info.Io = io;
		info.FlipArguments = flip;
		info.IsValid = true;

		// Insert it into the set
		this->BinaryOperators.insertOrError(info, "Two unary operators inserted with the same types and operator");
	}

	//***************************************************************************
	void Shared::AddBinaryCommunative(Type* type1, Type* type2, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
	{
		// The arguments only need flipping if they're not of the same type
		bool needsFlip = !Type::IsSame(type1, type2);

		// Since the order they added it was type1, type2, then it needs no flip
		this->AddBinary(type1, type2, result, oper, instruction, io, false);

		// When we reverse the types, a flip could be necessary for the opcode
		this->AddBinary(type2, type1, result, oper, instruction, io, needsFlip);
	}

	//***************************************************************************
	void Shared::AddBinaryNonCommunative(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
	{
		// Since the order they added it was type1, type2, then it needs no flip
		this->AddBinary(lhs, rhs, result, oper, instruction, io, false);
	}

	//***************************************************************************
	void Shared::AddBinary(Type* sameType, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
	{
		this->AddBinary(sameType, sameType, result, oper, instruction, io, false);
	}

	//***************************************************************************
	void Shared::AddUnary(Type* operand, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io)
	{
		// Generate the operator information
		UnaryOperator info;
		info.Operand = operand;
		info.Result = result;
		info.Operator = oper;
		info.Instruction = instruction;
		info.Io = io;
		info.IsValid = true;

		// Insert it into the set
		this->UnaryOperators.insertOrError(info, "Two binary operators inserted with the same types and operator");
	}

	//***************************************************************************
	void Shared::AddPrimitiveCast(Type* fromType, Type* toType, Instruction::Enum instruction, bool canBeImplicit)
	{
		CastOperator info;
		info.From = fromType;
		info.To = toType;
		info.Operation = CastOperation::Primitive;
		info.PrimitiveInstruction = instruction;
		info.CanBeImplicit = canBeImplicit;
		info.IsValid = true;

		// All primitive operations require code generation (an instruction)
		info.RequiresCodeGeneration = true;

		// Insert it into the set
		this->CastOperators.insertOrError(info, "Two cast operators inserted with the same from/to types");
		this->PrimitiveCastOperatorsFrom[fromType].push_back(info);
	}

	//***************************************************************************
	void Shared::AddPrecedence(size_t precedence, OperatorAssociativity::Enum associativity, OperatorArity::Enum arity, Grammar::Enum oper)
	{
		// Create a structure that describes everything we need to know generically about the operator
		UntypedOperator info;
		info.Associativity = associativity;
		info.Operator = oper;
		info.Precedence = precedence;
		info.Arity = arity;
		info.IsValid = true;

		// It turns out since sometimes we use the same symbol for an operator,
		// but in some cases it can be unary or binary, then we need to key off the 'arity'
		OperatorWithArity key;
		key.Operator = oper;
		key.Arity = arity;

		// Map the operator to its precedence level, which is useful for code formatters
		this->OperatorToPrecedence.insertOrError(key, info,
			"The operator was inserted twice");

		// Map the precedence level to any operators on that level, which is useful for documentation
		if (precedence >= this->PrecedenceToOperators.size())
		{
			// Make sure we can store the precedence up to this level
			this->PrecedenceToOperators.resize(precedence + 1);
		}

		// Get all the operators at the given precedence level (or create an empty array)
		Array<UntypedOperator>& operators = this->PrecedenceToOperators[precedence];

		// Add the operator to the precedence list, and we're done!
		operators.push_back(info);
	}

	//***************************************************************************
	bool Shared::OperatorWithArity::operator==(const OperatorWithArity& rhs) const
	{
		return this->Operator == rhs.Operator && this->Arity == rhs.Arity;
	}

	//***************************************************************************
	size_t Shared::OperatorWithArity::Hash() const
	{
		return (((size_t)this->Operator) * 234059) ^ (this->Arity * 98361);
	}

	//***************************************************************************
	Shared& Shared::GetInstance()
	{
		// Singleton pattern
		static Shared instance;
		return instance;
	}

	//***************************************************************************
	BinaryOperator Shared::GetBinaryOperator(Type* lhs, Type* rhs, Grammar::Enum oper, bool allowRecursiveLookup)
	{
		// First attempt to find the operator in the specialized place
		// This MUST be first, otherwise value assignment for primitives will be a slower memcpy
		BinaryOperator finder;
		finder.Lhs = lhs;
		finder.Rhs = rhs;
		finder.Operator = oper;

		// Look for the operator in the pre-defined operator set
		BinaryOperator* result = this->BinaryOperators.findPointer(finder);
		if (result != nullptr)
		{
			// We found it, so return it!
			return *result;
		}

		// Make sure at least one is an enum
		Type* integerType = ZilchTypeId(Integer);
		bool lhsIsEnum = Type::IsEnumOrFlagsType(lhs);
		bool rhsIsEnum = Type::IsEnumOrFlagsType(rhs);
		if (lhsIsEnum || rhsIsEnum)
		{
			// Check to see if the operation is between an enum and an integer
			// We assign to the left, meaning the type we're converting to would be on the left
			bool isEnumToInteger = Type::IsSame(lhs, integerType);
			bool isIntegerToEnum = Type::IsSame(rhs, integerType);

			// Check to see if the operation is between the enum and another enum of the same kind
			bool isSameEnumWithEnum = lhsIsEnum && rhsIsEnum && Type::IsSame(lhs, rhs);

			// Don't allow assignments with integer to enum (otheriwse if it's between enum/enum or enum to integer, let it through)
			if (isSameEnumWithEnum || isEnumToInteger || (isIntegerToEnum && oper != Grammar::Assignment))
			{
				// Treat both as integers, and see if the operation would have been valid
				BinaryOperator integerOperator = this->GetBinaryOperator(integerType, integerType, oper);

				// If the operator is valid
				if (integerOperator.IsValid)
				{
					// Modify the operator slightly to make the inputs the same, and also make the result the enum type
					if (Type::IsSame(integerOperator.Result, integerType))
					{
						// Set the result to the enum type
						if (lhsIsEnum)
							integerOperator.Result = lhs;
						else
							integerOperator.Result = rhs;
					}

					// Return the re-purposed integer operator
					return integerOperator;
				}
			}
		}

		// Are both types handle types?
		if (Type::IsHandleType(lhs) && Type::IsHandleType(rhs))
		{
			// If we can convert the right to the left hand side (or they are the same)
			CastOperator castRightToLeft = this->GetCastOperator(rhs, lhs);
			if (castRightToLeft.IsValid && castRightToLeft.CanBeImplicit && castRightToLeft.RequiresCodeGeneration == false)
			{
				// Based on the operation...
				switch (oper)
				{
					// It is only legal for us to do assignment here, since the right
					// hand side must convert to the left hand side (eg, upcasting or null)
				case Grammar::Assignment:
					return this->HandleAssignment;
				case Grammar::Equality:
					return this->HandleEquality;
				case Grammar::Inequality:
					return this->HandleInequality;
				}
			}

			// If we can convert the left to the right hand side (we already know they aren't the same from above)
			CastOperator castLeftToRight = this->GetCastOperator(lhs, rhs);
			if (castLeftToRight.IsValid && castLeftToRight.CanBeImplicit && castLeftToRight.RequiresCodeGeneration == false)
			{
				// Based on the operation...
				switch (oper)
				{
				case Grammar::Equality:
					return this->HandleEquality;
				case Grammar::Inequality:
					return this->HandleInequality;
				}
			}
		}
		// Are both types the same type?
		else if (Type::IsSame(lhs, rhs))
		{
			// Note: In all of these  checks below we only need to
			// check one of them because we know they are the same!

			// Are both types value types?
			if (Type::IsValueType(lhs))
			{
				// Based on the operation...
				switch (oper)
				{
				case Grammar::Assignment:
					return this->ValueAssignment;
				case Grammar::Equality:
					return this->ValueEquality;
				case Grammar::Inequality:
					return this->ValueInequality;
				}
			}

			// Are both types delegate types?
			if (Type::IsDelegateType(lhs))
			{
				// Based on the operation...
				switch (oper)
				{
				case Grammar::Assignment:
					return this->DelegateAssignment;
				case Grammar::Equality:
					return this->DelegateEquality;
				case Grammar::Inequality:
					return this->DelegateInequality;
				}
			}

			// Are both types any types?
			if (Type::IsAnyType(lhs))
			{
				// Based on the operation...
				switch (oper)
				{
				case Grammar::Assignment:
					return this->AnyAssignment;
				case Grammar::Equality:
					return this->AnyEquality;
				case Grammar::Inequality:
					return this->AnyInequality;
				}
			}
		}

		// We got to this point and didn't find any binary operators that worked without implicit casting
		// When testing for implicit casting, it is common for us to look into our own casts
		if (allowRecursiveLookup == false)
			return BinaryOperator();

		// Lets take a look and see if implicit casting can solve our problems!
		// First, attempt to cast the right argument into the left argument type
		{
			CastOperator rightCast = this->GetCastOperator(rhs, lhs);

			// Only accept valid implicit casts
			if (rightCast.IsValid && rightCast.CanBeImplicit)
			{
				// We only look for direct 'primitive' binary operators
				BinaryOperator binaryOperatorWithCast = this->GetBinaryOperator(lhs, lhs, oper, false);
				if (binaryOperatorWithCast.IsValid)
				{
					// Let the user know that they need to cast to make this operator work
					binaryOperatorWithCast.Rhs = rhs;
					binaryOperatorWithCast.CastRhsTo = lhs;
					return binaryOperatorWithCast;
				}
			}
		}

		// We enumerate all the values the right argument can be cast into
		Array<CastOperator> rightCasts = this->GetPrimitiveCastOperatorsFrom(rhs);
		for (size_t i = 0; i < rightCasts.size(); ++i)
		{
			CastOperator& rightCast = rightCasts[i];

			// We only consider implicit casts
			if (rightCast.CanBeImplicit == false)
				continue;

			// We only look for direct 'primitive' binary operators
			BinaryOperator binaryOperatorWithCast = this->GetBinaryOperator(lhs, rightCast.To, oper, false);
			if (binaryOperatorWithCast.IsValid)
			{
				// Let the user know that they need to cast to make this operator work
				binaryOperatorWithCast.Rhs = rhs;
				binaryOperatorWithCast.CastRhsTo = rightCast.To;
				return binaryOperatorWithCast;
			}
		}

		// We enumerate all the values the left argument can be cast into
		Array<CastOperator> leftCasts = this->GetPrimitiveCastOperatorsFrom(lhs);
		for (size_t i = 0; i < leftCasts.size(); ++i)
		{
			CastOperator& leftCast = leftCasts[i];

			// We only consider implicit casts
			if (leftCast.CanBeImplicit == false)
				continue;

			// We only look for direct 'primitive' binary operators
			BinaryOperator binaryOperatorWithCast = this->GetBinaryOperator(leftCast.To, rhs, oper, false);
			if (binaryOperatorWithCast.IsValid)
			{
				// We can't allow implicit casting of the left argument when the operator is an l-value operator
				// For example, we never want Integer = Real to attempt to cast Integer to Real to make it work
				// This is partially mitigated by attempting the right operand first
				if ((binaryOperatorWithCast.Io & IoMode::WriteLValue) != 0)
					continue;

				// Let the user know that they need to cast to make this operator work
				binaryOperatorWithCast.Lhs = lhs;
				binaryOperatorWithCast.CastLhsTo = leftCast.To;
				return binaryOperatorWithCast;
			}
		}

		// We were unable to find anything, return an invalid operator
		return BinaryOperator();
	}

	//***************************************************************************
	UnaryOperator Shared::GetUnaryOperator(Type* type, Grammar::Enum oper)
	{
		// Attempt to find the result in the pre-made set of instructions
		UnaryOperator finder;
		finder.Operand = type;
		finder.Operator = oper;
		UnaryOperator* result = this->UnaryOperators.findPointer(finder);

		// If we found any operator, return it
		if (result != nullptr)
			return *result;

		// Check to see if the type we're operating on is an enum...
		Type* integerType = ZilchTypeId(Integer);
		if (Type::IsEnumOrFlagsType(type))
		{
			// Check to see if we have an integer operator of the same kind...
			UnaryOperator integerOperator = this->GetUnaryOperator(integerType, oper);

			// If the operator is valid
			if (integerOperator.IsValid)
			{
				// Modify the operator slightly to make the inputs the same, and also make the result the enum type
				if (Type::IsSame(integerOperator.Result, integerType))
					integerOperator.Result = type;

				// Return the re-purposed integer operator
				return integerOperator;
			}
		}

		// Otherwise, we didn't find the unary operator for this type...
		return UnaryOperator();
	}

	//***************************************************************************
	Array<CastOperator> Shared::GetPrimitiveCastOperatorsFrom(Type* from)
	{
		return this->PrimitiveCastOperatorsFrom[from];
	}

	//***************************************************************************
	CastOperator Shared::GetCastOperator(Type* from, Type* to)
	{
		// Get the core library
		Core& core = Core::GetInstance();

		// If the types are the exact same, then we require no conversion at all!
		// Note: This check should always come first, to avoid situations like 'ToAny' when it's 'Any' to 'Any'
		if (Type::IsSame(from, to))
			return this->RawImplicitCast;

		// If we're attempting to convert to the 'any' type...
		if (Type::IsAnyType(to))
			return this->ToAnyCast;

		// If we're attempting to convert from the 'any' type...
		if (Type::IsAnyType(from))
			return this->FromAnyCast;

		// If we're casting from an Integer to an enum...
		if (Type::IsSame(from, ZilchTypeId(Integer)) && Type::IsEnumOrFlagsType(to))
			return this->IntegerEnumCast;

		// If we're casting from an enum to an Integer... (can be implicit)
		if (Type::IsEnumOrFlagsType(from) && Type::IsSame(to, ZilchTypeId(Integer)))
			return this->EnumIntegerCast;

		// First attempt to find the operator in the specialized place
		CastOperator finder;
		finder.From = from;
		finder.To = to;

		// Look for the operator in the pre-defined operator set
		CastOperator* result = this->CastOperators.findPointer(finder);
		if (result != nullptr)
			return *result;

		// If we're converting from null to any delegate type...
		if (Type::IsSame(ZilchTypeId(nullptr_t), from) && Type::IsDelegateType(to))
			return this->NullToDelegate;

		// If we're converting from null to any other handle type...
		if (Type::IsSame(ZilchTypeId(nullptr_t), from) && Type::IsHandleType(to))
			return this->RawImplicitCast;

		// If we are converting from a delegate to the 'any delegate'...
		if (Type::IsDelegateType(from) && to == core.AnyDelegateType)
			return this->RawImplicitCast;

		// Attempt to grab both types as reference types
		BoundType* fromBoundType = Type::GetReferenceType(from);
		BoundType* toBoundType = Type::GetReferenceType(to);

		// If both types are reference types (only one level of indirection)...
		if (fromBoundType != nullptr && toBoundType != nullptr)
		{
			// If the 'from' type is a 'to' type, meaning 'from' is either the same or more derived...
			if (TypeBinding::IsA(fromBoundType, toBoundType))
				return this->RawImplicitCast;

			// If the 'to' type is a 'from' type, meaning 'from' is either the same or more base... ('to' is more derived)
			if (TypeBinding::IsA(toBoundType, fromBoundType))
				return this->DynamicDownCast;
		}

		// Otherwise I was not able to find the cast operator
		return CastOperator();
	}

	//***************************************************************************
	UntypedOperator Shared::GetOperatorPrecedence(Grammar::Enum oper, OperatorArity::Enum arity)
	{
		OperatorWithArity finder;
		finder.Operator = oper;
		finder.Arity = arity;
		return this->OperatorToPrecedence.findValue(finder, UntypedOperator());
	}

	//***************************************************************************
	const Array<Array<UntypedOperator> >& Shared::GetPrecedences()
	{
		return this->PrecedenceToOperators;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	// Initialize static variables
	EventHandler Console::Events;
	static String ConsoleSeparator(", ");
	static String NewLine("\n");

	//***************************************************************************
	void DefaultWriteText(ConsoleEvent* event)
	{
		// Print the text to the console
		printf("%s", event->Text.c_str());
	}

	//***************************************************************************
	void DefaultReadText(ConsoleEvent* event)
	{
		// Attempt to read a string from the console
		const size_t BufferSize = 1024;
		char buffer[BufferSize + 1] = { 0 };

		// Read data into the buffer
		fgets(buffer, BufferSize, stdin);

		// Loop through all characters in the buffer
		for (size_t i = 0; i < BufferSize; ++i)
		{
			// If we hit a newline...
			if (buffer[i] == '\r' || buffer[i] == '\n')
			{
				// Terminate the string at the newline
				buffer[i] = '\0';
			}
		}

		// Return the read in data
		event->Text = String(buffer);
	}

	//***************************************************************************
	ZilchDefineType(Console, Core)
	{
		ZilchBindStaticMethodOverload(Write, void, AnyParam);
		ZilchBindStaticMethodOverload(Write, void, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(Write, void, AnyParam, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(Write, void, AnyParam, AnyParam, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(Write, void, AnyParam, AnyParam, AnyParam, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(WriteLine, void);
		ZilchBindStaticMethodOverload(WriteLine, void, AnyParam);
		ZilchBindStaticMethodOverload(WriteLine, void, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(WriteLine, void, AnyParam, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(WriteLine, void, AnyParam, AnyParam, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(WriteLine, void, AnyParam, AnyParam, AnyParam, AnyParam, AnyParam);
		ZilchBindStaticMethodOverload(DumpValue, void, AnyParam);
		ZilchBindStaticMethodOverload(DumpValue, void, AnyParam, Integer);

		//ZilchBindStaticMethod(ReadString);
		ZilchBindStaticMethod(ReadInteger);
		ZilchBindStaticMethod(ReadBoolean);
		ZilchBindStaticMethod(ReadReal);
	}

	//***************************************************************************
	void Console::WriteData(StringParam text)
	{
		// Send out the event with the given text data
		ConsoleEvent toSend;
		toSend.State = ExecutableState::CallingState;
		toSend.Text = text;
		Events.Send(Events::ConsoleWrite, &toSend);
	}

	//***************************************************************************
	String Console::ReadData()
	{
		// Send out the event (the user must fill out the text field)
		ConsoleEvent toSend;
		toSend.State = ExecutableState::CallingState;
		Events.Send(Events::ConsoleRead, &toSend);
		return toSend.Text;
	}

	//***************************************************************************
	void Console::Write(AnyParam value0)
	{
		WriteData(value0.ToString());
	}

	//***************************************************************************
	void Console::Write(AnyParam value0, AnyParam value1)
	{
		WriteData(BuildString(value0.ToString(), ConsoleSeparator, value1.ToString()));
	}

	//***************************************************************************
	void Console::Write(AnyParam value0, AnyParam value1, AnyParam value2)
	{
		WriteData(BuildString(value0.ToString(), ConsoleSeparator, value1.ToString(), ConsoleSeparator, value2.ToString()));
	}

	//***************************************************************************
	void Console::Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3)
	{
		StringBuilder builder;
		builder.Append(value0.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value1.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value2.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value3.ToString());
		WriteData(builder.ToString());
	}

	//***************************************************************************
	void Console::Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4)
	{
		StringBuilder builder;
		builder.Append(value0.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value1.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value2.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value3.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value4.ToString());
		WriteData(builder.ToString());
	}

	//***************************************************************************
	void Console::Write(StringParam value)
	{
		WriteData(value);
	}

	//***************************************************************************
	void Console::Write(StringRange value)
	{
		WriteData(value);
	}

	//***************************************************************************
	void Console::Write(cstr value)
	{
		WriteData(String(value));
	}

	//***************************************************************************
	void Console::Write(char value)
	{
		WriteData(String(value));
	}

	//***************************************************************************
	void Console::Write(Integer value)
	{
		WriteData(IntegerToString(value));
	}

	//***************************************************************************
	void Console::Write(Integer2Param value)
	{
		WriteData(Integer2ToString(value));
	}

	//***************************************************************************
	void Console::Write(Integer3Param value)
	{
		WriteData(Integer3ToString(value));
	}

	//***************************************************************************
	void Console::Write(Integer4Param value)
	{
		WriteData(Integer4ToString(value));
	}

	//***************************************************************************
	void Console::Write(DoubleInteger value)
	{
		WriteData(DoubleIntegerToString(value));
	}

	//***************************************************************************
	void Console::Write(Boolean value)
	{
		WriteData(BooleanToString(value));
	}

	//***************************************************************************
	void Console::Write(Boolean2Param value)
	{
		WriteData(Boolean2ToString(value));
	}

	//***************************************************************************
	void Console::Write(Boolean3Param value)
	{
		WriteData(Boolean3ToString(value));
	}

	//***************************************************************************
	void Console::Write(Boolean4Param value)
	{
		WriteData(Boolean4ToString(value));
	}

	//***************************************************************************
	void Console::Write(Real value)
	{
		WriteData(RealToString(value));
	}

	//***************************************************************************
	void Console::Write(DoubleReal value)
	{
		WriteData(DoubleRealToString(value));
	}

	//***************************************************************************
	void Console::Write(Real2Param value)
	{
		WriteData(Real2ToString(value));
	}

	//***************************************************************************
	void Console::Write(Real3Param value)
	{
		WriteData(Real3ToString(value));
	}

	//***************************************************************************
	void Console::Write(Real4Param value)
	{
		WriteData(Real4ToString(value));
	}

	//***************************************************************************
	void Console::Write(QuaternionParam value)
	{
		WriteData(QuaternionToString(value));
	}

	//***************************************************************************
	void Console::WriteLine()
	{
		WriteData(NewLine);
	}

	//***************************************************************************
	void Console::WriteLine(AnyParam value0)
	{
		WriteData(BuildString(value0.ToString(), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(AnyParam value0, AnyParam value1)
	{
		WriteData(BuildString(value0.ToString(), ConsoleSeparator, value1.ToString(), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(AnyParam value0, AnyParam value1, AnyParam value2)
	{
		StringBuilder builder;
		builder.Append(value0.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value1.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value2.ToString());
		builder.Append(NewLine);
		WriteData(builder.ToString());
	}

	//***************************************************************************
	void Console::WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3)
	{
		StringBuilder builder;
		builder.Append(value0.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value1.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value2.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value3.ToString());
		builder.Append(NewLine);
		WriteData(builder.ToString());
	}

	//***************************************************************************
	void Console::WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4)
	{
		StringBuilder builder;
		builder.Append(value0.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value1.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value2.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value3.ToString());
		builder.Append(ConsoleSeparator);
		builder.Append(value4.ToString());
		builder.Append(NewLine);
		WriteData(builder.ToString());
	}

	//***************************************************************************
	void Console::WriteLine(StringParam value)
	{
		WriteData(BuildString(value, NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(StringRange value)
	{
		WriteData(BuildString(value, NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(cstr value)
	{
		WriteData(BuildString(String(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(char value)
	{
		WriteData(BuildString(String(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Integer value)
	{
		WriteData(BuildString(IntegerToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Integer2Param value)
	{
		WriteData(BuildString(Integer2ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Integer3Param value)
	{
		WriteData(BuildString(Integer3ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Integer4Param value)
	{
		WriteData(BuildString(Integer4ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(DoubleInteger value)
	{
		WriteData(BuildString(DoubleIntegerToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Boolean value)
	{
		WriteData(BuildString(BooleanToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Boolean2Param value)
	{
		WriteData(BuildString(Boolean2ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Boolean3Param value)
	{
		WriteData(BuildString(Boolean3ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Boolean4Param value)
	{
		WriteData(BuildString(Boolean4ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Real value)
	{
		WriteData(BuildString(RealToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(DoubleReal value)
	{
		WriteData(BuildString(DoubleRealToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Real2Param value)
	{
		WriteData(BuildString(Real2ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Real3Param value)
	{
		WriteData(BuildString(Real3ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(Real4Param value)
	{
		WriteData(BuildString(Real4ToString(value), NewLine));
	}

	//***************************************************************************
	void Console::WriteLine(QuaternionParam value)
	{
		WriteData(BuildString(QuaternionToString(value), NewLine));
	}

	//***************************************************************************
	void Console::DumpValue(StringBuilderExtended& builder, Type* type, const byte* value, Integer howDeep, Integer currentDepth)
	{
		// First write the generic value of the type...
		String baseValueString = type->GenericToString(value);
		builder.WriteLine(baseValueString);

		// If this is the level of depth we wanted to traverse, exit out
		if (currentDepth == howDeep)
			return;

		// If this is a bound type, lets print out its property/member values
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);
		if (boundType != nullptr)
		{
			byte* instanceData = boundType->GenericGetMemory(value);
			if (instanceData)
			{
				// Loop through all the instance properties
				PropertyArray& properties = boundType->AllProperties;
				for (size_t i = 0; i < properties.size(); ++i)
				{
					// Grab the current property
					Property* property = properties[i];

					// If it's a static or hidden property, skip it
					if (property->IsStatic || property->IsHidden)
						continue;

					// TEMPORARY - Because we do not have the ExecutableState in bound C++ functions, we can only
					// print out fields (because we know their type and know where they exist in memory
					if (Field* field = TypeBinding::DynamicCast<Field*>(property))
					{
						// Write tabs up to the current depth
						for (Integer i = 0; i <= currentDepth; ++i)
							builder.Write("  ");

						// Write out the property name
						builder.Write(field->Name);
						builder.Write(": ");

						byte* fieldData = instanceData + field->Offset;

						// Recursively dumping will imediately print out the property value
						DumpValue(builder, field->PropertyType, fieldData, howDeep, currentDepth + 1);
					}
				}
			}
		}
	}

	//***************************************************************************
	void Console::DumpValue(AnyParam value)
	{
		DumpValue(value, 1);
	}

	//***************************************************************************
	void Console::DumpValue(AnyParam value, Integer howDeep)
	{
		// Create the string builder we'll use to fully build the object
		StringBuilderExtended builder;

		// Call the helper (recursive)
		DumpValue(builder, value.StoredType, value.Data, howDeep, 0);

		// Write out the debug text for the object
		String finalText = builder.ToString();
		Write(finalText);
	}

	//***************************************************************************
	String Console::ReadString()
	{
		// Just read the string directly (no interpreting, may be empty)
		return ReadData();
	}

	//***************************************************************************
	Integer Console::ReadInteger()
	{
		// Just read the string directly (may be empty)
		String readText = ReadData();

		// Convert the text to the value type
		Integer returnValue = 0;
		ToValue(readText, returnValue);

		// Return the resulting read value, or a default if we had no callback
		return returnValue;
	}

	//***************************************************************************
	Boolean Console::ReadBoolean()
	{
		// Just read the string directly (may be empty)
		String readText = ReadData();

		// Convert the text to the value type
		Boolean returnValue = false;
		ToValue(readText, returnValue);

		// Return the resulting read value, or a default if we had no callback
		return returnValue;
	}

	//***************************************************************************
	Real Console::ReadReal()
	{
		// Just read the string directly (may be empty)
		String readText = ReadData();

		// Convert the text to the value type
		Real returnValue = 0.0f;
		ToValue(readText, returnValue);

		// Return the resulting read value, or a default if we had no callback
		return returnValue;
	}

	//***************************************************************************
	ZilchDefineTypeAs(StringBuilderExtended, Core, "StringBuilder")
	{
		ZilchBindConstructor();
		ZilchBindDestructor();

		ZilchBindMethod(ToString);

		ZilchBindMethodOverload(Write, void, AnyParam);
		ZilchBindMethodOverload(WriteLine, void);
		ZilchBindMethodOverload(WriteLine, void, AnyParam);
	}

	//***************************************************************************
	void StringBuilderExtended::Write(AnyParam value)
	{
		this->Append(value.ToString());
	}

	//***************************************************************************
	void StringBuilderExtended::Write(StringParam value)
	{
		this->Append(value);
	}

	//***************************************************************************
	void StringBuilderExtended::Write(StringRange value)
	{
		this->Append(value);
	}

	//***************************************************************************
	void StringBuilderExtended::Write(cstr value)
	{
		this->Append(value);
	}

	//***************************************************************************
	void StringBuilderExtended::Write(char value)
	{
		this->Append(value);
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Integer value)
	{
		this->Append(IntegerToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Integer2Param value)
	{
		this->Append(Integer2ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Integer3Param value)
	{
		this->Append(Integer3ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Integer4Param value)
	{
		this->Append(Integer4ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(DoubleInteger value)
	{
		this->Append(DoubleIntegerToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Boolean value)
	{
		this->Append(BooleanToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Boolean2Param value)
	{
		this->Append(Boolean2ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Boolean3Param value)
	{
		this->Append(Boolean3ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Boolean4Param value)
	{
		this->Append(Boolean4ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Real value)
	{
		this->Append(RealToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(DoubleReal value)
	{
		this->Append(DoubleRealToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Real2Param value)
	{
		this->Append(Real2ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Real3Param value)
	{
		this->Append(Real3ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(Real4Param value)
	{
		this->Append(Real4ToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::Write(QuaternionParam value)
	{
		this->Append(QuaternionToString(value));
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine()
	{
		this->Append("\n");
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(AnyParam value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(StringParam value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(StringRange value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(cstr value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(char value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Integer value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Integer2Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Integer3Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Integer4Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(DoubleInteger value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Boolean value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Boolean2Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Boolean3Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Boolean4Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Real value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(DoubleReal value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Real2Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Real3Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(Real4Param value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	void StringBuilderExtended::WriteLine(QuaternionParam value)
	{
		this->Write(value);
		this->WriteLine();
	}

	//***************************************************************************
	String StringBuilderExtended::ToString() const
	{
		return StringBuilder::ToString();
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	String BuildGetterName(String name)
	{
		return BuildString("[Get", name, "]");
	}

	//***************************************************************************
	String BuildSetterName(String name)
	{
		return BuildString("[Set", name, "]");
	}

	//***************************************************************************
	String ReplaceStringEscapes(StringRange input)
	{
		StringBuilder builder;

		// Whether or not we hit the escape character '\'
		bool isEscape = false;

		// Walk through all the input characters
		for (size_t i = 0; i < input.size(); ++i)
		{
			// Grab the current character
			char c = input[i];

			// If we hit the escape character...
			if (c == '\\')
			{
				isEscape = true;
			}
			else
			{
				// If the last character we hit was an escape character...
				if (isEscape)
				{
					// Based on the escaped character type...
					switch (c)
					{
						// All these characters just get directly inserted as themselves
					case '"':
					case '`':
					case '\\':
						builder.Append(c);
						break;

						// These characters have special meanings or ascii values
					case '0':
						builder.Append('\0');
						break;
					case 'a':
						builder.Append('\a');
						break;
					case 'b':
						builder.Append('\b');
						break;
					case 'f':
						builder.Append('\f');
						break;
					case 'n':
						builder.Append('\n');
						break;
					case 'r':
						builder.Append('\r');
						break;
					case 't':
						builder.Append('\t');
						break;
					case 'v':
						builder.Append('\v');
						break;
					default:
						builder.Append(c);
						Error("Hit a character that shouldn't have been escaped (should have been caught by the tokenizer)");
						break;
					}
				}
				else
				{
					// Otherwise, we just hit a normal character
					builder.Append(c);
				}

				// No matter what, we've already handled the escape
				isEscape = false;
			}
		}

		// Return the resulting string
		return builder.ToString();
	}

	//***************************************************************************
	bool IsZilchQuoteCharacter(char c)
	{
		return c == '"' || c == '`';
	}

	//***************************************************************************
	StringRange StripStringQuotes(StringRange input)
	{
		// Error checking
		ErrorIf(input.size() < 2, "A string cannot contain quotes on both ends if it has a size less than 2");
		ErrorIf(IsZilchQuoteCharacter(input[0]) == false, "The starting character was not a Zilch quotation");
		ErrorIf(IsZilchQuoteCharacter(input[input.size() - 1]) == false, "The ending character was not a Zilch quotation");

		// Move the beginning inward and the end backwards by 1 to strip the quotes
		++input.begin;
		--input.end;

		return input;
	}

	//***************************************************************************
	String ReplaceStringEscapesAndStripQuotes(StringRange input)
	{
		// Strip the quotes
		input = StripStringQuotes(input);

		// Now perform the string replacements
		return ReplaceStringEscapes(input);
	}

	//***************************************************************************
	String ToLowerCamelCase(StringRange input)
	{
		if (input.empty())
			return String();

		int firstCharacter = input[0];
		firstCharacter = tolower(firstCharacter);
		return BuildString(String((char)firstCharacter), input.sub_string(1, input.size() - 1));
	}

	//***************************************************************************
	String ToUpperCamelCase(StringRange input)
	{
		if (input.empty())
			return String();

		int firstCharacter = input[0];
		firstCharacter = toupper(firstCharacter);
		return BuildString(String((char)firstCharacter), input.sub_string(1, input.size() - 1));
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	void TypingContext::Clear(bool tolerantMode)
	{
		// If we're not in tolerant mode, we better not have anything in our context
		ErrorIf(tolerantMode == false && this->ClassTypeStack.empty() == false,
			"Classes still leftover in the typing context after it was done being used");
		ErrorIf(tolerantMode == false && this->FunctionStack.empty() == false,
			"Functions still leftover in the typing context after it was done being used");

		// Always clear everything from the context, regardless of the mode (just for safety)
		this->ClassTypeStack.clear();
		this->FunctionStack.clear();
	}

	//***************************************************************************
	Syntaxer::Syntaxer(CompilationErrors& errors) :
		Errors(errors),
		Builder(nullptr),
		Tree(nullptr),
		TypeParsedHandlers(nullptr),
		Dependencies(nullptr),
		ClassWalker(&errors),
		MemberWalker(&errors),
		FunctionWalker(&errors),
		TypingWalker(&errors),
		ExpressionWalker(&errors)
	{
		ZilchErrorIfNotStarted(Syntaxer);

		// Collect all the classes first
		// We need to do a pass over all classes in the entire code base because if
		// anything references a type name later on, we need to be able to resolve it
		// or know if it's an error on the spot!
		this->ClassWalker.Register(&Syntaxer::CollectClass);
		this->ClassWalker.Register(&Syntaxer::CollectEnum);

		// We need to walk every expression, every node, every place where we could find types
		// We basically need to collect all uses of templates
		this->TemplateWalker.RegisterNonLeafBase(&Syntaxer::CollectTemplateInstantiations);

		// The next pass we do, we dive into each class definition and pull out member variables
		// and property declarations. This is so that if we reference anything using the member
		// access operator '.' in the next pass, then we know if it's an error or not
		this->MemberWalker.Register(&Syntaxer::CollectClassInheritance);
		this->MemberWalker.Register(&Syntaxer::CollectSendsEvents);
		this->MemberWalker.Register(&Syntaxer::CollectEnumInheritance);
		this->MemberWalker.Register(&Syntaxer::CollectMemberVariableAndProperty);

		// We have to do functions as a separate pass since we must know
		// the sizes of all objects before doing function signatures
		// We also do parameters here because function delegate types must be done by this point
		this->FunctionWalker.Register(&Syntaxer::PushClass);
		this->FunctionWalker.Register(&Syntaxer::CollectConstructor);
		this->FunctionWalker.Register(&Syntaxer::CollectDestructor);
		this->FunctionWalker.Register(&Syntaxer::CollectFunction);
		this->FunctionWalker.Register(&Syntaxer::CollectPropertyGetSet);
		this->FunctionWalker.RegisterDerived<ParameterNode>(&Syntaxer::CheckLocalVariable);

		// Walk through the tree and attempt to assign locations to every node (class, function, etc)
		this->LocationWalker.RegisterNonLeafBase(&Syntaxer::DecorateCodeLocations);

		// Walk all any type of expression (often, expressions are nested within each other)
		this->TypingWalker.Register(&Syntaxer::PushClass);
		this->TypingWalker.RegisterDerived<ConstructorNode>(&Syntaxer::PushFunction);
		this->TypingWalker.RegisterDerived<DestructorNode>(&Syntaxer::PushFunction);
		this->TypingWalker.RegisterDerived<FunctionNode>(&Syntaxer::PushFunction);
		this->TypingWalker.Register(&Syntaxer::DecorateInitializer);
		this->TypingWalker.Register(&Syntaxer::DecorateValue);
		this->TypingWalker.Register(&Syntaxer::DecorateStringInterpolant);
		this->TypingWalker.Register(&Syntaxer::DecorateCreationCall);
		this->TypingWalker.Register(&Syntaxer::DecorateCreationInitializer);
		this->TypingWalker.Register(&Syntaxer::DecorateUnnamedOperand);
		this->TypingWalker.Register(&Syntaxer::DecorateTypeId);
		this->TypingWalker.Register(&Syntaxer::DecorateCheckTypeCast);
		this->TypingWalker.Register(&Syntaxer::DecorateCheckBinaryOperator);
		this->TypingWalker.Register(&Syntaxer::DecorateCheckUnaryOperator);
		this->TypingWalker.Register(&Syntaxer::DecorateCheckPropertyDelegateOperator);
		this->TypingWalker.Register(&Syntaxer::DecorateCheckFunctionCall);
		this->TypingWalker.Register(&Syntaxer::CheckReturn);
		this->TypingWalker.Register(&Syntaxer::CheckDelete);
		this->TypingWalker.Register(&Syntaxer::CheckThrow);
		this->TypingWalker.Register(&Syntaxer::CheckMemberVariable);
		this->TypingWalker.Register(&Syntaxer::CheckLocalVariable);
		this->TypingWalker.Register(&Syntaxer::CheckWhile);
		this->TypingWalker.Register(&Syntaxer::CheckDoWhile);
		this->TypingWalker.Register(&Syntaxer::CheckFor);
		this->TypingWalker.RegisterDerived<ForEachNode>(&Syntaxer::CheckFor);
		this->TypingWalker.Register(&Syntaxer::CheckLoop);
		this->TypingWalker.Register(&Syntaxer::CheckScope);
		this->TypingWalker.Register(&Syntaxer::CheckTimeout);
		this->TypingWalker.Register(&Syntaxer::CheckIfRoot);
		this->TypingWalker.Register(&Syntaxer::CheckIf);
		this->TypingWalker.Register(&Syntaxer::CheckBreak);
		this->TypingWalker.Register(&Syntaxer::CheckContinue);
		this->TypingWalker.Register(&Syntaxer::ResolveLocalVariableReference);
		this->TypingWalker.Register(&Syntaxer::ResolveMember);
		this->TypingWalker.Register(&Syntaxer::ResolveTypeMember);

		// The last thing we do is walk all expressions and verify that r-values and l-values get treated properly
		this->ExpressionWalker.RegisterNonLeafBase(&Syntaxer::CheckExpressionIoModes);
	}

	//***************************************************************************
	Syntaxer::~Syntaxer()
	{
		// Get a list of all template root nodes
		HashMap<String, ClassNode*>::valuerange templateRootNodes = this->InternalBoundTemplates.values();

		// Loop through all the template root nodes...
		while (templateRootNodes.empty() == false)
		{
			// Get the current template and move to the next
			ClassNode* templateClassNode = templateRootNodes.front();
			templateRootNodes.popFront();

			// Delete the node (free's all the memory even of children)
			delete templateClassNode;
			templateClassNode = nullptr;
		}
	}

	//***************************************************************************
	void Syntaxer::ErrorAt(SyntaxNode* node, ErrorCode::Enum errorCode, ...)
	{
		// Start a variadic argument list
		va_list argList;
		va_start(argList, errorCode);

		// Call the other error function
		ErrorAtArgs(node, errorCode, argList);

		// End the argument list
		va_end(argList);
	}

	//***************************************************************************
	void Syntaxer::ErrorAtArgs(SyntaxNode* node, ErrorCode::Enum errorCode, va_list argList)
	{
		// Now call the error function
		this->Errors.RaiseArgs(node->Location, errorCode, argList);
	}

	//***************************************************************************
	Type* Syntaxer::RetrieveType(const SyntaxType* syntaxType, const CodeLocation& location, const Module& dependencies)
	{
		// Store the dependencies and all their types into a map
		this->Dependencies = &dependencies;
		this->PopulateDependencies();

		// Now attempt to turn the syntax type into an actual type (or return null)
		return this->RetrieveType(syntaxType, location);
	}

	//***************************************************************************
	void Syntaxer::PopulateDependencies()
	{
		// Clear any previous stored bound types, in case we're reusing the syntaxer
		this->ExternalBoundTypes.clear();

		// Loop through all the passed in libraries
		for (size_t i = 0; i < this->Dependencies->size(); ++i)
		{
			// Get the current library
			ConstLibraryRef library = (*this->Dependencies)[i];

			// Get a range of all bound types in the library
			BoundTypeRange libraryBoundTypes = library->BoundTypes.all();

			// Loop through all named types in the library
			while (libraryBoundTypes.empty() == false)
			{
				// Grab the current named type in the library and iterate forward
				BoundTypePair& pair = libraryBoundTypes.front();
				libraryBoundTypes.popFront();

				// If we didn't insert the type because something was in its place...
				if (this->ExternalBoundTypes.insertNoOverwrite(pair) == false)
				{
					// Add all the named true types from this library into to the hash map
					return this->Errors.Raise(CodeLocation(), ErrorCode::ExternalTypeNamesCollide,
						pair.first.c_str(),
						library->Name.c_str(),
						pair.second->SourceLibrary->Name.c_str());
				}
			}
		}
	}

	//***************************************************************************
	void Syntaxer::ApplyToTree
		(
		SyntaxTree& syntaxTree,
		LibraryBuilder& builder,
		const Array<TypeParsedDelegate>& typeParseCallbacks,
		const Module& dependencies
		)
	{
		// Store syntaxer state
		this->TypeParsedHandlers = &typeParseCallbacks;
		this->Tree = &syntaxTree;

		// Store the builder so we can add things to it as we run the syntaxer
		this->Builder = &builder;

		// Store the dependencies and all their types into a map
		this->Dependencies = &dependencies;
		this->PopulateDependencies();

		// Add our own builder's library to the mix
		this->AllLibraries.push_back(builder.BuiltLibrary);

		// Copy over all the dependencies into our library array
		this->AllLibraries.insert(this->AllLibraries.end(), this->Dependencies->all());

		// Note: Technically with single expression mode, we should only have to evaluate
		// the types of just the expression (no class/member gathering, etc)
		// However, the expression COULD be referring to a template, which may need to be instantiated

		// Collect all the class types first
		ClassContext classContext;
		this->ClassWalker.Walk(this, syntaxTree.Root, &classContext);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Walk the tree and look for any template instantiations
		this->TemplateWalker.Walk(this, syntaxTree.Root, &classContext);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Walk the tree and collect members
		TypingContext typingContext;
		this->MemberWalker.Walk(this, syntaxTree.Root, &typingContext);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Loop through all class nodes
		for (size_t i = 0; i < syntaxTree.Root->Classes.size(); ++i)
		{
			// Grab the current node
			ClassNode* node = syntaxTree.Root->Classes[i];
			if (node == nullptr)
				continue;

			// Loop through all the handlers
			for (size_t i = 0; i < this->TypeParsedHandlers->size(); ++i)
			{
				// Get the current callback
				const TypeParsedDelegate& handler = (*this->TypeParsedHandlers)[i];

				// Invoke the callback since we found this type
				handler.Callback(*this->Builder, node->Type, node->Location.CodeUserData, handler.UserData);
			}
		}

		// Loop through all enum nodes
		for (size_t i = 0; i < syntaxTree.Root->Enums.size(); ++i)
		{
			// Grab the current node
			EnumNode* node = syntaxTree.Root->Enums[i];
			if (node == nullptr)
				continue;

			// Loop through all the handlers
			for (size_t i = 0; i < this->TypeParsedHandlers->size(); ++i)
			{
				// Get the current callback
				const TypeParsedDelegate& handler = (*this->TypeParsedHandlers)[i];

				// Invoke the callback since we found this type
				handler.Callback(*this->Builder, node->Type, node->Location.CodeUserData, handler.UserData);
			}
		}

		// Clear the typing context after every use (not necessary, except in tolerant mode)
		typingContext.Clear(this->Errors.TolerantMode);

		// The class types that we've created
		HashMap<Type*, BoundType*> ourClassTypes;
		for (size_t i = 0; i < classContext.AllClasses.size(); ++i)
		{
			// Grab the current class type
			BoundType* type = classContext.AllClasses[i];
			ourClassTypes.insertOrError(type, type);
		}

		// We've collected all the classes we're compiling, as well as the members
		// Loop through all the classes and compute their sizes
		for (size_t i = 0; i < classContext.AllClasses.size(); ++i)
		{
			// Grab the current class type
			BoundType* type = classContext.AllClasses[i];

			// Compute the size for the class type
			this->ComputeSize(type, ourClassTypes, type->Location);
		}

		// Walk the tree and give functions types
		this->FunctionWalker.Walk(this, syntaxTree.Root, &typingContext);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Clear the typing context after every use (not necessary, except in tolerant mode)
		typingContext.Clear(this->Errors.TolerantMode);

		// Now actually walk the code and do all the checking
		this->LocationWalker.Walk(this, syntaxTree.Root, &typingContext);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Generate field properties here (after the sizing has been computed)
		builder.GenerateGetSetFields();

		// Clear the typing context after every use (not necessary, except in tolerant mode)
		typingContext.Clear(this->Errors.TolerantMode);

		// Now actually walk the code and do all the checking
		this->TypingWalker.Walk(this, syntaxTree.Root, &typingContext);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Clear the typing context after every use (not necessary, except in tolerant mode)
		typingContext.Clear(this->Errors.TolerantMode);

		// Lastly, we walk expressions to verify that all reads/writes were properly handled
		this->ExpressionWalker.Walk(this, syntaxTree.Root, &typingContext);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Clear the typing context after every use (not necessary, except in tolerant mode)
		typingContext.Clear(this->Errors.TolerantMode);
	}

	//***************************************************************************
	void Syntaxer::ComputeSize(BoundType* type, const HashMap<Type*, BoundType*>& ourClasses, const CodeLocation& location)
	{
		// Based on the size state...
		switch (type->SizeState)
		{
			// In the case that it has already been determined, we do nothing!
			// case SizeState::Determined:

		case SizeState::BeingDetermined:
			// This is an error, since we should never try to determine the size of an object again
			// whilst its already being determined from a parent call (it indicates a cycle of aggrigation)
			// This should actually be a compiler error
			this->Errors.Raise(location, ErrorCode::CompositionCycleDetected);
			break;

		case SizeState::Undetermined:
		{
			// Set the state as "being determined"
			type->SizeState = SizeState::BeingDetermined;

			// If we have a base class type...
			if (type->BaseType != nullptr)
			{
				// If the base type exists without our class hash set
				BoundType* baseClass = ourClasses.findValue(type->BaseType, nullptr);

				// If base type is a compiled class that we're currently working on...
				if (baseClass != nullptr)
				{
					// Compute the size if we haven't already
					this->ComputeSize(baseClass, ourClasses, baseClass->Location);
				}

				// Add the base type's size to the size of our object
				type->Size += AlignToBusWidth(type->BaseType->GetAllocatedSize());
			}

			// Loop through all the members
			FieldMapRange allFields = type->InstanceFields.all();
			while (allFields.empty() == false)
			{
				// Get the member
				Field& field = *allFields.front().second;
				allFields.popFront();

				// Set the position of the member as the current size
				field.Offset = type->Size;

				// We only care about computing the size of the type if it's a value type
				if (Type::IsValueType(field.PropertyType))
				{
					// If the class type exists without our hash set
					BoundType* classType = ourClasses.findValue(field.PropertyType, nullptr);

					// If the member is a compiled type...
					if (classType != nullptr)
					{
						// Compute the size if we haven't already
						this->ComputeSize(classType, ourClasses, field.Location);
					}
				}
				// If this type is a handle type...
				else if (Type::IsHandleType(field.PropertyType))
				{
					type->Handles.push_back(type->Size);
				}
				// Otherwise, if it's a delegate type
				else if (TypeBinding::DynamicCast<DelegateType*>(field.PropertyType) != nullptr)
				{
					type->Delegates.push_back(type->Size);
				}

				// Add to the size of the object
				type->Size += AlignToBusWidth(field.PropertyType->GetCopyableSize());
			}

			// Set the state as "being determined"
			type->SizeState = SizeState::Determined;
		}
		}
	}

	//***************************************************************************
	void Syntaxer::ReplaceTypes(SyntaxTypes& typesToReplace, Array<const UserToken*>& names, const BoundSyntaxType* instanceType, const CodeLocation& location)
	{
		// Loop through all the node's types
		for (size_t i = 0; i < typesToReplace.size(); ++i)
		{
			// Get the current type
			SyntaxType*& typeToReplace = *typesToReplace[i];

			// If the type we're looking at is a bound syntax type...
			if (BoundSyntaxType* dataTypeToReplace = TypeBinding::DynamicCast<BoundSyntaxType*>(typeToReplace))
			{
				// Loop through all the template names
				for (size_t j = 0; j < names.size(); ++j)
				{
					// Get the current template argument name
					const String& name = names[j]->Token;

					// Compare the data type name with each of the template argument type names
					if (dataTypeToReplace->TypeName == name)
					{
						// If the name matches, simply replace the name with what was passed in
						SyntaxType* replaceWithType = instanceType->TemplateArguments[j];

						// If the type we're currently replacing is a template, we have special logic...
						if (dataTypeToReplace->IsTemplateInstantiation())
						{
							// If the type we're replacing with is a data type
							if (BoundSyntaxType* replaceWithDataType = TypeBinding::DynamicCast<BoundSyntaxType*>(replaceWithType))
							{
								// We cannot replace a template type with another templated type
								if (replaceWithDataType->IsTemplateInstantiation() == false)
								{
									dataTypeToReplace->TypeName = replaceWithDataType->TypeName;
								}
								else
								{
									// We cannot perform the replacement of a templated arugment list with a non templatable type
									return this->Errors.Raise(location, ErrorCode::CannotReplaceTemplateInstanceWithTemplateArguments);
								}
							}
							else
							{
								// We cannot perform the replacement of a templated arugment list with a non templatable type
								return this->Errors.Raise(location, ErrorCode::CannotReplaceTemplateInstanceWithTemplateArguments);
							}
						}
						else
						{
							// Otherwise, we just do a full replacement :)
							// We MUST do a clone here or else we'll get a double delete situation
							typeToReplace = replaceWithType->Clone();
						}
					}
				}
			}

			// Traverse the syntax type recursively and apply the replacement
			this->PerformTemplateReplacement(typeToReplace, names, instanceType);

			// If we had an error, return out early
			if (this->Errors.WasError)
				return;
		}
	}

	//***************************************************************************
	void Syntaxer::PerformTemplateReplacement(SyntaxType* type, Array<const UserToken*>& names, const BoundSyntaxType* instanceType)
	{
		// Get all the syntax types from this node
		SyntaxTypes types;
		type->PopulateSyntaxTypes(types);

		// Perform recursive replacements of types
		this->ReplaceTypes(types, names, instanceType, CodeLocation());
	}

	//***************************************************************************
	void Syntaxer::PerformTemplateReplacement(SyntaxNode* node, Array<const UserToken*>& names, const BoundSyntaxType* instanceType)
	{
		// Get the children for the current node
		NodeChildren children;
		node->PopulateChildren(children);

		// Loop through all the children...
		for (size_t i = 0; i < children.size(); ++i)
		{
			// Get the current child
			SyntaxNode*& child = *children[i];

			// Traverse to that child recursively and apply the replacement
			this->PerformTemplateReplacement(child, names, instanceType);

			// If we had an error, return out early
			if (this->Errors.WasError)
				return;
		}

		// Get all the syntax types from this node
		SyntaxTypes types;
		node->PopulateSyntaxTypes(types);

		// Perform recursive replacements of types
		this->ReplaceTypes(types, names, instanceType, node->Location);
	}

	//***************************************************************************
	BoundType* Syntaxer::RetrieveBoundType(const BoundSyntaxType* type, const CodeLocation& location)
	{
		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// In tolerant mode, it is possible to get here and not have the template instantiation replaced
		// because templates are currently not exported in the library (which is reused by code completion)
		// and only the current class we're writing is actually parsed/seen by code completion
		if (this->Errors.TolerantMode == false)
		{
			// Error checking
			ErrorIf(type->IsTemplateInstantiation(),
				"All template instantiations should have been resolved by the TemplateWalker");

			// We ignore the builder not being set in tolerant mode
			ErrorIf(this->Builder == nullptr, "Attempted to retrieve a type without a builder being set");
		}

		// Make sure we have a valid builder, since this function can get called without one
		if (this->Builder != nullptr)
		{
			// Check to see if we found the type
			if (BoundType* namedType = this->Builder->FindBoundType(type->TypeName))
			{
				// Return the found type...
				return namedType;
			}
		}

		// Check to see if we found the type
		if (BoundType* namedType = this->ExternalBoundTypes.findValue(type->TypeName, nullptr))
		{
			// Return the found type...
			return namedType;
		}

		// If we stopped here, it means the user referenced a type that wasn't defined
		this->Errors.Raise(location, ErrorCode::ReferenceToUndefinedType, type->ToString().c_str());

		// Return null since we don't have a valid type!
		return core.ErrorType;
	}

	//***************************************************************************
	Type* Syntaxer::RetrieveType(const SyntaxType* syntaxType, const CodeLocation& location)
	{
		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// If the syntax type is an 'any' syntax type...
		if (TypeBinding::DynamicCast<const AnySyntaxType*>(syntaxType) != nullptr)
		{
			// We only ever have one instance of this type
			return core.AnythingType;
		}
		// If the syntax type is an indirection syntax type...
		else if (const IndirectionSyntaxType* indirectionSyntaxType = TypeBinding::DynamicCast<const IndirectionSyntaxType*>(syntaxType))
		{
			// Get our type as a named syntax type
			SyntaxType* referencedType = indirectionSyntaxType->ReferencedType;
			const BoundSyntaxType* boundSyntaxType = TypeBinding::DynamicCast<const BoundSyntaxType*>(referencedType);

			// We're only allowed to refer to a named type
			if (boundSyntaxType == nullptr)
			{
				// The type must not be a named type...
				this->Errors.Raise(location, ErrorCode::ReferencesOnlyToNamedValueTypes, referencedType->ToString().c_str());
				return core.ErrorType;
			}

			// Grab the type it is referring to...
			BoundType* type = this->RetrieveBoundType(boundSyntaxType, location);

			// If the type is not a value type, then we cannot form a reference to it
			if (type->GetCopyMode() == TypeCopyMode::ReferenceType)
			{
				// The ref keyword can only be used to refer to value types
				this->Errors.Raise(location, ErrorCode::ReferencesOnlyToNamedValueTypes, referencedType->ToString().c_str());
				return core.ErrorType;
			}

			// Return the result of attempting to find or create the type from a true type and its qualifiers
			return this->Builder->ReferenceOf(type);
		}
		// If the syntax type is a named syntax type...
		else if (const BoundSyntaxType* boundSyntaxType = TypeBinding::DynamicCast<const BoundSyntaxType*>(syntaxType))
		{
			// Find types by name since it's a data type
			return this->RetrieveBoundType(boundSyntaxType, location);
		}
		// If the syntax type is a delegate syntax type...
		else if (const DelegateSyntaxType* delegateSyntaxType = TypeBinding::DynamicCast<const DelegateSyntaxType*>(syntaxType))
		{
			// Store the return type
			Type* returnType = nullptr;

			// Store all the delegate parameters
			ParameterArray parameters;

			// Loop through all the parameters
			for (size_t i = 0; i < delegateSyntaxType->Parameters.size(); ++i)
			{
				// Get the syntax parameter
				const DelegateSyntaxParameter& syntaxParameter = delegateSyntaxType->Parameters[i];

				// Add the next parameter to the list
				DelegateParameter& parameter = parameters.push_back();
				parameter.Name = syntaxParameter.Name->Token;
				parameter.ParameterType = this->RetrieveType(syntaxParameter.Type, location);
			}

			// Loop through all the returns
			if (delegateSyntaxType->Return != nullptr)
			{
				// Set the return type of the delegate (resolve the proper type)
				returnType = this->RetrieveType(delegateSyntaxType->Return, location);
			}
			else
			{
				// Otherwise, there is no return type (use void)
				returnType = core.VoidType;
			}

			// Return the delegate type after adding or merging into the set
			return this->Builder->GetDelegateType(parameters, returnType);
		}

		// If we stopped here, it means the user referenced a type that wasn't defined
		this->Errors.Raise(location, ErrorCode::ReferenceToUndefinedType, syntaxType->ToString().c_str());

		// We return a special error type because it makes it so we crash less on null pointers
		return core.ErrorType;
	}

	//***************************************************************************
	void Syntaxer::ReadAttributes(SyntaxNode* parentNode, NodeList<AttributeNode>& nodes, Array<Attribute>& attributesOut)
	{
		// Go through all attributes and attach them to the class type
		for (size_t i = 0; i < nodes.size(); ++i)
		{
			// Add each attribute string to the class attributes
			AttributeNode* attributeNode = nodes[i];
			Attribute& attribute = attributesOut.push_back();
			attribute.Name = attributeNode->TypeName->Token;

			// If the attribute node has a function call...
			FunctionCallNode* attributeCall = attributeNode->AttributeCall;
			if (attributeCall != nullptr)
			{
				// To avoid later errors, set the io modes of the function call
				attributeCall->Io = IoMode::ReadRValue;
				attributeCall->IoUsage = IoMode::Ignore;

				// Loop through all the arguments to the function call
				for (size_t i = 0; i < attributeCall->Arguments.size(); ++i)
				{
					// Grab the current argument value
					ExpressionNode* argument = attributeCall->Arguments[i];

					// We only support literals in the attribute arguments
					ValueNode* literalArgument = TypeBinding::DynamicCast<ValueNode*>(argument);

					// If this isn't a literal argument, give an error
					if (literalArgument == nullptr)
						// The number of arguments -must- be the same
						return this->ErrorAt(argument, ErrorCode::AttributeArgumentMustBeLiteral);

					// Just so we don't get any errors complaining later, give this things an io mode
					literalArgument->Io = IoMode::ReadRValue;
					literalArgument->IoUsage = IoMode::Ignore;

					// Add the parameter to the attribute
					AttributeParameter& parameter = attribute.Parameters.push_back();

					// If this argument has a name...
					if (i < attributeCall->ArgumentNames.size())
						parameter.Name = attributeCall->ArgumentNames[i];

					// Store the original token text, just in case the user wants it
					parameter.Token = literalArgument->Value.Token;

					// Check to see what type of literal we have here
					switch (literalArgument->Value.TokenId)
					{
						// The value is an number
					case Grammar::IntegerLiteral:
					case Grammar::DoubleIntegerLiteral:
					case Grammar::RealLiteral:
					case Grammar::DoubleRealLiteral:
					{
						parameter.Type = AttributeType::Number;
						parameter.NumberValue = atof(parameter.Token.c_str());
						break;
					}

					// The value is a String
					case Grammar::StringLiteral:
					{
						parameter.Type = AttributeType::String;
						parameter.StringValue = ReplaceStringEscapesAndStripQuotes(parameter.Token);
						break;
					}

					// The value is a Bool
					case Grammar::True:
					case Grammar::False:
					{
						parameter.Type = AttributeType::Boolean;
						parameter.BooleanValue = (literalArgument->Value.TokenId == Grammar::True);
						break;
					}

					// The value is a null (which means that the type is unknown)
					case Grammar::Null:
					{
						parameter.Type = AttributeType::Null;
						break;
					}

					default:
					{
						// We don't know what type it is???
						// This especially should not be an identifier, since identifiers are caught as VariableReferences
						return ErrorAt(parentNode, ErrorCode::InternalError,
							"The literal in an attribute's argument list was of an unknown token type.");
					}
					}
				}
			}
		}
	}

	//***************************************************************************
	void Syntaxer::SetupClassInstance(ClassNode* node, ClassContext* context)
	{
		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Create the class type
		node->Type = new BoundType(node->Name, node->CopyMode, 0, 0);
		node->Type->SizeState = SizeState::Undetermined;

		// Use the comments as the class description
		String description = node->GetMergedComments();
		node->Type->Description = description;

		// Set the class type's originating location
		node->Type->Location = node->Location;

		// Push this class onto the list of all classes in the context
		context->AllClasses.push_back(node->Type);

		// Add the type to the list of types
		this->Builder->AddRawBoundType(node->Type);

		// Go through all attributes and attach them to the class type
		this->ReadAttributes(node, node->Attributes, node->Type->Attributes);

		// Set whether we're hidden or not (hides us from documentation, auto-complete, etc)
		node->Type->IsHidden = node->Type->HasAttribute(HiddenAttribute);

		// Create a new function for the pre-constructor
		String preConstructorName = String::Format("%s%s", PreConstructorName.c_str(), node->Type->Name.c_str());
		node->PreConstructor = this->Builder->CreateRawFunction(node->Type, preConstructorName, VirtualMachine::ExecuteNext, ParameterArray(), core.VoidType, FunctionOptions::None);

		// Only generate a post-destructor if our class is a reference type
		if (node->Type->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Create the post-destructor for this class
			node->Type->PostDestructor = VirtualMachine::PostDestructor;
		}

		// Add the function to the type's list of functions
		node->Type->PreConstructor = node->PreConstructor;
	}

	//***************************************************************************
	void Syntaxer::CollectTemplateInstantiations(SyntaxNode*& node, ClassContext* context)
	{
		// Get all the types for this node
		SyntaxTypes types;
		node->PopulateSyntaxTypes(types);

		// Instantiate any template types
		this->InstantiateTemplatesFromSyntaxTypes(types, context, node->Location);

		// Continue walking all of this node's children
		context->Walker->GenericWalkChildren(this, node, context);
	}

	//***************************************************************************
	void Syntaxer::InstantiateTemplatesFromSyntaxTypes(SyntaxTypes& types, ClassContext* context, const CodeLocation& location)
	{
		// Loop through all the types
		for (size_t i = 0; i < types.size(); ++i)
		{
			// Get the current type
			SyntaxType* type = *types[i];

			// CHECK THIS LOGIC
			// The first thing we need to do is traverse any sub-types
			// I believe this MUST happen before we try to instantiate templates (makes sense...)
			// otherwise we would try and instantiate a template with incorrect types

			// Get all child types of this type
			SyntaxTypes childTypes;
			type->PopulateSyntaxTypes(childTypes);

			// Traverse those child types and instantiate any templates
			// NOTE: It is very important this happens first
			// If a template type uses templates in it's instantiation (eg Array<Dictionary<Foo, Bar>>)
			// Then we must have instantiated the Dictionary before the Array can complete
			this->InstantiateTemplatesFromSyntaxTypes(childTypes, context, location);

			// If the type is a template instance
			if (type->IsTemplateInstantiation())
			{
				// If the type is a data type
				if (BoundSyntaxType* dataType = TypeBinding::DynamicCast<BoundSyntaxType*>(type))
				{
					// Get the fully qualified template name (unique for this instantiation)
					String fullyQualifiedTemplateName = dataType->ToString();

					// Get the base name of the template
					String baseName = dataType->TypeName;

					// First, look to see if we already instantiated this type...
					if (this->Builder->FindBoundType(fullyQualifiedTemplateName) == nullptr &&
						this->ExternalBoundTypes.findValue(fullyQualifiedTemplateName, nullptr) == nullptr)
					{
						// Check to see if we found the type as a named template
						if (ClassNode* classNode = this->InternalBoundTemplates.findValue(baseName, nullptr))
						{
							// Make sure the exact number of template arguments were given
							if (classNode->TemplateArguments.size() != dataType->TemplateArguments.size())
							{
								// The number of arguments -must- be the same
								return this->ErrorAt
									(
									classNode,
									ErrorCode::InvalidNumberOfTemplateArguments,
									classNode->TemplateArguments.size(),
									dataType->TemplateArguments.size()
									);
							}

							// Clone the class node and everything beneith it
							ClassNode* cloneTree = classNode->Clone();

							// Perform the advanced type replacement for the template
							this->PerformTemplateReplacement(cloneTree, classNode->TemplateArguments, dataType);

							// Tell the class node what type it is an instantiation of (normally null)
							cloneTree->TemplateInstantiation = dataType;

							// Change the name of the class to reflect its template type
							// The data type that we're instantiating it with should be able to represent the new name
							cloneTree->Name = fullyQualifiedTemplateName;

							// Setup the class as an instantiation
							this->SetupClassInstance(cloneTree, context);

							// Add ourselves to the roots. Note this will not be traversed
							// as the walker already grabbed the child list from the root
							ZilchTodo("Make sure we traverse the added class");
							this->Tree->Root->Classes.Add(cloneTree);

							// Now we need to walk the class node we just generated,
							// in case it has other template instantiations/references
							// This isn't exactly 'safe' for the walker, but I know
							// internally how walking works and it will be fine
							context->Walker->Walk(this, cloneTree, context);
						}
						else
						{
							// The resolved type arguments
							Array<Type*> templateInstanceArguments;
							templateInstanceArguments.resize(dataType->TemplateArguments.size());

							// Loop through all the given template instance arguments (the actual types)
							for (size_t i = 0; i < dataType->TemplateArguments.size(); ++i)
							{
								// Get the template argument
								SyntaxType* sytaxType = dataType->TemplateArguments[i];

								// Attempt to retrieve it as a valid type (this should always work...)
								Type* resolvedType = this->RetrieveType(sytaxType, location);

								// Get a reference to the core library
								Core& core = Core::GetInstance();

								// If we got no type back, we failed to instantiate this template
								if (resolvedType == core.VoidType)
								{
									return;
								}

								// Store the type in our array of resolved types...
								templateInstanceArguments[i] = resolvedType;
							}

							// Attempt to instantiate the template
							InstantiatedTemplate instantiatedTemplate = this->Builder->InstantiateTemplate(baseName, templateInstanceArguments, *this->Dependencies);

							// If we failed to instantiate the 
							if (instantiatedTemplate.Result == TemplateResult::FailedNameNotFound)
							{
								// If we got here, it means the user referenced a type that wasn't defined
								// Note that this is the same as in RetrieveNamedType
								return this->Errors.Raise(location, ErrorCode::ReferenceToUndefinedType, fullyQualifiedTemplateName.c_str());
							}
							// If we failed to instantiate the template due to an improper number of arguments...
							else if (instantiatedTemplate.Result == TemplateResult::FailedInvalidArgumentCount)
							{
								// The number of arguments -must- be the same
								//TODO: ExpectedArguments is not currently filled out
								return this->Errors.Raise
									(
									location,
									ErrorCode::InvalidNumberOfTemplateArguments,
									instantiatedTemplate.ExpectedArguments,
									dataType->TemplateArguments.size()
									);
							}
							else if (instantiatedTemplate.Result == TemplateResult::FailedInstantiatorDidNotReturnType)
							{
								// Show an error message
								return this->ErrorAt(classNode, ErrorCode::InternalError,
									"Unable to instantiate template via callback.");
							}

							// Make sure that we got a template type back
							ErrorIf(instantiatedTemplate.Type == nullptr,
								"The template instantiator did not return a failure, but the type was not created");
						}
					}

					// We need to clear and free the nodes that are template arguments since
					// we're replacing this type with an instantiated template type
					for (size_t i = 0; i < dataType->TemplateArguments.size(); ++i)
					{
						// Free all the template argument nodes
						// (what we're instantiating this template with)
						delete dataType->TemplateArguments[i];
						dataType->TemplateArguments[i] = nullptr;
					}

					// Clear out the template arguments and point it to the new class name
					dataType->TemplateArguments.clear();
					dataType->TypeName = fullyQualifiedTemplateName;
				}
				else
				{
					// Error handling
					Error("Unhandled case: A template instance was made for a type we didn't handle");
				}
			}
		}
	}

	//***************************************************************************
	void Syntaxer::PreventDuplicateTypeNames(StringParam name, const CodeLocation& location)
	{
		// Get our own library name (for convenience)
		cstr ourLibraryName = this->Builder->GetName().c_str();

		// Prevent duplicate template type names with the internal project
		ClassNode* foundTemplate = this->InternalBoundTemplates.findValue(name, nullptr);
		if (foundTemplate != nullptr)
			return this->Errors.Raise(location, String(), foundTemplate->Location, ErrorCode::DuplicateTypeName, name.c_str(), ourLibraryName);

		// Prevent duplicate type names with the internal project
		BoundType* foundInternalType = this->Builder->BoundTypes.findValue(name, nullptr);
		if (foundInternalType != nullptr)
		{
			// Give a better error message that tells us where the class was defined
			return this->Errors.Raise(location, String(), foundInternalType->Location, ErrorCode::DuplicateTypeName, name.c_str(), ourLibraryName);
		}

		// Prevent duplicate type names that come from external libraries
		BoundType* foundExternalType = this->ExternalBoundTypes.findValue(name, nullptr);
		if (foundExternalType != nullptr)
		{
			// Give a better error message that tells us where the class was defined
			return this->Errors.Raise(location, String(), foundExternalType->Location, ErrorCode::DuplicateTypeName, name.c_str(), foundExternalType->SourceLibrary->Name.c_str());
		}
	}

	//***************************************************************************
	void Syntaxer::PreventDuplicateMemberNames(BoundType* type, StringParam memberName, const CodeLocation& location, bool isStatic, bool isFunction)
	{
		// Make sure we don't have a property of the same name as this member
		PropertyMap& properties = type->GetPropertyMap(isStatic);
		Property* foundProperty = properties.findValue(memberName, nullptr);
		if (foundProperty != nullptr)
			return this->Errors.Raise(location, String(), foundProperty->Location, ErrorCode::DuplicateMemberName, memberName.c_str());

		// Make sure we don't have a field of the same name as this member
		FieldMap& fields = type->GetFieldMap(isStatic);
		Field* foundField = fields.findValue(memberName, nullptr);
		if (fields.containsKey(memberName))
			return this->Errors.Raise(location, String(), foundField->Location, ErrorCode::DuplicateMemberName, memberName.c_str());

		// Make sure we don't have a function of the same name as this member
		FunctionMultiMap& functionMap = type->GetFunctionMap(isStatic);
		FunctionArray* foundFunctions = functionMap.findPointer(memberName);
		if (foundFunctions != nullptr && foundFunctions->empty() == false)
		{
			// We only really want to show the location of the first function we find (it's really not necessary to show all of them...)
			return this->Errors.Raise(location, ErrorCode::DuplicateMemberName, memberName.c_str());
		}
	}

	//***************************************************************************
	void Syntaxer::CollectClass(ClassNode*& node, ClassContext* context)
	{
		// Error checking
		ErrorIf(node->TemplateInstantiation != nullptr,
			"We should never find any template instantiations");

		// Make sure another class or type of the same name doesn't conflict with ours
		this->PreventDuplicateTypeNames(node->Name, node->Location);
		if (this->Errors.WasError)
			return;

		// If the class type is a template
		if (node->IsTemplate())
		{
			// Add this node to the named templates list
			this->InternalBoundTemplates.insertOrError(node->Name, node);

			// Unlink the parent
			node->Parent = nullptr;
			node = nullptr;
		}
		else
		{
			// Setup the class as an instance
			this->SetupClassInstance(node, context);
		}
	}

	//***************************************************************************
	String EnumToString(const BoundType* type, const byte* data)
	{
		// Get the value of the enum
		Integer inputValue = *(const Integer*)data;

		// Loop through all the properties this type defines...
		const PropertyArray& properties = type->AllProperties;
		for (size_t i = 0; i < properties.size(); ++i)
		{
			// Grab the current property
			Property* property = properties[i];

			// Error checking
			ErrorIf(property->Get == nullptr, "The enum should have no properties that do not have a 'get' function");
			ErrorIf(property->IsStatic == false, "All properties on the enum should be static");

			// If this propertie's UserData matches our enum's value...
			if (property->Get->UserData == (void*)inputValue)
			{
				return property->Name;
			}
		}

		// Otherwise, this enum is not a known value... (just return the integer for readability)
		return IntegerToString(inputValue);
	}

	//***************************************************************************
	String FlagsToString(const BoundType* type, const byte* data)
	{
		// Get the value of the enum
		Integer inputValue = *(const Integer*)data;

		// With every bit we loop through, we mask the bit off
		// At the end, this value should be 0 unless there were invalid bits that we didn't know what they were
		Integer runningValue = inputValue;

		// Create a string builder so we can concatenate all the flags together
		StringBuilder builder;

		// If we wrote anything to the string buffer, then the next time we need to add the '|'
		bool wroteSomething = false;

		// Loop through all the properties this type defines...
		const PropertyArray& properties = type->AllProperties;
		for (size_t i = 0; i < properties.size(); ++i)
		{
			// Grab the current property
			Property* property = properties[i];

			// Error checking
			ErrorIf(property->Get == nullptr, "The flags should have no properties that do not have a 'get' function");
			ErrorIf(property->IsStatic == false, "All properties on the flags should be static");

			// Grab the value of this flag (may be multiple bits!)
			Integer flagValue = (Integer)(DoubleInteger)property->Get->UserData;

			// If we have a flag value of 0 (typically None) then ignore it
			// Otherwise every bitfield when printed would also have None set
			if (flagValue == 0)
				continue;

			// Mask off the bits so we know if there were any invalid bits leftover
			runningValue &= ~flagValue;

			// If the input value contains all these flags...
			if ((inputValue & flagValue) == flagValue)
			{
				// If we've already written anything, we need to add the delimiter (the bitwise OR operator)
				if (wroteSomething)
				{
					builder.Append(" ");
					builder.Append(Grammar::GetKeywordOrSymbol(Grammar::BitwiseOr));
					builder.Append(" ");
				}

				// Append the property name, and note that we've written something now
				// (meaning the next write needs a delimiter)
				builder.Append(property->Name);
				wroteSomething = true;
			}
		}

		// If nothing was written...
		if (wroteSomething == false)
		{
			// Otherwise, this flags is not a known value... (just return the integer for readability)
			return IntegerToString(inputValue);
		}
		else
		{
			// If we have any bits left that weren't accounted for...
			if (runningValue != 0)
			{
				// Show the user the true value
				builder.Append(" (");
				builder.Append(IntegerToString(inputValue));
				builder.Append(")");
			}

			// Return the bits that were set
			return builder.ToString();
		}
	}

	//***************************************************************************
	void Syntaxer::CollectEnum(EnumNode*& node, ClassContext* context)
	{
		// Make sure another class or type of the same name doesn't conflict with ours
		this->PreventDuplicateTypeNames(node->Name, node->Location);
		if (this->Errors.WasError)
			return;

		// Note: Most everything we do in major phases due to type references, member references, or template resolving
		// Enums are simple, and therefore can mostly be handled here (apart from inheritance and code generation)
		node->Type = new BoundType(node->Name, TypeCopyMode::ValueType, sizeof(Integer), 0);

		// Use the comments as the class description
		String description = node->GetMergedComments();
		node->Type->Description = description;

		// Set the class type's originating location
		node->Type->Location = node->Location;

		// Push this class onto the list of all classes in the context
		context->AllClasses.push_back(node->Type);

		// Add the type to the list of types
		this->Builder->AddRawBoundType(node->Type);

		// Go through all attributes and attach them to the enum type
		this->ReadAttributes(node, node->Attributes, node->Type->Attributes);

		// Assume this type is just a regular enum (if it's a 'flags', we will set that below)
		node->Type->SpecialType = SpecialType::Enumeration;
		node->Type->ToStringFunction = EnumToString;

		// The values we assign to any unassigned enum value
		// We automatically count up in value giving each one a
		// unique value, unless the user intervenes
		Integer valueCounter = 0;

		// If this is a flags enum...
		if (node->IsFlags)
		{
			// Flags should always start with 1 (the first bit set)
			valueCounter = 1;
			node->Type->SpecialType = SpecialType::Flags;
			node->Type->ToStringFunction = FlagsToString;
		}

		// Make sure we don't allow two names that are the same
		HashSet<String> uniqueNames;

		// Walk through all the enum values
		for (size_t i = 0; i < node->Values.size(); ++i)
		{
			// Add each attribute string to the class attributes
			EnumValueNode* enumValueNode = node->Values[i];

			// First, check to see if the name is already taken
			if (uniqueNames.contains(enumValueNode->Name))
			{
				// We cannot have two names are the same
				return this->ErrorAt
					(
					enumValueNode,
					ErrorCode::EnumDuplicateValue,
					enumValueNode->Name.c_str(),
					node->Name.c_str()
					);
			}

			// Since the name wasn't taken, add it to the list
			uniqueNames.insert(enumValueNode->Name);

			// If the user actually assigned a value to this entry
			if (enumValueNode->Value != nullptr)
			{
				// Convert the string to an integer value
				valueCounter = atoi(enumValueNode->Value->Token.c_str());
			}

			// Let the enum entry know what it's integral value is
			enumValueNode->IntegralValue = valueCounter;

			// If this is a flags enum...
			if (node->IsFlags)
			{
				// There's a special case where we have a bit flag of zero
				if (valueCounter == 0)
				{
					// Start at a value of 1
					valueCounter = 1;
				}
				else
				{
					// Flags enums jump by powers of 2 for the next enum value
					valueCounter *= 2;
				}
			}
			else
			{
				// Standard enums just increment for the next enum value
				++valueCounter;
			}

			// Create the property using the builder (auto added to our type)
			// Let the CodeGenerator create the getter and setter functions
			// Note: The enum value's type is the enum's type itself
			enumValueNode->IntegralProperty = this->Builder->AddBoundProperty
				(
				node->Type,
				enumValueNode->Name,
				node->Type,
				nullptr,
				LibraryBuilder::NoOperation,
				MemberOptions::Static
				);

			// Set the documentation on the property to be any comments on the value
			enumValueNode->IntegralProperty->Description = enumValueNode->GetMergedComments();
		}
	}

	//***************************************************************************
	void Syntaxer::CollectSendsEvents(SendsEventNode*& node, TypingContext* context)
	{
		// Let the type know which events are sent
		BoundType* classType = context->ClassTypeStack.back();
		SendsEvent& sendsEvent = classType->SendsEvents.push_back();
		sendsEvent.Name = node->Name->Token;
		sendsEvent.ResultType = this->RetrieveType(node->EventType, node->Location);

		// If we encountered an error with getting a type back, early out
		if (this->Errors.WasError)
			return;

		// Get a reference to the core events
		Core& core = Core::GetInstance();

		// Get the extension properties for the events type
		GuidType guid = core.EventsType->Hash();
		PropertyMap& properties = this->Builder->BuiltLibrary->StaticExtensionProperties[guid];

		// Check to see if we do not yet have a property by this name (if we do, we won't bother to create another)
		if (properties.findValue(sendsEvent.Name, nullptr) == nullptr)
		{
			// Create an extension property on the events object so that the event can be accessed by name
			node->EventProperty = this->Builder->AddExtensionProperty
				(
				core.EventsType,
				sendsEvent.Name,
				ZilchTypeId(String),
				nullptr,
				LibraryBuilder::NoOperation,
				MemberOptions::Static
				);

			// Use the comments as the event description
			String comments = node->GetMergedComments();

			// Add in the type that the event declares it sends
			String description = BuildString("Event Type: ", sendsEvent.ResultType->ToString(), ". ", comments);
			node->EventProperty->Description = description;
		}
	}

	//***************************************************************************
	void Syntaxer::CollectClassInheritance(ClassNode*& classNode, TypingContext* context)
	{
		// Walk the class and it's children
		this->PushClass(classNode, context);

		// Iterate through all inherited tokens
		for (SyntaxTypeList::range i = classNode->Inheritance.all(); !i.empty(); i.popFront())
		{
			// Grab the current token
			SyntaxType* syntaxType = i.front();

			// Get the actual inherited type
			Type* inheritedType = this->RetrieveType(syntaxType, classNode->Location);

			// If we had an error, return out early
			if (this->Errors.WasError)
				return;

			// Error checking!
			ErrorIf(inheritedType == nullptr, "Type should be valid");

			// If the type is a class type...
			if (BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(inheritedType))
			{
				// If we have no base class...
				if (classNode->Type->BaseType == nullptr)
				{
					// Store the base type
					classNode->Type->BaseType = boundType;
				}
				else
				{
					// We don't support multiple inheritance
					return this->ErrorAt(classNode, ErrorCode::MultipleInheritanceNotSupported);
				}
			}
			else
			{
				// We only support inheriting from classes (bound types) and interfaces (which we don't have yet!)
				return this->ErrorAt(classNode, ErrorCode::InternalError,
					"We don't yet support inheriting from types other than class/struct/bound types.");
			}
		}
	}

	//***************************************************************************
	void Syntaxer::CollectEnumInheritance(EnumNode*& node, TypingContext* context)
	{
		// Note: We don't really care about walking children here (our only children are enum values)

		// If we have inheritance...
		if (node->Inheritance)
		{
			// Right now we don't support enum inheritance, but we will in the future
			return this->ErrorAt(node, ErrorCode::InternalError,
				"Enum inheritance is not yet supported.");

			//// Get the actual inherited type
			//Type* inheritedType = this->RetrieveType(node->Inheritance, node->Location);

			//// If we had an error, return out early
			//if (this->Errors.WasError)
			//  return;

			//// Error checking!
			//ErrorIf(inheritedType == nullptr, "Type should be valid");
		}

		// Loop through all the handlers
		for (size_t i = 0; i < this->TypeParsedHandlers->size(); ++i)
		{
			// Get the current callback
			const TypeParsedDelegate& handler = (*this->TypeParsedHandlers)[i];

			// Invoke the callback since we found this type
			handler.Callback(*this->Builder, node->Type, node->Location.CodeUserData, handler.UserData);
		}
	}

	//***************************************************************************
	void Syntaxer::SetupGenericFunction(GenericFunctionNode* node, TypingContext* context, String name, FunctionOptions::Enum options, Type* returnType)
	{
		// Get a pointer to the current class type that this function is being implemented in
		BoundType* classType = context->ClassTypeStack.back();

		// Store all the delegate parameters
		ParameterArray delegateParameters;

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Walk through parameters
		NodeList<ParameterNode>::range parameters = node->Parameters.all();
		for (; parameters.empty() == false; parameters.popFront())
		{
			// Get the current parameter
			ParameterNode* parameter = parameters.front();

			// Add the parameter type to the signature (get the type from the parameter node)
			DelegateParameter& delegateParameter = delegateParameters.push_back();
			delegateParameter.Name = parameter->Name;

			// Get the variable's type from the syntax type
			delegateParameter.ParameterType = this->RetrieveType(parameter->ResultSyntaxType, node->Location);
		}

		// Set the function on the node
		node->DefinedFunction = this->Builder->CreateRawFunction(classType, name, VirtualMachine::ExecuteNext, delegateParameters, returnType, options);
		Function* function = node->DefinedFunction;

		// Clear any required stack space (code generator currently re-figures all this out)
		function->RequiredStackSpace = 0;

		// Push the function onto the stack so that children can access it
		// (the top of the stack will be the most relevant function to them)
		context->FunctionStack.push_back(function);

		// Walk all the parameters (which should give them types and generate variables)
		context->Walker->Walk(this, node->Parameters, context);

		// Mark the node as virtual if it is
		function->IsVirtual = (options == FunctionOptions::Virtual);

		// Use the comments as the class description
		String description = node->GetMergedComments();
		function->Description = description;

		// Go through all attributes and attach them to the function
		this->ReadAttributes(node, node->Attributes, function->Attributes);

		// Set whether we're hidden or not (hides us from documentation, auto-complete, etc)
		function->IsHidden = function->HasAttribute(HiddenAttribute);

		// Note that we don't actually bother pushing or popping the function onto a context
		// The reason is because nobody uses it (we don't even traverse children here)
		// The only possiblity is parameter checking, but that still doesn't use the context or parent function

		// If the function is a member function (not a static function)...
		if (options != FunctionOptions::Static)
		{
			// Get the scoped variable from the map
			// Note that it should probably be null (we're just getting a reference to the pointer)
			Variable*& thisVariable = node->ScopedVariables[ThisKeyword];

			// If the variable is not null, that means we somehow ended up with a 'this' variable already defined
			if (thisVariable != nullptr)
				return ErrorAt(node, ErrorCode::InternalError,
				"The variable 'this' was already defined.");

			// Adding the function should have created a this variable (since we're not static)
			thisVariable = function->This;
		}

		// Pop the function from the stack
		context->FunctionStack.pop_back();

		// Finally, set the node type so that we'll know it later
		node->Type = node->DefinedFunction->Type;
	}

	//***************************************************************************
	void Syntaxer::CollectConstructor(ConstructorNode*& node, TypingContext* context)
	{
		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Setup the function generically (this actually creates the compiled function object)
		this->SetupGenericFunction(node, context, ConstructorName, FunctionOptions::None, core.VoidType);

		// Grab the class type
		BoundType* classType = context->ClassTypeStack.back();

		// Add the constructor function to the class list of constructors
		classType->Constructors.push_back(node->DefinedFunction);

		// If we have a base class type but we aren't initializing it...
		BoundType* baseType = classType->BaseType;
		if (baseType != nullptr && node->BaseInitializer == nullptr)
		{
			// It is an error to not initialize our base class
			return ErrorAt(node, ErrorCode::BaseInitializerRequired, classType->Name.c_str(), baseType->Name.c_str());
		}
	}

	//***************************************************************************
	void Syntaxer::CollectDestructor(DestructorNode*& node, TypingContext* context)
	{
		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Setup the function generically (this actually creates the compiled function object)
		this->SetupGenericFunction(node, context, DestructorName, FunctionOptions::None, core.VoidType);

		// Add the constructor function to the class list of constructors
		context->ClassTypeStack.back()->Destructor = node->DefinedFunction;
	}

	//***************************************************************************
	void Syntaxer::CollectFunction(FunctionNode*& node, TypingContext* context)
	{
		// Store the return type
		Type* delegateReturn = nullptr;

		// Loop through all the return values
		if (node->ReturnType != nullptr)
		{
			// Add the return type to the signature
			//HACK (needs to be actually at the return node, maybe syntax types should get locations?)
			delegateReturn = this->RetrieveType(node->ReturnType, node->Location);

			// If we had an error, return out early
			if (this->Errors.WasError)
				return;
		}
		else
		{
			// Get the instance of the type database
			Core& core = Core::GetInstance();

			// There is no return type
			delegateReturn = core.VoidType;
		}

		// Assume no options are on this function
		FunctionOptions::Enum options = FunctionOptions::None;
		ErrorIf(node->IsStatic && node->Virtualized != VirtualMode::NonVirtual,
			"A function cannot be both static and virtual");

		// Static and virtual are mutually exclusive
		if (node->IsStatic)
			options = FunctionOptions::Static;
		else if (node->Virtualized != VirtualMode::NonVirtual)
			options = FunctionOptions::Virtual;

		// Setup the function generically (this actually creates the compiled function object)
		this->SetupGenericFunction(node, context, node->Name, options, delegateReturn);

		// If we had an error, return out early
		if (this->Errors.WasError)
			return;

		// HACK (this shouldn't always be the case due to nested classes and anonymous functions)

		// Add the function to the type's list of functions (checks for static or instance methods)
		BoundType* classType = context->ClassTypeStack.back();
		Function* function = node->DefinedFunction;
		AddMemberResult::Enum addResult = classType->AddRawFunction(function);

		// If an overload of the function already existed with the exact same signature (and name)
		if (addResult == AddMemberResult::AlreadyExists)
		{
			// It is an error to not initialize our base class
			return ErrorAt(node, ErrorCode::OverloadsCannotBeTheSame, function->Name.c_str());
		}
	}

	//***************************************************************************
	void Syntaxer::CollectMemberVariableAndProperty(MemberVariableNode*& node, TypingContext* context)
	{
		// As long as the type is not inferred...
		ErrorIf(node->IsInferred(),
			"Member variables should never have an inferred type (should be checked by the parser)");

		// Store the type on the node (this helps us with byte-code generation later)
		// Essentially, we are decorating the tree :)
		node->ResultType = this->RetrieveType(node->ResultSyntaxType, node->Location);

		// If we had an error, return out early
		if (this->Errors.WasError)
			return;

		// Set the member node's parent class type
		BoundType* classType = context->ClassTypeStack.back();
		node->ParentClassType = classType;

		// Make sure we don't have any other members of the same name
		this->PreventDuplicateMemberNames(classType, node->Name, node->Location, node->IsStatic, false);
		if (this->Errors.WasError)
			return;

		// Any options we want to apply to the creation of a member
		MemberOptions::Flags options = MemberOptions::None;

		// If the variable is a static variable
		if (node->IsStatic)
		{
			options |= MemberOptions::Static;
		}

		// The property we create below (members are properties...)
		Property* property = nullptr;

		// If this node is a property...
		if (node->IsProperty)
		{
			// The function we use to tell the library builder to ignore it (we will build it later)
			BoundFn doNotGenerate = LibraryBuilder::DoNotGenerate;

			// Create the property using the builder
			property = this->Builder->AddBoundProperty(classType, node->Name, node->ResultType, doNotGenerate, doNotGenerate, options);

			// Store the property variable on the node
			node->CreatedProperty = property;
		}
		else
		{
			// If this is a value type (struct) and the member is non-static...
			if (classType->GetCopyMode() == TypeCopyMode::ValueType && node->IsStatic == false)
			{
				// If this member has a complex copy
				if (node->ResultType->IsCopyComplex())
				{
					// A struct is only allowed to contain value types
					return ErrorAt
						(
						node,
						ErrorCode::StructsCanOnlyContainValueTypes,
						classType->Name.c_str(),
						node->Name.c_str()
						);
				}
			}

			// Create the member using the builder
			// The given offset is zero for now (we'll initialize it later when collecting sizes of objects)
			Field* field = this->Builder->AddBoundField(classType, node->Name, node->ResultType, 0, options);
			property = field;

			// Store the member variable on the node
			node->CreatedField = field;
		}

		// Use the comments as the class description
		String description = node->GetMergedComments();
		property->Description = description;

		// Go through all attributes and attach them to the property
		this->ReadAttributes(node, node->Attributes, property->Attributes);

		// Set whether we're hidden or not (hides us from documentation, auto-complete, etc)
		property->IsHidden = property->HasAttribute(HiddenAttribute);

		// Set the location of the property
		property->Location = node->Location;
	}

	//***************************************************************************
	void Syntaxer::CollectPropertyGetSet(MemberVariableNode*& node, TypingContext* context)
	{
		// Note: The first thing we must do is walk the Get/Set functions since whatever member
		//       we create, we want to give it the proper get and set functions

		// If the member has a get
		if (node->Get != nullptr)
		{
			// Walk the get function
			context->Walker->Walk(this, node->Get, context);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;

			// Mark this function as special
			node->Get->DefinedFunction->IsPropertyGetOrSet = true;
			node->Get->DefinedFunction->IsHidden = true;
		}

		// If the member has a set
		if (node->Set != nullptr)
		{
			// Walk the get function
			context->Walker->Walk(this, node->Set, context);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;

			// Mark this function as special
			node->Set->DefinedFunction->IsPropertyGetOrSet = true;
			node->Set->DefinedFunction->IsHidden = true;
		}

		// If this node is a property...
		if (node->IsProperty)
		{
			// Store the get function on the property
			if (node->Get != nullptr)
			{
				// Error checking
				ErrorIf(node->CreatedProperty->Get != nullptr,
					"The property getter should not be set yet (we're generating it)");

				// Point the property's getter at the compiled function
				node->CreatedProperty->Get = node->Get->DefinedFunction;
			}

			// Store the set function on the property
			if (node->Set != nullptr)
			{
				// Error checking
				ErrorIf(node->CreatedProperty->Set != nullptr,
					"The property setter should not be set yet (we're generating it)");

				// Point the property's setter at the compiled function
				node->CreatedProperty->Set = node->Set->DefinedFunction;
			}
		}
	}

	//***************************************************************************
	void Syntaxer::PushClass(ClassNode*& node, TypingContext* context)
	{
		// Push the class onto the stack so that children can access it
		// (the top of the stack will be the most relevant class to them)
		context->ClassTypeStack.push_back(node->Type);

		// Generically walk the children
		context->Walker->GenericWalkChildren(this, node, context);

		// We are exiting this class, so pop it off
		context->ClassTypeStack.pop_back();
	}

	//***************************************************************************
	template <typename FunctionNodeType>
	void Syntaxer::PushFunctionHelper
		(
		FunctionNodeType* node,
		TypingContext* context,
		void (Syntaxer::*postArgs)(FunctionNodeType* node)
		)
	{
		// Push the function onto the stack so that children can access it
		// (the top of the stack will be the most relevant function to them)
		context->FunctionStack.push_back(node->DefinedFunction);

		// Loop through all the parameters
		for (size_t i = 0; i < node->Parameters.size(); ++i)
		{
			// Walk the statements
			context->Walker->Walk(this, node->Parameters[i], context);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;
		}

		// If we have a post arguments function...
		if (postArgs != nullptr)
		{
			// Call the function...
			(this->*postArgs)(node);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;
		}

		// Process the statements inside the function
		this->ProcessScopeStatements(node, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// If not all paths return and we have a return type...
		if (node->AllPathsReturn == false && Type::IsSame(node->Type->Return, core.VoidType) == false)
		{
			// No child statement reported to us that it returned properly
			return ErrorAt(node, ErrorCode::NotAllPathsReturn);
		}

		// We are exiting this function, so pop it off
		context->FunctionStack.pop_back();
	}

	//***************************************************************************
	void Syntaxer::PushFunction(GenericFunctionNode*& node, TypingContext* context)
	{
		return PushFunctionHelper<GenericFunctionNode>(node, context, nullptr);
	}

	//***************************************************************************
	void Syntaxer::PushConstructor(ConstructorNode*& node, TypingContext* context)
	{
		return PushFunctionHelper<ConstructorNode>(node, context, &Syntaxer::CheckInitializerList);
	}

	//***************************************************************************
	void Syntaxer::CheckInitializerList(ConstructorNode* node)
	{
		ZilchTodo("Finish up initializer lists (at least checking if they pass type validation)");
		//DecorateCheckFunctionCall(node, node->BaseInitializer,
		//node->BaseInitializer
	}

	//***************************************************************************
	void Syntaxer::DecorateInitializer(InitializerNode*& node, TypingContext* /*context*/)
	{
		// Mark the node as being read only (we should not be able to change it)
		node->Io = IoMode::ReadRValue;
	}

	//***************************************************************************
	void Syntaxer::DecorateStringInterpolant(StringInterpolantNode*& node, TypingContext* context)
	{
		// Mark the node as being read only
		node->Io = IoMode::ReadRValue;

		// String interpolants always result in a string type
		node->ResultType = ZilchTypeId(String);

		// Walk through all the children we want to stringify
		for (size_t i = 0; i < node->Elements.size(); ++i)
		{
			// Get the current element (it may be a string itself...)
			ExpressionNode* elementNode = node->Elements[i];

			// Make sure we walk the element expression
			context->Walker->Walk(this, elementNode, context);

			// If we had an error, return out early
			if (this->Errors.WasError)
				return;

			// The element expression only needs to be readable
			elementNode->IoUsage = IoMode::ReadRValue;
		}
	}

	//***************************************************************************
	void Syntaxer::DecorateValue(ValueNode*& node, TypingContext* /*context*/)
	{
		// Mark the node as being read only
		node->Io = IoMode::ReadRValue;

		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Check to see what type of literal we have here
		switch (node->Value.TokenId)
		{
			// The value is an Integer
		case Grammar::IntegerLiteral:
		{
			node->ResultType = core.IntegerType;
			break;
		}

		// The value is a DoubleInteger
		case Grammar::DoubleIntegerLiteral:
		{
			node->ResultType = core.DoubleIntegerType;
			break;
		}

		// The value is a Real
		case Grammar::RealLiteral:
		{
			node->ResultType = core.RealType;
			break;
		}

		// The value is a DoubleReal
		case Grammar::DoubleRealLiteral:
		{
			node->ResultType = core.DoubleRealType;
			break;
		}

		// The value is a String
		case Grammar::StringLiteral:
		{
			node->ResultType = core.StringType;
			break;
		}

		// The value is a Bool
		case Grammar::True:
		case Grammar::False:
		{
			node->ResultType = core.BooleanType;
			break;
		}

		// The value is a null (which means that the type is unknown)
		case Grammar::Null:
		{
			// Always assume we're going to be a null handle (implicit cast may change us!)
			node->ResultType = core.NullType;
			break;
		}

		default:
		{
			// We don't know what type it is???
			// This especially should not be an identifier, since identifiers are caught as VariableReferences
			return ErrorAt(node, ErrorCode::InternalError,
				"We reached what should be a value and we have no idea what type it is.");
		}
		}
	}

	//***************************************************************************
	void SetAllIoToReadAndIgnore(SyntaxNode* node)
	{
		// If the current node is an expression...
		ExpressionNode* expression = TypeBinding::DynamicCast<ExpressionNode*>(node);
		if (expression != nullptr)
		{
			// Set the io and usage (technically usage should only be set by the parent, but this is a special case)
			expression->Io = IoMode::ReadRValue;
			expression->IoUsage = IoMode::Ignore;
		}

		// Get all this node's children
		NodeChildren children;
		node->PopulateChildren(children);

		// Loop through all the children and recursively set all their nodes to read only
		for (size_t i = 0; i < children.size(); ++i)
			SetAllIoToReadAndIgnore(*children[i]);
	}

	//***************************************************************************
	void Syntaxer::DecorateCreationInitializer(CreationInitializerNode*& node, TypingContext* context)
	{
		// Mark the node as being read only (we don't ever write directly to this value on the stack)
		// Note that doesn't mean we can't access a value on the type and write to it
		node->Io = IoMode::ReadRValue;

		// Mark all child nodes as using ignoring io access (we know this is generated by us, so it's ok/valid)
		// This should really come before we do anything else, just because member initialization does actually need to write
		SetAllIoToReadAndIgnore(node);

		// Walk the creation initializer (create the node, invoke the constructor...)
		context->Walker->Walk(this, node->LeftOperand, context);

		// If we had an error, return out early
		if (this->Errors.WasError)
			return;

		// Our type is the left operands type
		node->ResultType = node->LeftOperand->ResultType;

		// The creation expression only needs to be readable (always should be!)
		node->LeftOperand->IoUsage = IoMode::ReadRValue;

		// Walk the statements that generate the 'Add' and member initializations
		context->Walker->Walk(this, node->InitializerStatements, context);

		// Even though the code generator won't use these (and our own syntaxer doesn't care)
		// we still traverse the Add and Member initializer nodes for anyone using the tree
		// Technically if there was any error, we should have already seen it in walking 'InitializerStatements'
		context->Walker->Walk(this, node->AddValues, context);
		context->Walker->Walk(this, node->InitailizeMembers, context);
	}

	//***************************************************************************
	void Syntaxer::DecorateCreationCall(CreationCallNode*& node, TypingContext* /*context*/)
	{
		// Mark the node as being read only
		// Note that doesn't mean we can't access a value on the type and write to it
		node->Io = IoMode::ReadRValue;

		// Get the type that is to be created
		node->CreatedType = this->RetrieveBoundType(node->CreatedSyntaxType, node->Location);

		// If the type blocks itself from being created in script...
		if (node->CreatedType->CreatableInScript == false)
		{
			// Let the user know that this type can't be created (even if it has a constructor!)
			return ErrorAt(node, ErrorCode::CannotCreateType, node->CreatedType->ToString().c_str());
		}

		// If we had an error, return out early
		if (this->Errors.WasError)
			return;

		// Get the copy mode of the type we're creating (reference or value type)
		TypeCopyMode::Enum copyMode = node->CreatedType->GetCopyMode();

		// If we're doing a call to 'new', meaning we're making a heap object...
		if (node->Mode == CreationMode::New)
		{
			// If the type is a reference type, we're fine (reference types can only be created with 'new')
			if (copyMode == TypeCopyMode::ReferenceType)
			{
				// The result of the 'new' operation is just the same type
				node->ResultType = node->CreatedType;
			}
			// The type must be a value type, so therefore 'new' will return a reference
			else
			{
				// The result is a reference (indirection) to the created value type
				node->ResultType = this->Builder->ReferenceOf(node->CreatedType);
			}
		}
		// Otherwise, we're making a stack local or member
		else if (node->Mode == CreationMode::Local)
		{
			// If this type is a reference type...
			if (copyMode == TypeCopyMode::ReferenceType)
			{
				// We can only use local to create value types
				return ErrorAt(node, ErrorCode::LocalCreateMustBeValueType, node->CreatedType->ToString().c_str());
			}

			// The result is the same as the created type
			node->ResultType = node->CreatedType;
		}
		else
		{
			// If the type is a reference type, we're fine (reference types can only be created with 'new')
			if (copyMode == TypeCopyMode::ReferenceType)
			{
				// Because it's a reference type, we infer the 'new'
				node->Mode = CreationMode::New;
			}
			// The type must be a value type, so therefore 'new' will return a reference
			else
			{
				// Because it's a value type, we infer the 'local'
				node->Mode = CreationMode::Local;
			}

			// Since we're inferring the result, the result is always just the type itself
			node->ResultType = node->CreatedType;
		}
	}

	//***************************************************************************
	void Syntaxer::DecorateUnnamedOperand(UnnamedOperandNode*& node, TypingContext* context)
	{
		// Forward all parameters that the syntaxer typically handles
		// We have nothing to walk because we have no direct children (we're just a reference)
		node->ResultType = node->ToBeForwarded->ResultType;
		node->Io = node->ToBeForwarded->Io;
		node->IoUsage = node->ToBeForwarded->IoUsage;
		node->IsUsedAsStatement = node->ToBeForwarded->IsUsedAsStatement;
	}

	//***************************************************************************
	void Syntaxer::DecorateTypeId(TypeIdNode*& node, TypingContext* context)
	{
		// Mark the node as being read only
		// Note that doesn't mean we can't access a value on the type and write to it
		node->Io = IoMode::ReadRValue;

		// If we're attempting to get a the type of an expression
		if (node->Value != nullptr)
		{
			// Process the value expression
			context->Walker->Walk(this, node->Value, context);

			// The value expression only needs to be readable
			node->Value->IoUsage = IoMode::ReadRValue;

			// Get the resulting type of the expression
			node->CompileTimeType = node->Value->ResultType;
		}
		// Otherwise, we're getting the typeid of a static type
		else
		{
			// Error checking
			ErrorIf(node->CompileTimeSyntaxType == nullptr, "If the value wasn't parsed, the type should have been!");

			// Just get the type of what they passed in
			node->CompileTimeType = this->RetrieveType(node->CompileTimeSyntaxType, node->Location);

			// If we weren't able to determine the type, then we already threw an error
			if (this->Errors.WasError)
				return;
		}

		// By default the typeid will always something that derives from 'Type'
		node->ResultType = ZilchTypeId(Type);

		// If this is a bound type (enums, flags, normal class/struct types, etc)...
		if (TypeBinding::DynamicCast<BoundType*>(node->CompileTimeType) != nullptr)
		{
			node->ResultType = ZilchTypeId(BoundType);
		}
		// If this is an indirection type...
		else if (TypeBinding::DynamicCast<IndirectionType*>(node->CompileTimeType) != nullptr)
		{
			node->ResultType = ZilchTypeId(IndirectionType);
		}
		// If this is a delegate type...
		else if (TypeBinding::DynamicCast<DelegateType*>(node->CompileTimeType) != nullptr)
		{
			node->ResultType = ZilchTypeId(DelegateType);
		}

		// Error checking / warning
		ErrorIf(node->ResultType == ZilchTypeId(Type),
			"Hitting this case suggests we missed some fundamental leaf type, though this is not critical");
	}

	//***************************************************************************
	void Syntaxer::CheckMemberVariable(MemberVariableNode*& node, TypingContext* context)
	{
		// Get the initial value expression
		ExpressionNode* initialValue = node->InitialValue;

		// Error checking
		ErrorIf(initialValue == nullptr != node->IsProperty,
			"Properties must not have initial values, and data members must have it");

		// If we have an initial value...
		if (initialValue != nullptr)
		{
			// Process the initial value expression
			context->Walker->Walk(this, initialValue, context);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;

			// The initial value only needs to be readable
			initialValue->IoUsage = IoMode::ReadRValue;

			// Check if the types match, or if we can implicitly convert one to our resulting type
			if (this->ImplicitConvertAfterWalkAndIo(node->InitialValue, node->ResultType) == false)
			{
				// The expression assigned to the variable was not of the same type as the variable
				return ErrorAt
					(
					node, ErrorCode::VariableTypeMismatch,
					node->Name.c_str(),
					node->ResultType->ToString().c_str(),
					initialValue->ResultType->ToString().c_str()
					);
			}
		}

		// Process the get function if we have it
		if (node->Get != nullptr)
		{
			context->Walker->Walk(this, node->Get, context);
		}

		// Process the set function if we have it
		if (node->Set != nullptr)
		{
			context->Walker->Walk(this, node->Set, context);
		}
	}

	//***************************************************************************
	void Syntaxer::CheckLocalVariable(LocalVariableNode*& node, TypingContext* context)
	{
		// Note: This extends to both local variables AND parameters
		//       (hence checking for a possibly missing initial value)

		// Get the initial value expression
		ExpressionNode* initialValue = node->InitialValue;

		// If we have an initial value...
		if (initialValue != nullptr)
		{
			// Process the initial value expression
			context->Walker->Walk(this, initialValue, context);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;

			// The initial value only needs to be readable
			initialValue->IoUsage = IoMode::ReadRValue;
		}

		// A parent that use temporarily for traversing
		ScopeNode* scope = TypeBinding::DynamicCast<ScopeNode*>(node->Parent);
		SyntaxNode* currentParent = scope;

		// Loop through our scope parents until we hit the root
		do
		{
			// Grab the current scope
			ScopeNode* currentScope = TypeBinding::DynamicCast<ScopeNode*>(currentParent);

			// Make sure we have no variables defined in our parent scope
			// (or any parent of that) with the same exact name
			if (currentScope != nullptr && currentScope->ScopedVariables.containsKey(node->Name))
			{
				// We encountered a variable of the same name
				return ErrorAt(node, ErrorCode::DuplicateLocalVariableName, node->Name.c_str());
			}

			// Get our parent's parent as a scope node
			currentParent = currentParent->Parent;
		} while (currentParent != nullptr);

		// Add the variable to the current function that we're working on
		Function* function = context->FunctionStack.back();
		Variable* variable = this->Builder->CreateRawVariable(function, node->Name);

		// Try to insert the variable into the scope, but if we fail...
		// There should NEVER be an error here since we checked above (or something really bad happened)
		scope->ScopedVariables.insertOrError(variable->Name, variable);

		// Store the variable information
		node->CreatedVariable = variable;

		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// If the variable's type is inferred...
		if (node->IsInferred() == true)
		{
			// Error checking
			ErrorIf(initialValue == nullptr, "The initial value of a local variable was null");
			ErrorIf(initialValue->ResultType == nullptr, "The initial value's type was null");

			// Set the variable's type to the initial value's type
			variable->ResultType = initialValue->ResultType;
		}
		else
		{
			// Get the variables type from the syntax type
			variable->ResultType = this->RetrieveType(node->ResultSyntaxType, node->Location);

			// If we weren't able to determine the type, then we already threw an error
			if (this->Errors.WasError)
				return;

			// If we have an initial value...
			if (initialValue != nullptr)
			{
				// We need to check for cases where the result types could be null
				if (this->Errors.TolerantMode)
				{
					// If the variable was not able to resolve its type...
					if (variable->ResultType == nullptr)
					{
						// Lets just try and assume the type will be our initial value type, if it works?
						if (initialValue->ResultType != nullptr)
						{
							// This is actually similar to how we infer local variable types
							variable->ResultType = initialValue->ResultType;
						}
						else
						{
							// Otherwise, we have nothing better to assume this type is
							// Just make it void so it won't crash later
							variable->ResultType = core.ErrorType;
						}
					}

					// If for some reason the initial value has no type...
					if (initialValue->ResultType == nullptr)
					{
						// Lets assume the initial value type will be the variable's type!
						initialValue->ResultType = variable->ResultType;
					}
				}

				// Check if the types match, or if we can implicitly convert one to our resulting type
				if (this->ImplicitConvertAfterWalkAndIo(node->InitialValue, variable->ResultType) == false)
				{
					// The expression assigned to the variable was not of the same type as the variable
					return ErrorAt
						(
						node, ErrorCode::VariableTypeMismatch,
						variable->Name.c_str(),
						variable->ResultType->ToString().c_str(),
						initialValue->ResultType->ToString().c_str()
						);
				}
			}
		}
	}

	//***************************************************************************
	void Syntaxer::CheckDelete(DeleteNode*& node, TypingContext* context)
	{
		// Process the deleted object expression
		context->Walker->Walk(this, node->DeletedObject, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// The handle we're deleting needs to be readable (so we can read the handle's value)
		// For example, it cannot be a 'set' only property that we are deleting
		node->DeletedObject->IoUsage = IoMode::ReadRValue;

		// The type of the deleted object has to at least be a reference
		if (Type::IsHandleType(node->DeletedObject->ResultType) == false)
		{
			return this->ErrorAt(node->DeletedObject, ErrorCode::DeletingNonReferenceType);
		}
	}

	//***************************************************************************
	void Syntaxer::CheckThrow(ThrowNode*& node, TypingContext* context)
	{
		// Process the exception expression
		context->Walker->Walk(this, node->Exception, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// The value we're throwing needs to be readable
		node->Exception->IoUsage = IoMode::ReadRValue;

		// Grab the core library so we can use the exception type
		Core& core = Core::GetInstance();

		// Get the exception type as a bound type (it must be!)
		BoundType* exceptionType = TypeBinding::DynamicCast<BoundType*>(node->Exception->ResultType);

		// First, we need to check if the type is even a bound type (if not, it can't be thrown!)
		if (exceptionType == nullptr)
		{
			return this->ErrorAt(node->Exception, ErrorCode::ThrowTypeMustDeriveFromException);
		}

		// The type of the exception expression must derive from the core 'Exception' type
		if (TypeBinding::IsA(exceptionType, core.ExceptionType) == false)
		{
			return this->ErrorAt(node->Exception, ErrorCode::ThrowTypeMustDeriveFromException);
		}

		// Mark the parent scope as being a full return (nothing executes after a throw, much like a return)
		this->MarkParentScopeAsAllPathsReturn(node->Parent, false);
	}

	//***************************************************************************
	void Syntaxer::ProcessScopeStatements(ScopeNode* node, TypingContext* context)
	{
		// Loop through all the statements
		// Note: If any of the statements are a return value, it will set 'AllPathsReturn' for this node
		for (size_t i = 0; i < node->Statements.size(); ++i)
		{
			// If we hit a point where all code paths return,
			// yet we still have a statement left to parse...
			if (node->AllPathsReturn && node->IsDebugReturn == false)
			{
				// Statements after this point will never be reached!
				return ErrorAt(node->Statements[i], ErrorCode::StatementsWillNotBeExecutedEarlyReturn);
			}

			// Get the current statement
			StatementNode* statement = node->Statements[i];

			// Walk the statements
			context->Walker->Walk(this, statement, context);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;

			// Check if the statement is an expression
			ExpressionNode* expression = TypeBinding::DynamicCast<ExpressionNode*>(statement);

			// If the node was an expression node...
			if (expression != nullptr)
			{
				// We mark every expression statement as having an
				// ignored IO usage, we don't care if it's read/write!
				expression->IoUsage = IoMode::Ignore;
			}
		}
	}

	//***************************************************************************
	// Check the condition and statements in a conditional loop
	void Syntaxer::CheckConditionalLoop(ConditionalLoopNode* node, TypingContext* context)
	{
		// Process the initial value expression
		context->Walker->Walk(this, node->Condition, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// We need to be able to read the conditional value
		node->Condition->IoUsage = IoMode::ReadRValue;

		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Now that we've walked the condition, check to make sure it's a bool type
		Type* conditionType = node->Condition->ResultType;
		if (Type::IsSame(conditionType, core.BooleanType) == false)
		{
			// The condition was not a bool
			return ErrorAt
				(
				node->Condition,
				ErrorCode::ConditionMustBeABooleanType,
				conditionType->ToString().c_str()
				);
		}

		// Process all the statements inside the conditional loop
		this->ProcessScopeStatements(node, context);
	}

	//***************************************************************************
	void Syntaxer::CheckWhile(WhileNode*& node, TypingContext* context)
	{
		return CheckConditionalLoop(node, context);
	}

	//***************************************************************************
	void Syntaxer::CheckDoWhile(DoWhileNode*& node, TypingContext* context)
	{
		return CheckConditionalLoop(node, context);
	}

	//***************************************************************************
	void Syntaxer::CheckFor(ForNode*& node, TypingContext* context)
	{
		// If we have a range variable (only used in foreach)
		if (node->RangeVariable != nullptr)
		{
			// Process the variable
			context->Walker->Walk(this, node->RangeVariable, context);
		}

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// If we have a variable...
		if (node->ValueVariable != nullptr)
		{
			// Process the variable
			context->Walker->Walk(this, node->ValueVariable, context);
		}
		// Otherwise, we assume that we have an initialization expression
		else if (node->Initialization != nullptr)
		{
			// Process the initialization expression
			context->Walker->Walk(this, node->Initialization, context);

			// When using an initialization expression, we never need to either read or write from in
			// In that regard, we completely ignore however the user decides to use it
			node->Initialization->IoUsage = IoMode::Ignore;
		}

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Process the iterator expression
		context->Walker->Walk(this, node->Iterator, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// The iterator expression must be a readable one
		node->Iterator->IoUsage = IoMode::ReadRValue;

		// Now we want to check the condition
		return CheckConditionalLoop(node, context);
	}

	//***************************************************************************
	void Syntaxer::CheckLoop(LoopNode*& node, TypingContext* context)
	{
		// Process all the statements inside the loop
		this->ProcessScopeStatements(node, context);
	}

	//***************************************************************************
	void Syntaxer::CheckScope(ScopeNode*& node, TypingContext* context)
	{
		// Process all the statements inside the scope
		this->ProcessScopeStatements(node, context);
	}

	//***************************************************************************
	void Syntaxer::CheckTimeout(TimeoutNode*& node, TypingContext* context)
	{
		// Process all the statements inside the scope
		this->ProcessScopeStatements(node, context);
	}

	//***************************************************************************
	void Syntaxer::CheckIfRoot(IfRootNode*& node, TypingContext* context)
	{
		// Walk all the parts of the if statement
		context->Walker->GenericWalkChildren(this, node, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// We got a completely empty if statement (probably an if with no body), just early out
		if (this->Errors.TolerantMode && node->IfParts.empty())
			return;

		// Check if we have a standalone else statement (only logical when we have at least 2 parts of the if)
		bool hasNonConditionalElse = (node->IfParts.back()->Condition == nullptr);

		// If we have a non-conditional else, then it's possible that all paths of the if statement return from the function (or throw, etc)
		if (hasNonConditionalElse)
		{
			// We want to know if all the if parts of our if statement return, and if any of them are a debug return
			bool allIfPartsReturn = true;
			bool anyDebugReturns = false;

			// If any of the children are 'debug returns' then we mark all returns as being debug returns
			for (size_t i = 0; i < node->IfParts.size(); ++i)
			{
				// Grab the current part of the if statement
				IfNode* part = node->IfParts[i];

				// If we encounter any part of the if statement that doesn't return, then not all paths return!
				if (part->AllPathsReturn == false)
				{
					// Early out, no need to check anything else
					allIfPartsReturn = false;
					break;
				}

				// We just want to know if any if statement 
				anyDebugReturns |= part->IsDebugReturn;
			}

			// If we found that all of our if parts return...
			if (allIfPartsReturn)
			{
				// Inform our parent that all the paths return
				this->MarkParentScopeAsAllPathsReturn(node->Parent, anyDebugReturns);
			}
		}
	}

	//***************************************************************************
	void Syntaxer::CheckIf(IfNode*& node, TypingContext* context)
	{
		// If we have a condition...
		if (node->Condition != nullptr)
		{
			// Process the initial value expression
			context->Walker->Walk(this, node->Condition, context);

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;

			// We need to be able to read the conditional value
			node->Condition->IoUsage = IoMode::ReadRValue;

			// Get the instance of the type database
			Core& core = Core::GetInstance();

			// Now that we've walked the condition, check to make sure it's a bool type
			Type* conditionType = node->Condition->ResultType;
			if (Type::IsSame(conditionType, core.BooleanType) == false)
			{
				// The condition was not a bool
				return ErrorAt
					(
					node->Condition,
					ErrorCode::ConditionMustBeABooleanType,
					conditionType->ToString().c_str()
					);
			}
		}

		// Process all the statements inside the if
		this->ProcessScopeStatements(node, context);
	}

	//***************************************************************************
	LoopScopeNode* Syntaxer::FindLoopScope(size_t scopeCount, SyntaxNode* parent)
	{
		// Loop until we reach the root (we never should actually...)
		while (parent != nullptr)
		{
			// We want to stop if we hit a function node
			if (TypeBinding::IsA(parent->ZilchGetDerivedType(), ZilchTypeId(FunctionNode)))
			{
				// We did not find it
				return nullptr;
			}

			// If we hit some kind of breakable scope, then decrement the scope counter
			LoopScopeNode* loopScope = TypeBinding::DynamicCast<LoopScopeNode*>(parent);
			if (loopScope != nullptr)
			{
				// Decrement the counter
				--scopeCount;

				// If the counter hits zero, we found the loop we wish to break out of
				if (scopeCount == 0)
				{
					// Return the found loop scope
					return loopScope;
				}
			}

			// Iterate to the parent node
			parent = parent->Parent;
		}

		// We did not find the node
		Error("We actually shouldn't be able to get here, since we should at least hit a class node");
		return nullptr;
	}

	//***************************************************************************
	void Syntaxer::CheckBreak(BreakNode*& node, TypingContext* /*context*/)
	{
		// Attempt to find the scope we're supposed to break out of
		LoopScopeNode* scope = FindLoopScope(node->ScopeCount, node->Parent);

		// If we found that scope
		if (scope != nullptr)
		{
			// Add ourselves to a break
			scope->Breaks.push_back(node);
		}
		else
		{
			// Error, we didn't find it
			return ErrorAt(node, ErrorCode::BreakLoopNotFound);
		}
	}

	//***************************************************************************
	void Syntaxer::CheckContinue(ContinueNode*& node, TypingContext* /*context*/)
	{
		// Attempt to find the scope we're supposed to break out of
		LoopScopeNode* scope = FindLoopScope(1, node->Parent);

		// If we found that scope
		if (scope != nullptr)
		{
			// Add ourselves to a break
			scope->Continues.push_back(node);
		}
		else
		{
			// Error, we didn't find it
			return ErrorAt(node, ErrorCode::ContinueLoopNotFound);
		}
	}

	//***************************************************************************
	void Syntaxer::ResolveLocalVariableReference(LocalVariableReferenceNode*& node, TypingContext* /*context*/)
	{
		// We can both read and write to local variables
		node->Io = (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue);

		// Get the parent node (we'll also use this for iteration up the nodes)
		SyntaxNode* parent = node->Parent;

		// Loop until we reach the root (or something else below breaks us out)
		while (parent != nullptr)
		{
			// Check if our parent is a scope
			ScopeNode* scopedParent = TypeBinding::DynamicCast<ScopeNode*>(parent);

			// If it is indeed a scope...
			if (scopedParent != nullptr)
			{
				// Loop through all the variables at that scope
				for (size_t i = 0; i < scopedParent->ScopedVariables.size(); ++i)
				{
					// Get the current variable
					VariableRange range = scopedParent->ScopedVariables.find(node->Value.Token);

					// If we have a match with the variable's name...
					if (range.empty() == false)
					{
						// Get a pointer to the variable info
						Variable* variable = range.front().second;

						// Copy over the value, the node the identifier is referencing, and the type
						node->Access.Type = OperandType::Local;
						node->AccessedVariable = variable;
						node->ResultType = variable->ResultType;
						return;
					}
				}
			}

			// Iterate to the next parent
			parent = parent->Parent;
		}

		// An identifier was used, but we couldn't find the variable it was referencing!
		return ErrorAt
			(
			node,
			ErrorCode::LocalVariableReferenceNotFound,
			node->Value.Token.c_str()
			);
	}

	//***************************************************************************
	void Syntaxer::MarkParentScopeAsAllPathsReturn(SyntaxNode* parent, bool isDebugReturn)
	{
		// After we've actually checked the return is valid
		// Loop up the parents until we reach a scope node or the root
		while (parent != nullptr)
		{
			// Check if our parent is a scope
			ScopeNode* scopedParent = TypeBinding::DynamicCast<ScopeNode*>(parent);

			// If it is indeed a scope...
			if (scopedParent != nullptr)
			{
				// We hit a return statement, so this scope must return
				scopedParent->AllPathsReturn = true;

				// Debug return bubbles up
				scopedParent->IsDebugReturn |= isDebugReturn;
				return;
			}

			// Iterate to the next parent
			parent = parent->Parent;
		}

		// Error checking
		Error("We should never reach the root node!");
	}

	//***************************************************************************
	bool Syntaxer::ImplicitConvertAfterWalkAndIo(ExpressionNode*& nodeToReparent, Type* toType)
	{
		// We're casting from the original type of the node that we're re-parenting
		Type* fromType = nodeToReparent->ResultType;

		// First we need to see what kind of cast operation we're dealing with
		Shared& shared = Shared::GetInstance();
		CastOperator cast = shared.GetCastOperator(fromType, toType);

		// If there is no cast operator or it's not implicit, return that we can't do it!
		if (cast.IsValid == false || cast.CanBeImplicit == false)
			return false;

		// If the cast is a 'raw' cast, then there's nothing to do!
		// This means it is valid cast, but we don't actually need to generate a type cast node since no code-gen is required
		if (cast.RequiresCodeGeneration == false)
			return true;

		// Create the type cast node (our main operand is the given node, we are re-parenting the cast)
		TypeCastNode* typeCast = new TypeCastNode();
		typeCast->Operand = nodeToReparent;
		typeCast->OperatorInfo = cast;
		typeCast->Location = nodeToReparent->Location;

		// The result type is the type we're casting to in the type cast operation
		typeCast->ResultType = toType;

		// A type cast only requires read ability from the operand
		typeCast->Io = IoMode::ReadRValue;

		// We inherit whatever type of Io we applied to the node itself (typically just Read)
		typeCast->IoUsage = nodeToReparent->IoUsage;
		typeCast->IsUsedAsStatement = false;

		// Finally, perform the re-parenting
		nodeToReparent = typeCast;

		// We performed the implicit cast
		return true;
	}

	//***************************************************************************
	void Syntaxer::CheckReturn(ReturnNode*& node, TypingContext* context)
	{
		// Get the function on the top of the stack
		Function* function = context->FunctionStack.back();

		// Get the return type for convenience
		Type* returnType = function->Type->Return;

		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// If we have a return type for this function...
		if (Type::IsSame(returnType, core.VoidType) == false)
		{
			// As long as we have an actual return value
			if (node->ReturnValue != nullptr)
			{
				// Process the return value expression
				context->Walker->Walk(this, node->ReturnValue, context);

				// If an error occurred, exit out
				if (this->Errors.WasError)
					return;

				// We need to be able to read the value we're returning
				node->ReturnValue->IoUsage = IoMode::ReadRValue;

				// Check if the types match, or if we can implicitly convert one to our resulting type
				if (this->ImplicitConvertAfterWalkAndIo(node->ReturnValue, returnType) == false)
				{
					// The return values given did not match the function signature
					return ErrorAt
						(
						node,
						ErrorCode::ReturnTypeMismatch,
						node->ReturnValue->ResultType->ToString().c_str(),
						returnType->ToString().c_str()
						);
				}
			}
			else
			{
				// The return value was not found
				return ErrorAt(node, ErrorCode::ReturnValueNotFound, returnType->ToString().c_str());
			}
		}
		else
		{
			// As long as we have an actual return value
			if (node->ReturnValue != nullptr)
			{
				// A return value was given, but was totally not expected
				return ErrorAt
					(
					node,
					ErrorCode::ReturnValueUnexpected,
					node->ReturnValue->ResultType->ToString().c_str());
			}
		}

		// Mark the parent scope as being a full return (since this is a return!)
		this->MarkParentScopeAsAllPathsReturn(node->Parent, node->IsDebugReturn);
	}

	//***************************************************************************
	void Syntaxer::DecorateCheckTypeCast(TypeCastNode*& node, TypingContext* context)
	{
		// The result of a type cast will always be read only
		node->Io = IoMode::ReadRValue;

		// Get the actual type definition associated with the type-cast
		node->ResultType = this->RetrieveType(node->Type, node->Location);

		// If for some reason the type was not resolved, exit out
		if (this->Errors.WasError)
			return;

		// Now we need to traverse the expression!
		context->Walker->Walk(this, node->Operand, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// The operand only needs to be readable
		node->Operand->IoUsage = IoMode::ReadRValue;

		// Rename the types for convenience
		Type* fromType = node->Operand->ResultType;
		Type* toType = node->ResultType;

		// Figure out what kind of cast this is
		Shared& shared = Shared::GetInstance();
		node->OperatorInfo = shared.GetCastOperator(fromType, toType);

		// If the cast was not valid any way we tried it...
		if (node->OperatorInfo.IsValid == false)
		{
			// Inform the user that the types they were attempting to cast between are not valid
			return ErrorAt
				(
				node,
				ErrorCode::InvalidTypeCast,
				fromType->ToString().c_str(),
				toType->ToString().c_str()
				);
		}
	}

	//***************************************************************************
	void Syntaxer::DecorateCheckFunctionCall(FunctionCallNode*& node, TypingContext* context)
	{
		// For right now, all function calls will result in a read only
		// (note that when we get references properly working, this won't be the case)
		node->Io = IoMode::ReadRValue;

		// Process the left expression first
		context->Walker->Walk(this, node->LeftOperand, context);

		// The left hand node only needs to be readable
		node->LeftOperand->IoUsage = IoMode::ReadRValue;

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Loop through all the arguments
		for (size_t i = 0; i < node->Arguments.size(); ++i)
		{
			// Get the current argument
			ExpressionNode* argument = node->Arguments[i];

			// Walk the arguments so they get properly typed
			context->Walker->Walk(this, argument, context);

			// The arguments only need to be readable
			argument->IoUsage = IoMode::ReadRValue;

			// If an error occurred, exit out
			if (this->Errors.WasError)
				return;
		}

		// Tells us if we already resolved the function and therefore checked parameter types
		bool resolvedAndChecked = false;

		// If the left hand node is a creation call node (basically is this a constructor?)...
		if (CreationCallNode* creationNode = TypeBinding::DynamicCast<CreationCallNode*>(node->LeftOperand))
		{
			// Our resulting type should be the same as the creation call's type
			node->ResultType = creationNode->ResultType;

			// Attempt to find the overloaded functions with the matching name...
			BoundType* createdType = creationNode->CreatedType;

			// Walk up the base class chain until we find any constructors (we inherit constructors)
			// We start with the current class we're trying to create
			// Note: We can safely look up to our base classes because if we don't have a constructor
			// then we at least have been pre-constructed, and the user opted to not initialize anything with a constructor
			const FunctionArray* constructors = createdType->GetOverloadedInheritedConstructors();

			// If there is only one overload of the function, then we know its type!
			if (constructors != nullptr && constructors->empty() == false)
			{
				// Resolve the overload
				bool result = Overload::ResolveAndImplicitConvert(constructors, creationNode->ConstructorFunction, *node);

				// If the overload failed to be resolved... we need to throw an error
				if (result == false)
				{
					// Give a details report of the error
					return Overload::ReportError(this->Errors, node->Location, constructors, *node);
				}

				// If we got here, it means we successfully resolved the overload and checked it
				resolvedAndChecked = true;
			}
			else
			{
				// It is always an error if we have no constructors
				return ErrorAt(node, ErrorCode::NoConstructorsProvided, createdType->ToString().c_str());
			}
		}
		// If the left hand node is a base class initializer
		else if (InitializerNode* initializerNode = TypeBinding::DynamicCast<InitializerNode*>(node->LeftOperand))
		{
			// As long as this is a base class initializer...
			if (initializerNode->InitializerType->TokenId == Grammar::Base)
			{
				// Get a reference to the core library
				Core& core = Core::GetInstance();

				// We have no resulting type for this call
				node->ResultType = core.VoidType;

				// We should always be able to assume that an initializer is ONLY being called from the class it is within
				BoundType* classType = context->ClassTypeStack.front();
				BoundType* baseType = classType->BaseType;

				// Make sure the class type has a base class
				if (baseType == nullptr)
				{
					// It is an error to use a base class initializer without a base class
					return ErrorAt
						(
						node,
						ErrorCode::BaseClassInitializerRequiresBaseClassInheritance,
						classType->Name.c_str()
						);
				}

				// Walk up the base class chain until we find any constructors (we inherit constructors)
				// We start with the current class we're trying to create
				// Note: We can safely look up to our base classes because if we don't have a constructor
				// then we at least have been pre-constructed, and the user opted to not initialize anything with a constructor
				const FunctionArray* constructors = baseType->GetOverloadedInheritedConstructors();

				// If there is only one overload of the function, then we know its type!
				if (constructors != nullptr && constructors->empty() == false)
				{
					// Resolve the overload
					bool result = Overload::ResolveAndImplicitConvert(constructors, initializerNode->InitializerFunction, *node);

					// If the overload failed to be resolved... we need to throw an error
					if (result == false)
					{
						// Give a details report of the error
						return Overload::ReportError(this->Errors, node->Location, constructors, *node);
					}

					// Set the resulting type (the function on the node should now be valid)
					initializerNode->ResultType = initializerNode->InitializerFunction->Type;

					// If we got here, it means we successfully resolved the overload and checked it
					resolvedAndChecked = true;
				}
				else
				{
					// It is always an error if we have no constructors
					return ErrorAt(node, ErrorCode::NoConstructorsProvided, baseType->ToString().c_str());
				}
			}
			else
			{
				// We need to handle 'this' constructor calling
				ZilchTodo("Handle constructor calling");
				Error("We don't currently handle constructor calling");
			}
		}
		// Otherwise, it's something else (like a direct function call, a delegate call, or an error)
		else
		{
			// If the left hand node is a member access node...
			// Otherwise, it could just be a delegate type!
			if (MemberAccessNode* functionMember = TypeBinding::DynamicCast<MemberAccessNode*>(node->LeftOperand))
			{
				// As long as the member access type is a functino
				if (functionMember->MemberType == MemberAccessType::Function)
				{
					// Resolve the overload
					bool result = Overload::ResolveAndImplicitConvert(functionMember->OverloadedFunctions, functionMember->AccessedFunction, *node);

					// If the overload failed to be resolved... we need to throw an error
					if (result == false)
					{
						// Give a details report of the error
						return Overload::ReportError(this->Errors, node->Location, functionMember->OverloadedFunctions, *node);
					}

					// Set the resulting type
					functionMember->ResultType = functionMember->AccessedFunction->Type;

					// If we got here, it means we successfully resolved the overload and checked it
					resolvedAndChecked = true;
				}
			}

			// Attempt to get the left operand's type as a function type (signature)
			DelegateType* delegateType = TypeBinding::DynamicCast<DelegateType*>(node->LeftOperand->ResultType);

			// If the left hand side was not a delegate type...
			if (delegateType == nullptr)
			{
				// We're trying to invoke a function on something that isn't a function, like "5()"
				return ErrorAt(node, ErrorCode::FunctionCallOnNonCallableType);
			}

			// Note: I believe this got removed in error but we STILL need to check against
			// the delegate type IF we did not need to do overload resolution, as an example, invoking a stored delegate
			// We never want to run this twice due to double implicit conversion issues
			if (resolvedAndChecked == false && Overload::TestCallAndImplicitConvert(delegateType, *node) == false)
			{
				// Report and error that we failed to resolve against the delegate
				return Overload::ReportSingleError(this->Errors, node->Location, delegateType, *node);
			}

			// The "type" of the function call will be the type that it resolves to,
			// basically the return type of the function it's evaluating
			node->ResultType = delegateType->Return;
		} // Not a creation call
	}

	//***************************************************************************
	void Syntaxer::DecorateCheckBinaryOperator(BinaryOperatorNode*& node, TypingContext* context)
	{
		// Process all the left expression
		context->Walker->Walk(this, node->LeftOperand, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Process all the right expression
		context->Walker->Walk(this, node->RightOperand, context);

		// The right hand node only needs to be readable (in all cases, assignment, addition, etc)
		node->RightOperand->IoUsage = IoMode::ReadRValue;

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Get the instance of the type database
		Core& core = Core::GetInstance();
		Type* lhs = node->LeftOperand->ResultType;
		Type* rhs = node->RightOperand->ResultType;

		// Get the shared database and lookup the binary operator
		Shared& shared = Shared::GetInstance();
		node->OperatorInfo = shared.GetBinaryOperator(lhs, rhs, node->Operator->TokenId);

		// If we actually found a valid operator...
		if (node->OperatorInfo.IsValid)
		{
			// Note: Since an implicit cast of the left operand would change the node type, we must set the io-usage
			// BEFORE we perform the implicit cast. Also note that an implicit cast of the left argument should never
			// occur if the io usage is an l-value (that wouldn't make sense, GetBinaryOperator blocks these)
			// Output the result type and outmode
			node->ResultType = node->OperatorInfo.Result;
			node->LeftOperand->IoUsage = node->OperatorInfo.Io;

			// We already visited the left/right operands, which means its valid for us to generate any implicit type casts here
			// Check to see if we need to cast the left side
			if (node->OperatorInfo.CastLhsTo != nullptr)
			{
				// Apply the implicit conversion
				bool implicitCastResult = ImplicitConvertAfterWalkAndIo(node->LeftOperand, node->OperatorInfo.CastLhsTo);
				ErrorIf(implicitCastResult == false, "The operator told us that we could implicit cast, why did this fail?");
			}

			// Check to see if we need to cast the right side
			if (node->OperatorInfo.CastRhsTo != nullptr)
			{
				// Apply the implicit conversion
				bool implicitCastResult = ImplicitConvertAfterWalkAndIo(node->RightOperand, node->OperatorInfo.CastRhsTo);
				ErrorIf(implicitCastResult == false, "The operator told us that we could implicit cast, why did this fail?");
			}

			// Our usage is always the most restrictive of how the node designates
			// it can be used and how our operator designates it can be used
			node->Io = (IoMode::Enum)(node->LeftOperand->Io & node->LeftOperand->IoUsage);
		}
		else
		{
			// Report an error since we used two types that weren't of the same type!
			return ErrorAt(node, ErrorCode::InvalidBinaryOperation,
				node->Operator->Token.c_str(),
				Grammar::GetName(node->Operator->TokenId).c_str(),
				lhs->ToString().c_str(),
				rhs->ToString().c_str());
		}
	}

	//***************************************************************************
	void Syntaxer::DecorateCheckPropertyDelegateOperator(PropertyDelegateOperatorNode*& node, TypingContext* context)
	{
		// Process all the operand
		context->Walker->Walk(this, node->Operand, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Attempt to get the operand as a member access node...
		// This operator only works on properties and members
		MemberAccessNode* memberNode = TypeBinding::DynamicCast<MemberAccessNode*>(node->Operand);

		// If the operand is a member
		if (memberNode != nullptr)
		{
			// We only care if we accessed a property
			Property* property = nullptr;

			// If the member is a property...
			if (memberNode->AccessedProperty != nullptr)
			{
				property = memberNode->AccessedProperty;
			}
			// If the member is a straight data field (which is also a property!)
			else if (memberNode->AccessedField != nullptr)
			{
				property = memberNode->AccessedField;
			}

			// If we didn't find a property...
			if (property == nullptr)
			{
				// Report an error since we attempted to use the property delegate operator on a non-property
				return ErrorAt(node, ErrorCode::PropertyDelegateOperatorRequiresProperty);
			}

			// Make sure the property has the get and set functions
			if (property->Get == nullptr && property->Set == nullptr)
			{
				// Report an error since we can't form a property delegate to an object that has neither a get or set
				return ErrorAt(node, ErrorCode::PropertyDelegateRequiresGetOrSet, property->Name.c_str());
			}

			// The operand should either have a get or set, but we don't require one or the other
			node->Operand->IoUsage = IoMode::Ignore;

			// We're generating a temporary (just a read value)
			node->Io = IoMode::ReadRValue;

			// We need to instantiate the 'Property' template (an object that contains the get/set delegates)
			Array<Type*> templateArguments;
			templateArguments.push_back(property->PropertyType);

			// Instantiate the property object
			InstantiatedTemplate propertyTemplate = this->Builder->InstantiateTemplate(PropertyDelegateName, templateArguments, *this->Dependencies);

			// Make sure we instantiated the template
			ErrorIf(propertyTemplate.Result != TemplateResult::Success,
				"We should always be able to instantiate the property template!");

			// Our node's type is that property template type
			node->ResultType = propertyTemplate.Type;
			node->AccessedProperty = property;
		}
		else
		{
			// Report an error since we did some sort of an invalid binary operation between two types
			return ErrorAt(node, ErrorCode::PropertyDelegateOperatorRequiresProperty);
		}
	}

	//***************************************************************************
	void Syntaxer::DecorateCheckUnaryOperator(UnaryOperatorNode*& node, TypingContext* context)
	{
		// Process all the operand
		context->Walker->Walk(this, node->Operand, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// Get the operand type
		Type* operandType = node->Operand->ResultType;

		// Get the shared database and lookup the binary operator
		Shared& shared = Shared::GetInstance();
		node->OperatorInfo = shared.GetUnaryOperator(operandType, node->Operator->TokenId);

		// If we actually found a valid operator...
		if (node->OperatorInfo.IsValid)
		{
			// Output the result type and outmode
			node->ResultType = node->OperatorInfo.Result;
			node->Operand->IoUsage = node->OperatorInfo.Io;

			// Our usage is always the most restrictive of how the node designates
			// it can be used and how our operator designates it can be used
			node->Io = (IoMode::Enum)(node->Operand->Io & node->Operand->IoUsage);
		}
		else
		{
			// Report an error since we did some sort of an invalid binary operation between two types
			return ErrorAt(node, ErrorCode::InvalidUnaryOperation, operandType->ToString().c_str());
		}
	}

	//***************************************************************************
	void Syntaxer::DecorateCodeLocations(SyntaxNode*& node, TypingContext* context)
	{
		// If this node is a class node...
		ClassNode* classNode = TypeBinding::DynamicCast<ClassNode*>(node);
		if (classNode != nullptr)
		{
			// Push the class onto the stack so that children can access it
			// (the top of the stack will be the most relevant class to them)
			context->ClassTypeStack.push_back(classNode->Type);
		}

		// If this node is a function node...
		GenericFunctionNode* functionNode = TypeBinding::DynamicCast<GenericFunctionNode*>(node);
		if (functionNode != nullptr)
		{
			// Push the function onto the stack so that children can access it
			// (the top of the stack will be the most relevant function to them)
			context->FunctionStack.push_back(functionNode->DefinedFunction);
		}

		// The library is the name of our library builder
		node->Location.Library = this->Builder->BuiltLibrary->Name;

		// If we have a class in our context (we are inside a class)
		if (context->ClassTypeStack.empty() == false)
		{
			// Set the class name on the code location
			node->Location.Class = context->ClassTypeStack.back()->Name;
		}

		// If we have a function in our context (we are inside a function)
		if (context->FunctionStack.empty() == false)
		{
			// Why would we ever be inside a function but not inside a class?
			ErrorIf(context->ClassTypeStack.empty(), "Found a function that was not inside a class");

			// Set the function name on the code location
			node->Location.Function = context->FunctionStack.back()->Name;
		}

		// We need to traverse the children!
		// Normally we would return if any error occurred, but this is all useful information even with errors
		context->Walker->GenericWalkChildren(this, node, context);

		// If this node is a class node...
		if (classNode != nullptr)
		{
			// We are exiting this class, so pop it off
			context->ClassTypeStack.pop_back();
		}

		// If this node is a function node...
		if (functionNode != nullptr)
		{
			// We are exiting this class, so pop it off
			context->FunctionStack.pop_back();
		}
	}

	//***************************************************************************
	void Syntaxer::CheckExpressionIoModes(ExpressionNode*& node, TypingContext* context)
	{
		// We need to traverse the children!
		context->Walker->GenericWalkChildren(this, node, context);

		// If we had an error, do not continue
		if (this->Errors.WasError)
			return;

		// Skip any error checking if we're in tolerant mode...
		if (this->Errors.TolerantMode == false)
		{
			// Error checking
			ErrorIf(node->Io == IoMode::NotSet || node->Io == IoMode::Ignore,
				"A node's usage case was not set by its handler (or somehow it was set to ignore)");
			ErrorIf(node->IoUsage == IoMode::NotSet,
				"The parent node of an expression did not set the child's io usage");
			ErrorIf(node->ResultType == nullptr,
				"All expression node types must be valid (or void)");
		}

		// If we're trying to read from the node, but it's not readable...
		if ((node->IoUsage & IoMode::ReadRValue) != 0 && (node->Io & IoMode::ReadRValue) == 0)
		{
			// Report an error
			return ErrorAt(node, ErrorCode::ReadingFromAWriteOnlyValue);
		}

		// If we're trying to write to the node, but it's not writable...
		if ((node->IoUsage & IoMode::WriteLValue) != 0 && (node->Io & IoMode::WriteLValue) == 0)
		{
			// Report an error
			return ErrorAt(node, ErrorCode::WritingToAReadOnlyValue);
		}
	}

	//***************************************************************************
	void Syntaxer::ResolveMemberAccess(MemberAccessNode* node, const Resolver& resolver)
	{
		// Get access to the core library
		Core& core = Core::GetInstance();

		// Get the type instance for the type we're attempting to resolve on (the left operand generally)
		Type* type = resolver.TypeInstance;

		// If the left hand side is the 'any' type, it means we're accessing a dynamic property
		// A dynamic property is one that is resolved by string at runtime
		if (Type::IsAnyType(type))
		{
			// Set the member type (and resulting type)
			// We also want to set the access type to be a member, so that way anyone
			// who tries to modify it knows they can write directly to the member
			node->MemberType = MemberAccessType::Dynamic;
			//node->Access.Type     = OperandType::;????

			// Right now, we're only allowing reading from 'any' values (no writing to them)
			node->Io = IoMode::ReadRValue;
			//node->Io = (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue);

			// The resulting type will always end up being the 'any' type (which allows for chaining)
			node->ResultType = core.AnythingType;

			// Exit out early
			return;
		}

		// Attempt to find a field with the matching name...
		Field* field = (type->*resolver.GetField)(node->Name);

		// If we found the member...
		if (field != nullptr)
		{
			// Set the member type (and resulting type)
			// We also want to set the access type to be a member, so that way anyone
			// who tries to modify it knows they can write directly to the member
			node->MemberType = MemberAccessType::Field;
			node->Access.Type = OperandType::Field;
			node->ResultType = field->PropertyType;
			node->AccessedField = field;

			// We can both read and write to a data member
			node->Io = (IoMode::Enum)(IoMode::ReadRValue | IoMode::WriteLValue);

			// Exit out early
			return;
		}

		// Attempt to find a property with the matching name...
		Property* property = (type->*resolver.GetProperty)(node->Name);

		// If we found no property... attempt to look in dependency extension methods
		if (property == nullptr)
		{
			//ForEachExtensionPropertyMap

			// Loop through all the libraries
			for (size_t i = 0; i < this->AllLibraries.size() && property == nullptr; ++i)
			{
				// We need to look up the entire heirarchy (the property could be on any base classes)
				Type* baseIterator = type;
				do
				{
					// Grab the current library
					LibraryRef& library = this->AllLibraries[i];

					// Get the guid of the type (this should be legal here since we've collected all members)
					GuidType guid = baseIterator->Hash();

					// Get the array of properties (may be empty)
					PropertyMap* properties = nullptr;

					// If we're resolving a static member
					if (resolver.IsStatic)
					{
						properties = library->StaticExtensionProperties.findPointer(guid);
					}
					else
					{
						properties = library->InstanceExtensionProperties.findPointer(guid);
					}

					// If we got a valid array of properties...
					if (properties != nullptr)
					{
						// Attempt to find the property by name
						// If we find it, the loop will terminate because we don't need to keep looking
						property = properties->findValue(node->Name, nullptr);
						if (property != nullptr)
							break;
					}

					// Iterate to the next type
					baseIterator = Type::GetBaseType(baseIterator);
				} while (baseIterator != nullptr);
			}
		}

		// If we found the property...
		if (property != nullptr)
		{
			// Set the property type (and resulting type)
			// We also want to set the access type to be a property, so that way anyone
			// who tries to modify it knows they must use a getter/setter
			node->MemberType = MemberAccessType::Property;
			node->Access.Type = OperandType::Property;
			node->AccessedProperty = property;

			// Clear the io so we can set the flags below
			node->Io = IoMode::Ignore;

			// We assume the result type is void (if we have a get, then it will be the property type)
			node->ResultType = core.VoidType;

			// If we have a valid getter
			if (property->Get != nullptr)
			{
				node->Io = (IoMode::Enum)(node->Io | IoMode::ReadRValue);

				// We only have a resulting type when we are 
				node->ResultType = property->PropertyType;
			}

			// If we have a valid setter
			if (property->Set != nullptr)
			{
				node->Io = (IoMode::Enum)(node->Io | IoMode::WriteLValue);
			}

			// Exit out early
			return;
		}

		// Attempt to find the overloaded functions with the matching name...
		const FunctionArray* functions = (type->*resolver.GetOverloadedFunctions)(node->Name);

		// If we found no functions... attempt to look in dependency extension methods
		if (functions == nullptr || functions->empty())
		{
			// Loop through all the libraries
			for (size_t i = 0; i < this->AllLibraries.size(); ++i)
			{
				// Grab the current library
				LibraryRef& library = this->AllLibraries[i];

				// Get the guid of the type (this should be legal here since we've collected all members)
				GuidType guid = type->Hash();

				// Get the array of properties (may be empty)
				FunctionMultiMap* functionsByName = nullptr;

				// If we're resolving a static member
				if (resolver.IsStatic)
				{
					functionsByName = library->StaticExtensionFunctions.findPointer(guid);
				}
				else
				{
					functionsByName = library->InstanceExtensionFunctions.findPointer(guid);
				}

				// If we got a valid array of properties...
				if (functionsByName != nullptr)
				{
					// Attempt to find the property by name
					functions = functionsByName->findPointer(node->Name);

					// If we found a valid function array...
					if (functions != nullptr)
					{
						// We found it!
						break;
					}
				}
			}
		}

		// If we found the functions...
		if (functions != nullptr && functions->empty() == false)
		{
			// The node represents a function member access
			node->MemberType = MemberAccessType::Function;

			// The function will be referenced as a local (delegates are always locally generated)
			node->Access.Type = OperandType::Local;

			// A function can only be read (and in that same note, it really means create a delegate)
			node->Io = IoMode::ReadRValue;

			// If we have only one function
			if (functions->size() == 1)
			{
				// For now, we assume that the function we result in is the only one it can be
				node->AccessedFunction = functions->front();
				node->ResultType = node->AccessedFunction->Type;
			}
			else
			{
				// We don't yet know the function we'll resolve
				node->AccessedFunction = nullptr;
				node->ResultType = core.OverloadedMethodsType;
			}

			// Set the functions on the node
			node->OverloadedFunctions = functions;

			// Exit out early
			return;
		}

		// A member access/identifier was used, but we couldn't find the member it was referencing!
		return ErrorAt(node, ErrorCode::MemberNotFound, node->Name.c_str());
	}

	//***************************************************************************
	void Syntaxer::ResolveTypeMember(TypeMemberAccessNode*& node, TypingContext* /*context*/)
	{
		// Get the type that we're referencing
		node->ReferencedType = this->RetrieveType(node->ReferencedSyntaxType, node->Location);

		// If we had an error, return out early
		if (this->Errors.WasError)
			return;

		// Replace the instance member and instance functions
		ResolveMemberAccess(node, Resolver::Static(node->ReferencedType));
	}

	//***************************************************************************
	void Syntaxer::ResolveMember(MemberAccessNode*& node, TypingContext* context)
	{
		// Process the left expression first
		context->Walker->Walk(this, node->LeftOperand, context);

		// If an error occurred, exit out
		if (this->Errors.WasError)
			return;

		// The left operand only needs to be readable
		node->LeftOperand->IoUsage = IoMode::ReadRValue;

		// Get a reference to the left expression's type
		Type* leftType = node->LeftOperand->ResultType;

		// If the left type happens to be a indiret type...
		if (IndirectionType* qualifiedType = TypeBinding::DynamicCast<IndirectionType*>(leftType))
		{
			// Dereference the qualified type
			leftType = this->Builder->Dereference(qualifiedType);
		}

		// Replace the instance member and instance functions
		ResolveMemberAccess(node, Resolver::Instance(leftType));
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	ZilchDefineSimpleType(SyntaxType, Syntax);
	ZilchDefineSimpleType(AnySyntaxType, Syntax);
	ZilchDefineSimpleType(IndirectionSyntaxType, Syntax);
	ZilchDefineSimpleType(BoundSyntaxType, Syntax);
	ZilchDefineSimpleType(DelegateSyntaxType, Syntax);

	//***************************************************************************
	ZilchDefineSimpleType(SyntaxNode, Syntax);
	ZilchDefineSimpleType(RootNode, Syntax);
	ZilchDefineSimpleType(AttributeNode, Syntax);
	ZilchDefineSimpleType(StatementNode, Syntax);
	ZilchDefineSimpleType(ExpressionNode, Syntax);
	ZilchDefineSimpleType(UnnamedOperandNode, Syntax);
	ZilchDefineSimpleType(BinaryOperatorNode, Syntax);
	ZilchDefineSimpleType(UnaryOperatorNode, Syntax);
	ZilchDefineSimpleType(PropertyDelegateOperatorNode, Syntax);
	ZilchDefineSimpleType(TypeCastNode, Syntax);
	ZilchDefineSimpleType(PostExpressionNode, Syntax);
	ZilchDefineSimpleType(IndexerCallNode, Syntax);
	ZilchDefineSimpleType(FunctionCallNode, Syntax);
	ZilchDefineSimpleType(MemberAccessNode, Syntax);
	ZilchDefineSimpleType(TypeMemberAccessNode, Syntax);
	ZilchDefineSimpleType(CreationCallNode, Syntax);
	ZilchDefineSimpleType(CreationInitializerNode, Syntax);
	ZilchDefineSimpleType(CreationMemberInitializerNode, Syntax);
	ZilchDefineSimpleType(CreationAddInitializerNode, Syntax);
	ZilchDefineSimpleType(VariableNode, Syntax);
	ZilchDefineSimpleType(LocalVariableNode, Syntax);
	ZilchDefineSimpleType(ParameterNode, Syntax);
	ZilchDefineSimpleType(MemberVariableNode, Syntax);
	ZilchDefineSimpleType(ValueNode, Syntax);
	ZilchDefineSimpleType(StringInterpolantNode, Syntax);
	ZilchDefineSimpleType(DeleteNode, Syntax);
	ZilchDefineSimpleType(ReturnNode, Syntax);
	ZilchDefineSimpleType(ScopeNode, Syntax);
	ZilchDefineSimpleType(TimeoutNode, Syntax);
	ZilchDefineSimpleType(IfNode, Syntax);
	ZilchDefineSimpleType(IfRootNode, Syntax);
	ZilchDefineSimpleType(SendsEventNode, Syntax);
	ZilchDefineSimpleType(BreakNode, Syntax);
	ZilchDefineSimpleType(DebugBreakNode, Syntax);
	ZilchDefineSimpleType(ContinueNode, Syntax);
	ZilchDefineSimpleType(LoopScopeNode, Syntax);
	ZilchDefineSimpleType(ConditionalLoopNode, Syntax);
	ZilchDefineSimpleType(WhileNode, Syntax);
	ZilchDefineSimpleType(DoWhileNode, Syntax);
	ZilchDefineSimpleType(ForNode, Syntax);
	ZilchDefineSimpleType(ForEachNode, Syntax);
	ZilchDefineSimpleType(LoopNode, Syntax);
	ZilchDefineSimpleType(GenericFunctionNode, Syntax);
	ZilchDefineSimpleType(FunctionNode, Syntax);
	ZilchDefineSimpleType(InitializerNode, Syntax);
	ZilchDefineSimpleType(ConstructorNode, Syntax);
	ZilchDefineSimpleType(DestructorNode, Syntax);
	ZilchDefineSimpleType(ClassNode, Syntax);
	ZilchDefineSimpleType(TypeDefineNode, Syntax);
	ZilchDefineSimpleType(LocalVariableReferenceNode, Syntax);
	ZilchDefineSimpleType(ThrowNode, Syntax);
	ZilchDefineSimpleType(TypeIdNode, Syntax);
	ZilchDefineSimpleType(EnumValueNode, Syntax);
	ZilchDefineSimpleType(EnumNode, Syntax);

	//***************************************************************************
	SyntaxTree::SyntaxTree() :
		SingleExpression(nullptr)
	{
		// Create the root node
		this->Root = new RootNode();
	}

	//***************************************************************************
	SyntaxTree::~SyntaxTree()
	{
		delete this->Root;
		this->Root = nullptr;
	}

	//***************************************************************************
	void SyntaxType::DestroyChildren()
	{
		// Populate all the syntax types
		SyntaxTypes types;
		this->PopulateSyntaxTypes(types);

		// Loop through all the child syntax types
		for (size_t i = 0; i < types.size(); ++i)
		{
			// Get the current child type
			SyntaxType* childType = *types[i];

			// Destroy all of that child's type children
			delete childType;
			childType = nullptr;
		}
	}

	//***************************************************************************
	bool SyntaxType::IsTemplateInstantiation() const
	{
		// By default, we assume all syntax types are not templated
		return false;
	}

	//***************************************************************************
	void SyntaxType::PopulateSyntaxTypes(SyntaxTypes& /*typesOut*/)
	{
	}

	//***************************************************************************
	String AnySyntaxType::ToString() const
	{
		return Grammar::GetKeywordOrSymbol(Grammar::Any);
	}

	//***************************************************************************
	IndirectionSyntaxType::IndirectionSyntaxType() :
		ReferencedType(nullptr)
	{
	}

	//***************************************************************************
	String IndirectionSyntaxType::ToString() const
	{
		// Create a string builder since we're doing some concatenation
		StringBuilder output;

		// Add the 'ref' keyword
		output += Grammar::GetKeywordOrSymbol(Grammar::Ref);
		output += " ";

		// Add the type we're referencing
		output += this->ReferencedType->ToString();

		// Output the string
		return output.ToString();
	}

	//***************************************************************************
	void IndirectionSyntaxType::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->ReferencedType);
	}

	//***************************************************************************
	bool BoundSyntaxType::IsTemplateInstantiation() const
	{
		return this->TemplateArguments.size() > 0;
	}

	//***************************************************************************
	String BoundSyntaxType::ToString() const
	{
		if (this->IsTemplateInstantiation())
		{
			StringBuilder builder;
			builder.Append(this->TypeName);

			builder.Append('[');

			for (size_t i = 0; i < this->TemplateArguments.size(); ++i)
			{
				builder.Append(this->TemplateArguments[i]->ToString());

				if (i != this->TemplateArguments.size() - 1)
				{
					builder.Append(", ");
				}
			}

			builder.Append(']');

			return builder.ToString();
		}
		else
		{
			return this->TypeName;
		}
	}

	//***************************************************************************
	void BoundSyntaxType::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		this->TemplateArguments.Populate(typesOut);
	}

	//***************************************************************************
	DelegateSyntaxParameter::DelegateSyntaxParameter() :
		Name(nullptr),
		Type(nullptr)
	{
	}

	//***************************************************************************
	DelegateSyntaxType::DelegateSyntaxType() :
		Return(nullptr)
	{
	}

	//***************************************************************************
	bool DelegateSyntaxType::IsTemplateInstantiation() const
	{
		return this->TemplateArguments.size() > 0;
	}

	//***************************************************************************
	String DelegateSyntaxType::ToString() const
	{
		// Create a string builder for concatenation
		StringBuilder output;

		// Output the delegate keyword and the opening argument parentheses
		output += Grammar::GetKeywordOrSymbol(Grammar::Delegate);
		output += " (";

		// Loop through all the parameters
		for (size_t i = 0; i < this->Parameters.size(); ++i)
		{
			// Output the name of the parameter
			output += this->Parameters[i].Name->Token.c_str();
			output += " : ";

			// Always output the type of the parameter
			output += this->Parameters[i].Type->ToString();

			// If this is not the last parameter...
			if (i < this->Parameters.size() - 1)
			{
				// Output an argument separator
				output += ", ";
			}
		}

		// Output the ending argument parentheses
		output += ")";

		// If we have a return type
		if (this->Return != nullptr)
		{
			// Output the return type...
			output += " : ";
			output += this->Return->ToString();
		}

		// Finally, output the full concatenated type string
		return output.ToString();
	}

	//***************************************************************************
	void DelegateSyntaxType::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->Return);

		// Loop through all the parameters in the function
		for (size_t i = 0; i < this->Parameters.size(); ++i)
		{
			typesOut.Add(this->Parameters[i].Type);
		}
	}

	//***************************************************************************
	SyntaxNode::SyntaxNode() :
		Parent(nullptr)
	{
	}

	//***************************************************************************
	void SyntaxNode::DestroyChildren()
	{
		// Get all the children for this node
		NodeChildren children;
		this->PopulateChildren(children);
		this->PopulateNonTraversedChildren(children);

		// Loop through all this node's children
		for (size_t i = 0; i < children.size(); ++i)
		{
			// Get the current child
			SyntaxNode*& child = *children[i];

			// Destroy all of that child's children
			delete child;
			child = nullptr;
		}

		// Populate all the syntax types
		SyntaxTypes types;
		this->PopulateSyntaxTypes(types);

		// Loop through all the child syntax types
		for (size_t i = 0; i < types.size(); ++i)
		{
			// Get the current child type
			SyntaxType*& childType = *types[i];

			// Destroy all of that child's type children
			delete childType;
			childType = nullptr;
		}
	}

	//***************************************************************************
	SyntaxNode::SyntaxNode(const SyntaxNode& toCopy) :
		Location(toCopy.Location),
		Parent(nullptr)
	{
		// We never copy the parent from other nodes
	}

	//***************************************************************************
	String SyntaxNode::ToString() const
	{
		return this->ZilchGetDerivedType()->Name;
	}

	//***************************************************************************
	void SyntaxNode::PopulateChildren(NodeChildren& /*childrenOut*/)
	{
	}

	//***************************************************************************
	void SyntaxNode::PopulateNonTraversedChildren(NodeChildren& /*childrenOut*/)
	{
	}

	//***************************************************************************
	void SyntaxNode::PopulateSyntaxTypes(SyntaxTypes& /*typesOut*/)
	{
	}

	//***************************************************************************
	void SyntaxNode::FixParentPointers(SyntaxNode* node, SyntaxNode* parent)
	{
		// Get all the children for this node
		NodeChildren children;
		node->PopulateChildren(children);

		// Loop through all this node's children
		for (size_t i = 0; i < children.size(); ++i)
		{
			// Get the current child
			SyntaxNode* child = *children[i];

			// Destroy all of that child's children
			FixParentPointers(child, node);
		}

		// Setup the parent pointer for the current node
		node->Parent = parent;
	}

	//***************************************************************************
	String SyntaxNode::GetMergedComments()
	{
		// Create a string builder
		StringBuilder builder;

		// Loop through all the comment strings
		for (size_t i = 0; i < this->Comments.size(); ++i)
		{
			// Get the current comment
			String& comment = this->Comments[i];

			// Get a string range for the comment, since we're going to trim starting white space
			StringRange range = comment.all();

			// While we're reading a space...
			while (*range.begin == ' ')
			{
				// Move the range start forward
				++range.begin;
			}

			// Append the string range for the comment
			builder.Append(range);

			// Checks if this is not the last comment...
			bool isNotLast = (i != (this->Comments.size() - 1));
			if (isNotLast)
			{
				builder.Append("\n");
			}
		}

		// Return the merged comments
		return builder.ToString();
	}

	//***************************************************************************
	String ToNodeString(int nodeID)
	{
		// Return the node name
		return String::Format("node%d", nodeID);
	}

	//***************************************************************************
	String NodeConnection(int nodeA, int nodeB)
	{
		StringBuilder output;
		output += "  ";
		output += ToNodeString(nodeA);
		output += " -- ";
		output += ToNodeString(nodeB);
		output += "\n";
		return output.ToString();
	}

	//***************************************************************************
	String GetStart(int nodeID, const char* shape = "box")
	{
		// Return the node starting text
		StringBuilder output;
		output += "  ";
		output += ToNodeString(nodeID);
		output += " [shape = ";
		output += shape;
		output += ", label = \"";
		return output.ToString();
	}

	//***************************************************************************
	String GetEnd()
	{
		static const String ending = "\"];\n";
		return ending;
	}

	//***************************************************************************
	int GetGraphVizNodeRepresentation(StringBuilder& outString, int nodeID, SyntaxNode* node)
	{
		outString += GetStart(nodeID);
		outString += node->ToString();
		outString += GetEnd();

		int childNodeID = nodeID + 1;

		NodeChildren children;
		node->PopulateChildren(children);

		for (size_t i = 0; i < children.size(); ++i)
		{
			SyntaxNode* child = *children[i];

			outString += NodeConnection(nodeID, childNodeID);
			childNodeID = GetGraphVizNodeRepresentation(outString, childNodeID, child);
		}

		return childNodeID + 1;
	}

	//***************************************************************************
	String SyntaxTree::GetGraphVizRepresentation()
	{
		StringBuilder output;
		output += "graph \"Syntax Tree\"\n{\n";

		GetGraphVizNodeRepresentation(output, 0, this->Root);

		output += "}";
		return output.ToString();
	}

	//***************************************************************************
	void SyntaxTree::ShowGraphVizRepresentation()
	{
		FILE* fp = fopen("C:\\Temp\\Parse.gv", "w");

		if (fp)
		{
			String gv = GetGraphVizRepresentation();

			fwrite(gv.c_str(), gv.size(), 1, fp);
			fwrite("\0", 1, 1, fp);

			fclose(fp);

			//system("C:\\Progra~1\\Graphviz2.26.3\\bin\\dot.exe -Tpng \"C:\\temp.gv\" > \"C:\\temp.png\"");
			system("C:\\Progra~2\\Graphviz2.28\\bin\\dot.exe -Tpng \"C:\\Temp\\Parse.gv\" > \"C:\\Temp\\Parse.png\"");

			system("C:\\Temp\\Parse.png");
		}
	}

	//***************************************************************************
	void RootNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Classes.Populate(childrenOut);
		this->Enums.Populate(childrenOut);
	}

	//***************************************************************************
	bool StatementNode::IsNodeUsedAsStatement(SyntaxNode* node)
	{
		// If the node is an expression...
		ExpressionNode* expression = TypeBinding::DynamicCast<ExpressionNode*>(node);
		if (expression != nullptr)
		{
			// Return if the expression is being used as a statement
			return expression->IsUsedAsStatement;
		}

		// If the node is a function node... which, because it's a scope node,
		// is considered a statement (and should probably not be!)
		if (TypeBinding::DynamicCast<GenericFunctionNode*>(node) != nullptr)
		{
			return false;
		}

		// If the node is a member variable node... which, because it's a variable node,
		// is considered a statement (and should probably not be!)
		if (TypeBinding::DynamicCast<MemberVariableNode*>(node) != nullptr)
		{
			return false;
		}

		// Otherwise, just return if this node is a statement node
		return (TypeBinding::DynamicCast<StatementNode*>(node) != nullptr);
	}


	//***************************************************************************
	AttributeNode::AttributeNode() :
		AttributeCall(nullptr),
		TypeName(nullptr)
	{
	}

	//***************************************************************************
	void AttributeNode::PopulateChildren(NodeChildren& childrenOut)
	{
		childrenOut.Add(this->AttributeCall);
	}

	//***************************************************************************
	ExpressionNode::ExpressionNode() :
		Io(IoMode::NotSet),
		IoUsage(IoMode::NotSet),
		ResultType(Core::GetInstance().ErrorType),
		IsUsedAsStatement(false)
	{
	}

	//***************************************************************************
	UnnamedOperandNode::UnnamedOperandNode() :
		ToBeForwarded(nullptr)
	{
	}

	//***************************************************************************
	BinaryOperatorNode::BinaryOperatorNode() :
		LeftOperand(nullptr),
		RightOperand(nullptr),
		Operator(nullptr)
	{
	}

	//***************************************************************************
	String BinaryOperatorNode::ToString() const
	{
		return this->Operator->Token;
	}

	//***************************************************************************
	void BinaryOperatorNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->LeftOperand);
		childrenOut.Add(this->RightOperand);
	}

	//***************************************************************************
	UnaryOperatorNode::UnaryOperatorNode() :
		Operand(nullptr),
		Operator(nullptr)
	{
	}

	//***************************************************************************
	String UnaryOperatorNode::ToString() const
	{
		return this->Operator->Token;
	}

	//***************************************************************************
	void UnaryOperatorNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->Operand);
	}

	//***************************************************************************
	PropertyDelegateOperatorNode::PropertyDelegateOperatorNode() :
		AccessedProperty(nullptr)
	{
	}

	//***************************************************************************
	TypeCastNode::TypeCastNode() :
		Operand(nullptr),
		Type(nullptr)
	{
	}

	//***************************************************************************
	String TypeCastNode::ToString() const
	{
		if (this->Type == nullptr)
			return "Implicit cast";
		return BuildString("Cast to ", this->Type->ToString());
	}

	//***************************************************************************
	void TypeCastNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->Operand);
	}

	//***************************************************************************
	void TypeCastNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->Type);
	}

	//***************************************************************************
	PostExpressionNode::PostExpressionNode() :
		LeftOperand(nullptr)
	{
	}

	//***************************************************************************
	void PostExpressionNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->LeftOperand);
	}

	//***************************************************************************
	String IndexerCallNode::ToString() const
	{
		return "[...]";
	}

	//***************************************************************************
	void IndexerCallNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Arguments.Populate(childrenOut);
	}

	//***************************************************************************
	FunctionCallNode::FunctionCallNode() :
		IsNamed(false)
	{
	}

	//***************************************************************************
	String FunctionCallNode::ToString() const
	{
		return "(...)";
	}

	//***************************************************************************
	void FunctionCallNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Arguments.Populate(childrenOut);
	}

	//***************************************************************************
	MemberAccessNode::MemberAccessNode() :
		Operator(nullptr),
		AccessedFunction(nullptr),
		OverloadedFunctions(nullptr),
		AccessedProperty(nullptr),
		AccessedField(nullptr),
		MemberType(MemberAccessType::Invalid)
	{
	}

	//***************************************************************************
	String MemberAccessNode::ToString() const
	{
		return BuildString(this->Operator->Token, this->Name);
	}

	//***************************************************************************
	TypeMemberAccessNode::TypeMemberAccessNode() :
		ReferencedSyntaxType(nullptr),
		ReferencedType(Core::GetInstance().ErrorType)
	{
	}

	//***************************************************************************
	TypeIdNode::TypeIdNode() :
		Value(nullptr),
		CompileTimeSyntaxType(nullptr),
		CompileTimeType(Core::GetInstance().ErrorType)
	{
	}

	//***************************************************************************
	void TypeIdNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->Value);
	}

	//***************************************************************************
	void TypeIdNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->CompileTimeSyntaxType);
	}

	//***************************************************************************
	String TypeMemberAccessNode::ToString() const
	{
		return BuildString(this->ReferencedSyntaxType->ToString(), this->Operator->Token, this->Name);
	}

	//***************************************************************************
	void TypeMemberAccessNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->ReferencedSyntaxType);
	}

	//***************************************************************************
	CreationCallNode::CreationCallNode() :
		CreatedSyntaxType(nullptr),
		ThisHandleLocal(0),
		ConstructorFunction(nullptr),
		CreatedType(Core::GetInstance().ErrorType),
		Mode(CreationMode::Invalid)
	{
	}

	//***************************************************************************
	void CreationCallNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->CreatedSyntaxType);
	}

	//***************************************************************************
	CreationMemberInitializerNode::CreationMemberInitializerNode() :
		Value(nullptr)
	{
	}

	//***************************************************************************
	void CreationMemberInitializerNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->Value);
	}

	//***************************************************************************
	void CreationAddInitializerNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Arguments.Populate(childrenOut);
	}

	//***************************************************************************
	CreationInitializerNode::CreationInitializerNode()
	{
	}

	//***************************************************************************
	void CreationInitializerNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->AddValues.Populate(childrenOut);
		this->InitailizeMembers.Populate(childrenOut);
		this->InitializerStatements.Populate(childrenOut);
	}

	//***************************************************************************
	VariableNode::VariableNode() :
		InitialValue(nullptr),
		IsStatic(false),
		ResultSyntaxType(nullptr)
	{
	}

	//***************************************************************************
	bool VariableNode::IsInferred() const
	{
		// We are inferred if we have no syntax type
		return this->ResultSyntaxType == nullptr;
	}

	//***************************************************************************
	LocalVariableNode::LocalVariableNode() :
		CreatedVariable(nullptr)
	{
	}

	//***************************************************************************
	String VariableNode::ToString() const
	{
		return this->Name;
	}

	//***************************************************************************
	void VariableNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->InitialValue);
	}

	//***************************************************************************
	void VariableNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->ResultSyntaxType);
	}

	//***************************************************************************
	ParameterNode::ParameterNode() :
		ParameterIndex(0)
	{
	}

	//***************************************************************************
	MemberVariableNode::MemberVariableNode() :
		Get(nullptr),
		Set(nullptr),
		IsProperty(false),
		CreatedProperty(nullptr),
		CreatedField(nullptr),
		ParentClassType(nullptr),
		ResultType(Core::GetInstance().ErrorType),
		Virtualized(VirtualMode::NonVirtual)
	{
	}

	//***************************************************************************
	void MemberVariableNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Attributes.Populate(childrenOut);
		childrenOut.Add(this->Get);
		childrenOut.Add(this->Set);
	}

	//***************************************************************************
	ValueNode::ValueNode()
	{
	}

	//***************************************************************************
	String ValueNode::ToString() const
	{
		return this->Value.Token;
	}

	//***************************************************************************
	StringInterpolantNode::StringInterpolantNode()
	{
	}

	//***************************************************************************
	void StringInterpolantNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Elements.Populate(childrenOut);
	}

	//***************************************************************************
	DeleteNode::DeleteNode() :
		DeletedObject(nullptr)
	{
	}

	//***************************************************************************
	void DeleteNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->DeletedObject);
	}

	//***************************************************************************
	ReturnNode::ReturnNode() :
		ReturnValue(nullptr),
		IsDebugReturn(false)
	{
	}

	//***************************************************************************
	void ReturnNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->ReturnValue);
	}

	//***************************************************************************
	ScopeNode::ScopeNode() :
		AllPathsReturn(false),
		IsDebugReturn(false)
	{
	}

	//***************************************************************************
	void ScopeNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Statements.Populate(childrenOut);
	}

	//***************************************************************************
	TimeoutNode::TimeoutNode() :
		Seconds(0)
	{
	}

	//***************************************************************************
	IfNode::IfNode() :
		Condition(nullptr),
		IsFirstPart(false)
	{
	}

	//***************************************************************************
	void IfNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->Condition);
	}

	//***************************************************************************
	IfRootNode::IfRootNode()
	{
	}

	//***************************************************************************
	void IfRootNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->IfParts.Populate(childrenOut);
	}

	//***************************************************************************
	SendsEventNode::SendsEventNode() :
		EventType(nullptr),
		Name(nullptr),
		EventProperty(nullptr)
	{
	}

	//***************************************************************************
	void SendsEventNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->EventType);
	}

	//***************************************************************************
	BreakNode::BreakNode() :
		ScopeCount(0),
		InstructionIndex(InvalidOpcodeLocation),
		JumpOpcode(nullptr)
	{
	}

	//***************************************************************************
	ContinueNode::ContinueNode() :
		InstructionIndex(InvalidOpcodeLocation),
		JumpOpcode(nullptr)
	{
	}

	//***************************************************************************
	ThrowNode::ThrowNode() :
		Exception(nullptr)
	{
	}

	//***************************************************************************
	void ThrowNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->Exception);
	}

	//***************************************************************************
	LoopScopeNode::LoopScopeNode()
	{
	}

	//***************************************************************************
	LoopScopeNode::LoopScopeNode(const LoopScopeNode& toCopy) :
		ScopeNode(toCopy)
	{
		// Error checking
		ErrorIf(toCopy.Breaks.empty() == false,
			"You cannot copy a loop scope node with pointers to other break nodes");

		// Error checking
		ErrorIf(toCopy.Continues.empty() == false,
			"You cannot copy a loop scope node with pointers to other continue nodes");
	}

	//***************************************************************************
	ConditionalLoopNode::ConditionalLoopNode() :
		Condition(nullptr)
	{
	}

	//***************************************************************************
	void ConditionalLoopNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->Condition);
	}

	//***************************************************************************
	ForNode::ForNode() :
		ValueVariable(nullptr),
		RangeVariable(nullptr),
		Initialization(nullptr),
		Iterator(nullptr)
	{
	}

	//***************************************************************************
	void ForNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->ValueVariable);
		childrenOut.Add(this->RangeVariable);
		childrenOut.Add(this->Initialization);
		childrenOut.Add(this->Iterator);
	}

	//***************************************************************************
	ForEachNode::ForEachNode() :
		NonTraversedVariable(nullptr),
		NonTraversedRange(nullptr)
	{
	}

	//***************************************************************************
	void ForEachNode::PopulateNonTraversedChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		childrenOut.Add(this->NonTraversedVariable);
		childrenOut.Add(this->NonTraversedRange);
	}

	//***************************************************************************
	GenericFunctionNode::GenericFunctionNode() :
		Type(nullptr),
		DefinedFunction(nullptr)
	{
	}

	//***************************************************************************
	void GenericFunctionNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Parameters.Populate(childrenOut);
		this->Attributes.Populate(childrenOut);
	}

	//***************************************************************************
	FunctionNode::FunctionNode() :
		ReturnType(nullptr),
		IsStatic(false),
		Virtualized(VirtualMode::NonVirtual)
	{
	}

	//***************************************************************************
	String FunctionNode::ToString() const
	{
		return BuildString("Function ", this->Name);
	}

	//***************************************************************************
	void FunctionNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->ReturnType);
	}

	//***************************************************************************
	InitializerNode::InitializerNode() :
		InitializerType(nullptr),
		InitializerFunction(nullptr)
	{
	}

	//***************************************************************************
	ConstructorNode::ConstructorNode() :
		BaseInitializer(nullptr),
		ThisInitializer(nullptr)
	{
	}

	//***************************************************************************
	ClassNode::ClassNode() :
		TemplateInstantiation(nullptr),
		Destructor(nullptr),
		Type(nullptr),
		PreConstructor(nullptr),
		CopyMode(TypeCopyMode::ReferenceType)
	{
	}

	//***************************************************************************
	bool ClassNode::IsTemplate() const
	{
		return this->TemplateArguments.size() > 0;
	}

	//***************************************************************************
	String ClassNode::ToString() const
	{
		return BuildString("Class ", this->Name);
	}

	//***************************************************************************
	void ClassNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Attributes.Populate(childrenOut);
		this->SendsEvents.Populate(childrenOut);
		this->Variables.Populate(childrenOut);
		this->Constructors.Populate(childrenOut);
		childrenOut.Add(this->Destructor);
		this->Functions.Populate(childrenOut);
	}

	//***************************************************************************
	void ClassNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		this->Inheritance.Populate(typesOut);
	}

	//***************************************************************************
	EnumValueNode::EnumValueNode() :
		Value(nullptr),
		IntegralValue(0),
		IntegralProperty(nullptr)
	{
	}

	//***************************************************************************
	String EnumValueNode::ToString() const
	{
		// Return both the value name and the actual assigned integral value
		return String::Format("%s = %d", this->Name.c_str(), this->IntegralValue);
	}

	//***************************************************************************
	EnumNode::EnumNode() :
		IsFlags(false),
		Inheritance(nullptr),
		Type(nullptr)
	{
	}

	//***************************************************************************
	String EnumNode::ToString() const
	{
		return this->Name;
	}

	//***************************************************************************
	void EnumNode::PopulateChildren(NodeChildren& childrenOut)
	{
		ZilchBase::PopulateChildren(childrenOut);
		this->Values.Populate(childrenOut);
		this->Attributes.Populate(childrenOut);
	}

	//***************************************************************************
	void EnumNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->Inheritance);
	}

	//***************************************************************************
	TypeDefineNode::TypeDefineNode() :
		Name(nullptr)
	{
	}

	//***************************************************************************
	String TypeDefineNode::ToString() const
	{
		return BuildString(this->Name->Token, " : ", this->Type->ToString());
	}

	//***************************************************************************
	void TypeDefineNode::PopulateSyntaxTypes(SyntaxTypes& typesOut)
	{
		ZilchBase::PopulateSyntaxTypes(typesOut);
		typesOut.Add(this->Type);
	}

	//***************************************************************************
	LocalVariableReferenceNode::LocalVariableReferenceNode() :
		AccessedVariable(nullptr)
	{
	}

	//***************************************************************************
	String LocalVariableReferenceNode::ToString() const
	{
		return BuildString("[Local Variable]", this->Value.Token);
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

int gPublicSymbol = 1;

namespace Zilch
{
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	void TemplateBinding::ParseParameterArrays(ParameterArray& parameters, StringParam spaceDelimitedNames)
	{
		// We return immediately if the string is empty because this function
		// gets generically called even when no arguments are supplied
		if (spaceDelimitedNames.empty())
			return;

		// Whether we started reading a name or not
		bool gotLowerCamelName = false;

		// Store indicies for where we are in the name list
		size_t currentParameter = 0;
		size_t nameStart = 0;

		// Loop through all the characters in the names list (including the \0 at the end!)
		for (size_t i = 0; i <= spaceDelimitedNames.size(); ++i)
		{
			// Grab the current character
			char c = spaceDelimitedNames[i];

			// If we already started reading a name...
			if (gotLowerCamelName)
			{
				// If we hit the end of the name (a comma, whitespace, invalid character, etc)
				if (!isalnum(c))
				{
					// We're ready to read another variable name
					gotLowerCamelName = false;

					// Parse out the parameter name
					String parameterName = spaceDelimitedNames.sub_string(nameStart, i - nameStart);

					// Make sure we read a valid space character, or at least the null/end character...
					if (c != ' ' && c != '\0')
					{
						Error("Invalid character '%c' encountered when parsing name list (right after the name '%s')", c, parameterName.c_str());
						return;
					}

					// Make sure we're not reading too many parameters
					if (currentParameter < parameters.size())
					{
						// Set the name of the parameter and move to the next one
						parameters[currentParameter].Name = parameterName;
						++currentParameter;
					}
					else
					{
						Error("There were more named parameters then there were parameters in the function");
						return;
					}

				}
			}
			// We have yet to read a parameter name, check if this is the start of one
			else if (islower(c))
			{
				gotLowerCamelName = true;
				nameStart = i;
			}
			else
			{
				Error("Invalid character '%c' encountered when parsing name list (there must be only one space, no symbols, and variables must start with lower camel case)", c);
				return;
			}
		}

		// Make sure the user provides enough names...
		ErrorIf(currentParameter != parameters.size(), "We didn't read enough parameters to fill out the entire parameter array");
	}
}/**************************************************************\
 * Author: Trevor Sundberg
 * Copyright 2012-2014, DigiPen Institute of Technology
 \**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	void CodeGenerator::CreateLocal(Function* function, size_t size, Operand& accessOut)
	{
		// All r-value binary operations result in a value on the stack
		// Therefore we need to allocate a register to store our result in
		accessOut.HandleConstantLocal = function->AllocateRegister(size);

		// We don't use the secondary index (we aren't writing to a member or anything) so just ignore it
		accessOut.Field = 0;

		// Since we are going to be stored on the stack, our access type is as a local
		accessOut.Type = OperandType::Local;
	}

	//***************************************************************************
	void CodeGenerator::CreateRValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin)
	{
		// Create the opcode
		UnaryRValueOpcode& opcode = function->AllocateOpcode<UnaryRValueOpcode>(instruction, debugOrigin, node.Location);

		// All r-value binary operations result in a value on the stack
		// Therefore we need to allocate a register to store our result in
		CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

		// We always output to the stack
		opcode.Output = node.Access.HandleConstantLocal;

		// Initialize the only operand
		opcode.SingleOperand = node.Operand->Access;
	}

	//***************************************************************************
	void CodeGenerator::CreateLValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin)
	{
		// Create the opcode
		UnaryLValueOpcode& opcode = function->AllocateOpcode<UnaryLValueOpcode>(instruction, debugOrigin, node.Location);

		// All l-value binary operations result in a chained left hand value,
		// therefore we use the same primary and secondary index as the left operand
		// (no register allocation should ever be needed)
		node.Access = node.Operand->Access;

		// Initialize the only operand
		opcode.SingleOperand = node.Operand->Access;
	}

	//***************************************************************************
	void CodeGenerator::CreateConversionOpcode(Function* function, TypeCastNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin)
	{
		// Create the opcode
		ConversionOpcode& opcode = function->AllocateOpcode<ConversionOpcode>(instruction, debugOrigin, node.Location);

		// This expression's result will be stored in the last created register
		CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

		// We always output to the stack (it's a conversion, not a storage operator)
		opcode.Output = node.Access.HandleConstantLocal;

		// We pull the value out of our node's operand
		// (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
		opcode.ToConvert = node.Operand->Access;
	}

	//***************************************************************************
	void CodeGenerator::GenerateUnaryOp(Function* function, UnaryOperatorNode& node, DebugOrigin::Enum debugOrigin)
	{
		// Create the opcode so that we can fill it in
		size_t opcodeStart = function->GetCurrentOpcodeIndex();

		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// If this is creating a property delegate object
		ErrorIf(node.Operator->TokenId == Grammar::PropertyDelegate,
			"The property delegate operator is a unary operator, but should be handled by a separate handler");

		// Store the unary operator info for convenience (shared definition)
		UnaryOperator& info = node.OperatorInfo;

		// Unary plus always does nothing
		if (node.Operator->TokenId == Grammar::Positive)
		{
			// We need to make sure that the node knows its output is just its only operand (early out)
			node.Access = node.Operand->Access;
			return;
		}

		// If the operator results in an l-value...
		if (info.Io & IoMode::WriteLValue)
		{
			CreateLValueUnaryOpcode(function, node, info.Instruction, debugOrigin);
		}
		// Otherwise, the operator results in an r-value...
		else
		{
			CreateRValueUnaryOpcode(function, node, info.Instruction, debugOrigin);
		}

		// Error checking
		ErrorIf(opcodeStart == function->GetCurrentOpcodeIndex(), "No instructions were written!");
	}

	//***************************************************************************
	void CodeGenerator::GenerateConversion(Function* function, TypeCastNode& node, DebugOrigin::Enum debugOrigin)
	{
		// Create the opcode so that we can fill it in
		size_t opcodeStart = function->GetCurrentOpcodeIndex();

		// Get the instance of the type database
		Core& core = Core::GetInstance();

		// Store the cast operation for convenience
		CastOperation::Enum castOperation = node.OperatorInfo.Operation;

		// If the type cast is a primitive cast...
		if (castOperation == CastOperation::Primitive)
		{
			// Use the primitive instruction on the conversion operator
			CreateConversionOpcode(function, node, node.OperatorInfo.PrimitiveInstruction, debugOrigin);

			// Error checking
			ErrorIf(opcodeStart == function->GetCurrentOpcodeIndex(), "No instructions were written!");
		}
		// If it's an up cast, we pretty much don't do anything (just forward the access, type should be changed already)
		// Note: Dynamic down is currently NOT SAFE at all
		// It can also be a 'Same' cast, ex: Integer to Integer, in which we do absolutely nothing
		else if (castOperation == CastOperation::Raw)
		{
			// Forward access (there's no actual opcode we need to write!)
			node.Access = node.Operand->Access;
		}
		// Stores the value generically into an 'any' type, which does proper reference counting / handle / delegate / value copies
		// This also constructs an Any on the stack and initializes it
		// Note: May not go through the Any constructor as an optimization!
		else if (castOperation == CastOperation::ToAny)
		{
			// Create the opcode
			AnyConversionOpcode& opcode = function->AllocateOpcode<AnyConversionOpcode>(Instruction::ConvertToAny, debugOrigin, node.Location);

			// This expression's result will be stored in the last created register
			size_t anySize = node.ResultType->GetCopyableSize();
			ErrorIf(anySize != sizeof(Any), "The only way we should hit the 'ToAny' case is if we're casting to an Any type");
			CreateLocal(function, anySize, node.Access);

			// We always output to the stack (it's a conversion, not a storage operator)
			opcode.Output = node.Access.HandleConstantLocal;

			// We pull the value out of our node's operand
			// (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
			opcode.ToConvert = node.Operand->Access;

			// The conversion opcode needs to know about the operands type so it knows how to store it in the Any
			// (see the comment above for what 'Operand' is)
			opcode.RelatedType = node.Operand->ResultType;
		}
		// Copies the value back out of the any onto the stack
		else if (castOperation == CastOperation::FromAny)
		{
			// Create the opcode
			AnyConversionOpcode& opcode = function->AllocateOpcode<AnyConversionOpcode>(Instruction::ConvertFromAny, debugOrigin, node.Location);

			// This expression's result will be stored in the last created register
			CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

			// We always output to the stack (it's a conversion, not a storage operator)
			opcode.Output = node.Access.HandleConstantLocal;

			// We pull the value out of our node's operand
			// (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
			ErrorIf(node.Operand->ResultType != core.AnythingType, "When converting from an Any, the Operand should always be an Any");
			opcode.ToConvert = node.Operand->Access;

			// The conversion opcode needs to know about the type its converting to
			opcode.RelatedType = node.ResultType;
		}
		// When we cast from a base class down into a more derived class (handles only at the moment)
		else if (castOperation == CastOperation::DynamicDown)
		{
			// Create the opcode
			DowncastConversionOpcode& opcode = function->AllocateOpcode<DowncastConversionOpcode>(Instruction::ConvertDowncast, debugOrigin, node.Location);

			// This expression's result will be stored in the last created register
			ErrorIf(node.ResultType->GetCopyableSize() != sizeof(Handle),
				"We only support downcasting of handles at the moment");
			CreateLocal(function, node.ResultType->GetCopyableSize(), node.Access);

			// We always output to the stack (it's a conversion, not a storage operator)
			opcode.Output = node.Access.HandleConstantLocal;

			// We pull the value out of our node's operand
			// (the operand is the left side of the 'as', eg 5 as Real, 5 would be the Operand)
			opcode.ToConvert = node.Operand->Access;

			// The conversion opcode needs to know about the type its converting to
			opcode.ToType = node.ResultType;
		}
		else if (castOperation == CastOperation::NullToDelegate)
		{
			// The 'Null' object is allocated as a constant, and the constant is guaranteed to be as big as a delegate or handle
			// Just redirect access to the same constant
			node.Access = node.Operand->Access;
		}
		else
		{
			Error("Unknown cast type!");
		}
	}

	//***************************************************************************
	void CodeGenerator::CreateCopyOpcode(Function* function, CopyMode::Enum mode, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
	{
		// The instruction that we will end up using
		Instruction::Enum instruction = Instruction::InvalidInstruction;

		// Get the instance of the type database
		Core& core = Core::GetInstance();

		if (Type::IsSame(type, core.IntegerType))
		{
			instruction = Instruction::CopyInteger;
		}
		else if (Type::IsSame(type, core.RealType))
		{
			instruction = Instruction::CopyReal;
		}
		else if (Type::IsSame(type, core.BooleanType))
		{
			instruction = Instruction::CopyBoolean;
		}
		else if (Type::IsHandleType(type))
		{
			instruction = Instruction::CopyHandle;
		}
		else if (Type::IsDelegateType(type))
		{
			instruction = Instruction::CopyDelegate;
		}
		else if (Type::IsValueType(type))
		{
			instruction = Instruction::CopyValue;
		}
		else if (Type::IsAnyType(type))
		{
			instruction = Instruction::CopyAny;
		}
		else
		{
			Error("Unhandled case, should have been caught in syntaxer (what type could this be?)");
		}

		// Create the opcode
		CopyOpcode& opcode = function->AllocateOpcode<CopyOpcode>(instruction, debugOrigin, location);

		// Initialize the source and destination of the opcode
		opcode.Source = source;
		opcode.Destination = destination;
		opcode.Mode = mode;

		// The object opcode requires a size
		// Currently, unless we introduce the concept back
		// of general memory copy, this concept is not used
		opcode.Size = type->GetCopyableSize();
	}

	//***************************************************************************
	void CodeGenerator::GenerateCopyToReturn(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
	{
		return CreateCopyOpcode(function, CopyMode::ToReturn, type, source, destination, debugOrigin, location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateCopyInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
	{
		return CreateCopyOpcode(function, CopyMode::Initialize, type, source, destination, debugOrigin, location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateCopyToParameter(Function* function, Type* type, const Operand& source, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
	{
		return CreateCopyOpcode(function, CopyMode::ToParameter, type, source, Operand(destRegister), debugOrigin, location);
	}

	//***************************************************************************
	void CodeGenerator::GenerateCopyFromReturn(Function* function, Type* type, OperandIndex sourceRegister, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location)
	{
		// Side note, copying returns always copies to an uninitialized
		// place in memory so it must always be an initializing copy
		return CreateCopyOpcode(function, CopyMode::FromReturn, type, Operand(sourceRegister), Operand(destRegister), debugOrigin, location);
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	const long long Timer::TicksPerSecond = CLOCKS_PER_SEC;

	//***************************************************************************
	Timer::Timer() :
		TotalTicks(0),
		LastClock(clock())
	{
	}

	//***************************************************************************
	long long Timer::GetAndUpdateTicks()
	{
		// Get the current clock tick count (it may have wrapped around / overflowed!)
		long long currentClock = clock();

		// If the current value we sampled is greater than the last value, there's a good chance
		// that we didn't wrap around. The only time this could fail is if this function only gets
		// called once every 500 hours or so, giving it time to wrap back up to its last value
		if (currentClock >= this->LastClock)
		{
			// Just append the difference in ticks
			long long difference = currentClock - this->LastClock;
			this->TotalTicks += difference;

			// Because of wrap around, we need this timer to be updated periodicially (on a regular basis)
			// We'll basically throw an assert/warning if the user only calls this once an hour or longer
			const long long SecondsPerMinute = 60;
			const long long MinutesPerHour = 60;
			const long long HoursPerDay = 24;
			ErrorIf(difference > Timer::TicksPerSecond * SecondsPerMinute * MinutesPerHour * HoursPerDay,
				"The timer should be called at least once a day to prevent wrap around issues");
		}
		else
		{
			// Otherwise, we probably just wrapped around so we need to figure out how much we added
			// The amount that was added is the current clock value minus the bottom value (since it wrapped around)
			// plus the difference between the last clock value and the max, where it would have wrapped
			// We add 1 because the wrap itself actually represents an increment of 1
			this->TotalTicks += currentClock - numeric_limits<clock_t>::min();
			this->TotalTicks += numeric_limits<clock_t>::max() - this->LastClock;
			this->TotalTicks += 1;
		}

		// Store the last clock, used for resolving time
		this->LastClock = currentClock;

		// Return the ticks we've acounted for
		return this->TotalTicks;
	}

	//***************************************************************************
	void Timer::Reset()
	{
		// Just clear the tick count
		this->TotalTicks = 0;
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	UserToken::UserToken() :
		TokenId(Grammar::Invalid),
		Start(0),
		Length(0)
	{
	}

	//***************************************************************************
	UserToken::UserToken(StringParam token, Grammar::Enum tokenId) :
		Token(token),
		TokenId(tokenId),
		Start(0),
		Length(0)
	{
	}

	//***************************************************************************
	Tokenizer::Tokenizer(CompilationErrors& errors) :
		WasCarriageReturn(false),
		Errors(errors),
		EnableStringInterpolation(true)
	{
		ZilchErrorIfNotStarted(Tokenizer);

		// Start the position off at the beginning
		this->Position = 0;
		this->ForwardPosition = 0;

		// Start off with a comment depth of zero (we're not in a comment yet!)
		this->CommentDepth = 0;

		// Setup the 'Eof' token
		this->Eof.TokenId = Grammar::End;
		this->Eof.Start = 0;
		this->Eof.Length = 0;
	}

	//***************************************************************************
	void Tokenizer::Finalize(Array<UserToken>& tokensOut)
	{
		tokensOut.push_back(this->Eof);
	}

	//***************************************************************************
	const UserToken* Tokenizer::GetBaseToken()
	{
		static UserToken token(Grammar::GetKeywordOrSymbol(Grammar::Base), Grammar::Base);
		return &token;
	}

	//***************************************************************************
	const UserToken* Tokenizer::GetThisToken()
	{
		static UserToken token(ThisKeyword, Grammar::LowerIdentifier);
		return &token;
	}

	//***************************************************************************
	const UserToken* Tokenizer::GetValueToken()
	{
		static UserToken token(ValueKeyword, Grammar::LowerIdentifier);
		return &token;
	}

	//***************************************************************************
	const UserToken* Tokenizer::GetAccessToken()
	{
		static UserToken token(Grammar::GetKeywordOrSymbol(Grammar::Access), Grammar::Access);
		return &token;
	}

	//***************************************************************************
	const UserToken* Tokenizer::GetAssignmentToken()
	{
		static UserToken token(Grammar::GetKeywordOrSymbol(Grammar::Assignment), Grammar::Assignment);
		return &token;
	}

	//***************************************************************************
	bool Tokenizer::Parse(const CodeEntry& entry, Array<UserToken>& tokensOut, Array<UserToken>& commentsOut)
	{
		// Clear out our location for proper line and character counting
		this->Location = CodeLocation();
		this->Location.Origin = entry.Origin;
		this->Location.CodeUserData = entry.CodeUserData;
		this->Location.Code = entry.Code;
		this->Line = 1;
		this->Character = 1;

		// Store the data pointer
		this->Data = entry.Code;

		// The average number of characters per token (including whitespace)
		const int AverageCharsPerToken = 5;

		// Reserve some memory for parsed tokens
		tokensOut.reserve(this->Data.size() / AverageCharsPerToken);

		// Start the position off at the beginning
		this->Position = 0;
		this->ForwardPosition = 0;

		// Now attempt to parse the data
		return ParseInternal(tokensOut, commentsOut);
	}

	//***************************************************************************
	bool Tokenizer::ParseInternal(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut)
	{
		// The next token that will be parsed as we move along
		UserToken nextToken;

		// Loop and read tokens until we get an error or reach the end
		while (this->ReadToken(&nextToken))
		{
			// If we got here, then we know the symbol is valid because the ReadToken returned true
			// Do something based on the symbol's type
			switch (nextToken.TokenId)
			{
				// If we get a comment start symbol, continue on into block comment testing
			case Grammar::CommentStart:
			{
				// Since we just hit a comment start, increment the comment depth
				++this->CommentDepth;
			}
			break;

			// If we get a comment end symbol, back one comment scope out
			case Grammar::CommentEnd:
			{
				// Make sure our comment depth is greater than zero
				if (this->CommentDepth > 0)
				{
					// Since we just hit a comment end, decrement the comment depth
					--this->CommentDepth;
				}
				else
				{
					// Add a parsing error
					this->Errors.Raise(this->Location, ErrorCode::BlockCommentNotFound);
				}
			}
			break;

			// If we begin a line comment, skip to the end of the line
			case Grammar::CommentLine:
			{
				// Check and make sure we're not in a comment
				if (this->CommentDepth == 0)
				{
					// Skip to the end of the line via modifying the position
					nextToken.Token = this->SkipToEndOfLine();
					commentsOut.push_back(nextToken);
				}
			}
			break;

			// Whitespace we do absolutely nothing (just ignore it)
			case Grammar::Whitespace:
			{
			}
			break;

			// This was not a special symbol, just report it to the user
			default:
			{
				// Check and make sure we're not in a comment
				if (this->CommentDepth == 0)
				{
					// Push the token into the list
					tokensOut.push_back(nextToken);
				}
			}
			break;
			}
		}

		//printf("Was Error: %d\n", this->Errors.WasError);
		//printf("------ Begin Tokens ------\n");
		//for (size_t i = 0; i < tokensOut.size(); ++i)
		//{
		//  printf("Token: %d : %d '%s'\n", i, tokensOut[i].TokenId, tokensOut[i].Token.c_str());
		//}
		//printf("------ End Tokens ------\n");

		// As long as there were no errors...
		if (this->Errors.WasError == false)
		{
			// Check and make sure we're not in a comment
			if (this->CommentDepth == 0)
			{
				// We reached the end, no problems!
				return true;
			}
			// If we were in the middle of a comment, this is an error!
			else
			{
				// Add a parsing error and return out
				this->Errors.Raise(this->Location, ErrorCode::BlockCommentNotComplete);
				return false;
			}
		}
		else
		{
			// There was an error, so we failed
			return false;
		}
	}

	//***************************************************************************
	char Tokenizer::ReadCharacter()
	{
		// If the current position is outside the data bounds...
		if (this->Position >= this->Data.size())
		{
			// Increment the position by a byte even though we're past the end
			// We rely on this position being pushed out to properly get the length of tokens
			++this->Position;

			// Return the null character. Every place that calls ReadCharacter
			// should expect and handle the case of reaching the end
			return '\0';
		}

		// Stores the result of the read
		char result = this->Data[this->Position];

		// Increment the position by a byte
		++this->Position;

		// If we've actually moved forward
		if (this->ForwardPosition < this->Position)
		{
			// Update the line and character number
			UpdateLineAndCharacterNumber(result);

			// Move the forward position forward
			this->ForwardPosition = this->Position;
		}

		// Return the stored temporary value
		return result;
	}

	//***************************************************************************
	bool Tokenizer::DiffString(const char* string)
	{
		// Store the local string position
		int localStringPos = 0;

		// Have we matched the string to the input stream yet?
		bool match = false;

		// Loop until we reach the end of the given string, or we hit an invalid character
		ZilchLoop
		{
			// If we hit the end of our given string (and we've matched up to this point) then it's a match!
			if (string[localStringPos] == '\0')
			{
				// Mark it as being a match and jump out
				match = true;
				break;
			}
			// Otherwise, if the characters were not the same, we must break out
			// Eof is handled because the string we compare with should never have eof in it (see the check above)
			else if (ReadCharacter() != string[localStringPos])
			{
				// Backup the position by once since we just read a character that wasn't in this string
				--this->Position;
				break;
			}

			// Increment the local string position
			++localStringPos;
		}

			// Return whether we matched or not
		return match;
	}

	//***************************************************************************
	bool Tokenizer::ReadKeywordOrSymbol(UserToken* outToken, size_t& lastAcceptedPos, char& character, TokenCategory::Enum& tokenType)
	{
		// Was a token ever accepted?
		bool acceptedToken = false;

		// Store the type of token we're parsing (we should know immediately from the first branch)
		tokenType = TokenCategory::Unknown;

		// In the event that we've gotten here, 
		character = ReadCharacter();

		switch (character)
		{
		case 'a':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'b':
			{
				if (DiffString("stract"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Abstract /* Abstract */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 's':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::As /* As */;
				acceptedToken = true;

				character = ReadCharacter();

				switch (character)
				{
				case 's':
				{
					if (DiffString("ert"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Assert /* Assert */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'l':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'i':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'a':
					{
						if (DiffString("s"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Alias /* Alias */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					case 'g':
					{
						if (DiffString("nof"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Alignof /* Alignof */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				}
				break;
			}

			case 'n':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'd':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::And /* And */;
					acceptedToken = true;

					character = ReadCharacter();

					break;
				}

				case 'y':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Any /* Any */;
					acceptedToken = true;

					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'u':
			{
				if (DiffString("to"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Auto /* Auto */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'b':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'a':
			{
				if (DiffString("se"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Base /* Base */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'r':
			{
				if (DiffString("eak"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Break /* Break */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 's':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 't':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'a':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 't':
					{
						if (DiffString("ic"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Static /* Static */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					case 'c':
					{
						if (DiffString("kalloc"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Stackalloc /* Stackalloc */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				case 'r':
				{
					if (DiffString("uct"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Struct /* Struct */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'c':
			{
				if (DiffString("ope"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Scope /* Scope */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'i':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'g':
				{
					if (DiffString("ned"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Signed /* Signed */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'z':
				{
					if (DiffString("eof"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Sizeof /* Sizeof */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'e':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'a':
				{
					if (DiffString("led"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Sealed /* Sealed */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 't':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Set /* Set */;
					acceptedToken = true;

					character = ReadCharacter();

					break;
				}

				case 'n':
				{
					if (DiffString("ds"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Sends /* Sends */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'w':
			{
				if (DiffString("itch"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Switch /* Switch */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 't':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'r':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'u':
				{
					if (DiffString("e"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::True /* True */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'y':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Try /* Try */;
					acceptedToken = true;

					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'i':
			{
				if (DiffString("meout"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Timeout /* Timeout */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'h':
			{
				if (DiffString("row"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Throw /* Throw */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'y':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'p':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'e':
					{
						character = ReadCharacter();

						switch (character)
						{
						case 'i':
						{
							if (DiffString("d"))
							{
								lastAcceptedPos = this->Position;
								outToken->TokenId = Grammar::Typeid /* Typeid */;
								acceptedToken = true;
							}
							character = ReadCharacter();

							break;
						}

						case 'n':
						{
							if (DiffString("ame"))
							{
								lastAcceptedPos = this->Position;
								outToken->TokenId = Grammar::Typename /* Typename */;
								acceptedToken = true;
							}
							character = ReadCharacter();

							break;
						}

						case 'o':
						{
							if (DiffString("f"))
							{
								lastAcceptedPos = this->Position;
								outToken->TokenId = Grammar::Typeof /* Typeof */;
								acceptedToken = true;
							}
							character = ReadCharacter();

							break;
						}

						case 'd':
						{
							if (DiffString("ef"))
							{
								lastAcceptedPos = this->Position;
								outToken->TokenId = Grammar::Typedef /* Typedef */;
								acceptedToken = true;
							}
							character = ReadCharacter();

							break;
						}

						}
						break;
					}

					}
					break;
				}

				}
				break;
			}

			}
			break;
		}

		case 'r':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'e':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'a':
				{
					if (DiffString("donly"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Readonly /* Readonly */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 't':
				{
					if (DiffString("urn"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Return /* Return */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'g':
				{
					if (DiffString("ister"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Register /* Register */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'f':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Ref /* Ref */;
					acceptedToken = true;

					character = ReadCharacter();

					break;
				}

				case 'q':
				{
					if (DiffString("uire"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Require /* Require */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			}
			break;
		}

		case 'c':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'a':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 's':
				{
					if (DiffString("e"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Case /* Case */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 't':
				{
					if (DiffString("ch"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Catch /* Catch */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'l':
			{
				if (DiffString("ass"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Class /* Class */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'o':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'n':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 's':
					{
						character = ReadCharacter();

						switch (character)
						{
						case 't':
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Const /* Const */;
							acceptedToken = true;

							character = ReadCharacter();

							switch (character)
							{
							case 'r':
							{
								if (DiffString("uctor"))
								{
									lastAcceptedPos = this->Position;
									outToken->TokenId = Grammar::Constructor /* Constructor */;
									acceptedToken = true;
								}
								character = ReadCharacter();

								break;
							}

							}
							break;
						}

						}
						break;
					}

					case 't':
					{
						if (DiffString("inue"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Continue /* Continue */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				}
				break;
			}

			case 'h':
			{
				if (DiffString("ecked"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Checked /* Checked */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'l':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'o':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'c':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'a':
					{
						if (DiffString("l"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Local /* Local */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					case 'k':
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Lock /* Lock */;
						acceptedToken = true;

						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				case 'o':
				{
					if (DiffString("p"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Loop /* Loop */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			}
			break;
		}

		case 'i':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 's':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Is /* Is */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case 'n':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::In /* In */;
				acceptedToken = true;

				character = ReadCharacter();

				switch (character)
				{
				case 't':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'e':
					{
						character = ReadCharacter();

						switch (character)
						{
						case 'r':
						{
							character = ReadCharacter();

							switch (character)
							{
							case 'n':
							{
								if (DiffString("al"))
								{
									lastAcceptedPos = this->Position;
									outToken->TokenId = Grammar::Internal /* Internal */;
									acceptedToken = true;
								}
								character = ReadCharacter();

								break;
							}

							case 'f':
							{
								if (DiffString("ace"))
								{
									lastAcceptedPos = this->Position;
									outToken->TokenId = Grammar::Interface /* Interface */;
									acceptedToken = true;
								}
								character = ReadCharacter();

								break;
							}

							}
							break;
						}

						}
						break;
					}

					}
					break;
				}

				case 'c':
				{
					if (DiffString("lude"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Include /* Include */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'l':
				{
					if (DiffString("ine"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Inline /* Inline */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'f':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::If /* If */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case 'm':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'm':
				{
					if (DiffString("utable"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Immutable /* Immutable */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'p':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'l':
					{
						if (DiffString("icit"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Implicit /* Implicit */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					case 'o':
					{
						if (DiffString("rt"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Import /* Import */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				}
				break;
			}

			}
			break;
		}

		case 'g':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'l':
			{
				if (DiffString("obal"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Global /* Global */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'o':
			{
				if (DiffString("to"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Goto /* Goto */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'e':
			{
				if (DiffString("t"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Get /* Get */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'n':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'a':
			{
				if (DiffString("mespace"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Namespace /* Namespace */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'o':
			{
				if (DiffString("t"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Not /* Not */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'e':
			{
				if (DiffString("w"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::New /* New */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'u':
			{
				if (DiffString("ll"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Null /* Null */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'o':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'r':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Or /* Or */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case 'u':
			{
				if (DiffString("t"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Out /* Out */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'p':
			{
				if (DiffString("erator"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Operator /* Operator */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'v':
			{
				if (DiffString("erride"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Override /* Override */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'f':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'a':
			{
				if (DiffString("lse"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::False /* False */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'r':
			{
				if (DiffString("iend"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Friend /* Friend */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'l':
			{
				if (DiffString("ags"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Flags /* Flags */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'i':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'n':
				{
					if (DiffString("ally"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Finally /* Finally */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'x':
				{
					if (DiffString("ed"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Fixed /* Fixed */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'o':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'r':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::For /* For */;
					acceptedToken = true;

					character = ReadCharacter();

					switch (character)
					{
					case 'e':
					{
						if (DiffString("ach"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::ForEach /* ForEach */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				}
				break;
			}

			case 'u':
			{
				if (DiffString("nction"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Function /* Function */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'e':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'l':
			{
				if (DiffString("se"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Else /* Else */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'n':
			{
				if (DiffString("um"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Enumeration /* Enumeration */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'x':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 't':
				{
					if (DiffString("ern"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Extern /* Extern */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'p':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'l':
					{
						if (DiffString("icit"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Explicit /* Explicit */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					case 'o':
					{
						if (DiffString("rt"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Export /* Export */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				}
				break;
			}

			}
			break;
		}

		case 'u':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 's':
			{
				if (DiffString("ing"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Using /* Using */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'n':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 's':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'a':
					{
						if (DiffString("fe"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Unsafe /* Unsafe */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					case 'i':
					{
						if (DiffString("gned"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Unsigned /* Unsigned */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				case 'c':
				{
					if (DiffString("hecked"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Unchecked /* Unchecked */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			}
			break;
		}

		case 'd':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'o':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Do /* Do */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case 'e':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'b':
				{
					if (DiffString("ug"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Debug /* Debug */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 's':
				{
					if (DiffString("tructor"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Destructor /* Destructor */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'l':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'e':
					{
						character = ReadCharacter();

						switch (character)
						{
						case 't':
						{
							if (DiffString("e"))
							{
								lastAcceptedPos = this->Position;
								outToken->TokenId = Grammar::Delete /* Delete */;
								acceptedToken = true;
							}
							character = ReadCharacter();

							break;
						}

						case 'g':
						{
							if (DiffString("ate"))
							{
								lastAcceptedPos = this->Position;
								outToken->TokenId = Grammar::Delegate /* Delegate */;
								acceptedToken = true;
							}
							character = ReadCharacter();

							break;
						}

						}
						break;
					}

					}
					break;
				}

				case 'f':
				{
					if (DiffString("ault"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Default /* Default */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'y':
			{
				if (DiffString("namic"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Dynamic /* Dynamic */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'y':
		{
			tokenType = TokenCategory::Keyword;

			if (DiffString("ield"))
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Yield /* Yield */;
				acceptedToken = true;
			}
			character = ReadCharacter();

			break;
		}

		case 'm':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'o':
			{
				if (DiffString("dule"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Module /* Module */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'u':
			{
				if (DiffString("table"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Mutable /* Mutable */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'p':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'a':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'r':
				{
					character = ReadCharacter();

					switch (character)
					{
					case 'a':
					{
						if (DiffString("ms"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Params /* Params */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					case 't':
					{
						if (DiffString("ial"))
						{
							lastAcceptedPos = this->Position;
							outToken->TokenId = Grammar::Partial /* Partial */;
							acceptedToken = true;
						}
						character = ReadCharacter();

						break;
					}

					}
					break;
				}

				case 'c':
				{
					if (DiffString("kage"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Package /* Package */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'r':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'i':
				{
					if (DiffString("vate"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Private /* Private */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'o':
				{
					if (DiffString("tected"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Protected /* Protected */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case 'o':
			{
				if (DiffString("sitional"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Positional /* Positional */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'u':
			{
				if (DiffString("blic"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Public /* Public */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'v':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'a':
			{
				if (DiffString("r"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Variable /* Variable */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'i':
			{
				if (DiffString("rtual"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Virtual /* Virtual */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			case 'o':
			{
				if (DiffString("latile"))
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::Volatile /* Volatile */;
					acceptedToken = true;
				}
				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case 'w':
		{
			tokenType = TokenCategory::Keyword;

			character = ReadCharacter();

			switch (character)
			{
			case 'h':
			{
				character = ReadCharacter();

				switch (character)
				{
				case 'i':
				{
					if (DiffString("le"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::While /* While */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				case 'e':
				{
					if (DiffString("re"))
					{
						lastAcceptedPos = this->Position;
						outToken->TokenId = Grammar::Where /* Where */;
						acceptedToken = true;
					}
					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			}
			break;
		}

		case '.':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Access /* Access */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case '-':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Negative /* Negative, Subtract */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '-':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Decrement /* Decrement */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '>':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::DynamicAccess /* DynamicAccess */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentSubtract /* AssignmentSubtract */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '>':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::GreaterThan /* GreaterThan */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '>':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::BitshiftRight /* BitshiftRight */;
				acceptedToken = true;

				character = ReadCharacter();

				switch (character)
				{
				case '=':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::AssignmentRightShift /* AssignmentRightShift */;
					acceptedToken = true;

					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::GreaterThanOrEqualTo /* GreaterThanOrEqualTo */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '~':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::BitwiseNot /* BitwiseNot */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '>':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::NonVirtualAccess /* NonVirtualAccess */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case ':':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::TypeSpecifier /* TypeSpecifier, NameSpecifier, Inheritance, InitializerList */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case ',':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::ArgumentSeparator /* ArgumentSeparator */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case '=':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Assignment /* Assignment */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '>':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::RefersTo /* RefersTo */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Equality /* Equality */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '+':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Positive /* Positive, Add */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentAdd /* AssignmentAdd */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '+':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Increment /* Increment */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '/':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Divide /* Divide */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentDivide /* AssignmentDivide */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '/':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::CommentLine /* CommentLine */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '*':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::CommentStart /* CommentStart */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '*':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Multiply /* Multiply */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentMultiply /* AssignmentMultiply */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '/':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::CommentEnd /* CommentEnd */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '%':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Modulo /* Modulo */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentModulo /* AssignmentModulo */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '^':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::Exponent /* Exponent */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentExponent /* AssignmentExponent */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '<':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::LessThan /* LessThan */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::LessThanOrEqualTo /* LessThanOrEqualTo */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '<':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::BitshiftLeft /* BitshiftLeft */;
				acceptedToken = true;

				character = ReadCharacter();

				switch (character)
				{
				case '=':
				{
					lastAcceptedPos = this->Position;
					outToken->TokenId = Grammar::AssignmentLeftShift /* AssignmentLeftShift */;
					acceptedToken = true;

					character = ReadCharacter();

					break;
				}

				}
				break;
			}

			}
			break;
		}

		case '$':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::BitwiseXor /* BitwiseXor */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentBitwiseXor /* AssignmentBitwiseXor */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '|':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::BitwiseOr /* BitwiseOr */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentBitwiseOr /* AssignmentBitwiseOr */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '|':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::LogicalOr /* LogicalOr */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '&':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::BitwiseAnd /* BitwiseAnd */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::AssignmentBitwiseAnd /* AssignmentBitwiseAnd */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			case '&':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::LogicalAnd /* LogicalAnd */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '!':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::LogicalNot /* LogicalNot */;
			acceptedToken = true;

			character = ReadCharacter();

			switch (character)
			{
			case '=':
			{
				lastAcceptedPos = this->Position;
				outToken->TokenId = Grammar::Inequality /* Inequality */;
				acceptedToken = true;

				character = ReadCharacter();

				break;
			}

			}
			break;
		}

		case '@':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::PropertyDelegate /* PropertyDelegate */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case ';':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::StatementSeparator /* StatementSeparator */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case '[':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::BeginIndex /* BeginIndex, BeginTemplate, BeginInitializer */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case ']':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::EndIndex /* EndIndex, EndTemplate, EndInitializer */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case '(':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::BeginFunctionCall /* BeginFunctionCall, BeginFunctionParameters, BeginGroup */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case ')':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::EndFunctionCall /* EndFunctionCall, EndFunctionParameters, EndGroup */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case '{':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::BeginScope /* BeginScope */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		case '}':
		{
			tokenType = TokenCategory::Symbol;

			lastAcceptedPos = this->Position;
			outToken->TokenId = Grammar::EndScope /* EndScope */;
			acceptedToken = true;

			character = ReadCharacter();

			break;
		}

		}

		// If we accepted a token...
		if (acceptedToken)
		{
			// If the token type we started reading was a keyword...
			if (tokenType == TokenCategory::Keyword)
			{
				// As long as the last character read was not an alpha-numeric character...
				if (CharacterUtilities::IsAlphaNumeric(character) == false && character != '_')
				{
					// Backup the last read character
					--this->Position;

					// Return true since it must be a keyword
					return true;
				}

				// It's not at the end of a token, don't accept it... (but keep the position where it is)
				return false;
			}
			else
			{
				// Backup to the last accepted position
				this->Position = lastAcceptedPos;

				// Accept the token
				return true;
			}
		}

		// Since we got here, we must not have accepted the token
		return false;
	}

	//***************************************************************************
	bool Tokenizer::ReadIdentifier(UserToken* outToken, bool startedFromKeyword, size_t& lastAcceptedPos, char& character)
	{
		// Whether or not we've accepted the token
		bool acceptedToken = startedFromKeyword;

		// By default, assume we parsed a lower-case identifier
		// (starting from keywords will always lead to this case)
		Grammar::Enum assumedTokenType = Grammar::LowerIdentifier;

		// Loop until we hit a non-alpha numeric character
		ZilchLoop
		{
			// If we've accepted the token already
			if (acceptedToken)
			{
				// If it's not an alpha-numeric value or underscore, then we have to stop
				if (CharacterUtilities::IsAlphaNumeric(character) == false && character != '_')
					break;
			}
			// Otherwise, we haven't accepted anything yet (so we're on the first character)
			else
			{
				// If the first character is not just an alpha character, then we must stop
				// We cannot begin an identifier with an underscore
				if (CharacterUtilities::IsAlpha(character) == false)
					break;

				// If the first character is upper case, then this is an upper case identifier
				if (CharacterUtilities::IsUpper(character))
					assumedTokenType = Grammar::UpperIdentifier;
			}

			// Store away the position
			lastAcceptedPos = this->Position;

			// We read something! So we must accept the identifier
			acceptedToken = true;

			// Read the next character. We handle the eof in the next loop;
			// we will terminate since the character is not alphanumeric
			character = ReadCharacter();
		}

			// If we accepted the identifier...
			if (acceptedToken)
			{
				// Backup to the last accepted position
				this->Position = lastAcceptedPos;

				// It must be an identifier
				outToken->TokenId = assumedTokenType;
			}

		// Return the result...
		return acceptedToken;
	}

	//***************************************************************************
	bool Tokenizer::ReadNumber(UserToken* outToken, size_t& lastAcceptedPos, char& character)
	{
		// Whether or not we've accepted the token
		bool acceptedToken = false;

		// Is the number a real? This will be -1 if it's not
		size_t isRealPos = (size_t)-1;

		// If we're parsing an exponential number, then we can expect an exponent sign
		bool nextCanBeExplonentialSign = false;

		// If we hit an exponent 'e' or not (only may occur once)
		bool isScientificNotation = false;

		// If the number is double size (or precision)
		bool isDoubleSize = false;

		// While what we're reading is a digit or a decimal place
		ZilchLoop
		{
			// Clear the flag so we know that the next character cannot be a sign (store the flag for this loop)
			bool canBeExplonentialSign = nextCanBeExplonentialSign;
			nextCanBeExplonentialSign = false;

			// Note: Normally if ReadNumber was standalone, we'd need to be careful that we never
			// read something that starts with a '.', 'e', or 'd' as a token, however
			// because it only ever gets called after ReadIdentifier and ReadKeywordOrSymbol it cannot happen

			// If the character is a digit...
			if (CharacterUtilities::IsNumeric(character))
			{
				// Store away the position
				lastAcceptedPos = this->Position;

				// We read something! So we must accept the token
				acceptedToken = true;
			}
			// We only bother to read any other kind of symbol if we read a number already
			else if (acceptedToken)
			{
				// If the character is a decimal place...
				if (character == '.')
				{
					// If we haven't yet accepted a number, then it can't just start with '.'
					// (Though technically this should have been accepted as a symbol in the first place...)
					// Also break if we already determined it was a real, and then we broke out
					if (isRealPos != (size_t)-1 || acceptedToken == false)
						break;

					// Since we found a decimal, it must be a real number
					isRealPos = this->Position;
				}
				// If we hit an exponent 'e' and we're not already an exponent
				else if (character == 'e' && isScientificNotation == false)
				{
					// Since we're an exponent, the next character is allowed to be a '-' or '+'
					nextCanBeExplonentialSign = true;
				}
				// Check to see if this character is a sign...
				else if (canBeExplonentialSign && (character == '-' || character == '+'))
				{
					// We don't do anything here, including not accepting this token position
					// We need a number to follow in order to accept this!
				}
				// If we hit the 'double size' marker...
				else if (character == 'd')
				{
					// If the number ends in a 'd', it means our number is double sized (64 bit typically)
					isDoubleSize = true;

					// Accept the number and break out, since 'd' only ever occurs at the end
					lastAcceptedPos = this->Position;
					acceptedToken = true;
					break;
				}
				// If the character is unknown, we must break out
				else
				{
					break;
				}
			}
			// We attempted to read something that wasn't a number...
			else
			{
				break;
			}

			// Read the next character. We handle the eof in the next loop;
			// we will terminate since the character is not numeric or '.'
			character = ReadCharacter();
		}

			// If we accepted the identifier...
			if (acceptedToken)
			{
				// Backup to the last accepted position
				this->Position = lastAcceptedPos;

				// If the numeric literal is double sized...
				if (isDoubleSize)
				{
					// If we found a real instead of an integer...
					if (isRealPos < lastAcceptedPos)
						outToken->TokenId = Grammar::DoubleRealLiteral;
					else
						outToken->TokenId = Grammar::DoubleIntegerLiteral;
				}
				else
				{
					// If we found a real instead of an integer...
					if (isRealPos < lastAcceptedPos)
						outToken->TokenId = Grammar::RealLiteral;
					else
						outToken->TokenId = Grammar::IntegerLiteral;
				}
			}

		// Return the result...
		return acceptedToken;
	}

	//***************************************************************************
	bool Tokenizer::ReadString(UserToken* outToken, size_t& lastAcceptedPos, char& character)
	{
		// We only consider this string to be an interpolant end if it starts with a grave accent
		bool isInterpolantEnd = (this->EnableStringInterpolation && character == '`');

		// If the character is not a quote, then return failure immediately
		if (character != '"' && isInterpolantEnd == false)
			return false;

		// This is only used for tolerant mode when we don't parse a string because it wasn't closed
		size_t startPosition = this->Position;

		// Was an escape character hit?
		bool escaped = false;

		// Loop until we hit a non-alpha numeric character
		ZilchLoop
		{
			// Read the next character. We handle the eof specifically below
			character = ReadCharacter();

			// If the character is an escape character...
			if (character == '\\')
			{
				// Toggle the escaped flag
				// Note that we toggle it, instead of just turning it on
				// This is because \\ is actually escaping an escape
				escaped = !escaped;
			}
			else
			{
				// If we are currently escaped...
				if (escaped)
				{
					// Determine all the valid characters that we could escape on
					if (CharacterUtilities::IsStringEscapee(character) == false)
					{
						// If we're in a comment, ignroe invalid escape sequences
						if (this->CommentDepth == 0)
						{
							// We hit an invalid escape
							this->Errors.Raise(this->Location, ErrorCode::InvalidEscapeInStringLiteral, character);
							return false;
						}
					}

					// We are no longer escaped
					escaped = false;
				}
				// Otherwise, if it's a non escaped quotation..
				else if (character == '"' || (this->EnableStringInterpolation && character == '`'))
				{
					// Set that the last accepted position was this position
					lastAcceptedPos = this->Position;

					// If we're ending this string with a grave, then it means we're starting an interpolant
					bool isInterpolantStart = (this->EnableStringInterpolation && character == '`');

					// If the character is an interpolant starting character...
					if (isInterpolantStart)
					{
						if (isInterpolantEnd)
						{
							// We are both ending an intpolant and starting another...
							outToken->TokenId = Grammar::EndBeginStringInterpolate;
						}
						else
						{
							// We are just starting a new interpolant
							outToken->TokenId = Grammar::BeginStringInterpolate;
						}
					}
					else
					{
						if (isInterpolantEnd)
						{
							// We are just ending an interpolant
							outToken->TokenId = Grammar::EndStringInterpolate;
						}
						else
						{
							// It's just a straight up string literal
							outToken->TokenId = Grammar::StringLiteral;
						}
					}

					// We parsed the string or interpolant, call it good!
					return true;
				}
				// Is it the eof character or the end of a line?
				else if (character == '\0' || character == '\r' || character == '\n')
				{
					// If we're in tolerant mode, most likely the user was typing a string
					// or string interpolant and it wasn't yet closed
					// What we're going to do here is just parse this as a string token and cut it off
					if (this->Errors.TolerantMode)
					{
						// Just return this as if the entire line is a string
						outToken->TokenId = Grammar::StringLiteral;
						return true;
					}
					else
					{
						// We hit the eof before closing the string
						this->Errors.Raise(this->Location, ErrorCode::StringLiteralNotComplete);
						return false;
					}
				}
			}
		}
	}

	//***************************************************************************
	bool Tokenizer::ReadToken(UserToken* outToken)
	{
		// Store the last position at which we accepted a token (or the beginning of the token)
		size_t lastAcceptedPos = this->Position;

		// Set the starting position that the token is reading from
		outToken->Start = this->Position;

		// Store the character that we read
		char character = '\0';

		// Store the type of token we're parsing (we should know immediately from the first branch)
		TokenCategory::Enum tokenType;

		// Loop until we accept a token
		ZilchLoop
		{
			// Attempt to read a keyword or symbol
			// Internally we call 'ReadCharacter', which can return eof, so we handle it below
			if (ReadKeywordOrSymbol(outToken, lastAcceptedPos, character, tokenType) == true)
			{
				// Break out since we've found the full token
				break;
			}
			else
			{
				// If we started by reading a keyword...
				if (tokenType == TokenCategory::Keyword)
				{
					// Store away the position
					lastAcceptedPos = this->Position - 1;

					// Read the identifier (we don't actually need to check the return since we always know its 'true')
					bool result = ReadIdentifier(outToken, true, lastAcceptedPos, character);
					ErrorIf(result != true, "Reading the identifier must always succeed");
					break;
				}
				// If we didn't read anything yet...
				else if (tokenType == TokenCategory::Unknown)
				{
					// If the character is some sort of space character...
					if (CharacterUtilities::IsWhiteSpace(character))
					{
						// Set the starting position that the token is reading from
						outToken->Start = this->Position;

						// Since we hit whitespace, we want to update the location
						// so that the next token doesn't think it started in whitespace
						this->Location.StartLine = this->Line;
						this->Location.StartCharacter = this->Character;
						this->Location.PrimaryLine = this->Line;
						this->Location.PrimaryCharacter = this->Character;

						// Continue to the next loop iteration
						continue;
					}
					// Attempt to read it as an identifier
					else if (ReadIdentifier(outToken, false, lastAcceptedPos, character) ||
						ReadNumber(outToken, lastAcceptedPos, character) ||
						ReadString(outToken, lastAcceptedPos, character))
					{
						// Break out since we've found the full token
						break;
					}
					// If we reach the end of the file...
					else if (character == '\0')
					{
						// We hit the end
						return false;
					}
					// Otherwise, if there was an error...
					else if (this->Errors.WasError)
					{
						// An error occurred, return that we failed
						return false;
					}
				}

				// As long as we're not in the middle of a comment...
				if (this->CommentDepth == 0)
				{
					// Get the bad character
					char badCharacter = '?';

					// Ensure that the bad character was within the data bounds (for safety)
					if (outToken->Start < this->Data.size())
					{
						// Get the bad character
						badCharacter = this->Data[outToken->Start];
					}

					// If we got here, some sort of unknown data must have been input
					// Add a parsing error that informs the user that a token could not be read
					this->Errors.Raise(this->Location, ErrorCode::UnidentifiedSymbol, badCharacter);
					return false;
				}
			}
		}

			// Set the token's line and character number
		outToken->Location = this->Location;

		// Set the length of the token as the last recorded end minus the start
		outToken->Length = lastAcceptedPos - outToken->Start;

		// Read in the token
		outToken->Token = String(this->Data.c_str() + outToken->Start, outToken->Length);

		// Move the location's start forward
		this->Location.StartLine = this->Location.EndLine;
		this->Location.StartCharacter = this->Location.EndCharacter;
		this->Location.PrimaryLine = this->Location.EndLine;
		this->Location.PrimaryCharacter = this->Location.EndCharacter;

		// Return if the symbol was not null
		return true;
	}

	//***************************************************************************
	void Tokenizer::UpdateLineAndCharacterNumber(char character)
	{
		// The end of the location is always one character behind
		this->Location.EndLine = this->Line;
		this->Location.EndCharacter = this->Character;

		// Skip the null character
		if (character != '\0')
		{
			// Increment the character count for the current line
			++this->Character;

			// Check if the character matches that of the newline or carriage return
			if (character == '\n' || character == '\r')
			{
				// As long as the last character wasn't a carriage return and this character isn't a newline (CRLF)...
				// Note: If this was a full CRLF, we already incremented the line on the first CR, no need to do it again!
				if ((this->WasCarriageReturn && character == '\n') == false)
				{
					// Increment the line count since we hit a line
					++this->Line;
				}

				// If the character is a carriage return then set it
				this->WasCarriageReturn = (character == '\r');

				// For this new line, we start out on character one
				this->Character = 1;
			}
		}
	}

	//***************************************************************************
	String Tokenizer::SkipToEndOfLine()
	{
		// Get the range of text
		StringRange range;
		range.begin = this->Data.c_str() + this->Position;

		// Loop until we hit the end of a line or the end of the file
		ZilchLoop
		{
			// Read the next character. We handle eof specifically below
			char character = ReadCharacter();

			// Check if we hit either a newline or a carriage return
			if (character == '\n' || character == '\r' || character == '\0')
			{
				// Break out of the loop
				break;
			}
		}

			// Backup the input stream by one character
		--this->Position;

		// Set the end of the string range
		range.end = this->Data.c_str() + this->Position;

		// Return the parsed string
		return range;
	}

	//***************************************************************************
	bool CharacterUtilities::IsWhiteSpace(char c)
	{
		// Depending on the character...
		switch (c)
		{
			// Look for any of the standard white-space characters
		case ' ':
		case '\t':
		case '\n':
		case '\v':
		case '\f':
		case '\r':
			return true;
		}

		// Otherwise, we got here so it must not be white-space!
		return false;
	}

	//***************************************************************************
	bool CharacterUtilities::IsAlpha(char c)
	{
		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
	}

	//***************************************************************************
	bool CharacterUtilities::IsNumeric(char c)
	{
		return (c >= '0'&& c <= '9');
	}

	//***************************************************************************
	bool CharacterUtilities::IsAlphaNumeric(char c)
	{
		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0'&& c <= '9');
	}

	//***************************************************************************
	bool CharacterUtilities::IsUpper(char c)
	{
		return (c & 0x20) == 0;
	}

	//***************************************************************************
	bool CharacterUtilities::IsStringEscapee(char c)
	{
		// Determine all the valid characters that we could escape on
		switch (c)
		{
			// All of these are valid characters to be escaped (in a string literal)
		case '"':
		case '`':
		case '\\':
		case '0':
		case 'a':
		case 'b':
		case 'f':
		case 'n':
		case 'r':
		case 't':
		case 'v':
			return true;

			// We hit an invalid character...
		default:
			return false;
		}
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	ZilchDefineSimpleType(Type, Core);
	ZilchDefineSimpleType(AnyType, Core);
	ZilchDefineSimpleType(IndirectionType, Core);
	ZilchDefineSimpleType(DelegateType, Core);
	ZilchDefineType(BoundType, Core)
	{
		ZilchBindFieldGet(Name);
		type->CreatableInScript = false;
	}

	//***************************************************************************
	Type::Type() :
		SourceLibrary(nullptr),
		UserData(nullptr)
	{
	}

	//***************************************************************************
	String Type::GetDocumentationKey()
	{
		return this->ToString();
	}

	//***************************************************************************
	Resolver Resolver::Instance(Type* type)
	{
		Resolver resolver;
		resolver.IsStatic = false;
		resolver.TypeInstance = type;
		resolver.GetOverloadedFunctions = &Type::GetOverloadedInstanceFunctions;
		resolver.GetField = &Type::GetInstanceField;
		resolver.GetProperty = &Type::GetInstanceProperty;
		return resolver;
	}

	//***************************************************************************
	Resolver Resolver::Static(Type* type)
	{
		Resolver resolver;
		resolver.IsStatic = true;
		resolver.TypeInstance = type;
		resolver.GetOverloadedFunctions = &Type::GetOverloadedStaticFunctions;
		resolver.GetField = &Type::GetStaticField;
		resolver.GetProperty = &Type::GetStaticProperty;
		return resolver;
	}

	//***************************************************************************
	size_t Type::GetCopyableSize() const
	{
		return this->GetAllocatedSize();
	}

	//***************************************************************************
	byte* Type::GenericGetMemory(const byte* value) const
	{
		return const_cast<byte*>(value);
	}

	//***************************************************************************
	Function* Type::FindFunction(StringParam name, const Array<Type*>& parameters, Type* returnType, FindMemberOptions::Flags options) const
	{
		return nullptr;
	}

	//***************************************************************************
	Function* Type::GetPreConstructor() const
	{
		return nullptr;
	}

	//***************************************************************************
	Function* Type::GetDestructor() const
	{
		return nullptr;
	}

	//***************************************************************************
	const FunctionArray* Type::GetOverloadedInstanceFunctions(String name) const
	{
		return nullptr;
	}

	//***************************************************************************
	const FunctionArray* Type::GetOverloadedStaticFunctions(String name) const
	{
		return nullptr;
	}

	//***************************************************************************
	const FunctionArray* Type::GetOverloadedConstructors() const
	{
		return nullptr;
	}

	//***************************************************************************
	const FunctionArray* Type::GetOverloadedInheritedConstructors() const
	{
		return nullptr;
	}

	//***************************************************************************
	Function* Type::GetDefaultConstructor(const FunctionArray* constructors)
	{
		// Grab a reference to the core
		Core& core = Core::GetInstance();

		// Loop through all of our constructors
		for (size_t i = 0; i < constructors->size(); ++i)
		{
			// Grab the current constructor
			Function* constructor = (*constructors)[i];

			// Make sure none of the constructors have return values
			ErrorIf(constructor->Type->Return != core.VoidType,
				"A constructor was bound with a non-void return type");

			// As long as we have no parameters... this is the default constructor!
			if (constructor->Type->Parameters.empty())
			{
				return constructor;
			}
		}

		// If we got here, we failed to find a default constructor
		return nullptr;
	}

	//***************************************************************************
	Field* Type::GetInstanceField(String name) const
	{
		return nullptr;
	}

	//***************************************************************************
	Field* Type::GetStaticField(String name) const
	{
		return nullptr;
	}

	//***************************************************************************
	Property* Type::GetInstanceProperty(String name) const
	{
		return nullptr;
	}

	//***************************************************************************
	Property* Type::GetStaticProperty(String name) const
	{
		return nullptr;
	}

	//***************************************************************************
	SendsEventRange Type::GetSendsEvents() const
	{
		return SendsEventRange();
	}

	//***************************************************************************
	bool Type::IsHandleType(Type* type)
	{
		// See if the type is an indirection type...
		IndirectionType* indirectionType = TypeBinding::DynamicCast<IndirectionType*>(type);

		// If so, then it is a handle!
		if (indirectionType != nullptr)
		{
			return true;
		}

		// Otherwise, get the type as a named type...
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

		// If the type is a handle...
		return boundType != nullptr && boundType->GetCopyMode() == TypeCopyMode::ReferenceType;
	}

	//***************************************************************************
	bool Type::IsValueType(Type* type)
	{
		// Otherwise, get the type as a named type...
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

		// If the type is a value...
		return boundType != nullptr && boundType->GetCopyMode() == TypeCopyMode::ValueType;
	}

	//***************************************************************************
	bool Type::IsDelegateType(Type* type)
	{
		// See if the type is a delegate type...
		DelegateType* delegateType = TypeBinding::DynamicCast<DelegateType*>(type);
		return (delegateType != nullptr);
	}

	//***************************************************************************
	bool Type::IsEnumType(Type* type)
	{
		// Otherwise, get the type as a named type...
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

		// If the type is a bound type set to enumeration...
		return boundType != nullptr && boundType->SpecialType == SpecialType::Enumeration;
	}

	//***************************************************************************
	bool Type::IsFlagsType(Type* type)
	{
		// Otherwise, get the type as a named type...
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

		// If the type is a bound type set to flags...
		return boundType != nullptr && boundType->SpecialType == SpecialType::Flags;
	}

	//***************************************************************************
	bool Type::IsEnumOrFlagsType(Type* type)
	{
		// Otherwise, get the type as a named type...
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

		// If the type is a bound type set to flags or enumeration...
		return boundType != nullptr && (boundType->SpecialType == SpecialType::Flags || boundType->SpecialType == SpecialType::Enumeration);
	}

	//***************************************************************************
	bool Type::IsAnyType(Type* type)
	{
		// See if the type is a any type...
		AnyType* anyType = TypeBinding::DynamicCast<AnyType*>(type);
		return (anyType != nullptr);
	}

	//***************************************************************************
	Type* Type::GetBaseType(Type* type)
	{
		// Attempt to get the given type as a bound type
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(type);

		// If the type was a bound type...
		if (boundType != nullptr)
		{
			// The base type could be null if we don't have a base class
			return boundType->BaseType;
		}

		// Attempt to get the given type as a bound type
		IndirectionType* indirectType = TypeBinding::DynamicCast<IndirectionType*>(type);

		// If the type was a bound type...
		if (indirectType != nullptr)
		{
			// Get the type we're pointing at, then get it's base type
			return indirectType->ReferencedType->BaseType;
		}

		// If we got here then either we had no base type, or the
		// given type doesn't support base types (delegates, etc)
		return nullptr;
	}

	//***************************************************************************
	BoundType* Type::GetReferenceType(Type* handleType)
	{
		// See if the type is an indirection type...
		IndirectionType* indirectionType = TypeBinding::DynamicCast<IndirectionType*>(handleType);

		// If so, then it is a handle!
		if (indirectionType != nullptr)
		{
			return indirectionType->ReferencedType;
		}

		// Otherwise, get the type as a named type...
		BoundType* boundType = TypeBinding::DynamicCast<BoundType*>(handleType);

		// If the type is a handle...
		if (boundType != nullptr && boundType->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			return boundType;
		}

		// If it was neither, then it is not a handle type
		return nullptr;
	}

	//***************************************************************************
	bool Type::IsSame(Type* a, Type* b)
	{
		// If the two pointers are exactly the same, then of course its the same!
		if (a == b)
		{
			// Early out and return that they are the same :D
			return true;
		}

		// Compare the hashes (we do this anyways in the linking phase, might as well do it here too)
		GuidType hashA = a->Hash();
		GuidType hashB = b->Hash();
		bool result = (hashA == hashB);

		// We better not get the same hash when hashing two different types...
		ErrorIf(result && a->ZilchGetDerivedType() != b->ZilchGetDerivedType(),
			"The same hash/guid was computed for two different types!");

		// Return the result (true if they are the same, false otherwise)
		return result;
	}

	//***************************************************************************
	IndirectionType::IndirectionType() :
		ReferencedType(nullptr)
	{
	}

	//***************************************************************************
	bool IndirectionType::IsCopyComplex() const
	{
		// Handles are always a complex copy
		return true;
	}

	//***************************************************************************
	size_t IndirectionType::GetAllocatedSize() const
	{
		return sizeof(Handle);
	}

	//***************************************************************************
	GuidType IndirectionType::Hash() const
	{
		return 118465894487008423 ^ this->ReferencedType->Hash();
	}

	//***************************************************************************
	String IndirectionType::ToString() const
	{
		// Create a string builder since we're doing some concatenation
		StringBuilder output;

		// Add the 'ref' keyword
		output += Grammar::GetKeywordOrSymbol(Grammar::Ref);
		output += " ";

		// Add the type we're referencing
		output += this->ReferencedType->ToString();

		// Output the string
		return output.ToString();
	}

	//***************************************************************************
	void IndirectionType::GenericDefaultConstruct(byte* toConstruct) const
	{
		// Construct a null / empty handle
		new (toConstruct)Handle();
	}

	//***************************************************************************
	void IndirectionType::GenericCopyConstruct(byte* to, const byte* from) const
	{
		// Indirect types are always represented as handles (just perform a handle copy)
		new (to)Handle(*(Handle*)from);
	}

	//***************************************************************************
	void IndirectionType::GenericDestruct(byte* value) const
	{
		// Destroy the handle object
		((Handle*)value)->~Handle();
	}

	//***************************************************************************
	int IndirectionType::GenericHash(const byte* value) const
	{
		return ((Handle*)value)->Hash();
	}

	//***************************************************************************
	String IndirectionType::GenericToString(const byte* value) const
	{
		// Grab the handle primitive
		Handle* handle = (Handle*)value;

		// By default, we know at least a base class type of what we're referencing
		const BoundType* type = this->ReferencedType;

		// The handle may store a more derived type inside it, if so, we should use that to print instead (virtual)
		if (handle->Type != nullptr)
			type = handle->Type;

		// Get a pointer to the data of the object
		byte* data = handle->Dereference();

		// If converting a null handle to a string... let the user know it's null, and what type it is
		if (data == nullptr)
			return BuildString("(null) ", type->ToString());

		// Run the user provided to-string function
		return type->ToStringFunction(type, data);
	}

	//***************************************************************************
	bool IndirectionType::GenericEquals(const byte* lhs, const byte* rhs) const
	{
		// Compare the two handles
		Handle& lHandle = *((Handle*)lhs);
		Handle& rHandle = *((Handle*)rhs);
		return lHandle == rHandle;
	}

	//***************************************************************************
	byte* IndirectionType::GenericGetMemory(const byte* value) const
	{
		// Get a pointer to the data of the object (indirect types are always handles)
		return ((Handle*)value)->Dereference();
	}

	//***************************************************************************
	Type* IndirectionType::GenericGetVirtualType(const byte* value) const
	{
		// Grab the handle
		Handle* handle = ((Handle*)value);

		// If it has no type, then return our own type
		if (handle->Type == nullptr)
			return (Type*)(this);

		// Otherwise return the type stored on the handle
		return handle->Type;
	}

	//***************************************************************************
	AnyType::AnyType()
	{
	}

	//***************************************************************************
	bool AnyType::IsCopyComplex() const
	{
		// The 'Any' class has a proper copy constructor
		return true;
	}

	//***************************************************************************
	size_t AnyType::GetAllocatedSize() const
	{
		return sizeof(Any);
	}

	//***************************************************************************
	GuidType AnyType::Hash() const
	{
		return 764373915523575397;
	}

	//***************************************************************************
	String AnyType::ToString() const
	{
		return Grammar::GetKeywordOrSymbol(Grammar::Any);
	}

	//***************************************************************************
	void AnyType::GenericDefaultConstruct(byte* toConstruct) const
	{
		// Construct a default instance of 'any', should be null
		new (toConstruct)Any();
	}

	//***************************************************************************
	void AnyType::GenericCopyConstruct(byte* to, const byte* from) const
	{
		// Copy construct the 'any' to the given location
		new (to)Any(*(Any*)from);
	}

	//***************************************************************************
	void AnyType::GenericDestruct(byte* value) const
	{
		// Destroy the any type
		((Any*)value)->~Any();
	}

	//***************************************************************************
	int AnyType::GenericHash(const byte* value) const
	{
		return ((Any*)value)->Hash();
	}

	//***************************************************************************
	String AnyType::GenericToString(const byte* value) const
	{
		return ((Any*)value)->ToString();
	}

	//***************************************************************************
	bool AnyType::GenericEquals(const byte* lhs, const byte* rhs) const
	{
		// Compare the two any types
		Any& lAny = *((Any*)lhs);
		Any& rAny = *((Any*)rhs);
		return lAny == rAny;
	}

	//***************************************************************************
	byte* AnyType::GenericGetMemory(const byte* value) const
	{
		// Get access to the any primitive
		Any* any = ((Any*)value);

		// Get the data pointed at by the any
		const byte* storedValue = any->GetData();

		// If we have a valid stored type... recursively get its memory
		if (any->StoredType != nullptr)
			return any->StoredType->GenericGetMemory(storedValue);

		// Otherwise we had nothing stored... just return ourselves
		// This MUST match the 'GenericGetVirtualType' behavior!
		return (byte*)value;
	}

	//***************************************************************************
	Type* AnyType::GenericGetVirtualType(const byte* value) const
	{
		// Get access to the any primitive
		Any* any = ((Any*)value);

		// If we have a valid stored type... recursively get its memory
		if (any->StoredType != nullptr)
			return any->StoredType->GenericGetVirtualType(value);

		// Otherwise we had nothing stored... just return ourselves
		// This MUST match the 'GenericGetMemory' behavior!
		return (Type*)this;
	}

	//***************************************************************************
	String BoundType::DefaultTypeToString(const BoundType* type, const byte* data)
	{
		return type->Name;
	}

	//***************************************************************************
	BoundType::BoundType(const String& name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount) :
		Name(name),
		CopyMode(copyMode),
		BaseType(nullptr),
		RawNativeVirtualCount(nativeVirtualCount),
		BoundNativeVirtualCount(0),
		HandleManager(ZilchManagerId(HeapManager)),
		PostDestructor(nullptr),
		ToStringFunction(DefaultTypeToString),
		PreConstructor(nullptr),
		Destructor(nullptr),
		SizeState(SizeState::Determined),
		SpecialType(SpecialType::Standard),
		CreatableInScript(true),
		Size(size)
	{
	}

	//***************************************************************************
	BoundType::~BoundType()
	{
	}

	//***************************************************************************
	GuidType BoundType::Hash() const
	{
		return this->Name.hash();
	}

	//***************************************************************************
	bool BoundType::IsCopyComplex() const
	{
		// We've only got a compex copy if we're a reference type
		return (this->GetCopyMode() == TypeCopyMode::ReferenceType);
	}

	//***************************************************************************
	size_t BoundType::GetCopyableSize() const
	{
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			return sizeof(Handle);
		}
		else
		{
			return this->GetAllocatedSize();
		}
	}

	//***************************************************************************
	size_t BoundType::GetAllocatedSize() const
	{
		// Return the size of the class since it's already been computed
		ErrorIf(this->SizeState == SizeState::Undetermined,
			"Attempting to get the size of a class when it has not been determined!");
		return this->Size;
	}

	//***************************************************************************
	String BoundType::ToString() const
	{
		return this->Name;
	}

	//***************************************************************************
	void BoundType::GenericDefaultConstruct(byte* toConstruct) const
	{
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Create a null handle if it's a reference type...
			new (toConstruct)Handle();
		}
		else
		{
			// Otherwise, clear the memory out to zeros (a valid configuration for all structs)
			memset(toConstruct, 0, this->GetCopyableSize());
		}
	}

	//***************************************************************************
	void BoundType::GenericCopyConstruct(byte* to, const byte* from) const
	{
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Copy the handle to it's destination position
			new (to)Handle(*(Handle*)from);
		}
		else
		{
			// Copy the value type directly
			memcpy(to, from, this->GetCopyableSize());
		}
	}

	//***************************************************************************
	void BoundType::GenericDestruct(byte* value) const
	{
		// We only need to do anything if this is a reference type
		// Value types do not need to be released
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Copy the handle to it's destination position
			((Handle*)value)->~Handle();
		}
	}

	//***************************************************************************
	int BoundType::GenericHash(const byte* value) const
	{
		// If this is a reference type, it means it's a handle
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Hash the handle and return that value
			return ((Handle*)value)->Hash();
		}
		else
		{
			// Otherwise generate a hash from the value-type memory
			return (int)HashString((const char*)value, this->Size);
		}
	}

	//***************************************************************************
	String BoundType::GenericToString(const byte* value) const
	{
		// By default, we know at least a base class type of what we're referencing
		// For value types, this is always the case
		const BoundType* type = this;

		// For value types, we assume that the type is just the data we get (not for reference types!)
		byte* data = (byte*)value;

		// If this is a reference type (it may be virtual)
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Grab the handle primitive
			Handle* handle = (Handle*)value;

			// The handle may store a more derived type inside it, if so, we should use that to print instead (virtual)
			if (handle->Type != nullptr)
				type = handle->Type;

			// Get a pointer to the data of the object
			data = handle->Dereference();

			// If converting a null handle to a string... let the user know it's null, and what type it is
			if (data == nullptr)
				return BuildString("(null) ", type->ToString());
		}

		// Run the user provided to-string function
		return type->ToStringFunction(type, data);
	}

	//***************************************************************************
	bool BoundType::GenericEquals(const byte* lhs, const byte* rhs) const
	{
		// If this is a reference type, it means it's a handle
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Compare the two handles
			Handle& lHandle = *((Handle*)lhs);
			Handle& rHandle = *((Handle*)rhs);
			return lHandle == rHandle;
		}
		else
		{
			// Otherwise, do a comparison of the value-type memory
			return (memcmp(lhs, rhs, this->Size) == 0);
		}
	}

	//***************************************************************************
	byte* BoundType::GenericGetMemory(const byte* value) const
	{
		// If this is a reference type, it means it's a handle
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Hash the handle and return that value
			return ((Handle*)value)->Dereference();
		}
		else
		{
			// Otherwise this is a value type, so we just directly return the memory
			return const_cast<byte*>(value);
		}
	}

	//***************************************************************************
	Type* BoundType::GenericGetVirtualType(const byte* value) const
	{
		// If this is a reference type, it means it's a handle
		if (this->GetCopyMode() == TypeCopyMode::ReferenceType)
		{
			// Grab the handle (this behavior matches indirect type!)
			Handle* handle = ((Handle*)value);

			// If it has no type, then return our own type
			if (handle->Type == nullptr)
				return (Type*)(this);

			// Otherwise return the type stored on the handle
			return handle->Type;
		}
		else
		{
			// Otherwise this is a value type, so we the type is always the same
			return (Type*)this;
		}
	}

	//***************************************************************************
	TypeCopyMode::Enum BoundType::GetCopyMode() const
	{
		return this->CopyMode;
	}

	//***************************************************************************
	Function* BoundType::FindFunction(StringParam name, DelegateType* type, FindMemberOptions::Flags options) const
	{
		// The map of functions we'll look in (either static or instance)
		const FunctionMultiMap* functions = nullptr;

		// If we're looking for static functions...
		if (options & FindMemberOptions::Static)
			functions = &this->StaticFunctions;
		else
			functions = &this->InstanceFunctions;

		// Attempt to find the array
		const FunctionArray* foundFunctions = functions->findPointer(name);

		// Check if we found any functions by that name at this level
		if (foundFunctions != nullptr)
		{
			// Get a range so we can walk through all these functions
			FunctionArray::range foundRange = foundFunctions->all();

			// Loop through all the functions by the same name
			while (foundRange.empty() == false)
			{
				// Grab the current function and iterate to the next
				Function* function = foundRange.front();
				foundRange.popFront();

				// If the signature matches...
				if (Type::IsSame(function->Type, type))
				{
					// Return the function we found
					return function;
				}
			}
		}
		// If we found nothing...
		else
		{
			// If we're not searching base classes, just return out
			if (options & FindMemberOptions::DoNotIncludeBaseClasses || this->BaseType == nullptr)
				return nullptr;
			else
				// Walk up the base class looking for that same function
				return this->BaseType->FindFunction(name, type, options);
		}

		return nullptr;
	}

	//***************************************************************************
	Function* BoundType::FindFunction(StringParam name, const Array<Type*>& parameters, Type* returnType, FindMemberOptions::Flags options) const
	{
		// The map of functions we'll look in (either static or instance)
		const FunctionMultiMap* functions = nullptr;

		// If we're looking for static functions...
		if (options & FindMemberOptions::Static)
			functions = &this->StaticFunctions;
		else
			functions = &this->InstanceFunctions;

		// Attempt to find the array
		const FunctionArray* foundFunctions = functions->findPointer(name);

		// Check if we found any functions by that name at this level
		if (foundFunctions != nullptr)
		{
			// Get a range so we can walk through all these functions
			FunctionArray::range foundRange = foundFunctions->all();

			// Loop through all the functions by the same name
			while (foundRange.empty() == false)
			{
				// Grab the current function and iterate to the next
				Function* function = foundRange.front();
				foundRange.popFront();

				ParameterArray& params = function->Type->Parameters;

				if (parameters.size() != params.size())
					continue;

				bool sameParameters = true;

				for (size_t i = 0; i < params.size(); ++i)
				{
					DelegateParameter& current = params[i];
					if (Type::IsSame(current.ParameterType, parameters[i]) == false)
					{
						sameParameters = false;
						break;
					}
				}

				// If the signature matches...
				if (sameParameters)
				{
					// Return the function we found
					return function;
				}
			}
		}
		// If we found nothing...
		else
		{
			// If we're not searching base classes, just return out
			if (options & FindMemberOptions::DoNotIncludeBaseClasses || this->BaseType == nullptr)
				return nullptr;
			else
				return this->BaseType->FindFunction(name, parameters, returnType, options);
		}

		return nullptr;
	}

	//***************************************************************************
	const FunctionArray* BoundType::GetOverloadedInstanceFunctions(String name) const
	{
		// Attempt to find the array
		const FunctionArray* found = this->InstanceFunctions.findPointer(name);

		// If we found nothing...
		if (found == nullptr && this->BaseType != nullptr)
		{
			// Search our parent
			return this->BaseType->GetOverloadedInstanceFunctions(name);
		}

		// Return whatever we found
		return found;
	}

	//***************************************************************************
	const FunctionArray* BoundType::GetOverloadedStaticFunctions(String name) const
	{
		// Attempt to find the array
		const FunctionArray* found = this->StaticFunctions.findPointer(name);

		// If we found nothing...
		if (found == nullptr && this->BaseType != nullptr)
		{
			// Search our parent
			return this->BaseType->GetOverloadedStaticFunctions(name);
		}

		// Return whatever we found
		return found;
	}

	//***************************************************************************
	Field* BoundType::GetInstanceField(String name) const
	{
		// Attempt to find the value
		Field* found = this->InstanceFields.findValue(name, nullptr);

		// If we found nothing...
		if (found == nullptr && this->BaseType != nullptr)
		{
			// Search our parent
			return this->BaseType->GetInstanceField(name);
		}

		// Return whatever we found
		return found;
	}

	//***************************************************************************
	Field* BoundType::GetStaticField(String name) const
	{
		// Attempt to find the value
		Field* found = this->StaticFields.findValue(name, nullptr);

		// If we found nothing...
		if (found == nullptr && this->BaseType != nullptr)
		{
			// Search our parent
			return this->BaseType->GetStaticField(name);
		}

		// Return whatever we found
		return found;
	}

	//***************************************************************************
	Property* BoundType::GetInstanceProperty(String name) const
	{
		// Attempt to find the value
		Property* found = this->InstanceProperties.findValue(name, nullptr);

		// If we found nothing...
		if (found == nullptr && this->BaseType != nullptr)
		{
			// Search our parent
			return this->BaseType->GetInstanceProperty(name);
		}

		// Return whatever we found
		return found;
	}

	//***************************************************************************
	Property* BoundType::GetStaticProperty(String name) const
	{
		// Attempt to find the value
		Property* found = this->StaticProperties.findValue(name, nullptr);

		// If we found nothing...
		if (found == nullptr && this->BaseType != nullptr)
		{
			// Search our parent
			return this->BaseType->GetStaticProperty(name);
		}

		// Return whatever we found
		return found;
	}

	//***************************************************************************
	Function* BoundType::GetPreConstructor() const
	{
		// Attempt to find the value
		return this->PreConstructor;
	}

	//***************************************************************************
	const FunctionArray* BoundType::GetOverloadedConstructors() const
	{
		// Attempt to find the value
		return &this->Constructors;
	}

	//***************************************************************************
	const FunctionArray* BoundType::GetOverloadedInheritedConstructors() const
	{
		// Walk up the base class chain until we find any constructors (we inherit constructors)
		// We start with the current class we're trying to create
		// Note: We can safely look up to our base classes because if we don't have a constructor
		// then we at least have been pre-constructed, and the user opted to not initialize anything with a constructor
		const BoundType* constructedType = this;
		const FunctionArray* constructors = nullptr;

		ZilchLoop
		{
			// Grab the constructors for the current type
			constructors = constructedType->GetOverloadedConstructors();

			// If we found any constructors, early out
			if (constructors != nullptr && constructors->empty() == false)
				break;

			// We didn't find anything, so walk up to the base type and see if it has any (constructor inheritance)
			constructedType = constructedType->BaseType;

			// If we had no base, early out
			if (constructedType == nullptr)
				break;
		}

			// Return the constructors we found, or nothing (or an empty array!)
		return constructors;
	}

	//***************************************************************************
	Function* BoundType::GetDestructor() const
	{
		// Attempt to find the value
		return this->Destructor;
	}

	//***************************************************************************
	SendsEventRange BoundType::GetSendsEvents() const
	{
		return this->SendsEvents.all();
	}

	//***************************************************************************
	// Writes a line out that is tabbed in by two spaces
	// and every newline in the text will also be tabbed in
	void WriteLineTabbed(StringBuilderExtended& builder, StringParam text)
	{
		// Start off with two spaces of tabs
		builder.Write("  ");

		// Loop through every character in the text
		for (size_t i = 0; i < text.size(); ++i)
		{
			// Get the current character
			char c = text[i];

			// Write the character out
			builder.Write(c);

			// If the character was a newline, we need to insert a tab
			if (c == '\n')
			{
				// Write another two space tab, note that this is AFTER the newline
				builder.Write("  ");
			}
		}

		// Finally, write an ending newline
		builder.WriteLine();
	};

	//***************************************************************************
	// Writes a documented object's key and description out
	void WriteKeyDescription(StringBuilderExtended& builder, DocumentedObject* object)
	{
		// We denote keys in our format using the '#', which should never occur in a description
		builder.Write("#");
		builder.WriteLine(object->GetDocumentationKey());

		// Write the rest of the description on a tabbed in line (for human readability)
		WriteLineTabbed(builder, object->Description);
	};

	//***************************************************************************
	template <typename Range>
	void GenerateDocumentationText(StringBuilderExtended& builder, Range range)
	{
		// Loop through all members and write them out
		for (; range.empty() == false; range.popFront())
		{
			ZilchAutoVal(member, range.front());
			WriteKeyDescription(builder, member);
		}
	}

	//***************************************************************************
	template <>
	void GenerateDocumentationText<FunctionMultiMap::valuerange>(StringBuilderExtended& builder, FunctionMultiMap::valuerange range)
	{
		// Since we don't have a multi-map, we need to handle hash maps of function arrays specially
		for (; range.empty() == false; range.popFront())
		{
			FunctionArray& functions = range.front();
			GenerateDocumentationText(builder, functions.all());
		}
	}

	//***************************************************************************
	String BoundType::SaveDocumentation()
	{
		// We're going to build a file that includes all members and existing descriptions
		StringBuilderExtended builder;

		// Write out the type's name itself
		WriteKeyDescription(builder, this);

		// Then write out every member that we have (functions, properties, fields, etc)
		GenerateDocumentationText(builder, this->Constructors.all());
		GenerateDocumentationText(builder, this->StaticFunctions.values());
		GenerateDocumentationText(builder, this->InstanceFunctions.values());
		GenerateDocumentationText(builder, this->StaticProperties.values());
		GenerateDocumentationText(builder, this->InstanceProperties.values());
		GenerateDocumentationText(builder, this->StaticFields.values());
		GenerateDocumentationText(builder, this->InstanceFields.values());

		// Return the final documentation string for this type
		return builder.ToString();
	}

	//***************************************************************************
	// This class only exists so that we can mark members as having been documented (saftey checks)
	class DocumentedInfo
	{
	public:
		DocumentedInfo(DocumentedObject* object) :
			IsDocumented(false),
			Object(object)
		{
		}

		bool IsDocumented;
		DocumentedObject* Object;
	};

	//***************************************************************************
	// Maps a documented object by key to the object itself
	void MapDocumentedObject(HashMap<String, DocumentedInfo>& documentedObjects, DocumentedObject* object)
	{
		// Get the key for the current documented object
		String key = object->GetDocumentationKey();

		// Map the key (string) to the object itself
		documentedObjects.insert(key, DocumentedInfo(object));
	};

	//***************************************************************************
	template <typename Range>
	void GenerateDocumentationMap(HashMap<String, DocumentedInfo>& documentedObjects, Range range)
	{
		// Loop through each member and insert it into the map
		for (; range.empty() == false; range.popFront())
		{
			ZilchAutoVal(object, range.front());
			MapDocumentedObject(documentedObjects, object);
		}
	}

	//***************************************************************************
	template <>
	void GenerateDocumentationMap<FunctionMultiMap::valuerange>(HashMap<String, DocumentedInfo>& documentedObjects, FunctionMultiMap::valuerange range)
	{
		// Since we don't have a multi-map, we need to handle hash maps of function arrays specially
		for (; range.empty() == false; range.popFront())
		{
			FunctionArray& functions = range.front();
			GenerateDocumentationMap(documentedObjects, functions.all());
		}
	}

	//***************************************************************************
	void BoundType::LoadDocumentation(String doc)
	{
		// The first thing we need to do before actually parsing any of the file is build a map
		// that maps documentation keys back to our objects. The keys are human readable and unique per type
		HashMap<String, DocumentedInfo> documentedObjects;

		// Map the type itself first, since it can be documented
		MapDocumentedObject(documentedObjects, this);

		// Now map all the members of the type
		GenerateDocumentationMap(documentedObjects, this->Constructors.all());
		GenerateDocumentationMap(documentedObjects, this->StaticFunctions.values());
		GenerateDocumentationMap(documentedObjects, this->InstanceFunctions.values());
		GenerateDocumentationMap(documentedObjects, this->StaticProperties.values());
		GenerateDocumentationMap(documentedObjects, this->InstanceProperties.values());
		GenerateDocumentationMap(documentedObjects, this->StaticFields.values());
		GenerateDocumentationMap(documentedObjects, this->InstanceFields.values());

		// When parsing, we always start with a key which is denoted by the # character
		bool keyStarted = false;
		StringRange keyRange;

		// Once a key is finished parsing (once we hit the first newline after the #)
		// we attempt to find a documented object under the same key
		DocumentedInfo* foundInfo = nullptr;

		// After we've parsed a key, we attempt to parse a description (if it exists)
		StringBuilder descriptionBuilder;

		// When set to true, we will eat whitespace
		// Meant for eating the tabbing at the front of the descriptions
		bool eatTabs = false;

		// Walk through the entire documentation file/string
		const char* docCStr = doc.c_str();
		for (size_t i = 0; i <= doc.size(); ++i)
		{
			// Get the current character
			char c = docCStr[i];

			// We skip all carriage returns, and encourage this file to be written in Windows/Unix format
			if (c == '\r')
				continue;

			// If set, we will eat tabs (in the form of spaces) until we hit a valid character
			if (eatTabs)
			{
				// If we hit a space, eat it up (don't let it enter the descriptionBuilder)
				if (c == ' ')
				{
					continue;
				}
				// Otherwise, we hit a valid character to stop eating tabs
				else
				{
					eatTabs = false;
				}
			}

			// If we hit a marker for a new key (or the end of the text)
			if (c == '#' || c == '\0')
			{
				// If we had a key/description started...
				if (foundInfo != nullptr)
				{
					// Read out the description that we've built up and clear the builder
					foundInfo->Object->Description = descriptionBuilder.ToString();
					descriptionBuilder.Deallocate();
				}

				// If we're starting a new key...
				if (c == '#')
				{
					// Mark that we're starting the key and save the start of the key
					keyStarted = true;

					// The +1 is to skip the # sign
					keyRange.begin = docCStr + i + 1;
				}

				// We always clear the previous found member
				// It is possible to find a member, but not read any description
				foundInfo = nullptr;
			}
			// If we hit a newline...
			else if (c == '\n')
			{
				// If we already started a key, this means we're done with the key!
				if (keyStarted)
				{
					// Clear the key flag and finish the key range so we can get the key as a string
					keyStarted = false;
					keyRange.end = docCStr + i;
					String key = keyRange;

					// Lookup the key in the map of documented objects
					foundInfo = documentedObjects.findPointer(key);
					if (foundInfo != nullptr)
					{
						// We found it so mark it as documented
						// Note that even if a description is empty, we still count it as documenting the member
						// since we only care about MISSING members being errors
						foundInfo->IsDocumented = true;
					}
					else
					{
						//Error("A documented member '%s' was found in the file but not on the type", key.c_str());
					}
				}
				else
				{
					// We only want to count newlines after we've started parsing
					if (descriptionBuilder.GetSize() != 0)
					{
						descriptionBuilder.Append(c);
					}
				}

				eatTabs = true;
			}
			else if (foundInfo != nullptr)
			{
				descriptionBuilder.Append(c);
			}
		}

		bool allMembersDocumented = true;

		HashMap<String, DocumentedInfo>::valuerange range = documentedObjects.values();
		for (; range.empty() == false; range.popFront())
		{
			DocumentedInfo& documentedMember = range.front();

			if (documentedMember.IsDocumented == false)
			{
				allMembersDocumented = false;
				break;
			}
		}

		//ErrorIf(allMembersDocumented == false,
		//  "Not all members were documented, be sure to export a new documentation file for this Type");
	}

	//***************************************************************************
	AddMemberResult::Enum BoundType::AddRawFunction(Function* function)
	{
		// Assume we properly added the functino
		AddMemberResult::Enum result = AddMemberResult::Added;

		// Grab either the static or instance map of functions
		bool isStatic = (function->This == nullptr);
		FunctionMultiMap& map = this->GetFunctionMap(isStatic);

		// Grab the array of functions
		FunctionArray& functions = map[function->Name];

		// If we already have an overload of the exact same signature...
		for (size_t i = 0; i < functions.size(); ++i)
		{
			// If the type of each function exactly matches
			if (Type::IsSame(functions[i]->Type, function->Type))
			{
				result = AddMemberResult::AlreadyExists;
				break;
			}
		}

		// Add the function to the type's list of functions
		functions.push_back(function);

		// Add the function to the lsit of all functions
		this->AllFunctions.push_back(function);
		return result;
	}

	//***************************************************************************
	AddMemberResult::Enum BoundType::AddRawProperty(Property* property)
	{
		// Grab either the instance or static map of properties
		PropertyMap& map = this->GetPropertyMap(property->IsStatic);

		// Map the name of the property to the property itself
		bool inserted = map.insertOrError(property->Name, property,
			String::Format("Another property with the same name (%s) was added to the BoundType",
			property->Name.c_str()).c_str());

		// Add the property to the list of all properties
		this->AllProperties.push_back(property);

		// Return whether we inserted it or not
		if (inserted)
			return AddMemberResult::Added;
		else
			return AddMemberResult::AlreadyExists;
	}

	//***************************************************************************
	AddMemberResult::Enum BoundType::AddRawField(Field* field)
	{
		// Grab either the instance or static map of fields
		FieldMap& map = this->GetFieldMap(field->IsStatic);

		// Map the name of the field to the field itself
		bool inserted = map.insertOrError(field->Name, field,
			String::Format("Another member with the same name (%s) was added to the BoundType",
			field->Name.c_str()).c_str());

		// Add the member to the list of all properties
		this->AllProperties.push_back(field);

		// Return whether we inserted it or not
		if (inserted)
			return AddMemberResult::Added;
		else
			return AddMemberResult::AlreadyExists;
	}

	//***************************************************************************
	FieldMap& BoundType::GetFieldMap(bool isStatic)
	{
		if (isStatic)
			return this->StaticFields;
		else
			return this->InstanceFields;
	}

	//***************************************************************************
	PropertyMap& BoundType::GetPropertyMap(bool isStatic)
	{
		if (isStatic)
			return this->StaticProperties;
		else
			return this->InstanceProperties;
	}

	//***************************************************************************
	FunctionMultiMap& BoundType::GetFunctionMap(bool isStatic)
	{
		if (isStatic)
			return this->StaticFunctions;
		else
			return this->InstanceFunctions;
	}

	//***************************************************************************
	DelegateParameter::DelegateParameter() :
		ParameterType(nullptr),
		StackOffset(0)
	{
	}

	//***************************************************************************
	DelegateParameter::DelegateParameter(Type* type) :
		ParameterType(type),
		StackOffset(0)
	{
	}

	//***************************************************************************
	DelegateType::DelegateType() :
		Return(nullptr),
		ReturnStackOffset(0),
		ThisHandleStackOffset(0),
		TotalStackSizeExcludingThisHandle(0)
	{
	}

	//***************************************************************************
	GuidType DelegateType::Hash() const
	{
		// Store the hash result
		GuidType result = 0;

		// Loop through all the parameters
		for (size_t i = 0; i < this->Parameters.size(); ++i)
		{
			// Get a reference to the current parameter
			const DelegateParameter& parameter = this->Parameters[i];

			// Add the parameter type to the hash (we can just use the pointer value since it should be unique)
			result ^= parameter.ParameterType->Hash() * 983ULL * (i + 331ULL);

			// Add the parameter name hash
			result ^= parameter.Name.hash() * 6793ULL * (i + 13ULL);

			// We want to use i in some way so that the hash becomes order dependent
			result ^= 12764787846358441471ULL * i + 5463458053ULL + i;
		}

		// Add the return type to the hash (we can just use the pointer value since it should be unique)
		// Note that void is a type, and therefore has its own hash value (no special case)
		result ^= this->Return->Hash();

		// Use a random prime to make returns more unique
		result ^= 2305843009213693951ULL;

		// Return the computed hash
		return result;
	}

	//***************************************************************************
	void DelegateType::BuildParameterString(StringBuilder& builder) const
	{
		// Output the opening argument parentheses
		builder.Append("(");

		// Get the last parameter in the list
		size_t lastParameter = this->Parameters.size() - 1;

		// Loop through all the parameters
		for (size_t i = 0; i < this->Parameters.size(); ++i)
		{
			// Grab the current parameter
			const DelegateParameter& parameter = this->Parameters[i];

			// If the parameter actually has a name
			if (parameter.Name.empty() == false)
			{
				// Output the name of the parameter
				builder.Append(parameter.Name.c_str());
				builder.Append(" : ");
			}

			// Always output the type of the parameter
			builder.Append(parameter.ParameterType->ToString());

			// If this is not the last parameter...
			if (i < lastParameter)
			{
				// Output an argument separator
				builder.Append(", ");
			}
		}

		// Output the ending argument parentheses
		builder.Append(")");
	}

	//***************************************************************************
	void DelegateType::BuildSignatureString(StringBuilder& builder) const
	{
		// Build the parameter portion first
		this->BuildParameterString(builder);

		// Get a reference to the core library
		Core& core = Core::GetInstance();

		// If we have a return type
		if (this->Return != core.VoidType)
		{
			// Output the return type...
			builder.Append(" : ");
			builder.Append(this->Return->ToString());
		}
	}

	//***************************************************************************
	String DelegateType::GetSignatureString() const
	{
		// Create a string builder to build the signature
		StringBuilder builder;

		// Build the signature string
		this->BuildSignatureString(builder);

		// Return the resulting string
		return builder.ToString();
	}

	//***************************************************************************
	String DelegateType::ToString() const
	{
		// Create a string builder for concatenation
		StringBuilder builder;

		// Output the delegate keyword
		builder.Append(Grammar::GetKeywordOrSymbol(Grammar::Delegate));
		builder.Append(" ");

		// Build the parameter list string and return
		this->BuildSignatureString(builder);

		// Finally, output the full concatenated type string
		return builder.ToString();
	}

	//***************************************************************************
	bool DelegateType::IsCopyComplex() const
	{
		// Delegates always have a complex copy
		return true;
	}

	//***************************************************************************
	size_t DelegateType::GetAllocatedSize() const
	{
		// Functions take up the size of a function index
		return sizeof(Delegate);
	}

	//***************************************************************************
	void DelegateType::GenericDefaultConstruct(byte* toConstruct) const
	{
		// Construct a null / empty delegate
		new (toConstruct)Delegate();
	}

	//***************************************************************************
	void DelegateType::GenericCopyConstruct(byte* to, const byte* from) const
	{
		// Copy construct the delegate to the given location
		new (to)Delegate(*(Delegate*)from);
	}

	//***************************************************************************
	void DelegateType::GenericDestruct(byte* value) const
	{
		// Destroy the delegate type
		((Delegate*)value)->~Delegate();
	}

	//***************************************************************************
	int DelegateType::GenericHash(const byte* value) const
	{
		return ((Delegate*)value)->Hash();
	}

	//***************************************************************************
	String DelegateType::GenericToString(const byte* value) const
	{
		// Get the delegate value and write it's function out as a string
		Delegate& delegate = *(Delegate*)value;
		return delegate.BoundFunction->ToString();
	}

	//***************************************************************************
	bool DelegateType::GenericEquals(const byte* lhs, const byte* rhs) const
	{
		// Compare the two delegates
		Delegate& lDelegate = *((Delegate*)lhs);
		Delegate& rDelegate = *((Delegate*)rhs);
		return lDelegate == rDelegate;
	}

	//***************************************************************************
	Type* DelegateType::GenericGetVirtualType(const byte* value) const
	{
		Delegate* delegate = (Delegate*)value;
		Function* function = delegate->BoundFunction;
		if (function == nullptr)
			return (Type*)this;

		return function->Type;
	}
}/**************************************************************\
 * Author: Trevor Sundberg
 * Copyright 2012-2014, DigiPen Institute of Technology
 \**************************************************************/

// Includes

namespace Zilch
{

}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

//*****************************************************************************
#define ZilchCaseBinaryRValue2(argType1, argType2, resultType, operation, expression)                   \
  case Instruction::operation##argType1:                                                                \
  {                                                                                                     \
    const BinaryRValueOpcode& op = (const BinaryRValueOpcode&) opcode;                                  \
    const argType1& left = GetOperand<argType1>(ourFrame, ourFrame, op.Left);                           \
    const argType2& right = GetOperand<argType2>(ourFrame, ourFrame, op.Right);                         \
    resultType& output = GetLocal<resultType>(ourFrame->Frame, op.Output);                              \
    expression;                                                                                         \
    programCounter += sizeof(BinaryRValueOpcode);                                                       \
    break;                                                                                              \
  }

//*****************************************************************************
#define ZilchCaseBinaryLValue2(argType1, argType2, operation, expression)                               \
  case Instruction::operation##argType1:                                                                \
  {                                                                                                     \
    const BinaryLValueOpcode& op = (const BinaryLValueOpcode&) opcode;                                  \
    argType1& output = GetOperand<argType1>(ourFrame, ourFrame, op.Output);                             \
    const argType2& right = GetOperand<argType2>(ourFrame, ourFrame, op.Right);                         \
    expression;                                                                                         \
    programCounter += sizeof(BinaryLValueOpcode);                                                       \
    break;                                                                                              \
  }

//*****************************************************************************
#define ZilchCaseBinaryRValue(argType, resultType, operation, expression)                               \
  ZilchCaseBinaryRValue2(argType, argType, resultType, operation, expression)

//*****************************************************************************
#define ZilchCaseBinaryLValue(argType, operation, expression)                                           \
  ZilchCaseBinaryLValue2(argType, argType, operation, expression)

//*****************************************************************************
#define ZilchCaseUnaryRValue(argType, resultType, operation, expression)                                \
  case Instruction::operation##argType:                                                                 \
  {                                                                                                     \
    const UnaryRValueOpcode& op = (const UnaryRValueOpcode&) opcode;                                    \
    const argType& operand = GetOperand<argType>(ourFrame, ourFrame, op.SingleOperand);                 \
    resultType& output = GetLocal<resultType>(ourFrame->Frame, op.Output);                              \
    expression;                                                                                         \
    programCounter += sizeof(UnaryRValueOpcode);                                                        \
    break;                                                                                              \
  }

//*****************************************************************************
#define ZilchCaseUnaryLValue(argType, operation, expression)                                            \
  case Instruction::operation##argType:                                                                 \
  {                                                                                                     \
    const UnaryLValueOpcode& op = (const UnaryLValueOpcode&) opcode;                                    \
    argType& operand = GetOperand<argType>(ourFrame, ourFrame, op.SingleOperand);                       \
    expression;                                                                                         \
    programCounter += sizeof(UnaryLValueOpcode);                                                        \
    break;                                                                                              \
  }

//*****************************************************************************
#define ZilchCaseConversion(fromType, toType, expression)                                               \
  case Instruction::Convert##fromType##To##toType:                                                      \
  {                                                                                                     \
    const ConversionOpcode& op = (const ConversionOpcode&) opcode;                                      \
    const fromType& value = GetOperand<fromType>(ourFrame, ourFrame, op.ToConvert);                     \
    toType& output = GetLocal<toType>(ourFrame->Frame, op.Output);                                      \
    expression;                                                                                         \
    programCounter += sizeof(ConversionOpcode);                                                         \
    break;                                                                                              \
  }

//*****************************************************************************
#define ZilchCaseSimpleCopy(T)                                                                          \
  case Instruction::Copy##T:                                                                            \
  {                                                                                                     \
    PerFrameData* topFrame = state->StackFrames.back();                                                 \
    T* source;                                                                                          \
    T* destination;                                                                                     \
    CopyHandler<T>                                                                                      \
    (                                                                                                   \
      ourFrame,                                                                                         \
      topFrame,                                                                                         \
      source,                                                                                           \
      destination,                                                                                      \
      (const CopyOpcode&) opcode                                                                        \
    );                                                                                                  \
    break;                                                                                              \
  }

//*****************************************************************************
#define ZilchCaseComplexCopy(T)                                                                         \
  case Instruction::Copy##T:                                                                            \
  {                                                                                                     \
    /* Grab the rest of the data */                                                                     \
    const CopyOpcode& op = (const CopyOpcode&) opcode;                                                  \
                                                                                                        \
    /* Get the current frame on the top of the stack */                                                 \
    PerFrameData* topFrame = state->StackFrames.back();                                                 \
                                                                                                        \
    T* source;                                                                                          \
    T* destination;                                                                                     \
    CopyHandler<T>(ourFrame, topFrame, source, destination, op);                                        \
                                                                                                        \
    /* We need to make sure we cleanup any primitives */                                                \
    /* If this is just a standard copy from our stack to our stack... */                                \
    switch (op.Mode)                                                                                    \
    {                                                                                                   \
      case CopyMode::Initialize:                                                                        \
      {                                                                                                 \
        /* For any standard copy, if it's to the stack then */                                          \
        /* we just let our own stack frame clean it up */                                               \
        /* Note: Copies to properties are considered on the stack */                                    \
        if (op.Destination.Type != OperandType::Field)                                                  \
		        {                                                                                               \
          /* Queue the destination to be cleaned up */                                                  \
          ourFrame->Queue##T##Cleanup(destination);                                                     \
		        }                                                                                               \
        break;                                                                                          \
      }                                                                                                 \
                                                                                                        \
      case CopyMode::ToParameter:                                                                       \
      {                                                                                                 \
        /* For parameter copies, our stack frame will still clean it up */                              \
        /* but the cleanup must occur right after the function is called */                             \
        /* eg PopFrame (which will pop the top!) */                                                     \
        topFrame->Queue##T##Cleanup(destination);                                                       \
        break;                                                                                          \
      }                                                                                                 \
                                                                                                        \
      case CopyMode::FromReturn:                                                                        \
      {                                                                                                 \
        /* Note: The primitive used here is actually the source primitive! */                           \
        /* See the comment above 'CopyHandler' */                                                       \
        /* For returns, we need to clean up the primitive immediately after */                          \
        /* copy since that space could be reused by anyone else */                                      \
        source->~T();                                                                                   \
                                                                                                        \
        /* We also need to queue our own frame to clean */                                              \
        /* up where we copied it to */                                                                  \
        ourFrame->Queue##T##Cleanup(destination);                                                       \
        break;                                                                                          \
      }                                                                                                 \
    }                                                                                                   \
    break;                                                                                              \
  }

namespace Zilch
{
	//***************************************************************************
	// This is just a special identifier that means we jumped, there's really no reason to the number... ;)
	static const int ExceptionJumpResult = 1729;

	//***************************************************************************
	template <>
	void VirtualMachine::GenericPow<Integer>(Integer& out, const Integer& base, const Integer& exponent)
	{
		out = IntegralPower(base, exponent);
	}

	//***************************************************************************
	template <>
	inline void VirtualMachine::GenericPow<Integer2>(Integer2& out, const Integer2& base, const Integer2& exponent)
	{
		out.x = IntegralPower(base.x, exponent.x);
		out.y = IntegralPower(base.y, exponent.y);
	}

	//***************************************************************************
	template <>
	inline void VirtualMachine::GenericPow<Integer3>(Integer3& out, const Integer3& base, const Integer3& exponent)
	{
		out.x = IntegralPower(base.x, exponent.x);
		out.y = IntegralPower(base.y, exponent.y);
		out.z = IntegralPower(base.z, exponent.z);
	}

	//***************************************************************************
	template <>
	inline void VirtualMachine::GenericPow<Integer4>(Integer4& out, const Integer4& base, const Integer4& exponent)
	{
		out.x = IntegralPower(base.x, exponent.x);
		out.y = IntegralPower(base.y, exponent.y);
		out.z = IntegralPower(base.z, exponent.z);
		out.w = IntegralPower(base.w, exponent.w);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericPow<DoubleInteger>(DoubleInteger& out, const DoubleInteger& base, const DoubleInteger& exponent)
	{
		out = IntegralPower(base, exponent);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericPow<Real2>(Real2& out, const Real2& base, const Real2& exponent)
	{
		out.x = pow(base.x, exponent.x);
		out.y = pow(base.y, exponent.y);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericPow<Real3>(Real3& out, const Real3& base, const Real3& exponent)
	{
		out.x = pow(base.x, exponent.x);
		out.y = pow(base.y, exponent.y);
		out.z = pow(base.z, exponent.z);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericPow<Real4>(Real4& out, const Real4& base, const Real4& exponent)
	{
		out.x = pow(base.x, exponent.x);
		out.y = pow(base.y, exponent.y);
		out.z = pow(base.z, exponent.z);
		out.w = pow(base.w, exponent.w);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericMod<Real>(Real& out, const Real& value, const Real& mod)
	{
		out = fmod(value, mod);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericMod<DoubleReal>(DoubleReal& out, const DoubleReal& value, const DoubleReal& mod)
	{
		out = fmod(value, mod);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericMod<Real2>(Real2& out, const Real2& value, const Real2& mod)
	{
		out.x = fmod(value.x, mod.x);
		out.y = fmod(value.y, mod.y);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericMod<Real3>(Real3& out, const Real3& value, const Real3& mod)
	{
		out.x = fmod(value.x, mod.x);
		out.y = fmod(value.y, mod.y);
		out.z = fmod(value.z, mod.z);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericMod<Real4>(Real4& out, const Real4& value, const Real4& mod)
	{
		out.x = fmod(value.x, mod.x);
		out.y = fmod(value.y, mod.y);
		out.z = fmod(value.z, mod.z);
		out.w = fmod(value.w, mod.w);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarPow<Integer2, Integer>(Integer2& out, const Integer2& base, const Integer& exponent)
	{
		out.x = IntegralPower(base.x, exponent);
		out.y = IntegralPower(base.y, exponent);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarPow<Integer3, Integer>(Integer3& out, const Integer3& base, const Integer& exponent)
	{
		out.x = IntegralPower(base.x, exponent);
		out.y = IntegralPower(base.y, exponent);
		out.z = IntegralPower(base.z, exponent);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarPow<Integer4, Integer>(Integer4& out, const Integer4& base, const Integer& exponent)
	{
		out.x = IntegralPower(base.x, exponent);
		out.y = IntegralPower(base.y, exponent);
		out.z = IntegralPower(base.z, exponent);
		out.w = IntegralPower(base.w, exponent);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarPow<Real2, Real>(Real2& out, const Real2& base, const Real& exponent)
	{
		out.x = pow(base.x, exponent);
		out.y = pow(base.y, exponent);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarPow<Real3, Real>(Real3& out, const Real3& base, const Real& exponent)
	{
		out.x = pow(base.x, exponent);
		out.y = pow(base.y, exponent);
		out.z = pow(base.z, exponent);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarPow<Real4, Real>(Real4& out, const Real4& base, const Real& exponent)
	{
		out.x = pow(base.x, exponent);
		out.y = pow(base.y, exponent);
		out.z = pow(base.z, exponent);
		out.w = pow(base.w, exponent);
	}


	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarMod<Real2, Real>(Real2& out, const Real2& value, const Real& mod)
	{
		out.x = fmod(value.x, mod);
		out.y = fmod(value.y, mod);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarMod<Real3, Real>(Real3& out, const Real3& value, const Real& mod)
	{
		out.x = fmod(value.x, mod);
		out.y = fmod(value.y, mod);
		out.z = fmod(value.z, mod);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericScalarMod<Real4, Real>(Real4& out, const Real4& value, const Real& mod)
	{
		out.x = fmod(value.x, mod);
		out.y = fmod(value.y, mod);
		out.z = fmod(value.z, mod);
		out.w = fmod(value.w, mod);
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericIncrement<Real2>(Real2& out)
	{
		++out.x;
		++out.y;
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericIncrement<Real3>(Real3& out)
	{
		++out.x;
		++out.y;
		++out.z;
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericIncrement<Real4>(Real4& out)
	{
		++out.x;
		++out.y;
		++out.z;
		++out.w;
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericDecrement<Real2>(Real2& out)
	{
		--out.x;
		--out.y;
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericDecrement<Real3>(Real3& out)
	{
		--out.x;
		--out.y;
		--out.z;
	}

	//***************************************************************************
	template <>
	void VirtualMachine::GenericDecrement<Real4>(Real4& out)
	{
		--out.x;
		--out.y;
		--out.z;
		--out.w;
	}

	//***************************************************************************
	template <>
	bool VirtualMachine::GenericIsZero<Integer2>(const Integer2& value)
	{
		return
			value.x == 0 ||
			value.y == 0;
	}

	//***************************************************************************
	template <>
	bool VirtualMachine::GenericIsZero<Integer3>(const Integer3& value)
	{
		return
			value.x == 0 ||
			value.y == 0 ||
			value.z == 0;
	}

	//***************************************************************************
	template <>
	bool VirtualMachine::GenericIsZero<Integer4>(const Integer4& value)
	{
		return
			value.x == 0 ||
			value.y == 0 ||
			value.z == 0 ||
			value.w == 0;
	}

	//***************************************************************************
	template <>
	bool VirtualMachine::GenericIsZero<Real2>(const Real2& value)
	{
		return
			value.x == 0.0f ||
			value.y == 0.0f;
	}

	//***************************************************************************
	template <>
	bool VirtualMachine::GenericIsZero<Real3>(const Real3& value)
	{
		return
			value.x == 0.0f ||
			value.y == 0.0f ||
			value.z == 0.0f;
	}

	//***************************************************************************
	template <>
	bool VirtualMachine::GenericIsZero<Real4>(const Real4& value)
	{
		return
			value.x == 0.0f ||
			value.y == 0.0f ||
			value.z == 0.0f ||
			value.w == 0.0f;
	}

	//***************************************************************************
	// Get a reference to a member variable (field), given the place in the registers that the handle exists, and the member index...
	template <typename T>
	ZilchForceInline T& GetField(PerFrameData* stackFrame, PerFrameData* reportFrame, OperandIndex handleOperand, size_t memberOperand)
	{
		// Grab the handle to the object
		Handle& handle = *(Handle*)(stackFrame->Frame + handleOperand);

		// Get a pointer to the data
		byte* data = handle.Dereference();

		// If our data is null
		if (data == nullptr)
		{
			// Throw an exception (we'll need to unwind our stack)
			stackFrame->State->ThrowNullReferenceException(*reportFrame->Report);

			// Unwind our stack
			longjmp(reportFrame->ExceptionJump, ExceptionJumpResult);
		}

		// Return the data (with the member offset)
		return *(T*)(data + memberOperand);
	}

	//***************************************************************************
	// Get a particular constant from a function
	template <typename T>
	ZilchForceInline T& GetConstant(Function* function, OperandIndex constantOperand)
	{
		// Make sure the value we're grabbing is inside the constant buffer (error checking)
		ErrorIf(constantOperand < 0 || constantOperand + sizeof(T) > function->Constants.GetSize(),
			"The constant's position was outside the memory of the function's constants");

		// Grab the constant from the constants array
		return *(T*)(function->Constants.GetElement(constantOperand));
	}

	//***************************************************************************
	// Get a particular local from a function
	template <typename T>
	ZilchForceInline T& GetLocal(byte* frame, OperandIndex localOperand)
	{
		return *(T*)(frame + localOperand);
	}

	//***************************************************************************
	// Get an operand (we don't know what type it is)
	template <typename T>
	ZilchForceInline T& GetOperand(PerFrameData* stackFrame, PerFrameData* reportFrame, const Operand& operand)
	{
		// Based on what kind of operand it is...
		switch (operand.Type)
		{
		case OperandType::Field:
			return GetField<T>(stackFrame, reportFrame, operand.HandleConstantLocal, operand.Field);

		case OperandType::Constant:
			return GetConstant<T>(stackFrame->CurrentFunction, operand.HandleConstantLocal);

		case OperandType::Local:
			return GetLocal<T>(stackFrame->Frame, operand.HandleConstantLocal);
		}

		// This means that something REALLY bad happened...
		Error("We reached a garbage operand, or the operand was NotSet (something wrong in CodeGeneration?)");
		return *(T*)(nullptr);
	}

	//***************************************************************************
	// Reusable code for the if opcodes
	template <Boolean IfTrue>
	ZilchForceInline void IfHandler(PerFrameData* stackFrame, const Opcode& opcode)
	{
		// Validate the timeout (this will throw an exception if we go beyond the time we need to)
		// This only really needs to be ran in jumps
		if (stackFrame->State->ThrowExceptionOnTimeout(*stackFrame->Report))
		{
			// Unwind our stack
			longjmp(stackFrame->ExceptionJump, ExceptionJumpResult);
		}

		// Grab the rest of the data
		const IfOpcode& op = (const IfOpcode&)opcode;

		// Read the boolean value
		Boolean result = GetOperand<Boolean>(stackFrame, stackFrame, op.Condition);

		// If the register evaluates to true...
		if (result == IfTrue)
		{
			// Move the instruction counter by the given offset
			stackFrame->ProgramCounter += op.JumpOffset;
		}
		// Otherwise, we need to skip it
		else
		{
			// Move the instruction counter past this opcode
			stackFrame->ProgramCounter += sizeof(op);
		}
	}

	//***************************************************************************
	ZilchForceInline void CopyHandlerEx(PerFrameData* ourFrame, PerFrameData* topFrame, const byte*& sourceOut, byte*& destinationOut, const CopyOpcode& op)
	{
		// When we copy to parameters, it's always a destination
		// (we are placing parameters in the place they must go before we call)
		// When we copy a return, it is always the source, as we are getting the result
		// from a called function and storing it in the caller's stack
		// Note: Returns may be removed in the future as we can just directly refer to them

		// Offsets that may change depending on the copy mode
		size_t returnOffset = 0;
		PerFrameData* parameterFrame = ourFrame;

		// Based off the copy mode we're in...
		switch (op.Mode)
		{
		case CopyMode::ToParameter:
			parameterFrame = topFrame;
			break;

		case CopyMode::FromReturn:
			returnOffset = topFrame->NextFrame - ourFrame->Frame;
			break;
		}

		// Get pointers to both the source and destination memory
		sourceOut = &GetOperand<byte>(ourFrame, ourFrame, op.Source) + returnOffset;
		destinationOut = &GetOperand<byte>(parameterFrame, ourFrame, op.Destination);

		// Increment the program counter to point past the opcode
		ourFrame->ProgramCounter += sizeof(CopyOpcode);
	}

	//***************************************************************************
	// Note: This function return a pointer to the newly initialized handle
	// (where we copied to) unless we're performing a 'FromReturn' copy, where
	// it will return a pointer to the source handle (for cleanup purposes!)
	template <typename CopyType>
	ZilchForceInline void CopyHandler
		(
		PerFrameData* ourFrame,
		PerFrameData* topFrame,
		CopyType*& sourceTyped,
		CopyType*& destinationTyped,
		const CopyOpcode& op
		)
	{
		const byte* source;
		byte* destination;

		CopyHandlerEx(ourFrame, topFrame, source, destination, op);

		// Now copy from the source to the destination and return a pointer to the new copy
		sourceTyped = (CopyType*)source;

		// If this is an assignment...
		if (op.Mode == CopyMode::Assignment)
		{
			// We know the destination is the same type as us
			destinationTyped = (CopyType*)destination;

			// Perform the direct assignment
			*destinationTyped = *sourceTyped;
		}
		else
		{
			// Otherwise, we need to construct a new one over the memory
			destinationTyped = new (destination)CopyType(*sourceTyped);
		}
	}

	//***************************************************************************
	void VirtualMachine::EnumProperty(Call& call, ExceptionReport& report)
	{
		// Get the integral value for this enum value
		Integer integralValue = (Integer)(DoubleInteger)call.GetFunction()->UserData;

		// Return the integral value
		call.Set<Integer>(Call::Return, integralValue);
	}

	//***************************************************************************
	void VirtualMachine::EventsProperty(Call& call, ExceptionReport& report)
	{
		// Get the calling function (the property getter)
		Function* function = call.GetFunction();

		// Read its user data to get the string back that we want to return
		String& eventName = function->ComplexUserData.ReadObject<String>(0);

		// Simply just return the string (there are no parameters or anything else)
		call.Set<String>(Call::Return, eventName);
	}

	//***************************************************************************
	void VirtualMachine::ExecuteNext(Call& call, ExceptionReport& report)
	{
		// Since we do a raw copy, we always tell the caller to ignore debug checking of the return
		call.DisableReturnChecks();

		// Grab the executable state
		ExecutableState* state = call.GetState();

		// Block vectors are currently only POD
		// Grab the per frame data from the executable state
		PerFrameData* ourFrame = state->StackFrames.back();

		// The program counter increments with each instruction (instructions can also be variable width, and this number is measured in bytes)
		ourFrame->ProgramCounter = 0;
		size_t& programCounter = ourFrame->ProgramCounter;

		// Setup where we jump to if an exception occurs
		int jumpResult = setjmp(ourFrame->ExceptionJump);

		// If an exception occurred...
		if (jumpResult == ExceptionJumpResult)
		{
		ExceptionJump:
			return;
		}

		// Store the compacted opcode as an attempt to bring the opcode into crash reports / mini-dumps
		// Also save it into a non-thread safe global pointer (hopefully it will be pulled in)
		byte* compactedOpcode = ourFrame->CurrentFunction->CompactedOpcode.data();
		ZilchLastRunningOpcode = compactedOpcode;
		ZilchLastRunningFunction = ourFrame->CurrentFunction;
		ZilchLastRunningOpcodeLength = ourFrame->CurrentFunction->CompactedOpcode.size();

		// Loop through all the opcodes in the function
		// We don't need to check for the end since the return opcode will exit this function
		ZilchLoop
		{
			// Grab the current opcode that we're executing
			const Opcode& opcode = *(Opcode*)(compactedOpcode + programCounter);

			// If a pre opcode callback is set
			if (state->OpcodePreStepCallback.Callback != nullptr)
			{
				// Get the location of this opcode
				CodeLocation* location = ourFrame->CurrentFunction->GetCodeLocationFromProgramCounter(programCounter);

				// Invoke the callback
				state->OpcodePreStepCallback.Callback(state, programCounter, location, state->OpcodePreStepCallback.UserData);
			}

			// Based on the current instruction...
			switch (opcode.Instruction)
			{
			case Instruction::InternalDebugBreakpoint:
			{
				// Trigger the breakpoint
				ZilchDebugBreak();

				// Move the instruction counter past this opcode
				programCounter += sizeof(Opcode);
				break;
			}

			case Instruction::BeginTimeout:
			{
				// Grab the rest of the data
				const TimeoutOpcode& op = (const TimeoutOpcode&)opcode;

				// Let the executable state know we've started a timeout
				// This can technically throw if a timeout above it expired
				if (state->PushTimeout(ourFrame, op.LengthSeconds))
				{
					// Jump out so we don't run any more code
					goto ExceptionJump;
				}

				// Move the instruction counter past this opcode
				programCounter += sizeof(TimeoutOpcode);
				break;
			}

			case Instruction::EndTimeout:
			{
				// Validate the timeout (this will throw an exception if we go beyond the time we need to)
				// This only really needs to be ran in jumps
				if (state->PopTimeout(ourFrame))
				{
					// Jump out so we don't run any more code
					goto ExceptionJump;
				}

				// Move the instruction counter past this opcode
				programCounter += sizeof(Opcode);
				break;
			}

			case Instruction::BeginScope:
			{
				// Store a pointer to the newly created (or recycled) scope
				PerScopeData* newScope = state->AllocateScope();

				// Add a new scope so that we can destruct our scope properly
				ourFrame->Scopes.push_back(newScope);

				// Move the instruction counter past this opcode
				programCounter += sizeof(Opcode);
				break;
			}

			case Instruction::EndScope:
			{
				// Get the latest scope
				PerScopeData* scope = ourFrame->Scopes.back();

				// Cleanup any handles and delegates (this also clears for recycling)
				scope->PerformCleanup();

				// Pop this scope since we're exiting it
				ourFrame->Scopes.pop_back();

				// Instead of deleting this scope, we're going to recycle it for speed
				state->RecycledScopes.push_back(scope);

				// Move the instruction counter past this opcode
				programCounter += sizeof(Opcode);
				break;
			}

			case Instruction::ToHandle:
			{
				// Grab the rest of the data
				const ToHandleOpcode& op = (const ToHandleOpcode&)opcode;

				// If the object we're converting into a handle is a local...
				if (op.ToHandle.Type == OperandType::Local)
				{
					// Get the handle that we're going to write to on the stack
					Handle& handle = *new (ourFrame->Frame + op.SaveLocal) Handle();

					// We need to make sure we cleanup this handle
					ourFrame->QueueHandleCleanup(&handle);

					// Initialize the stack handle to point at the given location
					state->InitializeStackHandle(handle, ourFrame->Frame + op.ToHandle.HandleConstantLocal, op.Type);
				}
				else
				{
					// We assume this means we're taking a handle to a field
					ErrorIf(op.ToHandle.Type != OperandType::Field,
						"We can only take handles to locals and fields (not constants, for example)");

					// Get the handle that holds the base of the member we're going to make a handle to
					const Handle& baseHandle = *(Handle*)(ourFrame->Frame + op.ToHandle.HandleConstantLocal);

					// Make a copy from the base handle into our handle
					// This should properly handle incrementing a reference, if needed
					Handle& handle = *new (ourFrame->Frame + op.SaveLocal) Handle(baseHandle);

					// We need to make sure we cleanup this handle
					ourFrame->QueueHandleCleanup(&handle);

					// Add the offset to the handle
					handle.Offset += op.ToHandle.Field;

					// The type we're now referring to is whatever the field is at that offset
					handle.Type = op.Type;
				}

				// Move the instruction counter past this opcode
				programCounter += sizeof(op);

				//TODO the rest of the handle initialization
				break;
			}

			case Instruction::CreateStaticDelegate:
			{
				// Grab the rest of the data
				const CreateStaticDelegateOpcode& op = (const CreateStaticDelegateOpcode&)opcode;

				// Get the delegate that we're going to write to on the stack
				Delegate& delegate = *new (ourFrame->Frame + op.SaveLocal) Delegate();

				// Set the delegate's function index to the opcode's index
				delegate.BoundFunction = op.BoundFunction;

				// Even though the 'this' handle is null, we still need to clean it up
				// just to be proper, but also because someone could theoretically assign to it
				// if we expose it in the future
				ourFrame->QueueDelegateCleanup(&delegate);

				// Move the instruction counter past this opcode
				programCounter += sizeof(op);
				break;
			}

			case Instruction::CreateInstanceDelegate:
			{
				// Grab the rest of the data
				const CreateInstanceDelegateOpcode& op = (const CreateInstanceDelegateOpcode&)opcode;

				// Get the delegate that we're going to write to on the stack
				Delegate& delegate = *new (ourFrame->Frame + op.SaveLocal) Delegate();

				// Set the delegate's function index to the opcode's index
				delegate.BoundFunction = op.BoundFunction;

				// Set the handle that will basically act as the 'this' pointer for the delegate
				delegate.ThisHandle = GetOperand<Handle>(ourFrame, ourFrame, op.ThisHandle);

				// If the function we're binding is virtual and we're not calling this function 'non-virtually'
				if (op.BoundFunction->IsVirtual && op.CanBeVirtual)
				{
					// Find the function on our derived type that matches the signature / name
					Function* function = delegate.ThisHandle.Type->FindFunction(op.BoundFunction->Name, op.BoundFunction->Type, FindMemberOptions::None);
					if (function != nullptr)
						delegate.BoundFunction = function;
					else
						Error("Unable to find the most derived virtual function, we can continue but this should not happen");
				}

				// We need to make sure we cleanup this handle
				ourFrame->QueueDelegateCleanup(&delegate);

				// Move the instruction counter past this opcode
				programCounter += sizeof(op);
				break;
			}

			case Instruction::IfFalseRelativeGoTo:
			{
				IfHandler<false>(ourFrame, opcode);
				break;
			}

			case Instruction::IfTrueRelativeGoTo:
			{
				IfHandler<true>(ourFrame, opcode);
				break;
			}

			case Instruction::RelativeGoTo:
			{
				// Validate the timeout (this will throw an exception if we go beyond the time we need to)
				// This only really needs to be ran in jumps
				if (state->ThrowExceptionOnTimeout(report))
				{
					// Jump out so we don't run any more code
					goto ExceptionJump;
				}

				// Grab the rest of the data
				const RelativeJumpOpcode& op = (const RelativeJumpOpcode&)opcode;

				// Move the instruction counter by the given offset
				programCounter += op.JumpOffset;
				break;
			}

			case Instruction::Return:
			{
				return;
			}

			case Instruction::PrepForFunctionCall:
			{
				// Validate the timeout (this will throw an exception if we go beyond the time we need to)
				// This only really needs to be ran in jumps
				if (state->ThrowExceptionOnTimeout(report))
				{
					// Jump out so we don't run any more code
					goto ExceptionJump;
				}

				// Grab the rest of the data
				const PrepForFunctionCallOpcode& op = (const PrepForFunctionCallOpcode&)opcode;

				// Retrieve the delegate that we have to invoke
				const Delegate& delegate = GetOperand<Delegate>(ourFrame, ourFrame, op.Delegate);

				// Lookup the function in the function array
				Function* functionToInvoke = delegate.BoundFunction;

				// If we attempted to invoke a null delegate then throw an exception
				if (functionToInvoke == nullptr)
				{
					// Throw an exception and bail out
					state->ThrowException(report, "Attempted to invoke a null delegate");
					goto ExceptionJump;
				}

				// Get the frame at the top of the stack (it could be ours)
				PerFrameData* topFrame = state->StackFrames.back();

				// Create a new stack frame for our function
				PerFrameData* newFrame = state->PushFrame(topFrame->NextFrame, functionToInvoke);

				// If the stack frame was created in an error state, then attempt to throw exceptions
				// If this returns true (meaning exceptions were thrown) then we'll jump out
				if (newFrame->AttemptThrowStackExceptions(report))
				{
					goto ExceptionJump;
				}

				// Check if the "to be invoked" function is a static function (should we skip the next copy opcode?)
				if (functionToInvoke->This == nullptr)
				{
					// Skip copying the 'this' handle (and move past this opcode)
					programCounter += op.JumpOffsetIfStatic;
				}
				else
				{
					// Increment the program counter to point past the opcode
					programCounter += sizeof(PrepForFunctionCallOpcode);
				}
				break;
			}

			case Instruction::FunctionCall:
			{
				// Grab the per frame data from the executable state
				PerFrameData* topFrame = state->StackFrames.back();

				// Create a call (this is not a user call, so it should not push a stack frame)
				// Moreover, none of the debug features should be enabled
				Call subCall(topFrame);

				// Invoke the call (calls the bound function with all the parameters)
				subCall.Invoke(report);

				// Check to see if we threw any exceptions in the above invokation
				if (report.HasThrownExceptions())
				{
					goto ExceptionJump;
				}

				// Increment the program counter to point past the opcode
				programCounter += sizeof(Opcode);
				break;
			}

			case Instruction::LocalObject:
			{
				// Grab the rest of the data
				const CreateLocalTypeOpcode& op = (const CreateLocalTypeOpcode&)opcode;

				// Get the type that we're creating
				BoundType* createdType = op.CreatedType;

				// Allocate the object
				Handle handle = state->AllocateStackObject(ourFrame->Frame + op.StackLocal, createdType, report);

				// If allocating the stack object threw an exception...
				if (report.HasThrownExceptions())
				{
					goto ExceptionJump;
				}

				// Copy the handle to the stack
				Handle* handleOnStack = new (ourFrame->Frame + op.SaveHandleLocal) Handle(handle);

				// We need to make sure we cleanup this handle
				ourFrame->QueueHandleCleanup(handleOnStack);

				// Increment the program counter to point past the opcode
				programCounter += sizeof(CreateLocalTypeOpcode);
				break;
			}

			case Instruction::NewObject:
			{
				// Grab the rest of the data
				const CreateTypeOpcode& op = (const CreateTypeOpcode&)opcode;

				// Get the type that we're creating
				BoundType* createdType = op.CreatedType;

				// Allocate the object
				Handle handle = state->AllocateHeapObject(createdType, report, HeapFlags::ReferenceCounted);

				// If allocating the stack object threw an exception...
				if (report.HasThrownExceptions())
				{
					goto ExceptionJump;
				}

				// Copy the handle to the stack
				Handle* handleOnStack = new (ourFrame->Frame + op.SaveHandleLocal) Handle(handle);

				// We need to make sure we cleanup this handle
				ourFrame->QueueHandleCleanup(handleOnStack);

				// Increment the program counter to point past the opcode
				programCounter += sizeof(CreateTypeOpcode);
				break;
			}

			case Instruction::PropertyDelegate:
			{
				// Grab the rest of the data
				const CreatePropertyDelegateOpcode& op = (const CreatePropertyDelegateOpcode&)opcode;

				// Get the type that we're creating
				BoundType* createdType = op.CreatedType;

				// Allocate the object
				Handle handle = state->AllocateDefaultConstructedHeapObject(createdType, report, HeapFlags::ReferenceCounted);

				// If allocating the stack object threw an exception...
				if (report.HasThrownExceptions())
				{
					goto ExceptionJump;
				}

				// Copy the handle to the stack
				Handle* handleOnStack = new (ourFrame->Frame + op.SaveHandleLocal) Handle(handle);

				// We need to make sure we cleanup this handle
				ourFrame->QueueHandleCleanup(handleOnStack);

				// As long as nothing failed, the object we allocated should be a 'PropertyDelegate' object
				PropertyDelegateTemplate* propertyDelegate = (PropertyDelegateTemplate*)handleOnStack->Dereference();

				// Read the this handle from the stack
				Handle& thisHandle = *(Handle*)(ourFrame->Frame + op.ThisHandleLocal);

				// Set the delegate's function index to the opcode's index
				propertyDelegate->Get.BoundFunction = op.Get;
				propertyDelegate->Set.BoundFunction = op.Set;
				propertyDelegate->Get.ThisHandle = thisHandle;
				propertyDelegate->Set.ThisHandle = thisHandle;

				// Increment the program counter to point past the opcode
				programCounter += sizeof(CreatePropertyDelegateOpcode);
				break;
			}

			case Instruction::BeginStringBuilder:
			{
				// Create a new string builder
				state->StringBuilders.push_back();

				// Increment the program counter to point past the opcode
				programCounter += sizeof(BeginStringBuilderOpcode);
				break;
			}

			case Instruction::EndStringBuilder:
			{
				// Grab the rest of the data
				const EndStringBuilderOpcode& op = (const EndStringBuilderOpcode&)opcode;

				// Get the string builder that we're using
				StringBuilder& builder = state->StringBuilders.back();

				// Convert the concatenations into a single reference counted string
				String result = builder.ToString();

				// We're done with the string builder!
				state->StringBuilders.pop_back();

				// Copy the handle to the stack
				Handle* handle = new (ourFrame->Frame + op.SaveStringHandleLocal) Handle();

				// We need to make sure we cleanup this handle
				ourFrame->QueueHandleCleanup(handle);

				// Set the handle manager and type of the handle
				// We know explicitly that the string handle manager is a shared manager
				HandleManagers& managers = HandleManagers::GetInstance();
				handle->Manager = managers.GetSharedManager(ZilchManagerId(StringManager));
				handle->Type = ZilchTypeId(String);

				// Copy a string into the handle
				// This method will actually increase the reference count
				// which means we would need to store an array of destructors for constant memory (which we do)
				handle->Manager->ObjectToHandle((byte*)&result, *handle);

				// Increment the program counter to point past the opcode
				programCounter += sizeof(EndStringBuilderOpcode);
				break;
			}

			case Instruction::AddToStringBuilder:
			{
				// Grab the rest of the data
				const AddToStringBuilderOpcode& op = (const AddToStringBuilderOpcode&)opcode;

				// Get the string builder that we're using
				StringBuilder& builder = state->StringBuilders.back();

				// Generically get the operand that we want to turn into a string
				byte* data = &GetOperand<byte>(ourFrame, ourFrame, op.Value);

				// Convert the value to a string in the best way we know how to
				String stringifiedValue = op.TypeToConvert->GenericToString(data);

				// Append the stringified value to the string builder
				builder.Append(stringifiedValue);

				// Increment the program counter to point past the opcode
				programCounter += sizeof(AddToStringBuilderOpcode);
				break;
			}

			case Instruction::DeleteObject:
			{
				// Grab the rest of the data
				const DeleteObjectOpcode& op = (const DeleteObjectOpcode&)opcode;

				// Get a pointer to the handle we are deleting
				Handle& handle = GetOperand<Handle>(ourFrame, ourFrame, op.Object);

				// Delete the handle
				bool result = handle.Delete();

				// If we failed to delete the handle...
				if (result == false)
				{
					// The user handle type could not be deleted!
					state->ThrowException
						(
						report,
						String::Format("We attempted to delete a '%s' handle, but we aren't allowed to", handle.Manager->GetName().c_str())
						);

					// Jump back since we just threw an exception
					goto ExceptionJump;
				}

				// Increment the program counter to point past the opcode
				programCounter += sizeof(DeleteObjectOpcode);
				break;
			}

			case Instruction::ThrowException:
			{
				// Grab the rest of the data
				const ThrowExceptionOpcode& op = (const ThrowExceptionOpcode&)opcode;

				// Get a pointer to the handle we are deleting
				Handle& handle = GetOperand<Handle>(ourFrame, ourFrame, op.Exception);

				// If the handle itself is null, we actually throw a null reference exception!
				if (handle.IsNull())
				{
					state->ThrowNullReferenceException(report);
				}
				else
				{
					state->ThrowException(report, handle);
				}

				// Jump back since we just threw an exception
				goto ExceptionJump;
			}

			case Instruction::ConvertToAny:
			{
				// Grab the rest of the data
				const AnyConversionOpcode& op = (const AnyConversionOpcode&)opcode;
				const byte* value = &GetOperand<byte>(ourFrame, ourFrame, op.ToConvert);

				// Grab the bytes that will hold the 'Any' value
				byte* anyData = &GetLocal<byte>(ourFrame->Frame, op.Output);

				// Construct the any at the given position (this will do a proper copy of data into the any)
				Any* any = new (anyData)Any(value, op.RelatedType);

				// We need to make sure we cleanup this 'any'
				ourFrame->QueueAnyCleanup(any);
				programCounter += sizeof(AnyConversionOpcode);
				break;
			}

			case Instruction::ConvertFromAny:
			{
				// Grab the rest of the data
				const AnyConversionOpcode& op = (const AnyConversionOpcode&)opcode;
				const Any& any = GetOperand<Any>(ourFrame, ourFrame, op.ToConvert);

				// If we can't directly convert the any into this type...
				Shared& shared = Shared::GetInstance();
				CastOperator cast = shared.GetCastOperator(any.StoredType, op.RelatedType);
				if (cast.IsValid == false || cast.RequiresCodeGeneration)
				{
					// Generate an error string that gives a lot of context clues
					String error = String::Format
						(
						"The 'any' value '%s' of type '%s' cannot be converted to a '%s'. The type must match exactly or be directly convertable",
						any.StoredType->GenericToString(any.Data).c_str(),
						any.StoredType->ToString().c_str(),
						op.RelatedType->ToString().c_str()
						);

					// Throw an exception to let the user know the conversion was invalid
					state->ThrowException(report, error);

					// Jump back since we just threw an exception
					goto ExceptionJump;
				}

				// Grab the bytes that will hold the value we copy from the Any
				byte* outputData = &GetLocal<byte>(ourFrame->Frame, op.Output);

				// Copy the value out of the any onto the stack
				any.StoredType->GenericCopyConstruct(outputData, any.Data);
				programCounter += sizeof(AnyConversionOpcode);
				break;
			}

			case Instruction::ConvertDowncast:
			{
				// Grab the rest of the data
				const DowncastConversionOpcode& op = (const DowncastConversionOpcode&)opcode;
				const Handle& toConvert = GetOperand<Handle>(ourFrame, ourFrame, op.ToConvert);

				// Grab the output that we want to initialize either to a casted handle, or to null
				byte* outputHandle = &GetLocal<byte>(ourFrame->Frame, op.Output);

				// The value we were passed in was null, so just output null
				if (toConvert.IsNull())
				{
					// Initialize the temporary handle to null
					new (outputHandle)Handle();
				}
				// Check to see if this type inherits from the other type
				else if (TypeBinding::GenericIsA(toConvert.Type, op.ToType))
				{
					// Copy the handle over, it's now the down-casted type!
					new (outputHandle)Handle(toConvert);
				}
				else
				{
					// The downcast failed (not the same) so return null
					new (outputHandle)Handle();
				}

				programCounter += sizeof(DowncastConversionOpcode);
				break;
			}

			case Instruction::AnyDynamicMemberGet:
			{
				// Grab the rest of the data
				const CopyOpcode& op = (const CopyOpcode&)opcode;

				programCounter += sizeof(AnyConversionOpcode);
				break;
			}

			case Instruction::CopyValue:
			{
				// Grab the rest of the data
				const CopyOpcode& op = (const CopyOpcode&)opcode;

				const byte* source;
				byte* destination;

				// Get the frame at the top of the stack (it could be ours)
				PerFrameData* topFrame = state->StackFrames.back();

				CopyHandlerEx(ourFrame, topFrame, source, destination, op);

				memcpy(destination, source, op.Size);
				break;
			}

			ZilchCaseComplexCopy(Handle);
			ZilchCaseComplexCopy(Delegate);
			ZilchCaseComplexCopy(Any);

			case Instruction::TestEqualityValue:
			{
				const BinaryRValueOpcode& op = (const BinaryRValueOpcode&)opcode;
				const byte* left = &GetOperand<byte>(ourFrame, ourFrame, op.Left);
				const byte* right = &GetOperand<byte>(ourFrame, ourFrame, op.Right);
				Boolean& output = GetLocal<Boolean>(ourFrame->Frame, op.Output);
				output = (memcmp(left, right, op.Size) == 0);
				programCounter += sizeof(BinaryRValueOpcode);
				break;
			}

			case Instruction::TestInequalityValue:
			{
				const BinaryRValueOpcode& op = (const BinaryRValueOpcode&)opcode;
				const byte* left = &GetOperand<byte>(ourFrame, ourFrame, op.Left);
				const byte* right = &GetOperand<byte>(ourFrame, ourFrame, op.Right);
				Boolean& output = GetLocal<Boolean>(ourFrame->Frame, op.Output);
				output = (memcmp(left, right, op.Size) != 0);
				programCounter += sizeof(BinaryRValueOpcode);
				break;
			}

			// Note: These macros mirror those inside of InstructionEnum and Shared (for generation of instructions)

			// Copy
#define ZilchCopyCases(WithType)                                                                                                                \
          ZilchCaseSimpleCopy(WithType)

			// Equality and inequality
#define ZilchEqualityCases(WithType)                                                                                                            \
          ZilchCaseBinaryRValue(WithType, Boolean, TestInequality,  output = left != right);                                                            \
          ZilchCaseBinaryRValue(WithType, Boolean, TestEquality,    output = left == right);

			// Less and greater comparison
#define ZilchComparisonCases(WithType, ResultType)                                                                                              \
          ZilchCaseBinaryRValue(WithType, ResultType, TestLessThan,              output = left < right);                                                \
          ZilchCaseBinaryRValue(WithType, ResultType, TestLessThanOrEqualTo,     output = left <= right);                                               \
          ZilchCaseBinaryRValue(WithType, ResultType, TestGreaterThan,           output = left > right);                                                \
          ZilchCaseBinaryRValue(WithType, ResultType, TestGreaterThanOrEqualTo,  output = left >= right);

			// Generic numeric operators, copy, equality
#define ZilchNumericCases(WithType)                                                                                                             \
          ZilchCopyCases(WithType)                                                                                                                      \
          ZilchEqualityCases(WithType)                                                                                                                  \
          /* No case for unary plus */                                                                                                                  \
          ZilchCaseUnaryRValue (WithType, WithType, Negate,             output = -operand);                                                             \
          ZilchCaseUnaryLValue (WithType,           Increment,          GenericIncrement(operand));                                                     \
          ZilchCaseUnaryLValue (WithType,           Decrement,          GenericDecrement(operand));                                                     \
          ZilchCaseBinaryRValue(WithType, WithType, Add,                output = left + right);                                                         \
          ZilchCaseBinaryRValue(WithType, WithType, Subtract,           output = left - right);                                                         \
          ZilchCaseBinaryRValue(WithType, WithType, Multiply,           output = left * right);                                                         \
          ZilchCaseBinaryRValue(WithType, WithType, Divide,             if (GenericIsZero(right))                                                       \
			                                                                        {                                                                               \
                                                                          state->ThrowException(report, "Attempted to divide by zero");                 \
                                                                          goto ExceptionJump;                                                           \
			                                                                        }                                                                               \
                                                                        output = left / right);                                                         \
          ZilchCaseBinaryRValue(WithType, WithType, Modulo,             if (GenericIsZero(right))                                                       \
			                                                                        {                                                                               \
                                                                          state->ThrowException(report, "Attempted to modulo by zero");                 \
                                                                          goto ExceptionJump;                                                           \
			                                                                        }                                                                               \
                                                                        GenericMod(output, left, right));                                               \
          ZilchCaseBinaryRValue(WithType, WithType, Pow,                GenericPow(output, left, right));                                               \
          ZilchCaseBinaryLValue(WithType,           AssignmentAdd,      output += right);                                                               \
          ZilchCaseBinaryLValue(WithType,           AssignmentSubtract, output -= right);                                                               \
          ZilchCaseBinaryLValue(WithType,           AssignmentMultiply, output *= right);                                                               \
          ZilchCaseBinaryLValue(WithType,           AssignmentDivide,   if (GenericIsZero(right))                                                       \
			                                                                        {                                                                               \
                                                                          state->ThrowException(report, "Attempted to divide by zero");                 \
                                                                          goto ExceptionJump;                                                           \
			                                                                        }                                                                               \
                                                                        output /= right);                                                               \
          ZilchCaseBinaryLValue(WithType,           AssignmentModulo,   if (GenericIsZero(right))                                                       \
			                                                                        {                                                                               \
                                                                          state->ThrowException(report, "Attempted to modulo by zero");                 \
                                                                          goto ExceptionJump;                                                           \
			                                                                        }                                                                               \
                                                                        GenericMod(output, output, right));                                             \
          ZilchCaseBinaryLValue(WithType,           AssignmentPow,      GenericPow(output, output, right));

			// Generic numeric operators, copy, equality, comparison
#define ZilchScalarCases(WithType)                                                                                                              \
          ZilchNumericCases(WithType)                                                                                                                   \
          ZilchComparisonCases(WithType, Boolean)

			// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorCases(VectorType, ScalarType, ComparisonType)                                                                                \
          ZilchNumericCases(VectorType)                                                                                                                 \
          ZilchComparisonCases(VectorType, ComparisonType)                                                                                              \
          ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarMultiply,           output = left * right);                                 \
          ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarDivide,             output = left / right);                                 \
          ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarModulo,             GenericScalarMod(output, left, right));                 \
          ZilchCaseBinaryRValue2(VectorType, ScalarType, VectorType,  ScalarPow,                GenericScalarPow(output, left, right));                 \
          ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarMultiply, output *= right);                                       \
          ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarDivide,   output /= right);                                       \
          ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarModulo,   GenericScalarMod(output, output, right));               \
          ZilchCaseBinaryLValue2(VectorType, ScalarType,              AssignmentScalarPow,      GenericScalarPow(output, output, right));

			// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralCases(WithType)                                                                                                            \
          ZilchCaseUnaryRValue (WithType, WithType, BitwiseNot,               output = ~operand);                                                       \
          ZilchCaseBinaryRValue(WithType, WithType, BitshiftLeft,             output = left << right);                                                  \
          ZilchCaseBinaryRValue(WithType, WithType, BitshiftRight,            output = left >> right);                                                  \
          ZilchCaseBinaryRValue(WithType, WithType, BitwiseOr,                output = left | right);                                                   \
          ZilchCaseBinaryRValue(WithType, WithType, BitwiseXor,               output = left ^ right);                                                   \
          ZilchCaseBinaryRValue(WithType, WithType, BitwiseAnd,               output = left & right);                                                   \
          ZilchCaseBinaryLValue(WithType,           AssignmentBitshiftLeft,   output <<= right);                                                        \
          ZilchCaseBinaryLValue(WithType,           AssignmentBitshiftRight,  output >>= right);                                                        \
          ZilchCaseBinaryLValue(WithType,           AssignmentBitwiseOr,      output |= right);                                                         \
          ZilchCaseBinaryLValue(WithType,           AssignmentBitwiseXor,     output ^= right);                                                         \
          ZilchCaseBinaryLValue(WithType,           AssignmentBitwiseAnd,     output &= right);

			// Primitive type instructions
			ZilchIntegralCases(Integer)
				ZilchScalarCases(Integer)
				ZilchVectorCases(Integer2, Integer, Boolean2)
				ZilchVectorCases(Integer3, Integer, Boolean3)
				ZilchVectorCases(Integer4, Integer, Boolean4)
				ZilchIntegralCases(Integer2)
				ZilchIntegralCases(Integer3)
				ZilchIntegralCases(Integer4)
				ZilchScalarCases(Real)
				ZilchVectorCases(Real2, Real, Boolean2)
				ZilchVectorCases(Real3, Real, Boolean3)
				ZilchVectorCases(Real4, Real, Boolean4)
				ZilchScalarCases(DoubleReal)
				ZilchIntegralCases(DoubleInteger)
				ZilchScalarCases(DoubleInteger)

				ZilchEqualityCases(Boolean)
				ZilchEqualityCases(Handle)
				ZilchEqualityCases(Delegate)
				ZilchEqualityCases(Any)
				//ZilchEqualityCases(Value) // How is this handled currently?

				ZilchCopyCases(Boolean)
				// Handle, Delegate, and Value copy (assignment) operators are handled specially above

				ZilchCaseUnaryRValue(Boolean, Boolean, LogicalNot, output = !operand);

			ZilchCaseConversion(Integer, Real, output = (Real)value);
			ZilchCaseConversion(Integer, Boolean, output = (value != 0));
			ZilchCaseConversion(Real, Integer, output = (Integer)value);
			ZilchCaseConversion(Real, Boolean, output = (value != 0.0f));
			ZilchCaseConversion(Boolean, Integer, output = (Integer)value);
			ZilchCaseConversion(Boolean, Real, output = (Real)value);

			ZilchCaseConversion(Integer2, Real2, output = Real2((Real)value.x, (Real)value.y));
			ZilchCaseConversion(Integer2, Boolean2, output = Boolean2(value.x != 0, value.y != 0));
			ZilchCaseConversion(Real2, Integer2, output = Integer2((Integer)value.x, (Integer)value.y));
			ZilchCaseConversion(Real2, Boolean2, output = Boolean2(value.x != 0.0f, value.y != 0.0f));
			ZilchCaseConversion(Boolean2, Integer2, output = Integer2((Integer)value.x, (Integer)value.y));
			ZilchCaseConversion(Boolean2, Real2, output = Real2((Real)value.x, (Real)value.y));

			ZilchCaseConversion(Integer3, Real3, output = Real3((Real)value.x, (Real)value.y, (Real)value.z));
			ZilchCaseConversion(Integer3, Boolean3, output = Boolean3(value.x != 0, value.y != 0, value.z != 0));
			ZilchCaseConversion(Real3, Integer3, output = Integer3((Integer)value.x, (Integer)value.y, (Integer)value.z));
			ZilchCaseConversion(Real3, Boolean3, output = Boolean3(value.x != 0.0f, value.y != 0.0f, value.z != 0.0f));
			ZilchCaseConversion(Boolean3, Integer3, output = Integer3((Integer)value.x, (Integer)value.y, (Integer)value.z));
			ZilchCaseConversion(Boolean3, Real3, output = Real3((Real)value.x, (Real)value.y, (Real)value.z));

			ZilchCaseConversion(Integer4, Real4, output = Real4((Real)value.x, (Real)value.y, (Real)value.z, (Real)value.w));
			ZilchCaseConversion(Integer4, Boolean4, output = Boolean4(value.x != 0, value.y != 0, value.z != 0, value.w != 0));
			ZilchCaseConversion(Real4, Integer4, output = Integer4((Integer)value.x, (Integer)value.y, (Integer)value.z, (Integer)value.w));
			ZilchCaseConversion(Real4, Boolean4, output = Boolean4(value.x != 0.0f, value.y != 0.0f, value.z != 0.0f, value.w != 0.0f));
			ZilchCaseConversion(Boolean4, Integer4, output = Integer4((Integer)value.x, (Integer)value.y, (Integer)value.z, (Integer)value.w));
			ZilchCaseConversion(Boolean4, Real4, output = Real4((Real)value.x, (Real)value.y, (Real)value.z, (Real)value.w));

			// This case should not be hit (if so, it means things are bad!)
			default:
				Error("Invalid opcode reached (either it was unimplemented or the program counter was corrupted)");
				break;
			}

			// If a post-opcode callback is set
			if (state->OpcodePostStepCallback.Callback != nullptr)
			{
				// Get the location of this opcode
				CodeLocation* location = ourFrame->CurrentFunction->GetCodeLocationFromProgramCounter(programCounter);

				// Invoke the callback
				state->OpcodePostStepCallback.Callback(state, programCounter, location, state->OpcodePostStepCallback.UserData);
			}
		}
	}

	//***************************************************************************
	void VirtualMachine::PostDestructor(BoundType* boundType, byte* objectData)
	{
		// Loop through all the handles we want to destroy
		for (size_t i = 0; i < boundType->Handles.size(); ++i)
		{
			// Get the index that the primitive is at
			size_t index = boundType->Handles[i];

			// Destroy the primitive (which may decrement a reference)
			Handle& toDestroy = *(Handle*)(objectData + index);
			toDestroy.~Handle();
		}

		// Loop through all the delegates we want to destroy
		for (size_t i = 0; i < boundType->Delegates.size(); ++i)
		{
			// Get the index that the primitive is at
			size_t index = boundType->Delegates[i];

			// Destroy the primitive (which may decrement a reference)
			Delegate& toDestroy = *(Delegate*)(objectData + index);
			toDestroy.~Delegate();
		}
	}
}

//***************************************************************************
// ONLY FOR DEBUGGING
byte* ZilchLastRunningOpcode = nullptr;
Zilch::Function* ZilchLastRunningFunction = nullptr;
size_t ZilchLastRunningOpcodeLength = 0;
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

/*
cencode.h - c header for a base64 encoding algorithm

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

#ifndef BASE64_CENCODE_H
#define BASE64_CENCODE_H

typedef enum
{
	step_A, step_B, step_C
} base64_encodestep;

typedef struct
{
	base64_encodestep step;
	char result;
	int stepcount;
} base64_encodestate;

int compute_base64_size(int length);

void base64_init_encodestate(base64_encodestate* state_in);

char base64_encode_value(char value_in);

size_t base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in);

size_t base64_encode_blockend(char* code_out, base64_encodestate* state_in);

#endif /* BASE64_CENCODE_H */

/* public api for steve reid's public domain SHA-1 implementation */
/* this file is in the public domain */

#ifndef __SHA1_H
#define __SHA1_H

typedef u32 uint32_t;
typedef u8 uint8_t;

#ifdef __cplusplus
extern "C" {
#endif

	typedef struct {
		uint32_t state[5];
		uint32_t count[2];
		uint8_t  buffer[64];
	} SHA1_CTX;

#define SHA1_DIGEST_SIZE 20

	void SHA1_Init(SHA1_CTX* context);
	void SHA1_Update(SHA1_CTX* context, const uint8_t* data, const size_t len);
	void SHA1_Final(SHA1_CTX* context, uint8_t digest[SHA1_DIGEST_SIZE]);

#ifdef __cplusplus
}
#endif

#endif /* __SHA1_H */

// Using directives
using namespace Zero;

// Note: The entire implementation here is the WebSocket protocol:
// https://tools.ietf.org/html/rfc6455

namespace Zilch
{
	//***************************************************************************
	ZilchDefineSimpleType(WebSocketEvent, WebSockets);

	//***************************************************************************
	WebSocketEvent::WebSocketEvent() :
		Connection(nullptr),
		PacketType(WebSocketPacketType::Invalid)
	{
	}

	//***************************************************************************
	BlockingWebSocketConnection::BlockingWebSocketConnection()
	{
	}

	//***************************************************************************
	void BlockingWebSocketConnection::SendFullPacket(Status& status, const byte* data, size_t length, WebSocketPacketType::Enum packetType)
	{
		// The header has a maximum size without the mask, lets build that header
		byte header[10] = { 0 };
		size_t headerSize = 0;

		// Write the first two bytes (flags / opcode, and the payload)
		// Since we're always sending a full packet (not truncated or fragments) then this is always a FIN packet
		header[0] |= 0x80;

		// Set the opcode bit depending on if we're in text or binary or some other control opcode
		header[0] |= (byte)packetType;

		// We don't bother to set the mask bit, so just set the second byte as the size (and onward if we need it)
		if (length < 126)
		{
			header[1] = (byte)length;
			headerSize = 2;
		}
		// If we're using 2 bytes to describe the size (1 byte just to say we're using 2 bytes...)
		else if (length <= 0xFFFF)
		{
			header[1] = 126;

			*((unsigned short*)(header + 2)) = Socket::NetworkByteOrderSwap((unsigned short)length);
			headerSize = 4;
		}
		// If we're using 8 bytes to describe the size (1 byte just to say we're using 8 bytes...)
		else
		{
			header[1] = 127;
			*((unsigned long long*)(header + 2)) = Socket::NetworkByteOrderSwap((unsigned long long)length);
			headerSize = 10;
		}

		// Send the header off first (this will block until it sends the entire thing!)
		int sentSizeHeader = this->RemoteSocket.Send(status, header, (int)headerSize, SocketFlags::None);
		ErrorIf(sentSizeHeader != 0 && sentSizeHeader != (int)headerSize, "We should always send the entire header, send should block until its all sent!");
		if (status.Failed())
			return;

		// Now send the rest of the payload data (could be done in one send, no problem though!)
		int sentSizeData = this->RemoteSocket.Send(status, data, (int)length, SocketFlags::None);
		ErrorIf(sentSizeData != 0 && sentSizeData != (int)length, "We should always send the entire data, send should block until its all sent!");
		if (status.Failed())
			return;
	}

	//***************************************************************************
	bool BlockingWebSocketConnection::IsValid()
	{
		return this->RemoteSocket.IsValid();
	}

	//***************************************************************************
	WebSocketPacketType::Enum BlockingWebSocketConnection::ReceiveFullPacket(Status& status, String& dataOut)
	{
		// All the information we need for a web-socket header
		bool readHeader = false;
		size_t payloadSize = 0;
		char mask[4] = { 0 };
		bool fin = false;
		bool rsv1 = false;
		bool rsv2 = false;
		bool rsv3 = false;
		WebSocketPacketType::Enum opcode = WebSocketPacketType::Invalid;

		// Clear the data, just so that if the user is reusing a buffer, they don't get confused
		dataOut.clear();

		// Read until we hit a full packet (return inside loop below)
		for (;;)
		{
			// The default buffer size we use (big enough for a tcp window)
			const int ReceiveBufferSize = 4096;

			// Read the data from the socket
			byte buffer[ReceiveBufferSize];
			int amountReceived = this->RemoteSocket.Receive(status, buffer, ReceiveBufferSize, SocketFlags::None);

			// If the receive call failed, or we gracefully disconnected...
			if (status.Failed() || amountReceived == 0)
				return WebSocketPacketType::Invalid;

			// Add the data to a remaining buffer
			this->ReadData.insert(this->ReadData.end(), buffer, buffer + amountReceived);
			byte* data = this->ReadData.data();

			// The minimum amount of data a packet can be is 6, but the header can be larger because of extended sizes
			// This includes the opcode/starting bits (1), the payload length (1), and the mask (4)
			if (readHeader == false && this->ReadData.size() >= 6)
			{
				// First, read the header byte which tells us all the options
				byte headerByte = data[0];
				fin = (headerByte & 0x80) != 0;
				rsv1 = (headerByte & 0x40) != 0;
				rsv2 = (headerByte & 0x20) != 0;
				rsv3 = (headerByte & 0x10) != 0;
				opcode = (WebSocketPacketType::Enum)(headerByte & 0x0F);

				// Read the size of our packet
				byte sizeByte = data[1];

				// The highest bit is always set, basically clear it
				bool masking = (sizeByte & 0x80) != 0;
				sizeByte &= 0x7F;

				// We read the opcode/bits and the payload length, which is 2 bytes
				size_t position = 2;
				payloadSize = sizeByte;

				// Assume right now that we successfully read the header (we may still fail below if we don't have enough header data)
				readHeader = true;

				// If the size is 126, then it means we have an extra 16 bits of data (2 bytes)
				if (sizeByte == 126)
				{
					// We're reading an extended payload size of 2 bytes, which means we must have at least 8 bytes (6 + 2) of data in total for the whole header
					if (this->ReadData.size() >= 8)
					{
						payloadSize = Socket::NetworkByteOrderSwap((unsigned short)(data[2] + (data[3] << 8)));
						position = 4;
					}
					else
					{
						// We couldn't read the extended payload, because we didn't have enough data read for it
						readHeader = false;
					}
				}
				// If the size is 127, then we have an extra 64 bits of data (8 bytes)
				else if (sizeByte == 127)
				{
					// We're reading an extended payload size of 8 bytes, which means we must have at least 14 bytes (6 + 8) of data in total for the whole header
					if (this->ReadData.size() >= 14)
					{
						payloadSize = (size_t)Socket::NetworkByteOrderSwap((unsigned long long)(data[2] + (data[3] << 8) + (data[4] << 16) + (data[5] << 24) + ((unsigned long long)data[6] << 32) + ((unsigned long long)data[7] << 40) + ((unsigned long long)data[8] << 48) + ((unsigned long long)data[9] << 56)));
						position = 10;
					}
					else
					{
						// We couldn't read the extended payload, because we didn't have enough data read for it
						readHeader = false;
					}
				}

				// If we successfully read in all the header data...
				if (readHeader)
				{
					// Last but not least, read the mask!
					memcpy(mask, data + position, 4);
					position += 4;

					// Remove the header from the data
					this->ReadData.erase(Array<byte>::range(data, data + position));
				}
			}

			// If we already read the header and we have enough data to read the entire packet...
			if (readHeader && this->ReadData.size() >= payloadSize)
			{
				// Get a pointer to the data (for convenience)
				byte* data = this->ReadData.data();

				// Directly create a string node that we'll assign to a string (where we copy our data into)
				String::StringNode* node = String::allocateNode(payloadSize);

				// Clear the reference count to 0, since assigning the node to the String actuall increments the reference count
				// Note: This behavior may change in the future!
				node->RefCount = 0;

				// Loop through the payload and apply the mask to it
				for (size_t i = 0; i < payloadSize; ++i)
				{
					// Grab the current mask character (rotates by 4 over and over)
					// Apply this mask to the current byte we're reading, and put it into the user output
					char maskChar = mask[i % 4];
					node->Data[i] = data[i] ^ maskChar;
				}

				// Because we could be treating the payload data as a string, and we want to play nice with the String class
				// set the last byte in the output buffer to be a null terminator (binary data does not use this, but just to be safe!)
				node->Data[payloadSize] = '\0';

				// Now output the string from the node we just created
				dataOut = String(node);

				// We're done, we read a full packet, remove the data we read so that the next packet can be processed
				this->ReadData.erase(Array<byte>::range(data, data + payloadSize));
				return opcode;
			}
		}
	}

	//***************************************************************************
	BlockingWebSocketListener::BlockingWebSocketListener()
	{
	}

	//***************************************************************************
	void BlockingWebSocketListener::Initialize(Status& status, int port)
	{
		// Web sockets are strictly TCP
		this->ListenerSocket.Initialize(status, SocketAddressFamily::InterNetworkV4, SocketType::Stream, SocketProtocolType::Tcp);

		// First create a local socket address, bound to any network adapter (let the OS choose)
		// Use the port that the user passed in
		SocketAddress localAddress;
		localAddress.InitializeLocalInterNetwork4Any(status, port);

		if (status.Failed())
			return;

		// Next, bind our listener socket to that address
		this->ListenerSocket.Bind(status, localAddress);

		if (status.Failed())
			return;

		// Now listen on the socket, which should allow incoming connections to be accepted
		this->ListenerSocket.Listen(status, Socket::GetMaxConnectionBacklog());
	}

	//***************************************************************************
	void BlockingWebSocketListener::Close(Status& status)
	{
		this->ListenerSocket.Close(status);
	}

	//***************************************************************************
	bool BlockingWebSocketListener::IsValid()
	{
		return this->ListenerSocket.IsValid();
	}

	//***************************************************************************
	void BlockingWebSocketListener::Accept(Status& status, BlockingWebSocketConnection& connectionOut)
	{
		// Attempt to accept a connection
		this->ListenerSocket.Accept(status, &connectionOut.RemoteSocket, &connectionOut.RemoteAddress);

		if (status.Failed())
			return;

		// The default buffer size we use (big enough for a tcp window)
		const int ReceiveBufferSize = 4096;

		// Even though it's not the most efficient approach, we're going to take all data we receive
		// and stuff it into this array before we try and parse it (keeps data contiguous)
		// A better data structure would be able to work with the temporary received data, and then
		// only append what isn't read at the end
		Array<byte> remainingHeaderData;

		// Whether or not we read the full header (denoted when we read two newlines in a row)
		bool readFullHttpHeader = false;

		// We've accepted a connection, but we don't know if this is a proper websocket yet...
		do
		{
			// Read the data from the socket
			byte buffer[ReceiveBufferSize];
			int amountReceived = connectionOut.RemoteSocket.Receive(status, buffer, ReceiveBufferSize, SocketFlags::None);

			// If the receive call failed, or we gracefully disconnected...
			if (status.Failed() || amountReceived == 0)
				return;

			// Add the data to a remaining buffer
			remainingHeaderData.insert(remainingHeaderData.end(), buffer, buffer + amountReceived);

			// If we process the get request header
			bool getRequest = false;

			// Since the HTTP protocl is line based, store the last line we stopped on
			const char* lastLineStart = (char*)remainingHeaderData.data();

			// Get a pointer to the remaining data, for convenience
			char* data = (char*)remainingHeaderData.data();

			// Track whether we already hit a newline (used to break out from the HTTP request - two newlines)
			bool justHitNewline = false;

			// Loop through remaining data...
			for (size_t i = 0; i < remainingHeaderData.size(); ++i)
			{
				// Read a single character
				char c = data[i];

				// If the character is a newline...
				if (c == '\n')
				{
					// If we hit a newline now and we had just hit a newline before...
					if (justHitNewline)
					{
						// We read the entire HTTP header!
						readFullHttpHeader = true;
						break;
					}

					// Mark that we just hit a newline (gets reset in the 'else' clause below)
					justHitNewline = true;

					// Create a range that points from the start of the current line to the end (where we are now, the newline!)
					StringRange range(lastLineStart, data + i);

					// If we have yet to read that this is a get-request...
					if (getRequest == false)
					{
						// Read the get-request line
						if (String::StartsWith(range, "GET / HTTP/1.1"))
						{
							getRequest = true;
						}
						else
						{
							// This is NOT a get request, or it's an old version!
							connectionOut.RemoteSocket.Close(status);

							// Return that the http request was not valid (regardless of if closing the socket failed)
							status.SetFailed("Not a valid HTTP 1.1 client request");
							return;
						}
					}
					else
					{
						// Look for the HTTP header divider character ':'
						size_t dividerIndex = range.FindFirstOf(':');
						if (dividerIndex != String::InvalidIndex)
						{
							// Parse the key and value part of the header line
							// The +2 is for the ':' and the space after it
							StringRange httpHeaderKey(range.begin, dividerIndex);
							StringRange httpHeaderValue(range.begin + dividerIndex + 2, range.end);

							// Trim the trailing '\r' if it exists (it should, but some non-compliant browsers don't send it)
							if (httpHeaderValue.back() == '\r')
								--httpHeaderValue.end;

							// Finally, map the key to the value so we can lookup any header values later
							connectionOut.Headers.insert(httpHeaderKey, httpHeaderValue);
						}
						else
						{
							// We got some bad data, or just something we didn't yet handle!
							status.SetFailed(BuildString("Invalid line found in the http header request: ", range));
							return;
						}
					}

					// Skip the newline character (hence the +1)
					lastLineStart = data + i + 1;
				}
				else if (c != '\r')
				{
					// As long as we're not hitting the carriage return, mark this as no longer a newline
					justHitNewline = false;
				}
			}

			// Erase all the data we processed already
			remainingHeaderData.erase(Array<byte>::range((byte*)data, (byte*)lastLineStart));
		}
		// Loop until we read the full header
		while (readFullHttpHeader == false);

		// A special guid appended to the 'accept' message that the server sends back (just to identify web sockets)
		static const String ServerGuid("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
		static const String SecWebSocketKey("Sec-WebSocket-Key");

		// Make sure we got a web socket key request
		String* key = connectionOut.Headers.findPointer(SecWebSocketKey);
		if (key == nullptr)
		{
			return status.SetFailed("We did not receive the 'Sec-WebSocket-Key' parameter, and "
				"therefore the connection was not a valid web socket connection");
		}

		// As per RFC-6455 (page 7)
		// We take the above guid and concatenate it with the given key
		String concatenatedKey = BuildString(*key, ServerGuid);

		// Get the sha1 on of the concatenated key
		byte finalSha1[SHA1_DIGEST_SIZE];
		SHA1_CTX sha1Context;
		SHA1_Init(&sha1Context);
		SHA1_Update(&sha1Context, (byte*)concatenatedKey.data(), concatenatedKey.size());
		SHA1_Final(&sha1Context, finalSha1);

		// Lastly, we need to base64 encode the sha1 hash
		Array<char> base64Encoded;
		base64Encoded.resize(compute_base64_size(SHA1_DIGEST_SIZE));
		base64_encodestate base64EncodeContext;
		base64_init_encodestate(&base64EncodeContext);
		size_t written = base64_encode_block((char*)finalSha1, SHA1_DIGEST_SIZE, base64Encoded.data(), &base64EncodeContext);
		base64_encode_blockend(base64Encoded.data() + written, &base64EncodeContext);

		// Send the response to the web socket request
		String response = BuildString
			(
			"HTTP/1.1 101 Switching Protocols\r\n"
			"Upgrade: websocket\r\n"
			"Connection: Upgrade\r\n"
			"Sec-WebSocket-Accept: ",
			StringRange(base64Encoded.data(), base64Encoded.size()),
			"\r\n\r\n"
			);

		// This should be the last thing we have to send!
		connectionOut.RemoteSocket.Send(status, (byte*)response.data(), (int)response.size(), SocketFlags::None);
	}

	//***************************************************************************
	void ThreadedWebSocketConnection::SendPacket(StringParam message, WebSocketPacketType::Enum packetType)
	{
		// First initiale the lock around the send messages queue, append the message
		// then unlock it so the 'SendThread' can resume its work
		this->SendLock.Lock();

		// We just use the event structure because it has all the data we need
		WebSocketEvent& toSend = this->SendMessages.push_back();
		toSend.Data = message;
		toSend.PacketType = packetType;

		// We need to tell the send thread that it now has data to send (unblocks it)
		// This MUST happen inside the locks, otherwise it's possibly to consume
		// all messages in the send thread before the singal, and cause the send thread to exit
		this->SendEvent.Signal();
		this->SendLock.Unlock();
	}

	//***************************************************************************
	ThreadedWebSocketConnection::ThreadedWebSocketConnection()
	{
	}

	//***************************************************************************
	ThreadedWebSocketConnection::~ThreadedWebSocketConnection()
	{
		// Closing automatically terminates threads and the socket
		// It's also safe to call more than once
		this->Close();
	}

	//***************************************************************************
	bool ThreadedWebSocketConnection::IsValid()
	{
		return this->BlockingConnection.IsValid();
	}

	//***************************************************************************
	void ThreadedWebSocketConnection::Close()
	{
		// If the connection is already closed... early out
		if (this->IsValid() == false)
			return;

		// Shutdown the remote connection, which should signal that we're ending the connection
		WebSocketEvent shutdownEvent;
		shutdownEvent.Connection = this;
		this->BlockingConnection.RemoteSocket.Shutdown(shutdownEvent.ErrorStatus, SocketIo::Both);

		// Close the remote connection
		WebSocketEvent closeEvent;
		closeEvent.Connection = this;
		this->BlockingConnection.RemoteSocket.Close(closeEvent.ErrorStatus);

		// Clear out the messages to be sent
		this->SendLock.Lock();
		this->SendMessages.clear();
		this->SendLock.Unlock();

		// Signal the send event, if it gets signaled and there's no messages, it means we're closing
		this->SendEvent.Signal();
		this->SendThread.WaitForCompletion();

		// Wait until the receive thread ends...
		this->ReceiveThread.WaitForCompletion();

		// If the shutdown status failed for any reason, dispatch an event out
		if (shutdownEvent.ErrorStatus.Failed())
			this->Send(Events::WebSocketError, &shutdownEvent);

		// If the close status failed for any reason, dispatch an event out
		if (closeEvent.ErrorStatus.Failed())
			this->Send(Events::WebSocketError, &closeEvent);

		// After the entire closure of the socket, send out a disconnected event
		WebSocketEvent disconnectEvent;
		disconnectEvent.Connection = this;
		this->Send(Events::WebSocketDisconnected, &disconnectEvent);
	}

	//***************************************************************************
	void ThreadedWebSocketConnection::Update()
	{
		// Lock the recieve buffer and bring all messages to the owning recieve message array
		this->IncomingLock.Lock();
		this->OwnerIncomingEvents.swap(this->ThreadIncomingEvents);
		this->IncomingLock.Unlock();

		// Walk through all messages and deliver them to the user
		for (size_t i = 0; i < this->OwnerIncomingEvents.size(); ++i)
		{
			// Grab the current message and send out a recieved event
			WebSocketEvent* event = &this->OwnerIncomingEvents[i];

			// Depending on what happened, send out either an error message or a received data message
			// Note: Errors can originate both from the send and receive thread
			if (event->ErrorStatus.Failed())
			{
				// Only send out the error if its a real error (we don't consider receive/close errors as bad errors)
				if (Socket::IsReceiveCloseError(event->ErrorStatus.ExtendedErrorCode) == false)
					this->Send(Events::WebSocketError, event);
			}
			else
			{
				// Based on the packet type..
				// Note: We don't currently handle pong because we don't care (nor do we send out pings)
				switch (event->PacketType)
				{
					// If we received either text or binary data, let the user know
				case WebSocketPacketType::Binary:
				case WebSocketPacketType::Text:
					this->Send(Events::WebSocketReceivedData, event);
					break;

					// A continuation of a packet is a partial packet...
				case WebSocketPacketType::Continuation:
					Error("WebSocket Continuation packets are not currently handled");
					break;

					// We must respond with a pong
				case WebSocketPacketType::Ping:
					this->SendPacket(event->Data, WebSocketPacketType::Pong);
					break;

					// When the socket is closed, we must send a close response and close our own socket
				case WebSocketPacketType::Close:
					this->SendPacket(event->Data, WebSocketPacketType::Close);
					break;
				}
			}
		}

		// Clear out the owning messages
		this->OwnerIncomingEvents.clear();

		// Now, if we ever experienced a disconnect, either via a non-writable socket or a thread terminates
		// then we'll attempt to close the socket
		// The receive thread can terminate on any error or upon a gracefull disconnect (receives 0 data)
		// The send thread can terminate on any error or upon sending the final web-socket close packet
		if (this->ReceiveThread.IsCompleted() || this->SendThread.IsCompleted())
			this->Close();
	}

	//***************************************************************************
	void ThreadedWebSocketConnection::Initialize()
	{
		// The send event will be used to signal the send thread that we have data outgoing
		this->SendEvent.Initialize();

		// Initialize all of our threads
		this->ReceiveThread.Initialize(ReceiveEntryPoint, this, "WebSocketReceive");
		this->SendThread.Initialize(SendEntryPoint, this, "WebSocketSend");

		// Start the send and recieve threads
		this->SendThread.Resume();
		this->ReceiveThread.Resume();
	}

	//***************************************************************************
	OsInt ThreadedWebSocketConnection::ReceiveEntryPoint(void* context)
	{
		// The context we pass in is our 'this' pointer
		ThreadedWebSocketConnection* self = (ThreadedWebSocketConnection*)context;

		// Receive messages until the socket is closed or we disconnect
		ZilchLoop
		{
			// Create an event that we'll queue up for the owning thread to receive
			WebSocketEvent receivedEvent;
			receivedEvent.Connection = self;

			// Receive an entire packet of text, this text should be json data
			receivedEvent.PacketType = self->BlockingConnection.ReceiveFullPacket(receivedEvent.ErrorStatus, receivedEvent.Data);

			// Lock the recieve buffer and push the message into it
			// The message may be an actual packet, or an error message
			self->IncomingLock.Lock();
			self->ThreadIncomingEvents.push_back(receivedEvent);
			self->IncomingLock.Unlock();

			// If we failed to for any reason (or disconnected gracefully), exit out of the thread
			if (receivedEvent.PacketType == WebSocketPacketType::Invalid)
				return 0;
		}
	}

	//***************************************************************************
	OsInt ThreadedWebSocketConnection::SendEntryPoint(void* context)
	{
		// The context we pass in is our 'this' pointer
		ThreadedWebSocketConnection* self = (ThreadedWebSocketConnection*)context;

		// We pull messages from the debugger's owning thread into our thread
		Array<WebSocketEvent> messageQueue;

		ZilchLoop
		{
			// Wait for any messages to be put on the queue
			self->SendEvent.Wait();

			// Make sure OUR message queue is empty (this is safe to do outside the lock)
			ErrorIf(messageQueue.empty() == false,
				"We should have sent all messages before attempting to swap with the main thread");

			// We got some messages, lock and swap with our own message buffer
			self->SendLock.Lock();

			// If we have no messages but the send event was signaled
			if (self->SendMessages.empty())
			{
				// Make sure to unlock and early return out
				self->SendLock.Unlock();
				return 0;
			}

			// Very quickly swap our entire send messages array with theirs
			// Note: This should always clear our their array because ours should be empty
			messageQueue.swap(self->SendMessages);

			// Due to a race condition that can happen where the main thread queues up
			// a message between the Wait and the Lock, then we will have the event set in the next loop,
			// yet we will have cleared all the messages (swapped)
			self->SendEvent.Reset();

			// We're done, that was fast!
			self->SendLock.Unlock();

			// Send every message we have
			for (size_t i = 0; i < messageQueue.size(); ++i)
			{
				// Grab the current message
				WebSocketEvent& message = messageQueue[i];

				// This is only queued up in the case that an error occurs
				WebSocketEvent errorEvent;
				errorEvent.Connection = self;

				// Send the full packet over
				self->BlockingConnection.SendFullPacket(errorEvent.ErrorStatus, (const byte*)message.Data.data(), message.Data.size(), message.PacketType);

				// If we encountered an error when sending...
				if (errorEvent.ErrorStatus.Failed())
				{
					// Lock the recieve buffer and push the error into it
					self->IncomingLock.Lock();
					self->ThreadIncomingEvents.push_back(errorEvent);
					self->IncomingLock.Unlock();

					// We always exit the send thread in the event of an error
					return 0;
				}

				// If the last packet was a close packet, we must not send any more data, as per the web-socket RFC
				if (message.PacketType == WebSocketPacketType::Close)
					return 0;
			}

			// Clear out the queue
			messageQueue.clear();
		}
	}


	//***************************************************************************
	ThreadedWebSocketListener::ThreadedWebSocketListener() :
		AcceptingConnection(nullptr)
	{
	}

	//***************************************************************************
	ThreadedWebSocketListener::~ThreadedWebSocketListener()
	{
		this->Close();
	}

	//***************************************************************************
	void ThreadedWebSocketListener::Initialize(int port)
	{
		// Starts listening on the given port
		WebSocketEvent hostEvent;
		this->BlockingListener.Initialize(hostEvent.ErrorStatus, port);

		// If the hosting status failed for any reason, dispatch an event out
		if (hostEvent.ErrorStatus.Failed())
			this->Send(Events::WebSocketError, &hostEvent);

		// Create the web socket accepting thread
		this->AcceptThread.Initialize(AcceptEntryPoint, this, "WebSocketAccept");

		// Start the accepting thread
		this->AcceptThread.Resume();
	}

	//***************************************************************************
	bool ThreadedWebSocketListener::IsValid()
	{
		return this->BlockingListener.IsValid();
	}

	//***************************************************************************
	void ThreadedWebSocketListener::Close()
	{
		// If the connection is already closed... early out
		if (this->BlockingListener.ListenerSocket.IsValid() == false)
			return;

		// We only want to terminate the accepting listener socket while inside the lock, to prevent a race condition
		// We also want to terminate the socket for any connection that is currently being accepted (if it exists)
		this->AcceptingConnectionLock.Lock();

		// Close the remote connection, which should signal that we're ending the connection
		WebSocketEvent listenerCloseEvent;
		this->BlockingListener.ListenerSocket.Close(listenerCloseEvent.ErrorStatus);

		// Blocking connection close event
		WebSocketEvent acceptingCloseEvent;

		// If the accepting connection is valid (we have one that is currently being accepted
		if (this->AcceptingConnection != nullptr && this->AcceptingConnection->BlockingConnection.IsValid())
			this->AcceptingConnection->BlockingConnection.RemoteSocket.Close(acceptingCloseEvent.ErrorStatus);

		// Let the accepting thread resume
		this->AcceptingConnectionLock.Unlock();

		// The accept thread should encounter an error (accept will unblock)
		// and then because the listener descriptor was closed and made invalid by calling 'Close', the thread should terminate
		// Wait until the accept thread ends...
		this->AcceptThread.WaitForCompletion();

		// If the listener close status failed for any reason, dispatch an event out
		if (listenerCloseEvent.ErrorStatus.Failed())
			this->Send(Events::WebSocketError, &listenerCloseEvent);

		// If the accepting connection's close status failed for any reason, dispatch an event out
		if (acceptingCloseEvent.ErrorStatus.Failed())
			this->Send(Events::WebSocketError, &acceptingCloseEvent);
	}

	//***************************************************************************
	void ThreadedWebSocketListener::Update()
	{
		// Lock the recieve buffer and bring all messages to the owning recieve message array
		this->IncomingLock.Lock();
		this->OwnerIncomingEvents.swap(this->ThreadIncomingEvents);
		this->IncomingLock.Unlock();

		// Walk through all messages and deliver them to the user
		for (size_t i = 0; i < this->OwnerIncomingEvents.size(); ++i)
		{
			// Grab the current message and send out a recieved event
			WebSocketEvent* event = &this->OwnerIncomingEvents[i];

			// Depending on what happened, send out either an error message or a accepted connection message
			if (event->Connection != nullptr)
				this->Send(Events::WebSocketAcceptedConnection, event);
			else
				this->Send(Events::WebSocketError, event);
		}

		// Clear out the owning messages
		this->OwnerIncomingEvents.clear();

		// Now, if we ever experienced a disconnect, either via a non-writable socket or a thread terminates
		// Then we'll attempt to close the socket
		if (this->AcceptThread.IsCompleted())
			this->Close();
	}

	//***************************************************************************
	OsInt ThreadedWebSocketListener::AcceptEntryPoint(void* context)
	{
		// The context we pass in is our 'this' pointer
		ThreadedWebSocketListener* self = (ThreadedWebSocketListener*)context;

		ZilchLoop
		{
			// An event we send out if an error occurs
			WebSocketEvent acceptEvent;

			// Before accepting any connections, we need to check if we're terminating, and also let the owning
			// thread know the current connection we're accepting (so if the owning thread destructs this object, it
			// can also close the accepting connection)
			self->AcceptingConnectionLock.Lock();

			// If we no longer have a valid blocking listener, just exit out
			if (self->BlockingListener.IsValid() == false)
			{
				// Make sure to unlock, and terminate this thread
				self->AcceptingConnectionLock.Unlock();
				return 0;
			}

			// Create a new connection that can be accepted, and let the owning thread know what it is
			// Again, this is so the owning thread can cancel both the listening and accepting sockets so we don't deadlock on receieve
			ThreadedWebSocketConnection* connection = new ThreadedWebSocketConnection();
			self->AcceptingConnection = connection;

			// Let the owning thread resume
			self->AcceptingConnectionLock.Unlock();

			// Accept an incoming connection (blocks until the connection is fully acked according to web-sockets)
			// Will unblock if the sockets are terminated by the owning thread
			self->BlockingListener.Accept(acceptEvent.ErrorStatus, connection->BlockingConnection);

			// Now that we've finished accepting (could have failed, or could be a valid connection)
			// we are no longer accepting this 'connection'
			self->AcceptingConnectionLock.Lock();

			// Clear out the accepting connection so the owning thread won't try and close it
			self->AcceptingConnection = nullptr;

			// Let the owning thread resume
			self->AcceptingConnectionLock.Unlock();

			// If we didn't fail to accept a connection, then tell the main thread about the connection
			if (acceptEvent.ErrorStatus.Succeeded())
			{
				// This is an accepted connection with no errors!
				acceptEvent.Connection = connection;

				// Initialize the connection, which generally spins up the send/receive threads
				connection->Initialize();

				// Lock the recieve buffer and push the connection into it
				self->IncomingLock.Lock();
				self->ThreadIncomingEvents.push_back(acceptEvent);
				self->IncomingLock.Unlock();
			}
			else
			{
				// Any failure to connect should destroy the connection
				delete connection;
				connection = nullptr;

				// If the extended error code was set, it means we ran into a true socket error (or the socket was closed) so terminate the connection
				if (acceptEvent.ErrorStatus.ExtendedErrorCode != 0 && Socket::IsAcceptRemoteError(acceptEvent.ErrorStatus.ExtendedErrorCode) == false)
				{
					// We only dispatch the error message if it's not a close event
					if (Socket::IsReceiveCloseError(acceptEvent.ErrorStatus.ExtendedErrorCode) == false)
					{
						// Lock the recieve buffer and push the error into it
						self->IncomingLock.Lock();
						self->ThreadIncomingEvents.push_back(acceptEvent);
						self->IncomingLock.Unlock();
					}

					// We always exit the send thread in the event of an error
					return 0;
				}
			}
		}
	}

	//***************************************************************************
	ThreadedWebSocketServer::ThreadedWebSocketServer(size_t maxConnections) :
		MaximumConnections(maxConnections)
	{
		// We want to know when connections are accepted, and when errors occur with the listener
		EventConnect(&this->Listener, Events::WebSocketAcceptedConnection, &ThreadedWebSocketServer::OnAcceptedConnection, this);
		EventForward(&this->Listener, Events::WebSocketError, this);
	}

	//***************************************************************************
	ThreadedWebSocketServer::~ThreadedWebSocketServer()
	{
		// Loop through all the connections we have and update them
		for (size_t i = 0; i < this->Connections.size(); ++i)
		{
			// Grab the current connection
			ThreadedWebSocketConnection* connection = this->Connections[i];
			delete connection;
			connection = nullptr;
		}
	}

	//***************************************************************************
	void ThreadedWebSocketServer::Host(int port)
	{
		this->Listener.Initialize(port);
	}

	//***************************************************************************
	bool ThreadedWebSocketServer::IsValid()
	{
		return this->Listener.IsValid();
	}

	//***************************************************************************
	void ThreadedWebSocketServer::Update()
	{
		// Update the listener, which will dispatch events
		this->Listener.Update();

		// Loop through all the connections we have and update them
		for (size_t i = 0; i < this->Connections.size();)
		{
			// Grab the current connection
			ThreadedWebSocketConnection* connection = this->Connections[i];

			// Update the connection, which could actually close the socket
			connection->Update();

			// If the connection is closed, we should remove it!
			if (connection->IsValid() == false)
			{
				// Swap with the last connection and then pop the back
				this->Connections[i] = this->Connections.back();
				this->Connections.pop_back();
			}
			else
			{
				// Otherwise, the connection was fine so just walk to the next one
				++i;
			}
		}
	}

	//***************************************************************************
	void ThreadedWebSocketServer::SendPacketToAll(StringParam message, WebSocketPacketType::Enum packetType)
	{
		// Loop through all the connections and send the message to each
		for (size_t i = 0; i < this->Connections.size(); ++i)
		{
			// Grab the current connection and send the message
			ThreadedWebSocketConnection* connection = this->Connections[i];
			connection->SendPacket(message, packetType);
		}
	}

	//***************************************************************************
	void ThreadedWebSocketServer::OnAcceptedConnection(WebSocketEvent* event)
	{
		// If we're already at (or exceeded) our max connections...
		if (this->Connections.size() >= this->MaximumConnections)
		{
			// Terminate the accepted connection immediately (don't add it to our list)
			delete event->Connection;
			event->Connection = nullptr;
			return;
		}

		// Add the connection to our own tracked list
		this->Connections.push_back(event->Connection);

		// Forward the event on us, so anyone listening can see we got a new connection
		this->Send(event->EventName, event);

		// Forward all the errors, disconnect, and receive data events
		EventForward(event->Connection, Events::WebSocketError, this);
		EventForward(event->Connection, Events::WebSocketDisconnected, this);
		EventForward(event->Connection, Events::WebSocketReceivedData, this);
	}
}
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Includes

namespace Zilch
{
	//***************************************************************************
	void ZilchStartup(Debugging::Enum debug)
	{
		// Make sure all of our statics are initialized (guarantees thread safety)
		Grammar::GetUsedKeywords();
		Grammar::GetReservedKeywords();
		Grammar::GetSpecialKeywords();

		// If the user wants us to, we'll use our own custom error handler
		if (debug == Debugging::UseZilchErrorHandler)
		{
			ErrorSignaler::SetErrorHandler(DebugErrorHandler);
		}

		// Register the command handle managers we use
		ZilchRegisterUniqueHandleManager(HeapManager);
		ZilchRegisterUniqueHandleManager(StackManager);
		ZilchRegisterSharedHandleManager(PointerManager);
		ZilchRegisterSharedHandleManager(StringManager);

		// Lock any future handle managers from being added
		HandleManagers::GetInstance().Lock();

		// Finally build all the static libraries (C++ bound libraries)
		StaticLibraries::GetInstance().BuildAll();

		// Finally, after everything else is built, make the shared library
		Shared::GetInstance();
	}

	//***************************************************************************
	void ZilchShutdown()
	{
		// Shutdown the memory manager
		Shutdown();
	}
}///////////////////////////////////////////////////////////////////////////////
///
/// \file ByteBuffer.cpp
/// Definition of ByteBuffer.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	//------------------------------------------------------------ Block Range 

	ByteBuffer::BlockRange::BlockRange(ByteBuffer* buffer)
	{
		mBlock = buffer->mBlocks.data();
		mLast = buffer->mBlocks.end();
		mBlockSize = buffer->mBlockSize;
		mLastBlockSize = buffer->mCurBlockSize;
	}

	const ByteBuffer::Block& ByteBuffer::BlockRange::front()
	{
		ErrorIf(empty(), "Read empty range.");
		loadBlock();
		return mCurrent;
	}

	bool ByteBuffer::BlockRange::empty()
	{
		return mBlock >= mLast;
	}

	void ByteBuffer::BlockRange::loadBlock()
	{
		mCurrent.Size = mBlock == (mLast - 1) ? mLastBlockSize : mBlockSize;
		mCurrent.Data = *mBlock;
	}

	void ByteBuffer::BlockRange::popFront()
	{
		ErrorIf(empty(), "Popped and empty range.");
		++mBlock;
	}

	//------------------------------------------------------------ Byte Buffer 

	ByteBuffer::ByteBuffer(size_t blockSize)
	{
		mTotalSize = 0;
		mCurBlockSize = 0;
		mCurBlockBuffer = NULL;
		mBlockSize = blockSize;
	}

	ByteBuffer::~ByteBuffer()
	{
		Deallocate();
	}

	ByteBuffer::BlockRange ByteBuffer::Blocks()
	{
		return BlockRange(this);
	}

	size_t ByteBuffer::Tell()
	{
		return mTotalSize;
	}

	void ByteBuffer::Write(const byteType* data, size_t sizeInBytes)
	{
		Append(data, sizeInBytes);
	}

	void ByteBuffer::Append(const byteType* data, size_t sizeInBytes)
	{
		if (mCurBlockBuffer == NULL)
		{
			//Allocator more memory
			mCurBlockBuffer = (byteType*)zAllocate(mBlockSize);
			mCurBlockSize = 0;

			//Store the block
			mBlocks.push_back(mCurBlockBuffer);

		}

		while (mCurBlockSize + sizeInBytes > mBlockSize)
		{
			//Partial copy to remaining area of block
			size_t sizeToCopy = mBlockSize - mCurBlockSize;

			//Copy into data block
			memcpy(mCurBlockBuffer + mCurBlockSize, data, sizeToCopy);

			//Allocator more memory
			mCurBlockBuffer = (byteType*)zAllocate(mBlockSize);
			mCurBlockSize = 0;

			//Store the block
			mBlocks.push_back(mCurBlockBuffer);

			//Decrement bytes copied and try again
			sizeInBytes -= sizeToCopy;
			mTotalSize += sizeToCopy;
			data += sizeToCopy;
		}

		//Is there any more data to be copied?
		if (sizeInBytes > 0)
		{
			memcpy(mCurBlockBuffer + mCurBlockSize, data, sizeInBytes);
			mCurBlockSize += sizeInBytes;
			mTotalSize += sizeInBytes;
		}

	}

	void ByteBuffer::ExtractInto(byteType* byteBuffer, size_t bufferSizeInBytes) const
	{
		ErrorIf(mTotalSize > bufferSizeInBytes, "Buffer is not large enough for data.");
		if (mTotalSize > bufferSizeInBytes)
			return;//Do nothing

		//unreferenced formal parameter in release
		(void)bufferSizeInBytes;

		//Copy over all blocks
		byteType* bufferPosition = byteBuffer;
		Array<byteType*>::range blocks = mBlocks.all();
		for (; !blocks.empty(); blocks.popFront())
		{
			size_t blockSize = blocks.front() == mCurBlockBuffer ? mCurBlockSize : mBlockSize;
			memcpy(bufferPosition, blocks.front(), blockSize);
			bufferPosition += mBlockSize;
		}

	}

	void ByteBuffer::ExtractInto(ByteBufferBlock& buffer) const
	{
		buffer.Deallocate();
		buffer.mSize = mTotalSize;
		buffer.mData = (byte*)zAllocate(mTotalSize);
		buffer.mCurrent = buffer.mData;
		buffer.mOwnsData = true;
		ExtractInto(buffer.mData, buffer.mSize);
	};

	void ByteBuffer::Deallocate()
	{
		//Deallocate all blocks
		Array<byteType*>::range blocks = mBlocks.all();
		for (; !blocks.empty(); blocks.popFront())
		{
			zDeallocate(blocks.front());
		}

		mCurBlockSize = 0;
		mCurBlockBuffer = NULL;
		mBlocks.clear();
		mTotalSize = 0;
	}

	//------------------------------------------------------------ ByteBufferBlock

	ByteBufferBlock::ByteBufferBlock()
	{
		mData = NULL;
		mCurrent = NULL;
		mSize = 0;
		mOwnsData = false;
	}

	ByteBufferBlock::ByteBufferBlock(size_t size)
	{
		mData = (byte*)zAllocate(size);
		mCurrent = mData;
		mSize = size;
		mOwnsData = true;
	}

	ByteBufferBlock::ByteBufferBlock(byte* data, size_t size, bool owned)
	{
		mData = data;
		mCurrent = data;
		mSize = size;
		mOwnsData = owned;
	}

	void ByteBufferBlock::SetData(byte* data, size_t size, bool owned)
	{
		Deallocate();
		mData = data;
		mCurrent = data;
		mSize = size;
		mOwnsData = owned;
	}

	void ByteBufferBlock::SetBlock(DataBlock block)
	{
		Deallocate();
		mData = block.Data;
		mCurrent = block.Data;
		mSize = block.Size;
		mOwnsData = false;
	}

	ByteBufferBlock::~ByteBufferBlock()
	{
		Deallocate();
	}

	void ByteBufferBlock::Deallocate()
	{
		if (mData && mOwnsData)
			zDeallocate(mData);

		mData = NULL;
		mCurrent = NULL;
		mSize = 0;
		mOwnsData = false;
	}

	void ByteBufferBlock::Seek(int offset, uint origin)
	{
		mCurrent += offset;
	}

	size_t ByteBufferBlock::Read(byte* data, size_t sizeInBytes)
	{
		ErrorIf(mCurrent + sizeInBytes > mData + mSize, "Buffer Overflow Read");
		memcpy(data, mCurrent, sizeInBytes);
		mCurrent += sizeInBytes;
		return sizeInBytes;
	}

	size_t ByteBufferBlock::Write(byte* data, size_t sizeInBytes)
	{
		ErrorIf(mCurrent + sizeInBytes > mData + mSize, "Buffer Overflow Write");
		memcpy(mCurrent, data, sizeInBytes);
		mCurrent += sizeInBytes;
		return sizeInBytes;
	}

	size_t ByteBufferBlock::Size()
	{
		return mSize;
	}

	byte* ByteBufferBlock::GetCurrent()
	{
		return mCurrent;
	}

	size_t ByteBufferBlock::Tell()
	{
		return mCurrent - mData;
	}

	byte* ByteBufferBlock::GetBegin()
	{
		return mData;
	}

	String ByteBuffer::ToString() const
	{
		//Get buffer for text
		size_t bufferSize = GetSize();
		byte* buffer = (byte*)zAllocate(bufferSize + 1);

		//Copy data into buffer
		ExtractInto(buffer, bufferSize);

		//Null terminate
		buffer[bufferSize] = '\0';

		//Copy into string
		String str((cstr)buffer, bufferSize);

		//Free memory
		zDeallocate(buffer);

		return str;
	}

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file Console.cpp
/// Implementation of the Console
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdarg.h>

namespace Zero
{

	ConsoleListener::~ConsoleListener()
	{
		Console::Remove(this);
	};

	Array<ConsoleListener*> ConsoleListeners;

	void Console::PrintVa(Filter::Enum filter, cstr format, va_list args)
	{
		//Get the number of characters needed
		int bufferSize;
		VSPrintfCount(format, args, 1, bufferSize);

		if (bufferSize > 0)
		{
			char* messageBuffer = (char*)alloca((bufferSize + 1) * sizeof(char));
			VSPrintf(messageBuffer, bufferSize, format, args);

			PrintRaw(filter, messageBuffer);
		}
	}

	void Console::Print(Filter::Enum filter, cstr format, ...)
	{
		va_list args;
		va_start(args, format);
		PrintVa(filter, format, args);
		va_end(args);
	}

	void Console::PrintRaw(Filter::Enum filter, cstr messageBuffer)
	{
		forRange(ConsoleListener* listener, ConsoleListeners.all())
			listener->Print(filter, messageBuffer);
	}

	void Console::FlushAll()
	{
		forRange(ConsoleListener* listener, ConsoleListeners.all())
			listener->Flush();
	}

	void Console::Add(ConsoleListener* listener)
	{
		ConsoleListeners.push_back(listener);
	}

	void Console::Remove(ConsoleListener* listener)
	{
		size_t index = ConsoleListeners.findIndex(listener);
		if (index < ConsoleListeners.size())
			ConsoleListeners.eraseAt(index);
	}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Diagnostic.cpp
/// Implementation of the basic debug diagnostic functions.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdarg.h>

namespace Zero
{

	const int cDebugBufferLength = 1024;

	bool DefaultErrorHandler(ErrorSignaler::ErrorData& errorData)
	{
		char buffer[cDebugBufferLength];
		SPrintf(buffer, cDebugBufferLength, "%s(%d) : %s %s\n", errorData.File,
			errorData.Line, errorData.Message, errorData.Expression);
		Console::Print(Filter::ErrorFilter, buffer);
		return true;
	}

	ErrorSignaler::ErrorHandler ErrorSignaler::activeErrorHandler = DefaultErrorHandler;

	bool ErrorSignaler::SignalError(SignalErrorType signalType, cstr exp,
		cstr file, int line,
		cstr msgFormat, ...)
	{
		ErrorData errorData;
		errorData.Line = line;
		errorData.File = file;
		errorData.Expression = exp;
		errorData.ErrorType = signalType;
		errorData.Message = NULL;

		if (msgFormat != NULL)
		{
			va_list args;
			va_start(args, msgFormat);
			//Get the number of characters needed for message
			int bufferSize;
			VSPrintfCount(msgFormat, args, 1, bufferSize);

			char* messageBuffer = (char*)alloca((bufferSize + 1)*sizeof(char));
			VSPrintf(messageBuffer, bufferSize + 1, msgFormat, args);
			va_end(args);
			errorData.Message = messageBuffer;
			return (*activeErrorHandler)(errorData);
		}
		else
		{
			return (*activeErrorHandler)(errorData);
		}
	}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Block.cpp
/// Implementation of the block memory manger and allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	namespace Memory
	{

		byte Block::BucketLookUp[cMaxBlockSize + 1];
		bool Block::SizeTableInitialized = false;

		size_t Block::BlockSizes[cBlockCount] =
		{
			16,//[0]
			32,//[1]
			64,//[2]
			96,//[3]
			128,//[4]
			160,//[5]
			192,//[6]
			224,//[7]
			256,//[8]
			320,//[9]
			384,//[10]
			448,//[11]
			512,//[12]
			640,//[13]
		};

		Block::Block(StringRange name, Graph* parent)
			:Graph(name, parent)
		{
			for (size_t i = 0; i<cBlockCount; ++i)
				mBlockArray[i] = NULL;

			if (!SizeTableInitialized)
			{
				size_t currentBlock = 0;
				for (size_t i = 0; i<cMaxBlockSize + 1; ++i)
				{
					if (i>BlockSizes[currentBlock])
						++currentBlock;

					BucketLookUp[i] = (byte)currentBlock;
				}

				SizeTableInitialized = true;
			}
		}

		Block::~Block()
		{
			CleanUp();
		}

		MemPtr Block::Allocate(size_t numberOfBytes)
		{
			AddAllocation(numberOfBytes);

			//Determine what bucket to use
			ErrorIf(numberOfBytes > cMaxBlockSize, "Size is larger than max block size. "
				"This allocator can only allocate small objects");

			size_t bucketIndex = BucketLookUp[numberOfBytes];

			return PopOnFreeList(bucketIndex);
		}

		Block::FreeBlock* Block::PopOnFreeList(size_t blockIndex)
		{
			if (mBlockArray[blockIndex] == NULL)
				AllocateBlockPage(blockIndex);

			FreeBlock* block = mBlockArray[blockIndex];
			mBlockArray[blockIndex] = block->NextBlock;

			return block;
		}

		void Block::Deallocate(MemPtr ptr, size_t numberOfBytes)
		{
			RemoveAllocation(numberOfBytes);

			//Determine what bucket to use
			ErrorIf(numberOfBytes > cMaxBlockSize, "Size is larger than max block size. "
				"This allocator can only allocate small objects");

			size_t bucketIndex = BucketLookUp[numberOfBytes];
			PushFreeBlock(bucketIndex, (FreeBlock*)ptr);
		}

		void Block::PushFreeBlock(size_t blockIndex, FreeBlock* block)
		{
			block->NextBlock = mBlockArray[blockIndex];
			mBlockArray[blockIndex] = block;
		}

		void Block::AllocateBlockPage(size_t blockIndex)
		{
			size_t blockSize = BlockSizes[blockIndex];
			size_t blocksOnPage = cPageSize / blockSize;

			byte* memoryPage = (byte*)zAllocate(cPageSize);
			DeltaDedicated(cPageSize);

			for (size_t i = 0; i<blocksOnPage; ++i)
				PushFreeBlock(blockIndex, (FreeBlock*)(memoryPage + blockSize*i));

			mPageBlocks.push_back(memoryPage);
		}

		void Block::Print(size_t tabs, size_t flags)
		{
			PrintHelper(tabs, flags, "Block");
		}

		void Block::CleanUp()
		{
			Array<MemPtr>::range blocksToFree = mPageBlocks.all();
			while (!blocksToFree.empty())
			{
				zDeallocate(blocksToFree.front());
				blocksToFree.popFront();
			}
			mPageBlocks.clear();
		}

	}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Graph.cpp
/// Implementation of the Memory Graph.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>

#ifdef UseMemoryDebugger
#include "Allocations.hpp"
#endif

namespace Zero
{

	void* zAllocate(size_t numberOfBytes)
	{
#ifdef UseMemoryDebugger
		return DebugAllocate(numberOfBytes, AllocationType_Direct, 4);
#else
		return malloc(numberOfBytes);
#endif
	}

	void zDeallocate(void* ptr)
	{
#ifdef UseMemoryDebugger
		DebugDeallocate(ptr, AllocationType_Direct);
#else
		return free(ptr);
#endif
	}

	const uint cStaticMemoryBufferSize = 5000;
	byte StaticMemoryGraphBuffer[cStaticMemoryBufferSize];
	byte* BufferLocation = StaticMemoryGraphBuffer;

	MemPtr zStaticAllocate(size_t size)
	{
		//Static Memory graph nodes and other static objects
		//are allocated from a fixed size buffer this allows them to have controlled 
		//or optional initialization and prevents them from showing up in leaks
		ErrorIf(BufferLocation >= StaticMemoryGraphBuffer + cStaticMemoryBufferSize,
			"Allocated too many memory graph objects. Increase cStaticMemoryBufferSize.");
		byte* current = BufferLocation;
		BufferLocation += size;
		//DebugPrint("Max Static Memory %d\n", uint(BufferLocation - StaticMemoryGraphBuffer));
		return current;
	}

	namespace Memory
	{
		//------------------------------------------------------------------------ Stats
		Stats::Stats()
			: Allocations(0),
			Active(0),
			BytesAllocated(0),
			BytesDedicated(0),
			PeakAllocated(0)
		{
		}

#define VisitByName(name) vistor(#name, name)

		template<typename Vistor>
		void Stats::Visit(Vistor& vistor, size_t flags)
		{
			if (flags & ShowActive)
				VisitByName(Active);

			if (flags & ShowCount)
				VisitByName(Allocations);

			if (flags & ShowBytes)
				VisitByName(BytesAllocated);

			if (flags & ShowDedicated)
				VisitByName(BytesDedicated);

			if (flags & ShowPeak)
				VisitByName(PeakAllocated);
		}

#undef VisitByName

		void Stats::Accumulate(const Stats& right)
		{
			Allocations += right.Allocations;
			Active += right.Active;
			BytesAllocated += right.BytesAllocated;
			BytesDedicated += right.BytesDedicated;
			PeakAllocated += right.PeakAllocated;
		}

		Root* Root::RootGraph = nullptr;
		Heap* Root::GloblHeap = nullptr;
		Heap* Root::StaticHeap = nullptr;

		void Shutdown()
		{
			GetRoot()->CleanUp();
		}

		void Root::Shutdown()
		{
			//Only delete the root
			//the root graph node will delete all child graph
			//nodes and clean up memory.
			if (RootGraph != nullptr)
			{
				delete RootGraph;
				RootGraph = nullptr;
			}
		}

		void Root::Initialize()
		{
#ifdef UseMemoryDebugger
			InitializeMemory();
#endif

			if (RootGraph == NULL)
			{
				RootGraph = new Root("Root", NULL);
				StaticHeap = new Heap("Static", RootGraph);
				GloblHeap = new Heap("Global", RootGraph);
			}
		}

		Root* GetRoot()
		{
			Root::Initialize();
			return Root::RootGraph;
		}

		Heap* GetGlobalHeap()
		{
			Root::Initialize();
			return Root::GloblHeap;
		}

		Heap* GetStaticHeap()
		{
			Root::Initialize();
			return Root::StaticHeap;
		}

		const size_t maxTabs = 10;
		const size_t tabSize = 2;

		void Root::PrintAll()
		{
			if (RootGraph)
				Root::RootGraph->PrintGraph(Stats::ShowBytes | Stats::ShowTotal | Stats::ShowActive);
		}

		class VistPrinter
		{
		public:
			void operator()(cstr /*name*/, MemCounterType var)
			{
				DebugPrint("%16u", var);
			}
		};

		class VistNamePrinter
		{
		public:
			void operator()(cstr name, MemCounterType /*var*/)
			{
				DebugPrint("%16s", name);
			}
		};

		Graph::Graph(StringRange name, Graph* parent)
			: Name(name),
			mParent(parent)
		{
			if (parent != NULL)
				parent->Children.push_back(this);
		}

		void Graph::PrintHeader(size_t flags)
		{
			//DebugPrint("%-*s", maxTabs*tabSize, "Name" );

			VistNamePrinter p;

			if (flags & Stats::ShowLocal)
				mData.Visit(p, flags);

			if (flags & Stats::ShowTotal)
				mData.Visit(p, flags);

			DebugPrint("\n");
		}

		void Graph::CleanUp()
		{
			InListBaseLink<Graph>::range sub = Children.all();
			while (!sub.empty())
			{
				sub.front().CleanUp();
				sub.popFront();
			}
		}

		void Graph::PrintHelper(size_t tabs, size_t flags, cstr /*name*/)
		{
			size_t tabWidth = tabs * tabSize;
			size_t nameWidth = (maxTabs - tabs) * tabSize;

			Stats total;
			this->Compute(total);

			DebugPrint("%*s%-*s", tabWidth, "", nameWidth, Name.c_str());
			VistPrinter p;

			if (flags & Stats::ShowLocal)
				mData.Visit(p, flags);

			if (flags & Stats::ShowTotal)
				total.Visit(p, flags);

			DebugPrint("\n");

			InListBaseLink<Graph>::range sub = Children.all();
			while (!sub.empty())
			{
				sub.front().Print(tabs + 1, flags);
				sub.popFront();
			}
		}

		void Graph::Compute(Stats& data)
		{
			data.Accumulate(mData);
			InListBaseLink<Graph>::range sub = Children.all();
			while (!sub.empty())
			{
				sub.front().Compute(data);
				sub.popFront();
			}
		}

		void Graph::PrintGraph(size_t flags)
		{
			PrintHeader(flags);
			Print(0, flags);
		}

		void Graph::Print(size_t tabs, size_t flags)
		{
			PrintHelper(tabs, flags, "Main");
		};

		Graph::~Graph()
		{
			DeleteObjectsIn(Children);
		}

		Heap* GetNamedHeap(cstr name)
		{
			Root::Initialize();

			StringTokenRange tokens(name, '.');
			Graph* current = Root::RootGraph;
			Graph* parent = NULL;
			StringRange token = StringRange(name);
			while (!tokens.empty() && current != NULL)
			{
				parent = current;
				current = NULL;

				InListBaseLink<Graph>::range managers = parent->Children.all();

				token = tokens.front();
				while (!managers.empty())
				{
					if (managers.front().Name == token)
						current = &managers.front();
					managers.popFront();
				}

				if (current == NULL)
					current = new Heap(token, parent);

				tokens.popFront();
			}

			return (Heap*)current;
		}

	}//namespace Memory

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Heap.cpp
/// Implementation of the Heap Allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	namespace Memory
	{

		//------------------------------------------------------------------------- Heap
		Heap::Heap(StringRange name, Graph* parent)
			: Graph(name, parent)
		{
			//
		}

		MemPtr Heap::Allocate(size_t numberOfBytes)
		{
			AddAllocation(numberOfBytes);
			MemPtr mem = zAllocate(numberOfBytes);
			return mem;
		}

		void Heap::Deallocate(MemPtr ptr, size_t numberOfBytes)
		{
			RemoveAllocation(numberOfBytes);
			zDeallocate(ptr);
		}

		void Heap::Print(size_t tabs, size_t flags)
		{
			PrintHelper(tabs, flags, "Heap");
		}

	}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Pool.cpp
/// Implementation of the pool memory manger and allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	namespace Memory
	{

		Pool::Pool(StringRange name, Graph* parent, size_t blockSize, size_t blocksPerPage)
			:Graph(name, parent)
		{
			//ErrorIf(parent == NULL,"Memory pool needs a parent node "
			//                       "otherwise it will not be deallocated.");
			mNextFreeBlock = NULL;
			mBlockSize = blockSize;
			mBlocksPerPage = blocksPerPage;
			mPageSize = blockSize*blocksPerPage;
		}

		void Pool::AllocatePage()
		{
			//Allocate a new page of memory and 
			//divide it into blocks that are 
			//each placed on the free list.
			DeltaDedicated(mPageSize);
			byte* memoryPage = (byte*)zAllocate(mPageSize);
			mPages.push_back(memoryPage);
			for (unsigned block = 0; block<mBlocksPerPage; ++block)
				PushOnFreeList(memoryPage + mBlockSize*block);
		}

		void Pool::CleanUp()
		{
			//ErrorIf(mData.BytesAllocated!=0, "Failed to release all memory from pool %s", Name.c_str());
			//Deallocate each page
			for (unsigned i = 0; i<mPages.size(); ++i)
				zDeallocate(mPages[i]);//mPageSize
			mPages.deallocate();
		}

		Pool::~Pool()
		{
			CleanUp();
		}

		MemPtr Pool::Allocate(size_t numberOfBytes)
		{
			//Allocate memory by pop a block off the free list.
			ErrorIf(numberOfBytes > mBlockSize, "Allocation is large than block size.");
			AddAllocation(mBlockSize);
			return PopOnFreeList();
		}

		void Pool::Deallocate(MemPtr ptr, size_t /*numberOfBytes*/)
		{
			//Deallocate memory by push a block on the free list.
			RemoveAllocation(mBlockSize);
			PushOnFreeList(ptr);
		}

		MemPtr Pool::PopOnFreeList()
		{
			//No blocks left allocate a new page.
			if (mNextFreeBlock == NULL)
				AllocatePage();

			//Pop the block
			FreeBlock* block = (FreeBlock*)mNextFreeBlock;
			mNextFreeBlock = block->NextBlock;
			return block;
		}

		void Pool::PushOnFreeList(MemPtr ptr)
		{
			//Push the block
			FreeBlock* block = (FreeBlock*)ptr;
			block->NextBlock = mNextFreeBlock;
			mNextFreeBlock = block;
		}

		void Pool::Print(size_t tabs, size_t flags)
		{
			PrintHelper(tabs, flags, "Pool");
		}

	}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Stack.cpp
/// Implementation of the Stack memory allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	namespace Memory
	{

		Stack::Stack(StringRange name, Graph* parent, size_t stackSize, size_t maxEntries)
			:Graph(name, parent)
		{
			mStackSize = stackSize;
			mMaxEntries = maxEntries;

			if (StackDebug)
			{
				mEntries.reserve(maxEntries);
			}

			mStackHeader = (byte*)zAllocate(mStackSize);
			mStackIndex = 0;
			mMaxSizeReached = 0;
		}

		Stack::~Stack()
		{
			CleanUp();
		}

		void Stack::Print(size_t tabs, size_t flags)
		{
			PrintHelper(tabs, flags, "Stack");
		}

		MemPtr Stack::Allocate(size_t numberOfBytes)
		{
			AddAllocation(numberOfBytes);

			if (StackDebug)
			{
				ErrorIf(mEntries.size() == mMaxEntries, "Maximun number of stack entries reached."
					"Expand the max entries.");

				ErrorIf(mStackIndex + numberOfBytes > mStackSize, "All memory used in stack."
					"Expand the starting size.");
			}

			byte* curHead = mStackHeader + mStackIndex;
			mStackIndex += numberOfBytes;

			if (StackDebug)
			{
				if (mMaxSizeReached < mStackIndex)
					mMaxSizeReached = mStackIndex;

				mEntries.push_back(Entry(curHead, numberOfBytes));
			}

			return curHead;
		}

		void Stack::Deallocate(MemPtr ptr, size_t numberOfBytes)
		{
			if (StackDebug)
			{
				Entry& entry = mEntries.back();
				ErrorIf(entry.Ptr != ptr, "Stack deallocation out of order. Stack items"
					" must be deleted in proper stack order, first in last out.");
				ErrorIf(entry.Size != numberOfBytes, "Bad sized passed to deallocate.");
				mEntries.pop_back();
			}

			mStackIndex -= numberOfBytes;
		}

		void Stack::CleanUp()
		{
			zDeallocate(mStackHeader);
		}

	}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Regex.cpp
/// Implementation of the Regex class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	// Default Constructor
	Regex::Regex()
	{

	}

	// Constructor
	Regex::Regex(StringRange regexStr, RegexFlavor::Enum flavor, bool caseSensitive)
	{

	}

	// Copy constructor
	Regex::Regex(const Regex& source)
	{

	}

	// Destructor
	Regex::~Regex()
	{

	}

	// Assignment operator
	Regex& Regex::operator=(const Regex& source)
	{
		return *this;
	}

	// Validate the regular expression
	bool Regex::Validate(StringRange regexStr, RegexFlavor::Enum flavor, bool caseSensitive)
	{
		return true;
	}

	// Search a given string and return matches
	Matches Regex::Search(StringRange text)
	{
		return Matches();
	}

	// Replace all matches in a given string
	String Regex::Replace(StringRange source, StringRange replaceWith)
	{
		return String();
	}

	// Escape a string so that it can be used directly in a regex, typically for finding exactly that string
	String Regex::Escape(StringRange input, EscapeMode::Enum mode, RegexFlavor::Enum flavor)
	{
		return String();
	}

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file CharacterTraits.cpp
/// Used to convert strings into values.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <ctype.h>

namespace Zero
{

	const uint CharacterTableSize = 128;
	typedef int(*ControlFunction)(int c);

	class CharacterTable
	{
	public:
		CharacterTable()
		{
			// clear all states to zero
			for (uint i = 0; i<CharacterTableSize; ++i)
				CharacterTrait[i] = 0;

			// fill out the state bits
			Annotate(isgraph, CharacterBits::Graphical);
			Annotate(isalpha, CharacterBits::Alpha);
			Annotate(isdigit, CharacterBits::Number);
			Annotate(isspace, CharacterBits::WhiteSpace);
			Annotate(islower, CharacterBits::Lower);
			Annotate(ispunct, CharacterBits::Symbol);
			Annotate(iscntrl, CharacterBits::Control);
		}

		// Get the character state
		int GetTraits(int c)
		{
			if (c >= 0 && c <128)
				return CharacterTrait[c];
			return 0;
		}

	private:
		void Annotate(ControlFunction c, u32 bit)
		{
			for (uint i = 0; i<CharacterTableSize; ++i)
			{
				if ((*c)((int)i))
				{
					CharacterTrait[i] |= bit;
				}
			}
		}

		char CharacterTrait[CharacterTableSize];
	};

	CharacterTable t;
	int IsSpace(int c){ return t.GetTraits(c) & CharacterBits::WhiteSpace; }
	int IsGraph(int c){ return t.GetTraits(c) & CharacterBits::Graphical; }
	int IsGraphOrSpace(int c){ return t.GetTraits(c) & (CharacterBits::Graphical | CharacterBits::WhiteSpace); }
	int IsAlpha(int c){ return t.GetTraits(c) & CharacterBits::Alpha; }
	int IsDigit(int c){ return t.GetTraits(c) & CharacterBits::Number; }
	int IsNumber(int c){ return t.GetTraits(c) & CharacterBits::Number; }
	int IsAlphaNumeric(int c){ return t.GetTraits(c) & (CharacterBits::Alpha | CharacterBits::Number); }
	int IsLower(int c){ return t.GetTraits(c) & CharacterBits::Lower; }
	int IsUpper(int c){ return !(t.GetTraits(c) & CharacterBits::Lower); }
	int IsSymbol(int c){ return t.GetTraits(c) & CharacterBits::Symbol; }
	int IsControl(int c){ return t.GetTraits(c) & CharacterBits::Control; }
	int GetTrait(int c){ return t.GetTraits(c); }
	int ToLower(int c){ return tolower(c); }
	int ToUpper(int c){ return toupper(c); }

};
///////////////////////////////////////////////////////////////////////////////
///
/// \file String.cpp
/// Implementation of the referenced string class.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	size_t HashString(const char* str, size_t l)
	{
		size_t h = l;
		// if string is too long, don't hash all its chars
		size_t step = (l >> 5) + 1;
		size_t l1;
		for (l1 = l; l1 >= step; l1 -= step)  /* compute hash */
			h = h ^ ((h << 5) + (h >> 2) + byte(str[l1 - 1]));
		return h;
	}

	bool CaseSensitiveCompare(char a, char b)
	{
		return a == b;
	}

	bool CaseInsensitiveCompare(char a, char b)
	{
		return tolower(a) == tolower(b);
	}

	String::String()
	{
		initializeToDefault();
	}

	void String::initializeToDefault()
	{
		static StringNode node = { 1, 0, 0, { 0 } };
		assign(&node);
	}

	void String::assign(const_pointer data, size_type size)
	{
		StringNode* node = allocateNode(size);
		memcpy(node->Data, data, size);
		node->Data[size] = '\0';
		node->HashCode = HashString(data, size);
		//Assign value
		mNode = node;
	}

	void String::assign(StringNode* node)
	{
		mNode = node;
		addRef();
	}

	void String::StringNode::addRef()
	{
		AtomicIncrement(&RefCount);
	}

	void String::StringNode::release()
	{
		AtomicDecrement(&RefCount);
		if (RefCount == 0)
			zDeallocate(this);
	}

	bool String::StringNode::isEqual(StringNode* l, StringNode* r)
	{
		if (!(l == r))
		{
			if (l->Size == r->Size &&
				l->HashCode == r->HashCode &&
				strcmp(l->Data, r->Data) == 0)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return true;
		}
	}

	void String::addRef()
	{
		mNode->addRef();
	}

	void String::release()
	{
		if (mNode)
			mNode->release();
	}

	String::StringNode* String::allocateNode(size_type size)
	{
		const size_type nodeSize =
			sizeof(StringNode) //size of the string node
			- sizeof(value_type);//remove the extra

		//size of buffer is string size plus once extra buffer
		//for null terminator '\0'
		const size_type bufferSize = size + sizeof(value_type);

		//Make new string node
		StringNode* newNode = (StringNode*)zAllocate(nodeSize + bufferSize);
		newNode->RefCount = 1;
		newNode->Size = size;
		newNode->HashCode = 0;

		return newNode;
	}

	//--------------------------------------------------------------- String Helpers
	String String::Format(cstr format, ...)
	{
		va_list va;
		va_start(va, format);
		String result = String::FormatArgs(format, va);
		va_end(va);
		return result;
	}

	String String::FormatArgs(cstr format, va_list args)
	{
		//Get the number of characters needed for message
		int bufferSize;
		VSPrintfCount(format, args, 1, bufferSize);
		char* stringBuffer = (char*)alloca((bufferSize + 1)*sizeof(char));
		stringBuffer[bufferSize] = '\0';
		VSPrintf(stringBuffer, bufferSize, format, args);
		return String(stringBuffer);
	}

	String String::ReplaceSub(StringRange source, StringRange text,
		size_type start, size_type end)
	{
		size_type sizeToRemove = end - start;
		size_type sizeToAdd = text.size();

		//time to build the new string
		size_type newSize = source.size() - sizeToRemove + sizeToAdd;

		char* buffer = (char*)alloca(newSize + 1);//one for the null terminator
		char* bufferPos = buffer;
		char* bufferEnd = bufferPos + newSize + 1;

		//Copy over the front if there is anything to copy
		if (start > 0)
		{
			CStringCopy(bufferPos, bufferEnd - bufferPos, source.data(), start);
			bufferPos += start;
		}

		if (sizeToAdd != 0)
		{
			CStringCopy(bufferPos, bufferEnd - bufferPos, text.data(), sizeToAdd);
			bufferPos += sizeToAdd;
		}

		size_type sizeOfEndText = source.size() - end;
		if (sizeOfEndText)
		{
			CStringCopy(bufferPos, bufferEnd - bufferPos, source.data() + end,
				sizeOfEndText);
			bufferPos += sizeOfEndText;
		}

		bufferPos[0] = '\0';

		return String(buffer);
	}

	//----------------------------------------------------------- String Token Range
	StringTokenRange::StringTokenRange(StringRange string, char delim)
		: internalRange(string)
	{
		mDelim = delim;
		popFront();
	}

	StringRange StringTokenRange::front()
	{
		return curRange;
	}

	void StringTokenRange::popFront()
	{
		cstr start = internalRange.begin;
		cstr current = start;

		//scan until delim or end
		while (current != internalRange.end && *current != mDelim)
			++current;

		cstr end = current;
		while (current != internalRange.end && *current == mDelim)
		{
			++current;
		}

		curRange = StringRange(start, end);
		internalRange.begin = current;
	}

	bool StringTokenRange::empty()
	{
		return curRange.empty() && internalRange.empty();
	}

	//------------------------------------------------------------- Global Functions
	String ToLower(StringParam str)
	{
		size_t size = str.size();
		char* buffer = (char*)alloca(size + 1);

		for (size_t i = 0; i < str.size(); ++i)
		{
			buffer[i] = (char)tolower(str[i]);
		}
		buffer[size] = '\0';

		return buffer;
	}

	size_t GetNextWhitespace(StringRange input)
	{
		for (size_t i = 0; i < input.size(); ++i)
		{
			if (isspace(input[i]))
				return i;
		}
		return input.size();
	}

	String WordWrap(StringRange input, size_t maxLineLength)
	{
		StringBuilder builder;

		size_t lineLength = 0;

		while (!input.empty())
		{
			char c = input.front();
			input.popFront();

			++lineLength;

			if (c == '\n' || c == '\r')
			{
				lineLength = 0;
			}
			else if (!isspace(c))
			{
				size_t wordLength = GetNextWhitespace(input);
				bool isWordShort = wordLength < maxLineLength;
				bool doesWordMakeLineTooLong = lineLength + wordLength >= maxLineLength;
				if (isWordShort && doesWordMakeLineTooLong)
				{
					lineLength = 0;
					builder.Append("\n");
				}
			}

			if (lineLength >= maxLineLength)
			{
				lineLength = 0;
				builder.Append("\n");
			}

			builder.Append(c);
		}

		return builder.ToString();
	}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file String.cpp
/// Implementation of the StringBuilder and ByteBuffer.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdarg.h>

namespace Zero
{
	char* AppendRange(char* bufferPos, char* bufferEnd, StringRange& b)
	{
		CStringCopy(bufferPos, bufferEnd - bufferPos, b.begin, b.size());
		bufferPos += b.size();
		return bufferPos;
	}

	String BuildString(StringRange a, StringRange b)
	{
		//+1 extra for null terminator
		const size_t bufferSize = a.size() + b.size() + 1;
		char* buffer = (char*)alloca(bufferSize);
		char* bufferPos = buffer;
		char* bufferEnd = buffer + bufferSize;

		bufferPos = AppendRange(bufferPos, bufferEnd, a);
		bufferPos = AppendRange(bufferPos, bufferEnd, b);
		*bufferPos = '\0';

		return String(buffer);
	}

	String BuildString(StringRange a, StringRange b, StringRange c)
	{
		StringRange* strings[] = { &a, &b, &c };
		return BuildString(strings, 3);
	}

	String BuildString(StringRange a, StringRange b, StringRange c, StringRange d)
	{
		StringRange* strings[] = { &a, &b, &c, &d };
		return BuildString(strings, 4);
	}

	String BuildString(StringRange a, StringRange b, StringRange c, StringRange d, StringRange e)
	{
		StringRange* strings[] = { &a, &b, &c, &d, &e };
		return BuildString(strings, 5);
	}

	String BuildString(StringRange** ranges, uint count)
	{
		//+1 extra for null terminator
		size_t bufferSize = 1;
		for (size_t i = 0; i<count; ++i)
			bufferSize += ranges[i]->size();

		char* buffer = (char*)alloca(bufferSize);
		char* bufferPos = buffer;
		char* bufferEnd = buffer + bufferSize;

		for (size_t i = 0; i<count; ++i)
			bufferPos = AppendRange(bufferPos, bufferEnd, *ranges[i]);

		*bufferPos = '\0';

		return String(buffer);
	}

	String StringJoin(Array<String>& strings, StringParam joinToken)
	{
		//join together all of the strings with the join token in between
		if (strings.size() == 0)
			return String();

		if (strings.size() == 1)
			return strings[0];

		StringBuilder builder;
		builder.Append(strings[0]);
		for (uint i = 1; i < strings.size(); ++i)
		{
			builder.Append(joinToken);
			builder.Append(strings[i]);
		}
		return builder.ToString();
	}

	void StringBuilder::Append(StringRange range)
	{
		ByteBuffer::Append((byteType*)range.data(), range.size());
	}

	void StringBuilder::Append(char character)
	{
		ByteBuffer::Append((const byte*)&character, sizeof(character));
	}

	char& StringBuilder::operator[](size_t index)
	{
		ErrorIf(index >= mTotalSize, "Index is out of bounds");

		size_t blockIndex = index / mBlockSize;

		byteType* block = mBlocks[blockIndex];

		ErrorIf(block == NULL, "The block should be filled out");

		return (char&)block[index %  mBlockSize];
	}

	void StringBuilder::Repeat(size_t count, StringParam str)
	{
		for (size_t i = 0; i < count; ++i)
			Append(str);
	}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file StringConversion.cpp
/// Used to convert strings into values.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>

namespace Zero
{

	u64 ReadHexString(StringRange range)
	{
		size_t size = range.size();
		u64 result = 0;
		for (size_t i = 0; i < size; ++i)
		{
			// process the string in reverse
			char c = range[size - i - 1];
			u64 val = 0;
			if ('0' <= c && c <= '9')
				val = c - '0';
			else if ('a' <= c && c <= 'f')
				val = c - 'a' + 10;
			else if ('A' <= c && c <= 'F')
				val = c - 'A' + 10;
			result += val << i * 4;
		}
		return result;
	}

	uint WriteToHexSize(char* buffer, uint bufferSize, uint places, u64 integerValue)
	{
		if (bufferSize < places + 1)
			return 0;

		for (uint i = 0; i < places; ++i)
		{
			uint indexVal = uint(integerValue % 16);
			uint charVal = 0;
			if (indexVal <= 9)
				charVal = indexVal + '0';
			else if (10 <= indexVal && indexVal <= 16)
				charVal = indexVal + ('a' - 10);
			buffer[places - 1 - i] = (char)charVal;
			integerValue = integerValue >> 4;
		}
		buffer[places] = '\0';
		return places;
	}

	uint WriteToHex(char* buffer, uint bufferSize, u64 integerValue)
	{
		return WriteToHexSize(buffer, bufferSize, 16, integerValue);
	}

	uint WriteToHex(char* buffer, uint bufferSize, u32 integerValue)
	{
		return WriteToHexSize(buffer, bufferSize, 8, (u64)integerValue);
	}

	//Max 4294967295
	const uint cMaxIntSize = 12;

	void ReverseString(char* start, char* end)
	{
		--end;
		while (start<end)
		{
			Swap(*start, *end);
			++start;
			--end;
		}
	}

	String ReverseString(StringParam string)
	{
		size_t size = string.size();

		// Allocate a buffer on the stack
		char* reverseString = (char*)alloca(size * sizeof(char));

		// Null terminate the buffer
		reverseString[size] = '\0';

		// Copy the string into the reverse string
		memcpy(reverseString, (void*)string.data(), size * sizeof(char));

		// Reverse the string
		ReverseString(reverseString, reverseString + size);

		return String(reverseString);
	}

	uint ToString(char* buffer, uint bufferSize, s64 value)
	{
		if (bufferSize < cMaxIntSize)
			return 0;

		bool valueIsNegative = false;
		if (value < 0)
		{
			value = -value;
			valueIsNegative = true;
		}

		uint index = 0;
		do
		{
			char c = value % 10 + '0';
			buffer[index] = c;
			++index;
			value /= 10;
		} while (value != 0);

		if (valueIsNegative)
		{
			buffer[index] = '-';
			++index;
		}

		buffer[index] = '\0';
		ReverseString(buffer, buffer + index);
		return index;
	}

	void ToValue(StringRange range, float& value)
	{
		value = (float)atof(range.begin);
	}

	void ToValue(StringRange range, double& value)
	{
		value = atof(range.begin);
	}

	void ToValue(StringRange range, int& value)
	{
		value = atoi(range.begin);
	}

	void ToValue(StringRange range, unsigned int& value)
	{
		value = strtoul(range.begin, NULL, 0);
	}

	void ToValue(StringRange range, u64& value)
	{
		value = ReadHexString(range);
	}

	void ToValue(StringRange range, s64& value)
	{
#ifdef _MSC_VER
		value = _strtoui64(range.begin, nullptr, 10);
#else
		value = strtoull(range.begin, nullptr, 10);
#endif
	}

	void ToValue(StringRange range, String& value)
	{
		value = range;
	}

	void ToValue(StringRange token, StringRange& range)
	{
		range = token;
	}

	bool IsCharacter(char c, cstr search)
	{
		while (*search != 0)
		{
			if (c == *search)
				return true;
			++search;
		}
		return false;
	}

	void ToValue(StringRange token, bool& value)
	{
		//true, True, on , On , 1
		if (IsCharacter(token.front(), "tToO1"))
			value = true;
		else
			value = false;
	}

	uint ToBuffer(char* buffer, uint bufferSize, u64 value)
	{
		ErrorIf(bufferSize < 16, "Buffer is not large enought for hex value.");
		if (bufferSize > 16)
			return WriteToHex(buffer, bufferSize, value);
		else
			return 0;
	}

	uint ToBuffer(char* buffer, uint bufferSize, int value)
	{
		return ToString(buffer, bufferSize, value);
	}

	uint ToBuffer(char* buffer, uint bufferSize, unsigned int value)
	{
		return ToString(buffer, bufferSize, value);
	}

	uint ToBuffer(char* buffer, uint bufferSize, float value)
	{
		return SPrintf(buffer, bufferSize, "%g", value);
	}

	uint ToBuffer(char* buffer, uint bufferSize, double value)
	{
		return SPrintf(buffer, bufferSize, "%f", value);
	}

#define TextTrue "true"
#define  TextFalse  "false"

	uint ToBuffer(char* buffer, uint bufferSize, bool value)
	{
		if (value)
		{
			StrCpy(buffer, bufferSize, TextTrue);
			return sizeof(TextTrue) - 1;
		}
		else
		{
			StrCpy(buffer, bufferSize, TextFalse);
			return sizeof(TextFalse) - 1;
		}
	}

	//Basic conversion function (input must be UTF-16/2) DestAscii must be unicodeLength +1
	void ConvertUnicodeToAscii(char* destAscii, uint bufferSize,
		const wchar_t* unicodeData, size_t unicodeLength)
	{
		if (bufferSize < unicodeLength + 1)
		{
			ErrorIf(true, "Ascii Buffer is not large enough.");
			destAscii[0] = '\0';
		}
		else
		{
			for (uint i = 0; i<unicodeLength; ++i)
			{
				if (unicodeData[i] > 128)
				{
					//Can not be display in ascii
					destAscii[i] = '?';
				}
				else
				{
					destAscii[i] = (char)unicodeData[i];
				}
			}
			destAscii[unicodeLength] = '\0';
		}

	}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file StringUtility.cpp
///
/// 
/// Authors: Chris Peters
/// Copyright 2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#include <ctype.h>

namespace Zero
{

	//---------------------------------------------------------------------- Strings
	bool CaseInsensitiveStringLess(String a, String b)
	{
		StringRange achars = a.all();
		StringRange bchars = b.all();

		while (!achars.empty() && !bchars.empty())
		{
			char aChar = (char)tolower(achars.front());
			char bChar = (char)tolower(bchars.front());

			if (aChar < bChar)
				return true;

			if (aChar > bChar)
				return false;

			achars.popFront();
			bchars.popFront();
		}

		if (achars.empty() && !bchars.empty())
			return true;

		return false;
	}
	Pair<StringRange, StringRange> SplitOnLast(StringRange input, char delimiter)
	{
		//With empty just return empty String
		if (input.empty())
			return Pair<StringRange, StringRange>(input, input);

		uint size = input.size();

		uint position = input.FindLastOf(delimiter);

		// Delim found return string and empty
		if (position == String::InvalidIndex)
			return Pair<StringRange, StringRange>(input, StringRange());

		if (position == 0)
			return Pair<StringRange, StringRange>(StringRange(), input.sub_string(1, size - 1));

		if (position == size - 1)
			return Pair<StringRange, StringRange>(input.sub_string(0, size - 1), StringRange());

		return Pair<StringRange, StringRange>(input.sub_string(0, position), input.sub_string(position + 1, size - position - 1));

	}

	Pair<StringRange, StringRange> SplitOnFirst(StringRange input, char delimiter)
	{
		StringTokenRange tokenRange(input, delimiter);
		StringRange left = tokenRange.front();
		StringRange right = StringRange(left.end, input.end);
		return Pair<StringRange, StringRange>(left, right);
	}

	StringRange StripBeforeLast(StringRange input, char delimiter)
	{
		Pair<StringRange, StringRange> split = SplitOnLast(input, delimiter);

		// If the delimiter was not found the second will be empty
		if (split.second.empty())
			return input;
		else
			return split.second;
	}

	String JoinStrings(const Array<String>& strings, StringParam delimiter)
	{
		StringBuilder builder;

		for (size_t i = 0; i < strings.size(); ++i)
		{
			const String& string = strings[i];

			builder.Append(string);

			bool isNotLast = (i + 1 != strings.size());

			if (isNotLast)
			{
				builder.Append(delimiter);
			}
		}

		return builder.ToString();
	}

	char OnlyAlphaNumeric(char c)
	{
		if (!isalnum(c))
			return '_';
		else
			return c;
	}

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file ToString.cpp
/// Conversion to and from strings.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	const int cBufferSize = 256;

	String ToString(const int& value)
	{
		char buffer[cBufferSize];
		ToBuffer(buffer, cBufferSize, value);
		return buffer;
	}

	String ToString(const uint& value)
	{
		char buffer[cBufferSize];
		ToBuffer(buffer, cBufferSize, value);
		return buffer;
	}

	String ToString(const float& value)
	{
		char buffer[cBufferSize];
		ToBuffer(buffer, cBufferSize, value);
		return buffer;
	}

	String ToString(const double& value)
	{
		char buffer[cBufferSize];
		ToBuffer(buffer, cBufferSize, value);
		return buffer;
	}

	String ToString(const bool& value)
	{
		char buffer[cBufferSize];
		ToBuffer(buffer, cBufferSize, value);
		return buffer;
	}

	String ToString(const u64& value)
	{
		char buffer[cBufferSize];
		ToBuffer(buffer, cBufferSize, value);
		return buffer;
	}

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file Atomic.cpp
/// Implementation of the atomic functions.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#ifdef _MSC_VER

//MS compiler version

extern "C"
{
	long  __cdecl _InterlockedExchange(long volatile* destination, long value);
	long  __cdecl _InterlockedExchangeAdd(long volatile* destination, long addvalue);

	long  __cdecl _InterlockedIncrement(long volatile* destination);
	long  __cdecl _InterlockedDecrement(long volatile* destination);

	long  __cdecl _InterlockedCompareExchange(long volatile* destination, long exchange, long Comp);
	__int64 __cdecl _InterlockedCompareExchange64(__int64 volatile* destination,
		__int64 exchange, __int64 Comperand);
}

#pragma intrinsic (_InterlockedExchange)
#pragma intrinsic (_InterlockedExchangeAdd)

#pragma intrinsic (_InterlockedIncrement)
#pragma intrinsic (_InterlockedDecrement)

#pragma intrinsic (_InterlockedCompareExchange)
#pragma intrinsic (_InterlockedCompareExchange64)

namespace Zero
{

	s32 AtomicIncrement(volatile s32* number)
	{
		return ::_InterlockedIncrement((volatile long *)number);
	}

	s32 AtomicDecrement(volatile s32* number)
	{
		return ::_InterlockedDecrement((volatile long *)number);
	}

	s32 AtomicAdd(volatile s32* number, s32 valueToAdd)
	{
		return ::_InterlockedExchangeAdd((volatile long *)number, valueToAdd);
	}

	bool AtomicCompareExchange(volatile s32* number, s32 exchange, s32 comparison)
	{
		return ::_InterlockedCompareExchange((volatile long *)number, exchange, comparison) == comparison;
	}

	bool AtomicCompareExchange64(volatile s64* number, s64 exchange, s64 comparison)
	{
		return ::_InterlockedCompareExchange64((volatile __int64 *)number, exchange, comparison) == comparison;
	}

}

#else

namespace Zero
{

	s32 AtomicIncrement(volatile s32* number)
	{
		return __sync_add_and_fetch(number, 1);
	}

	s32 AtomicDecrement(volatile s32* number)
	{
		return __sync_sub_and_fetch(number, 1);
	}

	s32 AtomicAdd(volatile s32* number, s32 valueToAdd)
	{
		return __sync_add_and_fetch(number, valueToAdd);
	}

	bool AtomicCompareExchange(volatile s32* number, s32 exchange, s32 comparison)
	{
		return __sync_bool_compare_and_swap(number, comparison, exchange);
	}

	bool AtomicCompareExchange64(volatile s64* number, s64 exchange, s64 comparison)
	{
		return __sync_bool_compare_and_swap(number, comparison, exchange);
	}

}
#endif
///////////////////////////////////////////////////////////////////////////////
///
/// \file Misc.cpp
/// Miscellaneous functions.
///
/// Authors: 
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	namespace Z
	{
		static u32 gLexicographicMask = 0xffffffff;
		static u64 gLexicographicUpperMask = static_cast<u64>(gLexicographicMask) << 32;
		static u64 gLexicographicLowerMask = static_cast<u64>(gLexicographicMask);
	}//namespace Z

	u64 GetLexicographicId(u32 id1, u32 id2)
	{
		u64 id = 0;

		//put the smaller number in the top 32 bits and the larger in the bottom 16
		if (id1 < id2)
		{
			id |= (static_cast<u64>(id1)& Z::gLexicographicMask) << 32;
			id |= (static_cast<u64>(id2)& Z::gLexicographicMask);
		}
		else
		{
			id |= (static_cast<u64>(id2)& Z::gLexicographicMask) << 32;
			id |= (static_cast<u64>(id1)& Z::gLexicographicMask);
		}

		/*could also do
		u32* start = reinterpret_cast<u32*>(&id);
		if(id1 < id2)
		{
		start[0] = id2;
		start[1] = id1;
		}
		else
		{
		start[0] = id1;
		start[1] = id2;
		}
		although endianess matters, which would only screw up if
		sending a pair id from one machine to another
		*/

		return id;
	}

	void UnPackLexicographicId(u32& id1, u32& id2, u64 pairId)
	{
		id1 = static_cast<u32>(pairId & Z::gLexicographicLowerMask);
		id2 = static_cast<u32>((pairId & Z::gLexicographicUpperMask) >> 32);

		/*could also do
		u32* start = reinterpret_cast<u32*>(&pairId);
		id1 = *start;
		id2 = *(start + 1);*/
	}

	bool IsBigEndian()
	{
		int i = 1;
		byte* lowByte = (byte*)&i;

		return (*lowByte == 0);
	}

}//namespace Zero

// Used for counting printf statement lengths
char gDiscardBuffer[2] = { 0 };

namespace Math
{

	uint BlockVector3::GetSize() const
	{
		return mBlocks.size();
	}

	void BlockVector3::SetSize(uint size)
	{
		mBlocks.resize(size, Vector3::cZero);
	}

	Vector3& BlockVector3::operator[](uint index)
	{
		ErrorIf(index > mBlocks.size(), "Math::BlockVector3 - Subscript out of range.");
		return mBlocks[index];
	}

	Vector3 BlockVector3::operator[](uint index) const
	{
		ErrorIf(index > mBlocks.size(), "Math::BlockVector3 - Subscript out of range.");
		return mBlocks[index];
	}

	real& BlockVector3::GlobalIndex(uint index)
	{
		int blockIndex = index / 3;
		int finalIndex = index % 3;

		return mBlocks[blockIndex][finalIndex];
	}

	void BlockVector3::operator*=(real rhs)
	{
		for (uint i = 0; i < mBlocks.size(); ++i)
			mBlocks[i] *= rhs;
	}

	void BlockVector3::operator+=(const BlockVector3& rhs)
	{
		ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
			"Cannot add two block vectors of different dimensions");

		for (uint i = 0; i < mBlocks.size(); ++i)
			mBlocks[i] += rhs.mBlocks[i];
	}

	void BlockVector3::operator-=(const BlockVector3& rhs)
	{
		ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
			"Cannot subtract two block vectors of different dimensions");

		for (uint i = 0; i < mBlocks.size(); ++i)
			mBlocks[i] -= rhs.mBlocks[i];
	}

	real BlockVector3::Dot(const BlockVector3& rhs) const
	{
		ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
			"Cannot perform the dot product between two block "
			"vectors of different dimensions");

		real result = real(0.0);
		for (uint i = 0; i < mBlocks.size(); ++i)
			result += Math::Dot(mBlocks[i], rhs.mBlocks[i]);
		return result;
	}

	void BlockVector3::Scale(const BlockVector3& rhs, BlockVector3& out) const
	{
		ErrorIf(rhs.mBlocks.size() != mBlocks.size(),
			"Cannot perform vector scale between two block "
			"vectors of different dimensions");

		for (uint i = 0; i < mBlocks.size(); ++i)
			out[i] = mBlocks[i] * rhs[i];
	}

	uint BlockMatrix3::GetSize() const
	{
		return mBlocks.size();
	}

	void BlockMatrix3::SetSize(uint size)
	{
		mBlocks.resize(size);

		Matrix3 zero;
		zero.ZeroOut();
		for (uint i = 0; i < size; ++i)
			mBlocks[i].resize(size, zero);
	}

	Matrix3 BlockMatrix3::operator()(uint row, uint col) const
	{
		ErrorIf(row > mBlocks.size() || col > mBlocks.size(),
			"Math::BlockMatrix3 - Subscript out of range.");

		return mBlocks[row][col];
	}

	Matrix3& BlockMatrix3::operator()(uint row, uint col)
	{
		ErrorIf(row > mBlocks.size() || col > mBlocks.size(),
			"Math::BlockMatrix3 - Subscript out of range.");

		return mBlocks[row][col];
	}

	real& BlockMatrix3::GlobalIndex(uint row, uint col)
	{
		uint size = mBlocks.size() * 3;
		ErrorIf(row > size || col > size,
			"Math::BlockMatrix3 - Subscript out of range.");

		int blockRow = row / 3;
		int blockCol = col / 3;
		int finalRow = row % 3;
		int finalCol = col % 3;
		return mBlocks[blockRow][blockCol](finalRow, finalCol);
	}

	BlockMatrix3 BlockMatrix3::Transposed() const
	{
		uint size = mBlocks.size();
		BlockMatrix3 result;
		result.SetSize(size);
		for (uint j = 0; j < size; ++j)
		{
			for (uint i = 0; i < size; ++i)
			{
				result(i, j) = (*this)(j, i).Transposed();
			}
		}
		return result;
	}

	BlockMatrix3 BlockMatrix3::Transform(const BlockMatrix3& rhs) const
	{
		uint size = mBlocks.size();
		BlockMatrix3 result;
		result.SetSize(size);
		for (uint j = 0; j < size; ++j)
		{
			for (uint i = 0; i < size; ++i)
			{
				for (uint x = 0; x < size; ++x)
				{
					Matrix3 left = (*this)(i, x);
					Matrix3 right = rhs(x, j);
					result(i, j) += left * right;
				}
			}
		}
		return result;
	}

	void BlockMatrix3::Transform(const BlockVector3& rhs, BlockVector3& out) const
	{
		out.SetSize(rhs.GetSize());

		for (uint i = 0; i < mBlocks.size(); ++i)
		{
			const Cells& cell = mBlocks[i];
			Vector3 sum = Vector3::cZero;

			for (uint j = 0; j < cell.size(); ++j)
			{
				Matrix3 m = cell[j];
				Vector3 v = rhs[j];
				sum += Math::Transform(m, v);
			}

			out[i] = sum;
		}
	}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file BoolVector2.cpp
///  Implementation of the BoolVector2 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const BoolVector2 BoolVector2::cZero(false, false);
	const BoolVector2 BoolVector2::cXAxis(true, false);
	const BoolVector2 BoolVector2::cYAxis(false, true);

	BoolVector2::BoolVector2(bool x_, bool y_)
	{
		x = x_;
		y = y_;
	}

	bool& BoolVector2::operator[](uint index)
	{
		ErrorIf(index > 1, "Math::BoolVector2 - Subscript out of range.");
		return array[index];
	}

	bool BoolVector2::operator[](uint index) const
	{
		ErrorIf(index > 1, "Math::BoolVector2 - Subscript out of range.");
		return array[index];
	}

	BoolVector2 BoolVector2::operator!(void) const
	{
		return BoolVector2(!x, !y);
	}

	bool BoolVector2::operator==(BoolVec2Param rhs) const
	{
		return x == rhs.x && y == rhs.y;
	}

	bool BoolVector2::operator!=(BoolVec2Param rhs) const
	{
		return !((*this) == rhs);
	}

	void BoolVector2::Set(bool x_, bool y_)
	{
		x = x_;
		y = y_;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file BoolVector3.cpp
///  Implementation of the BoolVector3 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const BoolVector3 BoolVector3::cZero(false, false, false);
	const BoolVector3 BoolVector3::cXAxis(true, false, false);
	const BoolVector3 BoolVector3::cYAxis(false, true, false);
	const BoolVector3 BoolVector3::cZAxis(false, false, true);

	BoolVector3::BoolVector3(bool x_, bool y_, bool z_)
	{
		x = x_;
		y = y_;
		z = z_;
	}

	bool& BoolVector3::operator[](uint index)
	{
		ErrorIf(index > 2, "Math::BoolVector3 - Subscript out of range.");
		return array[index];
	}

	bool BoolVector3::operator[](uint index) const
	{
		ErrorIf(index > 2, "Math::BoolVector3 - Subscript out of range.");
		return array[index];
	}

	BoolVector3 BoolVector3::operator!(void) const
	{
		return BoolVector3(!x, !y, !z);
	}

	bool BoolVector3::operator==(BoolVec3Param rhs) const
	{
		return x == rhs.x && y == rhs.y && z == rhs.z;
	}

	bool BoolVector3::operator!=(BoolVec3Param rhs) const
	{
		return !((*this) == rhs);
	}

	void BoolVector3::Set(bool x_, bool y_, bool z_)
	{
		x = x_;
		y = y_;
		z = z_;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file BoolVector4.cpp
///  Implementation of the BoolVector4 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const BoolVector4 BoolVector4::cZero(false, false, false, false);
	const BoolVector4 BoolVector4::cXAxis(true, false, false, false);
	const BoolVector4 BoolVector4::cYAxis(false, true, false, false);
	const BoolVector4 BoolVector4::cZAxis(false, false, true, false);
	const BoolVector4 BoolVector4::cWAxis(false, false, false, true);

	BoolVector4::BoolVector4(bool x_, bool y_, bool z_, bool w_)
	{
		x = x_;
		y = y_;
		z = z_;
		w = w_;
	}

	bool& BoolVector4::operator[](uint index)
	{
		ErrorIf(index > 2, "Math::BoolVector4 - Subscript out of range.");
		return array[index];
	}

	bool BoolVector4::operator[](uint index) const
	{
		ErrorIf(index > 2, "Math::BoolVector4 - Subscript out of range.");
		return array[index];
	}

	BoolVector4 BoolVector4::operator!(void) const
	{
		return BoolVector4(!x, !y, !z, !w);
	}

	bool BoolVector4::operator==(BoolVec4Param rhs) const
	{
		return x == rhs.x && y == rhs.y && z == rhs.z && w == rhs.w;
	}

	bool BoolVector4::operator!=(BoolVec4Param rhs) const
	{
		return !((*this) == rhs);
	}

	void BoolVector4::Set(bool x_, bool y_, bool z_, bool w_)
	{
		x = x_;
		y = y_;
		z = z_;
		w = w_;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Curve.cpp
/// Implementation of the Curve class.
///
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	static const Mat4 CatmullBasis = Mat4(Vec4(0, -1, 2, -1) / real(2.0),
		Vec4(2, 0, -5, 3) / real(2.0),
		Vec4(0, 1, 4, -3) / real(2.0),
		Vec4(0, 0, -1, 1) / real(2.0));

	static const Mat4 BSplineBasis = Mat4(Vec4(-1, 3, -3, 1) / real(6.0),
		Vec4(3, -6, 0, 4) / real(6.0),
		Vec4(-3, 3, 3, 1) / real(6.0),
		Vec4(1, 0, 0, 0) / real(6.0));

	//------------------------------------------------------------------------ Curve
	SplineCurve::SplineCurve()
	{
		mCurveType = CurveType::CatmulRom;
		mClosed = false;
	}

	void SplineCurve::AddControlPoint(Vec3Param controlPoint)
	{
		ControlPoints.push_back(controlPoint);
	}

	void SplineCurve::RemovePointAtIndex(uint index)
	{
		if (index >= ControlPoints.size())
			return;

		ControlPoints.eraseAt(index);
	}

	void SplineCurve::AddControlPoints(const Vec3Array& controlPoints)
	{
		ControlPoints.insert(ControlPoints.end(), controlPoints.begin(), controlPoints.end());
	}

	void SplineCurve::SetControlPoints(const Vec3Array& controlPoints)
	{
		ControlPoints = controlPoints;
	}

	void SplineCurve::GetPoints(Vec3Array& results, uint resolution) const
	{
		if (resolution == 0)
			return;

		Vec3Array points;
		GetSmoothPoints(points);
		if (points.size() < 4)
		{
			results = points;
			return;
		}

		//generate the points for the given curve type
		uint curveType = mCurveType;
		if (curveType == CurveType::Linear)
			results = points;
		else if (curveType == CurveType::BSpline)
			GetPoints<BSplinePolicy>(points, results, resolution);
		else if (curveType == CurveType::CatmulRom)
			GetPoints<CatmullRomPolicy>(points, results, resolution);
	}

	void SplineCurve::BakeAdaptive(Vec3Array& results, real error) const
	{
		Vec3Array points;
		GetSmoothPoints(points);
		if (points.size() < 4)
		{
			results = points;
			return;
		}

		//generate the points for the given curve type
		uint curveType = mCurveType;
		if (curveType == CurveType::Linear)
			results = points;
		if (curveType == CurveType::BSpline)
			GetPoints<BSplinePolicy>(points, results, error);
		else if (curveType == CurveType::CatmulRom)
			GetPoints<CatmullRomPolicy>(points, results, error);
	}

	Vec3Array& SplineCurve::GetControlPoints()
	{
		return ControlPoints;
	}

	void SplineCurve::Clear(void)
	{
		ControlPoints.clear();
	}

	bool SplineCurve::GetClosed()
	{
		return mClosed;
	}

	void SplineCurve::SetClosed(bool state)
	{
		mClosed = state;
	}

	uint SplineCurve::GetCurveType()
	{
		return mCurveType;
	}

	void SplineCurve::SetCurveType(uint curveType)
	{
		mCurveType = curveType;
	}

	bool SplineCurve::DistanceSq(Vec3 point, uint resolution, real& distSq) const
	{
		Vec3Array points;
		GetPoints(points, resolution);

		if (points.size() < 2)
			return false;

		real minDistSq1 = Math::PositiveMax(); // smallest distance
		real minDistSq2 = Math::PositiveMax(); // second smallest distance
		int idx1 = 0; // index of the point with the smallest distance
		int idx2 = 0; // index of the point with the second smallest distance

		for (uint i = 0; i < points.size(); ++i)
		{
			float distSq = (points[i] - point).LengthSq();
			if (distSq < minDistSq2)
			{
				minDistSq2 = distSq;
				idx2 = i;
			}
			if (distSq < minDistSq1)
			{
				minDistSq2 = minDistSq1;
				idx2 = idx1;
				minDistSq1 = distSq;
				idx1 = i;
			}
		}

		if (idx1 == 0 && idx2 == 0)
			return false;

		distSq = Math::DistanceToLineSq(points[idx1], points[idx2], point);
		return true;
	}

	void SplineCurve::GetSmoothPoints(Vec3Array& pts) const
	{
		pts = ControlPoints;
		//if we have no points, just do nothing...
		if (pts.size() == 0)
			return;

		//if we have less than 4 points, we can't make a curve,
		//so just switch to linear mode
		uint curveType = mCurveType;
		if (pts.size() < 3)
			curveType = CurveType::Linear;

		//if we are in linear mode, just push back the control points
		//(and take into account the curve being closed)
		if (curveType == CurveType::Linear)
		{
			if (mClosed)
				pts.push_back(ControlPoints[0]);
			return;
		}

		//Fix the curve to be either closed or continuous
		if (mClosed)
			MakeClosed(pts);
		else
		{
			//deal with only having 3 control points by pushing the last point on again
			//don't need to do this when the curve is closed though.
			if (pts.size() == 3)
			{
				Vec3 point = pts.back();
				pts.push_back(point);
			}
			MakeContinuous(pts);
		}
	}

	void SplineCurve::MakeContinuous(Vec3Array& points) const
	{
		//to make a curve continuous, we need an extra control point that keeps
		//the same direction. Therefore, compute a new point at both the
		//beginning and end that keeps the correct direction.
		Vec3 ab = points[0] - points[1];
		points.insert(points.begin(), points[0] + ab);

		uint size = points.size();
		Vec3 cd = points[size - 1] - points[size - 2];
		points.push_back(points[size - 1] + cd);
	}

	void SplineCurve::MakeClosed(Vec3Array& points) const
	{
		//to make a curve closed, we have to duplicate 2 points at the other end
		//of the curve
		Vec3 end = points[points.size() - 1];
		Vec3 secondEnd = points[points.size() - 2];
		points.insert(points.begin(), end);
		points.insert(points.begin(), secondEnd);

		points.push_back(points[2]);
		points.push_back(points[3]);
	}

	template <typename Policy>
	void SplineCurve::GetPoints(const Vec3Array& points, Vec3Array& results, uint resolution) const
	{
		real t = real(0.0);
		uint start = 0;
		uint end = resolution;
		uint countControlPoints = uint(points.size() - 3);

		real step = real(1.0) / static_cast<real>(resolution);

		for (uint i = mClosed ? 1 : 0; i < countControlPoints; ++i)
		{
			t = real(0.0);
			end = resolution;

			if (i == countControlPoints - 1)
				++end;

			Vec3Param cp0 = points[i];
			Vec3Param cp1 = points[i + 1];
			Vec3Param cp2 = points[i + 2];
			Vec3Param cp3 = points[i + 3];

			for (uint j = start; j < end; ++j)
			{
				PointData data = ComputePointData<Policy>(t, cp0, cp1, cp2, cp3);
				Vec3 point = data.Point;
				results.push_back(point);
				t += step;
			}
		}
	}

	template <typename Policy>
	void SplineCurve::GetPoints(const Vec3Array& points, Vec3Array& results, real error) const
	{
		uint countControlPoints = uint(points.size() - 3);

		Vec3 veryLastPoint;
		for (uint i = mClosed ? 1 : 0; i < countControlPoints; ++i)
		{
			Vec3Param cp0 = points[i];
			Vec3Param cp1 = points[i + 1];
			Vec3Param cp2 = points[i + 2];
			Vec3Param cp3 = points[i + 3];

			//add the start, mid and last point to the stack (need the middle point
			//since the spline is cubic, this "approximates" each sub-section as a quadratic)
			Zero::Array<PointData> stack;
			PointData firstPoint = ComputePointData<Policy>(real(0.0), cp0, cp1, cp2, cp3);
			PointData centerPoint = ComputePointData<Policy>(real(0.5), cp0, cp1, cp2, cp3);
			PointData lastPoint = ComputePointData<Policy>(real(1.0), cp0, cp1, cp2, cp3);
			stack.push_back(lastPoint);
			stack.push_back(centerPoint);
			stack.push_back(firstPoint);
			veryLastPoint = lastPoint.Point;

			while (stack.size() != 1)
			{
				uint size = stack.size();

				PointData data0 = stack[size - 1];
				PointData data1 = stack[size - 2];

				Vec3 movement = data1.Point - data0.Point;
				//calculate the point half-way in-between the two points on the stack
				real midT = (data0.T + data1.T) * real(0.5);
				PointData midData = ComputePointData<Policy>(midT, cp0, cp1, cp2, cp3);
				Vec3 midPoint = midData.Point;

				//calculate the distance of this point from the line
				//(aka, calculate the height of the triangle)
				real doubleArea = (Math::Cross(midPoint - data0.Point, midPoint - data1.Point)).Length();

				real base = movement.Length();
				real height = doubleArea / base;

				//if the height of the triangle is too large then we need to
				//subdivide more to get a better approximation of the curve
				if (height > error)
				{
					stack[size - 1] = midData;
					stack.push_back(data0);
				}
				else
				{
					results.push_back(data0.Point);
					results.push_back(midPoint);
					stack.pop_back();
				}
			}
		}
		results.push_back(veryLastPoint);
	}

	template <typename Policy>
	Vec3 SplineCurve::ComputePoint(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const
	{
		Vec4 param = Policy::GetParam(t);
		const Mat4& basis = Policy::GetBasis();

		Vec4 x(a.x, b.x, c.x, d.x);
		x = Math::Transform(basis, x);

		Vec4 y(a.y, b.y, c.y, d.y);
		y = Math::Transform(basis, y);

		Vec4 z(a.z, b.z, c.z, d.z);
		z = Math::Transform(basis, z);

		return Vec3(Math::Dot(param, x), Math::Dot(param, y), Math::Dot(param, z));
	}

	template <typename Policy>
	SplineCurve::PointData SplineCurve::ComputePointData(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const
	{
		PointData data;

		data.Point = ComputePoint<Policy>(t, a, b, c, d);
		data.T = t;
		return data;
	}

	//-------------------------------------------------------------- B-Spline Policy
	const Mat4& SplineCurve::BSplinePolicy::GetBasis()
	{
		return BSplineBasis;
	}

	Vec4 SplineCurve::BSplinePolicy::GetParam(real t)
	{
		return Vec4(t*t*t, t*t, t, 1);
	}

	//----------------------------------------------------------- Catmull-Rom Policy
	const Mat4& SplineCurve::CatmullRomPolicy::GetBasis()
	{
		return CatmullBasis;
	}

	Vec4 SplineCurve::CatmullRomPolicy::GetParam(real t)
	{
		return Vec4(1, t, t*t, t*t*t);
	}

	//-------------------------------------------------------------------BakedCurve
	void BakedCurve::Bake(const SplineCurve& curve, real error)
	{
		//get all of the baked points from the curve (right now allocate a
		//temp array for this, maybe figure something better out later)
		Vec3Array pts;
		curve.BakeAdaptive(pts, error);
		if (pts.size() == 0)
			return;

		float totalLength = 0.0f;

		mArcLengthTable.resize(pts.size());
		//the 1st point is at length 0, 
		mArcLengthTable[0].ArcLength = 0.0f;
		mArcLengthTable[0].Position = pts[0];

		//now compute the rest of the points
		for (uint i = 1; i < pts.size(); ++i)
		{
			Vec3 oldPos = pts[i - 1];
			Vec3 curPos = pts[i];

			//get the vector from the previous point to the current point
			Vec3 dir = curPos - oldPos;
			//now increase the total arc length by this distance vector
			float length = dir.Length();
			totalLength += length;

			//make sure to set the position and arc length of this point
			mArcLengthTable[i].ArcLength = totalLength;
			mArcLengthTable[i].Position = pts[i];
		}
	}

	uint BakedCurve::Size() const
	{
		return mArcLengthTable.size();
	}

	real BakedCurve::GetTotalArcLength() const
	{
		uint tableSize = Size();
		if (tableSize == 0)
			return real(0.0);

		return mArcLengthTable[tableSize - 1].ArcLength;
	}

	BakedCurve::BakedData BakedCurve::GetPoint(uint index)
	{
		if (index >= mArcLengthTable.size())
			return BakedData();

		return mArcLengthTable[index];
	}

	void BakedCurve::SetPoint(uint index, Vec3Param pos)
	{
		if (index < mArcLengthTable.size())
			mArcLengthTable[index].Position = pos;
	}

	Vec3 BakedCurve::SampleTable(float distance, Vec3* tangent) const
	{
		//handle the two special cases where we can't interpolate between two points
		if (mArcLengthTable.size() == 0)
			return Vec3::cZero;
		if (mArcLengthTable.size() == 1)
			return mArcLengthTable[0].Position;
		//there is no curve (the only points are on top of each other)
		if (GetTotalArcLength() == real(0.0))
			return mArcLengthTable[0].Position;

		real oldDistance = distance;
		distance = Math::FMod(distance, GetTotalArcLength());
		//If the user passes in the total arc-length, fmod will return the start point
		//not the end point. To fix this if fmod returns 0 but our original value
		//wasn't zero then instead use the total arc-length.
		if (distance == real(0.0) && oldDistance != real(0.0))
			distance = GetTotalArcLength();
		//fmod can still return negative numbers so convert to positive
		if (distance < real(0.0))
			distance += GetTotalArcLength();

		//get the indices of the two baked point we're between
		uint lowerBound = SampleLowerBound(distance);
		uint upperBound = lowerBound + 1;

		const BakedData& lowerBoundData = mArcLengthTable[lowerBound];
		const BakedData& upperBoundData = mArcLengthTable[upperBound];

		float d0 = lowerBoundData.ArcLength;
		float d1 = upperBoundData.ArcLength;
		//compute how far in-between these two points we are
		float t = (distance - d0) / (d1 - d0);

		Vec3 p0 = lowerBoundData.Position;
		Vec3 p1 = upperBoundData.Position;
		Vec3 samplePoint = Math::Lerp(p0, p1, t);

		//if the user wants a tangent, compute it simply as the vector from the first to
		//second point, where we are on this linear segment doesn't matter
		if (tangent != NULL)
		{
			Vec3 tangentDir = p1 - p0;
			*tangent = tangentDir.AttemptNormalized();
		}

		return samplePoint;
	}

	uint BakedCurve::SampleLowerBound(real distance) const
	{
		//binary search for the lower bound
		uint begin = 0;
		uint end = mArcLengthTable.size() - 1;

		while (begin < end)
		{
			uint mid = (begin + end) / 2;
			if (mArcLengthTable[mid].ArcLength <= distance)
				begin = mid + 1;
			else
				end = mid;
		}

		//this binary search actually produced the upper bound,
		//the lower bound is the previous index
		return begin - 1;
	}

	//----------------------------------------------------------- Piecewise Function
	/// Used to sort the control points by the x-position.
	struct SortByX
	{
		bool operator()(PiecewiseFunction::ControlPoint& left,
			PiecewiseFunction::ControlPoint& right)
		{
			// We never want two control points to have the same Time,
			// so every time they're sorted, check and move one slightly
			if (left.Position.x == right.Position.x)
				right.Position.x += 0.0001f;
			return left.Position.x < right.Position.x;
		}
	};

	//******************************************************************************
	PiecewiseFunction::PiecewiseFunction()
	{
		mCurveType = CurveType::BSpline;
		mError = real(0.05);
	}

	//******************************************************************************
	void PiecewiseFunction::Clear()
	{
		// Clear all the control points
		mControlPoints.clear();

		// The baked curve is no longer valid
		mBakedCurve.clear();
	}

	//******************************************************************************
	void PiecewiseFunction::AddControlPoint(Vec2Param pos, Vec2Param tanIn,
		Vec2Param tanOut)
	{
		ControlPoint cp;
		cp.Position = pos;
		cp.TangentIn = tanIn;
		cp.TangentOut = tanOut;
		mControlPoints.push_back(cp);

		// Sort the control points along the x
		sort(mControlPoints.all(), SortByX());

		// The baked curve is no longer valid
		mBakedCurve.clear();
	}

	//******************************************************************************
	void PiecewiseFunction::SetControlPoints(Zero::Array<ControlPoint>& controlPoints)
	{
		mControlPoints.assign(controlPoints.all());

		// Sort the control points along the x
		sort(mControlPoints.all(), SortByX());

		// The baked curve is no longer valid
		mBakedCurve.clear();
	}

	//******************************************************************************
	float PiecewiseFunction::Sample(real x)
	{
		// Default case
		if (mControlPoints.empty())
			return 0.0f;

		// If it's to the left of the left most control point, return its y
		if (x <= mControlPoints.front().Position.x)
			return mControlPoints.front().Position.y;
		// If it's to the right of the right most control point, return its y
		else if (x >= mControlPoints.back().Position.x)
			return mControlPoints.back().Position.y;

		// Make sure the curve is baked
		if (!IsBaked())
			Bake();

		// Binary search to find the location of the sample
		int begin = 0;
		int end = (int)mBakedCurve.size();

		while (begin < end)
		{
			int mid = (begin + end) / 2;
			if (mBakedCurve[mid].x < x)
				begin = mid + 1;
			else
				end = mid;
		}

		// Interpolate between the two points in the baked curve
		Vec3 p0 = mBakedCurve[begin - 1];
		Vec3 p1 = mBakedCurve[begin];
		real localT = (x - p0.x) / (p1.x - p0.x);
		return Math::Lerp(p0.y, p1.y, localT);
	}

	//******************************************************************************
	void PiecewiseFunction::Bake()
	{
		mBakedCurve.clear();

		// Can't do anything with 0 control points
		if (mControlPoints.empty())
			return;

		// With just one point, any sample value will result in the single point
		if (mControlPoints.size() == 1)
		{
			mBakedCurve.push_back(ToVector3(mControlPoints.front().Position));
			return;
		}

		// We are going to use this to generate curves between control points
		static SplineCurve sCurve;
		sCurve.SetClosed(false);
		sCurve.mCurveType = mCurveType;

		// Walk through each set of control points
		for (uint i = 0; i < mControlPoints.size() - 1; ++i)
		{
			// Get the two control points
			ControlPoint& cp0 = mControlPoints[i];
			ControlPoint& cp1 = mControlPoints[i + 1];

			// Clear the old curve
			sCurve.ControlPoints.clear();

			// If it is discontinuous, 
			if (cp0.TangentOut.x == 0.0f || cp1.TangentIn.x == 0.0f)
			{
				// Only on the first iteration is the left control point not added
				if (i == 0)
					mBakedCurve.push_back(Vec3(cp0.Position));
				mBakedCurve.push_back(Vec3(Vec2(cp1.Position.x, cp0.Position.y)));
				mBakedCurve.push_back(Vec3(cp1.Position));
				continue;
			}

			// It's a function, so we must clamp the tangent at the midway
			// point on the x-axis
			Vec2 halfWay = (cp0.Position + cp1.Position) * 0.5f;

			// Clamp the out tangent of the first control point
			float maxExtent = (halfWay.x - cp0.Position.x);
			float tangentScalar = maxExtent / cp0.TangentOut.x;
			tangentScalar = Math::Min(tangentScalar, 1.0f);

			// The newly clamped tangent
			Vec2 tangentOutClamped = cp0.Position + cp0.TangentOut * tangentScalar;

			// Add the first control point and clamped tangent out
			sCurve.AddControlPoint(Vec3(cp0.Position));
			sCurve.AddControlPoint(Vec3(tangentOutClamped));

			// Now do the same for the tangentIn on the second control point
			maxExtent = (halfWay.x - cp1.Position.x);
			tangentScalar = maxExtent / cp1.TangentIn.x;
			tangentScalar = Math::Min(tangentScalar, 1.0f);
			Vec2 tangentInClamped = cp1.Position + cp1.TangentIn * tangentScalar;

			// Add the clamped tangent in and the second control point
			sCurve.AddControlPoint(Vec3(tangentInClamped));
			sCurve.AddControlPoint(Vec3(cp1.Position));

			// Add the points of the curve
			sCurve.BakeAdaptive(mBakedCurve, mError);
		}
	}

	//******************************************************************************
	bool PiecewiseFunction::IsBaked()
	{
		return !mBakedCurve.empty();
	}

	//******************************************************************************
	Vec3Array::range PiecewiseFunction::GetBakedCurve()
	{
		return mBakedCurve.all();
	}

	//******************************************************************************
	bool PiecewiseFunction::empty()
	{
		return mBakedCurve.empty();
	}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file DecomposedMatrix4.cpp
/// Implementation of the DecomposedMatrix4 structure.
/// 
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	DecomposedMatrix4::DecomposedMatrix4()
	{
		Translation.ZeroOut();
		Scale.Splat(real(1.0));
		Rotation.SetIdentity();
	}

	DecomposedMatrix4::DecomposedMatrix4(Mat4Param transform)
	{
		Set(transform);
	}

	void DecomposedMatrix4::Set(Mat4Param transform)
	{
		transform.Decompose(&Scale, &Rotation, &Translation);
	}

	Vector3 DecomposedMatrix4::TransformNormal(Vec3Param normal)
	{
		Vector3 result = normal * Scale;
		return Math::Transform(Rotation, result);
	}

	Vector3 DecomposedMatrix4::InverseTransformNormal(Vec3Param normal)
	{
		Vector3 result = Math::TransposedTransform(Rotation, normal);
		return result / Scale;
	}

	Vector3 DecomposedMatrix4::TransformSurfaceNormal(Vec3Param direction)
	{
		Vector3 result = Math::Transform(Rotation, direction);
		return result / Scale;
	}

	Vector3 DecomposedMatrix4::InverseTransformSurfaceNormal(Vec3Param direction)
	{
		Vector3 result = Math::TransposedTransform(Rotation, direction);
		return result * Scale;
	}

	Vector3 DecomposedMatrix4::TransformPoint(Vec3Param point)
	{
		Vector3 result = point * Scale;
		result = Math::Transform(Rotation, result);
		return result + Translation;
	}

	Vector3 DecomposedMatrix4::InverseTransformPoint(Vec3Param point)
	{
		Vector3 result = point - Translation;
		result = Math::TransposedTransform(Rotation, result);
		return result / Scale;
	}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerAngles.cpp
///  Implementation of the EulerAngle structure, design referenced from
///  Insomniac Games.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{
	//----------------------------------------------------------------- Euler Angles
	EulerAngles::EulerAngles(EulerOrderParam order)
		: Order(order)
	{
		//
	}

	EulerAngles::EulerAngles(Vec3Param xyzRotation, EulerOrderParam order)
		: Angles(xyzRotation), Order(order)
	{
		//
	}

	EulerAngles::EulerAngles(real xRotation, real yRotation, real zRotation,
		EulerOrderParam order)
		: Angles(xRotation, yRotation, zRotation), Order(order)
	{
		//
	}

	EulerAngles::EulerAngles(Mat3Param matrix, EulerOrderParam order)
		: Order(order)
	{
		Math::ToEulerAngles(matrix, this);
	}

	EulerAngles::EulerAngles(Mat4Param matrix, EulerOrderParam order)
		: Order(order)
	{
		Math::ToEulerAngles(matrix, this);
	}

	EulerAngles::EulerAngles(QuatParam quaternion, EulerOrderParam order)
		: Order(order)
	{
		Math::ToEulerAngles(quaternion, this);
	}

	real EulerAngles::operator [] (uint index) const
	{
		return Angles[index];
	}

	real& EulerAngles::operator [] (uint index)
	{
		return Angles[index];
	}

	real EulerAngles::I(void) const
	{
		return Angles[Order.I()];
	}

	real EulerAngles::J(void) const
	{
		return Angles[Order.J()];
	}

	real EulerAngles::K(void) const
	{
		return Angles[Order.K()];
	}

	real EulerAngles::H(void) const
	{
		return Angles[Order.H()];
	}

	void EulerAngles::I(real i)
	{
		Angles[Order.I()] = i;
	}

	void EulerAngles::J(real j)
	{
		Angles[Order.J()] = j;
	}

	void EulerAngles::K(real k)
	{
		Angles[Order.K()] = k;
	}

	void EulerAngles::H(real h)
	{
		Angles[Order.H()] = h;
	}

	void EulerAngles::Reorder(EulerOrderParam newOrder)
	{
		Order = newOrder;
	}
}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerOrder.cpp
///  Implementation of the Euler angles order as described in Graphic Gems IV,
///  EulerOrder design referenced from Insomniac Games.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	EulerOrder::EulerOrder(EulerOrders::Enum eulerOrder)
		: Order(eulerOrder)
	{
		//
	}

	EulerOrder& EulerOrder::operator = (EulerOrderParam rhs)
	{
		Order = rhs.Order;
		return *this;
	}

	bool EulerOrder::operator == (EulerOrderParam rhs)
	{
		return Order == rhs.Order;
	}

	bool EulerOrder::operator != (EulerOrderParam rhs)
	{
		return Order != rhs.Order;
	}

	uint EulerOrder::I(void) const
	{
		return EulerOrders::Safe[((uint(Order) >> 3) & 3)];
	}

	uint EulerOrder::J(void) const
	{
		return EulerOrders::Next[I() + (OddParity() ? 1 : 0)];
	}

	uint EulerOrder::K(void) const
	{
		return EulerOrders::Next[I() + (OddParity() ? 0 : 1)];
	}

	uint EulerOrder::H(void) const
	{
		return RepeatingAngles() == EulerOrders::No ? K() : I();
	}

	bool EulerOrder::RepeatingAngles(void) const
	{
		return ((uint(Order) >> 1) & 1) == EulerOrders::Yes;
	}

	bool EulerOrder::RotatingFrame(void) const
	{
		return (uint(Order) & 1) == EulerOrders::Rotated;
	}

	bool EulerOrder::OddParity(void) const
	{
		return ((uint(Order) >> 2) & 1) == EulerOrders::Odd;
	}

	void EulerOrder::GetOrder(EulerOrder order, uint& i, uint& j, uint& k, uint& h,
		uint& parity, uint& repeated, uint& frame)
	{
		uint orderValue = uint(order.Order);

		frame = orderValue & 1;
		orderValue >>= 1;

		repeated = orderValue & 1;
		orderValue >>= 1;

		parity = orderValue & 1;
		orderValue >>= 1;

		i = EulerOrders::Safe[orderValue & 3];

		j = EulerOrders::Next[i + parity];

		k = EulerOrders::Next[i + 1 - parity];

		h = repeated ? k : i;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExtendableMath.cpp
/// 
/// Authors: Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
//////////////////////////////////////////////////////////////////////////////

namespace Math
{

	//-------------------------------------------------------------------ExtendableVector
	void ExtendableVector::resize(uint size)
	{
		mSize = size;
		mData.resize(mSize);
	}

	real& ExtendableVector::operator[](uint index)
	{
		return mData[index];
	}

	real ExtendableVector::operator[](uint index) const
	{
		return mData[index];
	}

	uint ExtendableVector::GetSize() const
	{
		return mSize;
	}

	//-------------------------------------------------------------------ExtendableMatrix
	void ExtendableMatrix::resize(uint sizeX, uint sizeY)
	{
		mSizeX = sizeX;
		mSizeY = sizeY;
		mData.resize(mSizeX * mSizeY);
	}

	real& ExtendableMatrix::operator()(uint y, uint x)
	{
		return mData[x + mSizeX * y];
	}

	real ExtendableMatrix::operator()(uint y, uint x) const
	{
		return mData[x + mSizeX * y];
	}

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file IntVector2.cpp
///  Implementation of the IntVector2 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const IntVector2 IntVector2::cZero(0, 0);
	const IntVector2 IntVector2::cXAxis(1, 0);
	const IntVector2 IntVector2::cYAxis(0, 1);

	IntVector2::IntVector2(int x_, int y_)
	{
		x = x_;
		y = y_;
	}

	int& IntVector2::operator[](uint index)
	{
		ErrorIf(index > 1, "Math::IntVector2 - Subscript out of range.");
		return array[index];
	}

	int IntVector2::operator[](uint index) const
	{
		ErrorIf(index > 1, "Math::IntVector2 - Subscript out of range.");
		return array[index];
	}

	////////// Unary Operators /////////////////////////////////////////////////////

	IntVector2 IntVector2::operator-(void) const
	{
		return IntVector2(-x, -y);
	}

	////////// Binary Assignment Operators (reals) /////////////////////////////////

	void IntVector2::operator*=(int rhs)
	{
		x *= rhs;
		y *= rhs;
	}

	void IntVector2::operator/=(int rhs)
	{
		ErrorIf(rhs == 0, "Math::IntVector2 - Division by zero.");
		x /= rhs;
		y /= rhs;
	}

	////////// Binary Operators (reals) ////////////////////////////////////////////

	IntVector2 IntVector2::operator*(int rhs) const
	{
		return IntVector2(x * rhs, y * rhs);
	}

	IntVector2 IntVector2::operator/(int rhs) const
	{
		ErrorIf(rhs == 0, "Math::IntVector2 - Division by zero.");
		return IntVector2(x / rhs, y / rhs);
	}

	IntVector2 IntVector2::operator%(int rhs) const
	{
		ErrorIf(rhs == 0, "Math::IntVector2 - Mod by zero.");
		return IntVector2(x % rhs, y % rhs);
	}

	IntVector2& IntVector2::operator++()
	{
		++x;
		++y;
		return *this;
	}

	IntVector2& IntVector2::operator--()
	{
		--x;
		--y;
		return *this;
	}

	////////// Binary Assignment Operators (Vectors) ///////////////////////////////

	void IntVector2::operator+=(IntVec2Param rhs)
	{
		x += rhs.x;
		y += rhs.y;
	}

	void IntVector2::operator-=(IntVec2Param rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
	}

	void IntVector2::operator*=(IntVec2Param rhs)
	{
		x *= rhs.x;
		y *= rhs.y;
	}

	void IntVector2::operator/=(IntVec2Param rhs)
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0,
			"IntVector2 - Division by zero.");
		x /= rhs.x;
		y /= rhs.y;
	}

	////////// Binary Operators (Vectors) //////////////////////////////////////////

	IntVector2 IntVector2::operator+(IntVec2Param rhs) const
	{
		return IntVector2(x + rhs.x, y + rhs.y);
	}

	IntVector2 IntVector2::operator-(IntVec2Param rhs) const
	{
		return IntVector2(x - rhs.x, y - rhs.y);
	}

	////////// Binary Vector Comparisons ///////////////////////////////////////////

	bool IntVector2::operator==(IntVec2Param rhs) const
	{
		return x == rhs.x && y == rhs.y;
	}

	bool IntVector2::operator!=(IntVec2Param rhs) const
	{
		return !(*this == rhs);
	}

	BoolVec2 IntVector2::operator< (IntVec2Param rhs) const
	{
		return BoolVec2(x < rhs.x,
			y < rhs.y);
	}

	BoolVec2 IntVector2::operator<=(IntVec2Param rhs) const
	{
		return BoolVec2(x <= rhs.x,
			y <= rhs.y);
	}

	BoolVec2 IntVector2::operator>(IntVec2Param rhs) const
	{
		return BoolVec2(x > rhs.x,
			y > rhs.y);
	}

	BoolVec2 IntVector2::operator>=(IntVec2Param rhs) const
	{
		return BoolVec2(x >= rhs.x,
			y >= rhs.y);
	}

	void IntVector2::Set(int x_, int y_)
	{
		x = x_;
		y = y_;
	}

	void IntVector2::ZeroOut(void)
	{
		x = 0;
		y = 0;
	}

	IntVector2 IntVector2::operator/(IntVec2Param rhs) const
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0,
			"IntVector2 - Division by zero.");
		return IntVector2(x / rhs.x, y / rhs.y);
	}

	IntVector2 IntVector2::operator*(IntVec2Param rhs) const
	{
		return IntVector2(x * rhs.x, y * rhs.y);
	}

	IntVector2 IntVector2::operator%(IntVec2Param rhs) const
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0,
			"IntVector2 - Mod by zero.");
		return IntVector2(x % rhs.x, y % rhs.y);
	}

	IntVector2 operator*(int lhs, IntVec2Param rhs)
	{
		return rhs * lhs;
	}

	IntVector2 Abs(IntVec2Param vec)
	{
		return IntVector2(Math::Abs(vec.x), Math::Abs(vec.y));
	}

	IntVector2 Min(IntVec2Param lhs, IntVec2Param rhs)
	{
		return IntVector2(Math::Min(lhs.x, rhs.x),
			Math::Min(lhs.y, rhs.y));
	}

	IntVector2 Max(IntVec2Param lhs, IntVec2Param rhs)
	{
		return IntVector2(Math::Max(lhs.x, rhs.x),
			Math::Max(lhs.y, rhs.y));
	}

	IntVector2  IntVector2::operator~() const
	{
		return IntVector2(~x,
			~y);
	}

	IntVector2  IntVector2::operator<< (IntVec2Param rhs) const
	{
		return IntVector2(x << rhs.x,
			y << rhs.y);
	}

	IntVector2  IntVector2::operator>> (IntVec2Param rhs) const
	{
		return IntVector2(x >> rhs.x,
			y >> rhs.y);
	}

	IntVector2  IntVector2::operator|  (IntVec2Param rhs) const
	{
		return IntVector2(x | rhs.x,
			y | rhs.y);
	}

	IntVector2  IntVector2::operator^  (IntVec2Param rhs) const
	{
		return IntVector2(x ^ rhs.x,
			y ^ rhs.y);
	}

	IntVector2  IntVector2::operator&  (IntVec2Param rhs) const
	{
		return IntVector2(x & rhs.x,
			y & rhs.y);
	}

	IntVector2& IntVector2::operator<<=(IntVec2Param rhs)
	{
		x <<= rhs.x;
		y <<= rhs.y;
		return *this;
	}

	IntVector2& IntVector2::operator>>=(IntVec2Param rhs)
	{
		x >>= rhs.x;
		y >>= rhs.y;
		return *this;
	}

	IntVector2& IntVector2::operator|= (IntVec2Param rhs)
	{
		x |= rhs.x;
		y |= rhs.y;
		return *this;
	}

	IntVector2& IntVector2::operator^= (IntVec2Param rhs)
	{
		x ^= rhs.x;
		y ^= rhs.y;
		return *this;
	}

	IntVector2& IntVector2::operator&= (IntVec2Param rhs)
	{
		x &= rhs.x;
		y &= rhs.y;
		return *this;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file IntVector3.cpp
///  Implementation of the IntVector3 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const IntVector3 IntVector3::cZero(0, 0, 0);
	const IntVector3 IntVector3::cXAxis(1, 0, 0);
	const IntVector3 IntVector3::cYAxis(0, 1, 0);
	const IntVector3 IntVector3::cZAxis(0, 0, 1);

	IntVector3::IntVector3(int x_, int y_, int z_)
	{
		x = x_;
		y = y_;
		z = z_;
	}

	int& IntVector3::operator[](uint index)
	{
		ErrorIf(index > 2, "IntVector3 - Subscript out of range.");
		return array[index];
	}

	int IntVector3::operator[](uint index) const
	{
		ErrorIf(index > 2, "IntVector3 - Subscript out of range.");
		return array[index];
	}

	////////// Unary Operators /////////////////////////////////////////////////////

	IntVector3 IntVector3::operator-(void) const
	{
		return IntVector3(-x, -y, -z);
	}

	////////// Binary Assignment Operators (reals) /////////////////////////////////

	void IntVector3::operator*=(int rhs)
	{
		x *= rhs;
		y *= rhs;
		z *= rhs;
	}

	void IntVector3::operator/=(int rhs)
	{
		ErrorIf(rhs == 0, "IntVector3 - Division by zero.");
		x /= rhs;
		y /= rhs;
		z /= rhs;
	}

	////////// Binary Operators (reals) ////////////////////////////////////////////

	IntVector3 IntVector3::operator*(int rhs) const
	{
		return IntVector3(x * rhs, y * rhs, z * rhs);
	}

	IntVector3 IntVector3::operator/(int rhs) const
	{
		ErrorIf(rhs == 0, "IntVector3 - Division by zero.");
		return IntVector3(x / rhs, y / rhs, z / rhs);
	}

	IntVector3 IntVector3::operator%(int rhs) const
	{
		ErrorIf(rhs == 0, "IntVector3 - Mod by zero.");
		return IntVector3(x % rhs, y % rhs, z % rhs);
	}

	IntVector3& IntVector3::operator++()
	{
		++x;
		++y;
		++z;
		return *this;
	}

	IntVector3& IntVector3::operator--()
	{
		--x;
		--y;
		--z;
		return *this;
	}

	////////// Binary Assignment Operators (Vectors) ///////////////////////////////

	void IntVector3::operator+=(IntVec3Param rhs)
	{
		x += rhs.x;
		y += rhs.y;
		z += rhs.z;
	}

	void IntVector3::operator-=(IntVec3Param rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
		z -= rhs.z;
	}

	void IntVector3::operator*=(IntVec3Param rhs)
	{
		x *= rhs.x;
		y *= rhs.y;
		z *= rhs.z;
	}

	void IntVector3::operator/=(IntVec3Param rhs)
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0,
			"Vector2 - Division by zero.");
		x /= rhs.x;
		y /= rhs.y;
		z /= rhs.z;
	}

	////////// Binary Operators (Vectors) //////////////////////////////////////////

	IntVector3 IntVector3::operator+(IntVec3Param rhs) const
	{
		return IntVector3(x + rhs.x, y + rhs.y, z + rhs.z);
	}

	IntVector3 IntVector3::operator-(IntVec3Param rhs) const
	{
		return IntVector3(x - rhs.x, y - rhs.y, z - rhs.z);
	}

	////////// Binary Vector Comparisons ///////////////////////////////////////////

	bool IntVector3::operator==(IntVec3Param rhs) const
	{
		return x == rhs.x && y == rhs.y && z == rhs.z;
	}

	bool IntVector3::operator!=(IntVec3Param rhs) const
	{
		return !(*this == rhs);
	}

	BoolVec3 IntVector3::operator< (IntVec3Param rhs) const
	{
		return BoolVec3(x < rhs.x,
			y < rhs.y,
			z < rhs.z);
	}

	BoolVec3 IntVector3::operator<=(IntVec3Param rhs) const
	{
		return BoolVec3(x <= rhs.x,
			y <= rhs.y,
			z <= rhs.z);
	}

	BoolVec3 IntVector3::operator>(IntVec3Param rhs) const
	{
		return BoolVec3(x > rhs.x,
			y > rhs.y,
			z > rhs.z);
	}

	BoolVec3 IntVector3::operator>=(IntVec3Param rhs) const
	{
		return BoolVec3(x >= rhs.x,
			y >= rhs.y,
			z >= rhs.z);
	}

	void IntVector3::Set(int x_, int y_, int z_)
	{
		x = x_;
		y = y_;
		z = z_;
	}

	void IntVector3::ZeroOut(void)
	{
		x = 0;
		y = 0;
		z = 0;
	}

	IntVector3 IntVector3::operator/(IntVec3Param rhs) const
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0,
			"IntVector3 - Division by zero.");
		return IntVector3(x / rhs.x, y / rhs.y, z / rhs.z);
	}

	IntVector3 IntVector3::operator*(IntVec3Param rhs) const
	{
		return IntVector3(x * rhs.x, y * rhs.y, z * rhs.z);
	}

	IntVector3 IntVector3::operator%(IntVec3Param rhs) const
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0,
			"IntVector3 - Mod by zero.");
		return IntVector3(x % rhs.x, y % rhs.y, z % rhs.z);
	}

	IntVector3 operator*(int lhs, IntVec3Param rhs)
	{
		return rhs * lhs;
	}

	IntVector3 Abs(IntVec3Param vec)
	{
		return IntVector3(Math::Abs(vec.x), Math::Abs(vec.y), Math::Abs(vec.z));
	}

	IntVector3 Min(IntVec3Param lhs, IntVec3Param rhs)
	{
		return IntVector3(Math::Min(lhs.x, rhs.x),
			Math::Min(lhs.y, rhs.y),
			Math::Min(lhs.z, rhs.z));
	}

	IntVector3 Max(IntVec3Param lhs, IntVec3Param rhs)
	{
		return IntVector3(Math::Max(lhs.x, rhs.x),
			Math::Max(lhs.y, rhs.y),
			Math::Max(lhs.z, rhs.z));
	}

	IntVector3  IntVector3::operator~() const
	{
		return IntVector3(~x,
			~y,
			~z);
	}

	IntVector3  IntVector3::operator<< (IntVec3Param rhs) const
	{
		return IntVector3(x << rhs.x,
			y << rhs.y,
			z << rhs.z);
	}

	IntVector3  IntVector3::operator>> (IntVec3Param rhs) const
	{
		return IntVector3(x >> rhs.x,
			y >> rhs.y,
			z >> rhs.z);
	}

	IntVector3  IntVector3::operator|  (IntVec3Param rhs) const
	{
		return IntVector3(x | rhs.x,
			y | rhs.y,
			z | rhs.z);
	}

	IntVector3  IntVector3::operator^  (IntVec3Param rhs) const
	{
		return IntVector3(x ^ rhs.x,
			y ^ rhs.y,
			z ^ rhs.z);
	}

	IntVector3  IntVector3::operator&  (IntVec3Param rhs) const
	{
		return IntVector3(x & rhs.x,
			y & rhs.y,
			z & rhs.z);
	}

	IntVector3& IntVector3::operator<<=(IntVec3Param rhs)
	{
		x <<= rhs.x;
		y <<= rhs.y;
		z <<= rhs.z;
		return *this;
	}

	IntVector3& IntVector3::operator>>=(IntVec3Param rhs)
	{
		x >>= rhs.x;
		y >>= rhs.y;
		z >>= rhs.z;
		return *this;
	}

	IntVector3& IntVector3::operator|= (IntVec3Param rhs)
	{
		x |= rhs.x;
		y |= rhs.y;
		z |= rhs.z;
		return *this;
	}

	IntVector3& IntVector3::operator^= (IntVec3Param rhs)
	{
		x ^= rhs.x;
		y ^= rhs.y;
		z ^= rhs.z;
		return *this;
	}

	IntVector3& IntVector3::operator&= (IntVec3Param rhs)
	{
		x &= rhs.x;
		y &= rhs.y;
		z &= rhs.z;
		return *this;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file IntVector4.cpp
///  Implementation of the IntVector4 structure.
/// 
///  Authors: Trevor Sundberg
///  Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const IntVector4 IntVector4::cZero(0, 0, 0, 0);
	const IntVector4 IntVector4::cXAxis(1, 0, 0, 0);
	const IntVector4 IntVector4::cYAxis(0, 1, 0, 0);
	const IntVector4 IntVector4::cZAxis(0, 0, 1, 0);
	const IntVector4 IntVector4::cWAxis(0, 0, 0, 1);

	IntVector4::IntVector4(int x_, int y_, int z_, int w_)
	{
		x = x_;
		y = y_;
		z = z_;
		w = w_;
	}

	int& IntVector4::operator[](uint index)
	{
		ErrorIf(index > 3, "IntVector4 - Subscript out of range.");
		return array[index];
	}

	int IntVector4::operator[](uint index) const
	{
		ErrorIf(index > 3, "IntVector4 - Subscript out of range.");
		return array[index];
	}

	////////// Unary Operators /////////////////////////////////////////////////////

	IntVector4 IntVector4::operator-(void) const
	{
		return IntVector4(-x, -y, -z, -w);
	}

	////////// Binary Assignment Operators (reals) /////////////////////////////////

	void IntVector4::operator*=(int rhs)
	{
		x *= rhs;
		y *= rhs;
		z *= rhs;
		w *= rhs;
	}

	void IntVector4::operator/=(int rhs)
	{
		ErrorIf(rhs == 0, "IntVector4 - Division by zero.");
		x /= rhs;
		y /= rhs;
		z /= rhs;
		w /= rhs;
	}

	////////// Binary Operators (reals) ////////////////////////////////////////////

	IntVector4 IntVector4::operator*(int rhs) const
	{
		return IntVector4(x * rhs, y * rhs, z * rhs, w * rhs);
	}

	IntVector4 IntVector4::operator/(int rhs) const
	{
		ErrorIf(rhs == 0, "IntVector4 - Division by zero.");
		return IntVector4(x / rhs, y / rhs, z / rhs, w / rhs);
	}

	IntVector4 IntVector4::operator%(int rhs) const
	{
		ErrorIf(rhs == 0, "IntVector4 - Mod by zero.");
		return IntVector4(x % rhs, y % rhs, z % rhs, w % rhs);
	}

	IntVector4& IntVector4::operator++()
	{
		++x;
		++y;
		++z;
		++w;
		return *this;
	}

	IntVector4& IntVector4::operator--()
	{
		--x;
		--y;
		--z;
		--w;
		return *this;
	}

	////////// Binary Assignment Operators (Vectors) ///////////////////////////////

	void IntVector4::operator+=(IntVec4Param rhs)
	{
		x += rhs.x;
		y += rhs.y;
		z += rhs.z;
		w += rhs.w;
	}

	void IntVector4::operator-=(IntVec4Param rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
		z -= rhs.z;
		w -= rhs.w;
	}

	void IntVector4::operator*=(IntVec4Param rhs)
	{
		x *= rhs.x;
		y *= rhs.y;
		z *= rhs.z;
		w *= rhs.w;
	}

	void IntVector4::operator/=(IntVec4Param rhs)
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0 || rhs.w == 0,
			"Vector2 - Division by zero.");
		x /= rhs.x;
		y /= rhs.y;
		z /= rhs.z;
		w /= rhs.w;
	}

	////////// Binary Operators (Vectors) //////////////////////////////////////////

	IntVector4 IntVector4::operator+(IntVec4Param rhs) const
	{
		return IntVector4(x + rhs.x, y + rhs.y, z + rhs.z, w + rhs.w);
	}

	IntVector4 IntVector4::operator-(IntVec4Param rhs) const
	{
		return IntVector4(x - rhs.x, y - rhs.y, z - rhs.z, w - rhs.w);
	}

	////////// Binary Vector Comparisons ///////////////////////////////////////////

	bool IntVector4::operator==(IntVec4Param rhs) const
	{
		return x == rhs.x && y == rhs.y && z == rhs.z && w == rhs.w;
	}

	bool IntVector4::operator!=(IntVec4Param rhs) const
	{
		return !(*this == rhs);
	}

	BoolVec4 IntVector4::operator< (IntVec4Param rhs) const
	{
		return BoolVec4(x < rhs.x,
			y < rhs.y,
			z < rhs.z,
			w < rhs.w);
	}

	BoolVec4 IntVector4::operator<=(IntVec4Param rhs) const
	{
		return BoolVec4(x <= rhs.x,
			y <= rhs.y,
			z <= rhs.z,
			w <= rhs.w);
	}

	BoolVec4 IntVector4::operator> (IntVec4Param rhs) const
	{
		return BoolVec4(x > rhs.x,
			y > rhs.y,
			z > rhs.z,
			w > rhs.w);
	}

	BoolVec4 IntVector4::operator>=(IntVec4Param rhs) const
	{
		return BoolVec4(x >= rhs.x,
			y >= rhs.y,
			z >= rhs.z,
			w >= rhs.w);
	}

	void IntVector4::Set(int x_, int y_, int z_, int w_)
	{
		x = x_;
		y = y_;
		z = z_;
		w = w_;
	}

	void IntVector4::ZeroOut(void)
	{
		x = 0;
		y = 0;
		z = 0;
		w = 0;
	}

	IntVector4 IntVector4::operator/(IntVec4Param rhs) const
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0 || rhs.w == 0,
			"IntVector4 - Division by zero.");
		return IntVector4(x / rhs.x, y / rhs.y, z / rhs.z, w / rhs.w);
	}

	IntVector4 IntVector4::operator*(IntVec4Param rhs) const
	{
		return IntVector4(x * rhs.x, y * rhs.y, z * rhs.z, w * rhs.w);
	}

	IntVector4 IntVector4::operator%(IntVec4Param rhs) const
	{
		ErrorIf(rhs.x == 0 || rhs.y == 0 || rhs.z == 0 || rhs.w == 0,
			"IntVector4 - Mod by zero.");
		return IntVector4(x % rhs.x, y % rhs.y, z % rhs.z, w % rhs.w);
	}

	IntVector4 operator*(int lhs, IntVec4Param rhs)
	{
		return rhs * lhs;
	}

	IntVector4 Abs(IntVec4Param vec)
	{
		return IntVector4(Math::Abs(vec.x), Math::Abs(vec.y), Math::Abs(vec.z), Math::Abs(vec.w));
	}

	IntVector4 Min(IntVec4Param lhs, IntVec4Param rhs)
	{
		return IntVector4(Math::Min(lhs.x, rhs.x),
			Math::Min(lhs.y, rhs.y),
			Math::Min(lhs.z, rhs.z),
			Math::Min(lhs.w, rhs.w));
	}

	IntVector4 Max(IntVec4Param lhs, IntVec4Param rhs)
	{
		return IntVector4(Math::Max(lhs.x, rhs.x),
			Math::Max(lhs.y, rhs.y),
			Math::Max(lhs.z, rhs.z),
			Math::Max(lhs.w, rhs.w));
	}

	IntVector4  IntVector4::operator~() const
	{
		return IntVector4(~x,
			~y,
			~z,
			~w);
	}

	IntVector4  IntVector4::operator<< (IntVec4Param rhs) const
	{
		return IntVector4(x << rhs.x,
			y << rhs.y,
			z << rhs.z,
			w << rhs.w);
	}

	IntVector4  IntVector4::operator>> (IntVec4Param rhs) const
	{
		return IntVector4(x >> rhs.x,
			y >> rhs.y,
			z >> rhs.z,
			w >> rhs.w);
	}

	IntVector4  IntVector4::operator|  (IntVec4Param rhs) const
	{
		return IntVector4(x | rhs.x,
			y | rhs.y,
			z | rhs.z,
			w | rhs.w);
	}

	IntVector4  IntVector4::operator^  (IntVec4Param rhs) const
	{
		return IntVector4(x ^ rhs.x,
			y ^ rhs.y,
			z ^ rhs.z,
			w ^ rhs.w);
	}

	IntVector4  IntVector4::operator&  (IntVec4Param rhs) const
	{
		return IntVector4(x & rhs.x,
			y & rhs.y,
			z & rhs.z,
			w & rhs.w);
	}

	IntVector4& IntVector4::operator<<=(IntVec4Param rhs)
	{
		x <<= rhs.x;
		y <<= rhs.y;
		z <<= rhs.z;
		w <<= rhs.w;
		return *this;
	}

	IntVector4& IntVector4::operator>>=(IntVec4Param rhs)
	{
		x >>= rhs.x;
		y >>= rhs.y;
		z >>= rhs.z;
		w >>= rhs.w;
		return *this;
	}

	IntVector4& IntVector4::operator|= (IntVec4Param rhs)
	{
		x |= rhs.x;
		y |= rhs.y;
		z |= rhs.z;
		w |= rhs.w;
		return *this;
	}

	IntVector4& IntVector4::operator^= (IntVec4Param rhs)
	{
		x ^= rhs.x;
		y ^= rhs.y;
		z ^= rhs.z;
		w ^= rhs.w;
		return *this;
	}

	IntVector4& IntVector4::operator&= (IntVec4Param rhs)
	{
		x &= rhs.x;
		y &= rhs.y;
		z &= rhs.z;
		w &= rhs.w;
		return *this;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Math.cpp
/// Central location for all the math used by the Zero engine.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <cfloat>

namespace Math
{
	typedef Vector2    Vec2;
	typedef Vector3    Vec3;
	typedef Vector4    Vec4;
	typedef Matrix3    Mat3;
	typedef Matrix4    Mat4;
	typedef Quaternion Quat;

	namespace
	{
		const uint I = 0;
		const uint J = 1;
		const uint H = 2;

		void ClampAngle(real* angle)
		{
			while (*angle < -Math::cPi)
			{
				*angle += Math::cTwoPi;
			}
			while (*angle > Math::cPi)
			{
				*angle -= Math::cTwoPi;
			}
		}

	} // namespace

	///Creates a skew symmetric matrix from the given 3D vector. Multiplying a 
	///vector by this matrix is equivalent to the cross product using the input 
	///vector.
	Matrix3 SkewSymmetric(Vec3Param vec3)
	{
		Matrix3 mtx;
		mtx.m22 = mtx.m11 = mtx.m00 = real(0.0);
		mtx.m01 = -vec3[2];
		mtx.m02 = vec3[1];
		mtx.m10 = vec3[2];
		mtx.m12 = -vec3[0];
		mtx.m20 = -vec3[1];
		mtx.m21 = vec3[0];
		return mtx;
	}

	Vector3 ProjectOut(Vec3Param vector, Vec3Param normal)
	{
		real projCoef = Math::Dot(vector, normal);
		return vector - normal * projCoef;
	}

	Vector3 Project(Vec3Param a, Vec3Param axis)
	{
		return a.Project(axis);
	}

	Vector3 Reflect(Vec3Param a, Vec3Param axis)
	{
		return a.Reflect(axis);
	}

	///Converts a quaternion to an axis-angle pair (in radians). Axis is stored in 
	///the Vector4's xyz and the angle is stored in the w.
	Vector4 ToAxisAngle(QuatParam quaternion, EulerOrders::Enum order)
	{
		Vector4 axisAngle;
		ToAxisAngle(quaternion, &axisAngle);
		return axisAngle;
	}

	void ToAxisAngle(QuatParam quaternion, Vec4Ptr axisAngle)
	{
		ErrorIf(axisAngle == NULL, "Math - Null pointer passed for axis-angle pair.");
		Quat tempQuat(Normalized(quaternion));

		axisAngle->w = real(2.0) * Math::ArcCos(tempQuat.w);
		real invSinAngle = Math::Sqrt(real(1.0) - tempQuat.w * tempQuat.w);

		if (Math::Abs(invSinAngle) < real(0.0005))
		{
			invSinAngle = real(1.0);
		}
		else
		{
			invSinAngle = real(1.0) / invSinAngle;
		}
		axisAngle->x = tempQuat.x * invSinAngle;
		axisAngle->y = tempQuat.y * invSinAngle;
		axisAngle->z = tempQuat.z * invSinAngle;
	}

	///Converts a quaternion to an axis-angle pair (in radians).
	void ToAxisAngle(QuatParam quaternion, Vec3Ptr axis, real* radians)
	{
		ErrorIf(axis == NULL, "Math - Null pointer passed for axis.");
		ErrorIf(radians == NULL, "Math - Null pointer passed for radians.");
		Quat tempQuat(Normalized(quaternion));

		*radians = real(2.0) * Math::ArcCos(tempQuat.w);
		real invSinAngle = Math::Sqrt(real(1.0) - tempQuat.w * tempQuat.w);

		if (Math::Abs(invSinAngle) < real(0.0005))
		{
			invSinAngle = real(1.0);
		}
		else
		{
			invSinAngle = real(1.0) / invSinAngle;
		}
		axis->x = tempQuat.x * invSinAngle;
		axis->y = tempQuat.y * invSinAngle;
		axis->z = tempQuat.z * invSinAngle;
	}

	///Convert a 3x3 matrix to a set of Euler angles (in radians). The desired order
	///of the rotations is expected to be in the given Euler angle structure.
	EulerAngles ToEulerAngles(Mat3Param matrix, EulerOrders::Enum order)
	{
		EulerAngles eulerAngles(order);
		ToEulerAngles(matrix, &eulerAngles);
		return eulerAngles;
	}

	void ToEulerAngles(Mat3Param matrix, EulerAnglesPtr eulerAngles)
	{
		ErrorIf(eulerAngles == NULL, "Math - Null pointer passed for Euler angles.");
		uint i, j, k, h, parity, repeated, frame;
		EulerOrder::GetOrder(eulerAngles->Order, i, j, k, h, parity, repeated, frame);
		if (EulerOrders::Yes == repeated)
		{
			real sy = Math::Sqrt(matrix(i, j) * matrix(i, j) +
				matrix(i, k) * matrix(i, k));
			if (sy > real(16.0) * real(FLT_EPSILON))
			{
				(*eulerAngles)[cX] = Math::ArcTan2(matrix(i, j), matrix(i, k));
				(*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
				(*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), -matrix(k, i));
			}
			else
			{
				(*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
				(*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
				(*eulerAngles)[cZ] = real(0.0);
			}
		}
		else
		{
			real cy = Math::Sqrt(matrix(i, i) * matrix(i, i) +
				matrix(j, i) * matrix(j, i));
			if (cy > real(16.0) * real(FLT_EPSILON))
			{
				(*eulerAngles)[cX] = Math::ArcTan2(matrix(k, j), matrix(k, k));
				(*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
				(*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), matrix(i, i));
			}
			else
			{
				(*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
				(*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
				(*eulerAngles)[cZ] = real(0.0);
			}
		}
		if (EulerOrders::Odd == parity)
		{
			(*eulerAngles)[cX] *= real(-1.0);
			(*eulerAngles)[cY] *= real(-1.0);
			(*eulerAngles)[cZ] *= real(-1.0);
		}

		ClampAngle(&((*eulerAngles)[cX]));
		ClampAngle(&((*eulerAngles)[cY]));
		ClampAngle(&((*eulerAngles)[cZ]));

		if (EulerOrders::Rotated == frame)
		{
			Math::Swap((*eulerAngles)[cX], (*eulerAngles)[cZ]);
		}
	}

	///Convert a 4x4 matrix to a set of Euler angles in radians. The desired order
	///of the rotations is expected to be in the given Euler angle structure.
	EulerAngles ToEulerAngles(Mat4Param matrix, EulerOrders::Enum order)
	{
		EulerAngles eulerAngles(order);
		ToEulerAngles(matrix, &eulerAngles);
		return eulerAngles;
	}

	void ToEulerAngles(Mat4Param matrix, EulerAnglesPtr eulerAngles)
	{
		ErrorIf(eulerAngles == NULL, "Math - Null pointer passed for Euler angles.");

		uint i, j, k, h, parity, repeated, frame;
		EulerOrder::GetOrder(eulerAngles->Order, i, j, k, h, parity, repeated, frame);
		if (EulerOrders::Yes == repeated)
		{
			real sy = Math::Sqrt(matrix(i, j) * matrix(i, j) +
				matrix(i, k) * matrix(i, k));
			if (sy > real(16.0) * real(FLT_EPSILON))
			{
				(*eulerAngles)[cX] = Math::ArcTan2(matrix(i, j), matrix(i, k));
				(*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
				(*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), -matrix(k, i));
			}
			else
			{
				(*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
				(*eulerAngles)[cY] = Math::ArcTan2(sy, matrix(i, i));
				(*eulerAngles)[cZ] = real(0.0);
			}
		}
		else
		{
			real cy = Math::Sqrt(matrix(i, i) * matrix(i, i) +
				matrix(j, i) * matrix(j, i));
			if (cy > real(16.0) * real(FLT_EPSILON))
			{
				(*eulerAngles)[cX] = Math::ArcTan2(matrix(k, j), matrix(k, k));
				(*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
				(*eulerAngles)[cZ] = Math::ArcTan2(matrix(j, i), matrix(i, i));
			}
			else
			{
				(*eulerAngles)[cX] = Math::ArcTan2(-matrix(j, k), matrix(j, j));
				(*eulerAngles)[cY] = Math::ArcTan2(-matrix(k, i), cy);
				(*eulerAngles)[cZ] = real(0.0);
			}
		}
		if (EulerOrders::Odd == parity)
		{
			(*eulerAngles)[cX] *= real(-1.0);
			(*eulerAngles)[cY] *= real(-1.0);
			(*eulerAngles)[cZ] *= real(-1.0);
		}

		ClampAngle(&((*eulerAngles)[cX]));
		ClampAngle(&((*eulerAngles)[cY]));
		ClampAngle(&((*eulerAngles)[cZ]));

		if (EulerOrders::Rotated == frame)
		{
			Math::Swap((*eulerAngles)[cX], (*eulerAngles)[cZ]);
		}
	}

	///Convert a quaternion to a set of Euler angles (in radians). The desired order
	///of the rotations is expected to be in the given Euler angle structure.
	EulerAngles ToEulerAngles(QuatParam quaternion, EulerOrders::Enum order)
	{
		EulerAngles eulerAngles(order);
		ToEulerAngles(quaternion, &eulerAngles);
		return eulerAngles;
	}

	void ToEulerAngles(QuatParam quaternion, EulerAnglesPtr eulerAngles)
	{
		ErrorIf(eulerAngles == NULL, "Math - Null pointer passed for Euler angles.");

		Matrix3 matrix;
		ToMatrix3(quaternion, &matrix);
		ToEulerAngles(matrix, eulerAngles);
	}

	/// Converts from Vector3 to Vector2, removing the z component of the Vector3.
	Vector2 ToVector2(Vec3Param v3)
	{
		return Vector2(v3.x, v3.y);
	}

	/// Converts from Vector2 to Vector3, adding the given z component.
	Vector3 ToVector3(Vec2Param v2, real z)
	{
		return Vector3(v2.x, v2.y, z);
	}

	/// Turns the 3d transformation matrix into 2d.
	Matrix3 ProjectXY(Mat4Param mat4)
	{
		Matrix3 mat3;
		mat3.m00 = mat4.m00;
		mat3.m01 = mat4.m01;
		mat3.m02 = mat4.m03; // Pull over the x translation

		mat3.m10 = mat4.m10;
		mat3.m11 = mat4.m11;
		mat3.m12 = mat4.m13; // Pull over the y translation

		mat3.m20 = 0;
		mat3.m21 = 0;
		mat3.m22 = 1;

		return mat3;
	}

	///Converts an axis-angle pair to a 3x3 (in radians). Axis is stored in the
	///Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
	///normalized.
	Matrix3 ToMatrix3(Vec4Param axisAngle)
	{
		Matrix3 matrix;
		ToMatrix3(axisAngle, &matrix);
		return matrix;
	}

	void ToMatrix3(Vec4Param axisAngle, Mat3Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

		real c0 = Math::Cos(axisAngle.w);
		real n1C0 = real(1.0) - c0;
		real s0 = Math::Sin(axisAngle.w);

		//| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
		//| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
		//| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
		matrix->m00 = axisAngle.x * axisAngle.x * n1C0 + c0;
		matrix->m01 = axisAngle.x * axisAngle.y * n1C0 - axisAngle.z * s0;
		matrix->m02 = axisAngle.x * axisAngle.z * n1C0 + axisAngle.y * s0;

		matrix->m10 = axisAngle.x * axisAngle.y * n1C0 + axisAngle.z * s0;
		matrix->m11 = axisAngle.y * axisAngle.y * n1C0 + c0;
		matrix->m12 = axisAngle.y * axisAngle.z * n1C0 - axisAngle.x * s0;

		matrix->m20 = axisAngle.x * axisAngle.z * n1C0 - axisAngle.y * s0;
		matrix->m21 = axisAngle.y * axisAngle.z * n1C0 + axisAngle.x * s0;
		matrix->m22 = axisAngle.z * axisAngle.z * n1C0 + c0;
	}

	///Converts an axis-angle pair to a 3x3 matrix (in radians). Axis is assumed to
	///be normalized.
	Matrix3 ToMatrix3(Vec3Param axis, real radians)
	{
		Matrix3 matrix;
		ToMatrix3(axis, radians, &matrix);
		return matrix;
	}

	void ToMatrix3(Vec3Param axis, real radians, Mat3Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

		real c0 = Math::Cos(radians);
		real n1C0 = real(1.0) - c0;
		real s0 = Math::Sin(radians);

		//| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
		//| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
		//| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
		matrix->m00 = axis.x * axis.x * n1C0 + c0;
		matrix->m01 = axis.x * axis.y * n1C0 - axis.z * s0;
		matrix->m02 = axis.x * axis.z * n1C0 + axis.y * s0;

		matrix->m10 = axis.x * axis.y * n1C0 + axis.z * s0;
		matrix->m11 = axis.y * axis.y * n1C0 + c0;
		matrix->m12 = axis.y * axis.z * n1C0 - axis.x * s0;

		matrix->m20 = axis.x * axis.z * n1C0 - axis.y * s0;
		matrix->m21 = axis.y * axis.z * n1C0 + axis.x * s0;
		matrix->m22 = axis.z * axis.z * n1C0 + c0;
	}

	///Convert a set of Euler angles to a 3x3 matrix (in radians).
	Matrix3 ToMatrix3(EulerAnglesParam eulerAngles)
	{
		Matrix3 matrix;
		ToMatrix3(eulerAngles, &matrix);
		return matrix;
	}

	void ToMatrix3(EulerAnglesParam eulerAngles, Mat3Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

		real angles[3] = { eulerAngles[0], eulerAngles[1], eulerAngles[2] };
		uint i, j, k, h, parity, repeated, frame;
		EulerOrder::GetOrder(eulerAngles.Order, i, j, k, h, parity, repeated, frame);
		if (EulerOrders::Rotated == frame)
		{
			Math::Swap(angles[cX], angles[cZ]);
		}
		if (EulerOrders::Odd == parity)
		{
			angles[cX] *= real(-1.0);
			angles[cY] *= real(-1.0);
			angles[cZ] *= real(-1.0);
		}

		real t[3], c[3], s[3];
		t[I] = angles[cX];      t[J] = angles[cY];      t[H] = angles[cZ];
		c[I] = Math::Cos(t[I]); c[J] = Math::Cos(t[J]); c[H] = Math::Cos(t[H]);
		s[I] = Math::Sin(t[I]); s[J] = Math::Sin(t[J]); s[H] = Math::Sin(t[H]);

		const real cc = c[I] * c[H];
		const real cs = c[I] * s[H];
		const real sc = s[I] * c[H];
		const real ss = s[I] * s[H];
		if (EulerOrders::Yes == repeated)
		{
			(*matrix)(i, i) = c[J];
			(*matrix)(i, j) = c[J] * s[I];
			(*matrix)(i, k) = c[J] * c[I];

			(*matrix)(j, i) = c[J] * s[H];
			(*matrix)(j, j) = -c[J] * ss + cc;
			(*matrix)(j, k) = -c[J] * cs - sc;

			(*matrix)(k, i) = -c[J] * c[H];
			(*matrix)(k, j) = c[J] * sc + cs;
			(*matrix)(k, k) = c[J] * cc - ss;
		}
		else
		{
			(*matrix)(i, i) = c[J] * c[H];
			(*matrix)(j, i) = c[J] * s[H];
			(*matrix)(k, i) = -s[J];

			(*matrix)(i, j) = s[J] * sc - cs;
			(*matrix)(j, j) = s[J] * ss + cc;
			(*matrix)(k, j) = c[J] * s[I];

			(*matrix)(i, k) = s[J] * cc + ss;
			(*matrix)(j, k) = s[J] * cs - sc;
			(*matrix)(k, k) = c[J] * c[I];
		}
	}

	///Convert a 4x4 matrix to a 3x3 matrix. Simply copies the 4x4 matrix's upper 
	///3x3 matrix (rotation & scale) to the 3x3 matrix.
	Matrix3 ToMatrix3(Mat4Param matrix)
	{
		Matrix3 mat3;
		ToMatrix3(matrix, &mat3);
		return mat3;
	}

	void ToMatrix3(Mat4Param mat4, Mat3Ptr mat3)
	{
		ErrorIf(mat3 == NULL, "Math - Null pointer passed for matrix.");

		//First "cross" components
		mat3->m00 = mat4.m00;
		mat3->m01 = mat4.m01;
		mat3->m02 = mat4.m02;

		//Second "cross" components
		mat3->m10 = mat4.m10;
		mat3->m11 = mat4.m11;
		mat3->m12 = mat4.m12;

		//Third "cross" components
		mat3->m20 = mat4.m20;
		mat3->m21 = mat4.m21;
		mat3->m22 = mat4.m22;
	}

	///Converts a quaternion to a 3x3 rotation matrix (in radians).
	Matrix3 ToMatrix3(QuatParam quaternion)
	{
		Matrix3 matrix;
		ToMatrix3(quaternion, &matrix);
		return matrix;
	}

	void ToMatrix3(QuatParam quaternion, Mat3Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

		//     |       2     2                                |
		//     | 1 - 2Y  - 2Z    2XY - 2ZW      2XZ + 2YW     |
		//     |                                              |
		//     |                       2     2                |
		// M = | 2XY + 2ZW       1 - 2X  - 2Z   2YZ - 2XW     |
		//     |                                              |
		//     |                                      2     2 |
		//     | 2XZ - 2YW       2YZ + 2XW      1 - 2X  - 2Y  |
		//     |                                              |

		real xx = quaternion.x * quaternion.x;
		real xy = quaternion.x * quaternion.y;
		real xz = quaternion.x * quaternion.z;
		real yy = quaternion.y * quaternion.y;
		real yz = quaternion.y * quaternion.z;
		real zz = quaternion.z * quaternion.z;
		real zw = quaternion.z * quaternion.w;
		real yw = quaternion.y * quaternion.w;
		real xw = quaternion.x * quaternion.w;

		matrix->m00 = real(1.0) - real(2.0) * (yy + zz);
		matrix->m01 = real(2.0) * (xy - zw);
		matrix->m02 = real(2.0) * (xz + yw);

		matrix->m10 = real(2.0) * (xy + zw);
		matrix->m11 = real(1.0) - real(2.0) * (xx + zz);
		matrix->m12 = real(2.0) * (yz - xw);

		matrix->m20 = real(2.0) * (xz - yw);
		matrix->m21 = real(2.0) * (yz + xw);
		matrix->m22 = real(1.0) - real(2.0) * (xx + yy);
	}

	Matrix3 ToMatrix3(Vec3Param facing)
	{
		Vec3 up, right;
		Math::GenerateOrthonormalBasis(facing, &right, &up);
		return ToMatrix3(facing, up, right);
	}

	Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up)
	{
		//Get the right vector
		Vec3 right = Math::Cross(facing, up);
		return ToMatrix3(facing, up, right);
	}

	Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up, Vec3Param right)
	{
		Matrix3 mat;
		mat.SetBasis(0, right);
		mat.SetBasis(1, up);
		mat.SetBasis(2, -facing);
		return mat;
	}

	///Convert a set of Euler angles to a 4x4 matrix (in radians).
	Matrix4 ToMatrix4(EulerAnglesParam eulerAngles)
	{
		Matrix4 matrix;
		ToMatrix4(eulerAngles, &matrix);
		return matrix;
	}

	void ToMatrix4(EulerAnglesParam eulerAngles, Mat4Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

		real angles[3] = { eulerAngles[0], eulerAngles[1], eulerAngles[2] };
		uint i, j, k, h, parity, repeated, frame;
		EulerOrder::GetOrder(eulerAngles.Order, i, j, k, h, parity, repeated, frame);
		if (EulerOrders::Rotated == frame)
		{
			Math::Swap(angles[cX], angles[cZ]);
		}
		if (EulerOrders::Odd == parity)
		{
			angles[cX] *= real(-1.0);
			angles[cY] *= real(-1.0);
			angles[cZ] *= real(-1.0);
		}
		real t[3], c[3], s[3];
		t[I] = angles[cX];       t[J] = angles[cY];       t[H] = angles[cZ];
		c[I] = Math::Cos(t[I]); c[J] = Math::Cos(t[J]); c[H] = Math::Cos(t[H]);
		s[I] = Math::Sin(t[I]); s[J] = Math::Sin(t[J]); s[H] = Math::Sin(t[H]);
		real cc = c[I] * c[H];
		real cs = c[I] * s[H];
		real sc = s[I] * c[H];
		real ss = s[I] * s[H];
		if (EulerOrders::Yes == repeated)
		{
			(*matrix)(i, i) = c[J];
			(*matrix)(i, j) = c[J] * s[I];
			(*matrix)(i, k) = c[J] * c[I];

			(*matrix)(j, i) = c[J] * s[H];
			(*matrix)(j, j) = -c[J] * ss + cc;
			(*matrix)(j, k) = -c[J] * cs - sc;

			(*matrix)(k, i) = -c[J] * c[H];
			(*matrix)(k, j) = c[J] * sc + cs;
			(*matrix)(k, k) = c[J] * cc - ss;
		}
		else
		{
			(*matrix)(i, i) = c[J] * c[H];
			(*matrix)(j, i) = c[J] * s[H];
			(*matrix)(k, i) = -s[J];

			(*matrix)(i, j) = s[J] * sc - cs;
			(*matrix)(j, j) = s[J] * ss + cc;
			(*matrix)(k, j) = c[J] * s[I];

			(*matrix)(i, k) = s[J] * cc + ss;
			(*matrix)(j, k) = s[J] * cs - sc;
			(*matrix)(k, k) = c[J] * c[I];
		}
		matrix->m03 = real(0.0);  matrix->m13 = real(0.0);  matrix->m23 = real(0.0);
		matrix->m30 = real(0.0);  matrix->m31 = real(0.0);  matrix->m32 = real(0.0);
		matrix->m33 = real(1.0);
	}

	///Convert a 3x3 matrix to a 4x4 matrix. Simply copies the 3x3 matrix's values
	///into the rotational part of the 4x4 matrix.
	Matrix4 ToMatrix4(Mat3Param matrix)
	{
		Matrix4 matrix4;
		ToMatrix4(matrix, &matrix4);
		return matrix4;
	}

	void ToMatrix4(Mat3Param mat3, Mat4Ptr mat4)
	{
		ErrorIf(mat4 == NULL, "Math - Null pointer passed for matrix.");

		//First "cross" components
		mat4->m00 = mat3.m00;
		mat4->m01 = mat3.m01;
		mat4->m02 = mat3.m02;
		mat4->m03 = real(0.0);

		//Second "cross" components
		mat4->m10 = mat3.m10;
		mat4->m11 = mat3.m11;
		mat4->m12 = mat3.m12;
		mat4->m13 = real(0.0);

		//Third "cross" components
		mat4->m20 = mat3.m20;
		mat4->m21 = mat3.m21;
		mat4->m22 = mat3.m22;
		mat4->m23 = real(0.0);

		//Fourth "cross" components
		mat4->m30 = real(0.0);
		mat4->m31 = real(0.0);
		mat4->m32 = real(0.0);
		mat4->m33 = real(1.0);
	}

	///Converts a quaternion to a 4x4 rotation matrix (in radians).
	Matrix4 ToMatrix4(QuatParam quaternion)
	{
		Matrix4 matrix;
		ToMatrix4(quaternion, &matrix);
		return matrix;
	}

	void ToMatrix4(QuatParam quaternion, Mat4Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Math - Null pointer passed for matrix.");

		//     |       2     2                                |
		//     | 1 - 2Y  - 2Z    2XY - 2ZW      2XZ + 2YW     |
		//     |                                              |
		//     |                       2     2                |
		// M = | 2XY + 2ZW       1 - 2X  - 2Z   2YZ - 2XW     |
		//     |                                              |
		//     |                                      2     2 |
		//     | 2XZ - 2YW       2YZ + 2XW      1 - 2X  - 2Y  |
		//     |                                              |

		real xx = quaternion.x * quaternion.x;
		real xy = quaternion.x * quaternion.y;
		real xz = quaternion.x * quaternion.z;
		real yy = quaternion.y * quaternion.y;
		real yz = quaternion.y * quaternion.z;
		real zz = quaternion.z * quaternion.z;
		real zw = quaternion.z * quaternion.w;
		real yw = quaternion.y * quaternion.w;
		real xw = quaternion.x * quaternion.w;

		matrix->m00 = real(1.0) - real(2.0) * (yy + zz);
		matrix->m01 = real(2.0) * (xy - zw);
		matrix->m02 = real(2.0) * (xz + yw);
		matrix->m03 = real(0.0);

		matrix->m10 = real(2.0) * (xy + zw);
		matrix->m11 = real(1.0) - real(2.0) * (xx + zz);
		matrix->m12 = real(2.0) * (yz - xw);
		matrix->m13 = real(0.0);

		matrix->m20 = real(2.0) * (xz - yw);
		matrix->m21 = real(2.0) * (yz + xw);
		matrix->m22 = real(1.0) - real(2.0) * (xx + yy);
		matrix->m23 = real(0.0);

		matrix->m30 = real(0.0);
		matrix->m31 = real(0.0);
		matrix->m32 = real(0.0);
		matrix->m33 = real(1.0);
	}

	///Converts an axis-angle pair to a quaternion (in radians). Axis is stored in
	///the Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
	///normalized.
	Quat ToQuaternion(Vec4Param axisAngle)
	{
		Quat quaternion;
		ToQuaternion(axisAngle, &quaternion);
		return quaternion;
	}

	void ToQuaternion(Vec4Param axisAngle, QuatPtr quaternion)
	{
		ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

		real alpha = axisAngle.w * real(0.5);
		real sinAlpha = Math::Sin(alpha);

		quaternion->x = axisAngle.x * sinAlpha;
		quaternion->y = axisAngle.y * sinAlpha;
		quaternion->z = axisAngle.z * sinAlpha;
		quaternion->w = Math::Cos(alpha);
	}

	///Converts an axis-angle pair to a quaternion (in radians). Axis is assumed to
	///be normalized.
	Quaternion ToQuaternion(Vec3Param axis, real radians)
	{
		Quat quaternion;
		ToQuaternion(axis, radians, &quaternion);
		return quaternion;
	}

	void ToQuaternion(Vec3Param axis, real radians, QuatPtr quaternion)
	{
		ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

		real alpha = radians * real(0.5);
		real sinAlpha = Math::Sin(alpha);

		quaternion->x = axis.x * sinAlpha;
		quaternion->y = axis.y * sinAlpha;
		quaternion->z = axis.z * sinAlpha;
		quaternion->w = Math::Cos(alpha);
	}

	///Convert a set of Euler angles to a quaternion (in radians).
	Quat ToQuaternion(EulerAnglesParam eulerAngles)
	{
		Quat quaternion;
		ToQuaternion(eulerAngles, &quaternion);
		return quaternion;
	}

	void ToQuaternion(EulerAnglesParam eulerAngles, QuatPtr quaternion)
	{
		ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

		real angles[3] = { eulerAngles[cX], eulerAngles[cY], eulerAngles[cZ] };
		uint i, j, k, h, parity, repeated, frame;
		EulerOrder::GetOrder(eulerAngles.Order, i, j, k, h, parity, repeated, frame);
		if (EulerOrders::Rotated == frame)
		{
			Math::Swap(angles[cX], angles[cZ]);
		}

		if (EulerOrders::Odd == parity)
		{
			angles[cY] *= real(-1.0);
		}

		real t[3], c[3], s[3];
		t[I] = angles[cX] * real(0.5); c[I] = Math::Cos(t[I]); s[I] = Math::Sin(t[I]);
		t[J] = angles[cY] * real(0.5); c[J] = Math::Cos(t[J]); s[J] = Math::Sin(t[J]);
		t[H] = angles[cZ] * real(0.5); c[H] = Math::Cos(t[H]); s[H] = Math::Sin(t[H]);

		const real cc = c[I] * c[H];
		const real cs = c[I] * s[H];
		const real sc = s[I] * c[H];
		const real ss = s[I] * s[H];
		if (EulerOrders::Yes == repeated)
		{
			angles[i] = c[J] * (cs + sc);
			angles[j] = s[J] * (cc + ss);
			angles[k] = s[J] * (cs - sc);
			quaternion->w = c[J] * (cc - ss);
		}
		else
		{
			angles[i] = c[J] * sc - s[J] * cs;
			angles[j] = c[J] * ss + s[J] * cc;
			angles[k] = c[J] * cs - s[J] * sc;
			quaternion->w = c[J] * cc + s[J] * ss;
		}
		if (EulerOrders::Odd == parity)
		{
			angles[j] *= real(-1.0);
		}
		quaternion->x = angles[cX];
		quaternion->y = angles[cY];
		quaternion->z = angles[cZ];
	}

	///Converts a 3x3 matrix to a quaternion (in radians).
	Quat ToQuaternion(Mat3Param matrix)
	{
		Quat quaternion;
		ToQuaternion(matrix, &quaternion);
		return quaternion;
	}

	void ToQuaternion(Mat3Param matrix, QuatPtr quaternion)
	{
		ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

		if (matrix.m00 + matrix.m11 + matrix.m22 > real(0.0))
		{
			real t = matrix.m00 + matrix.m11 + matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[3] = s * t;
			(*quaternion)[2] = (matrix.m10 - matrix.m01) * s;
			(*quaternion)[1] = (matrix.m02 - matrix.m20) * s;
			(*quaternion)[0] = (matrix.m21 - matrix.m12) * s;
		}
		else if (matrix.m00 > matrix.m11 && matrix.m00 > matrix.m22)
		{
			real t = matrix.m00 - matrix.m11 - matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[0] = s * t;
			(*quaternion)[1] = (matrix.m10 + matrix.m01) * s;
			(*quaternion)[2] = (matrix.m02 + matrix.m20) * s;
			(*quaternion)[3] = (matrix.m21 - matrix.m12) * s;
		}
		else if (matrix.m11 > matrix.m22)
		{
			real t = -matrix.m00 + matrix.m11 - matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[1] = s * t;
			(*quaternion)[0] = (matrix.m10 + matrix.m01) * s;
			(*quaternion)[3] = (matrix.m02 - matrix.m20) * s;
			(*quaternion)[2] = (matrix.m21 + matrix.m12) * s;
		}
		else
		{
			real t = -matrix.m00 - matrix.m11 + matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[2] = s * t;
			(*quaternion)[3] = (matrix.m10 - matrix.m01) * s;
			(*quaternion)[0] = (matrix.m02 + matrix.m20) * s;
			(*quaternion)[1] = (matrix.m21 + matrix.m12) * s;
		}
	}

	///Converts a 4x4 matrix to a quaternion (in radians).
	Quat ToQuaternion(Mat4Param matrix)
	{
		Quat quaternion;
		ToQuaternion(matrix, &quaternion);
		return quaternion;
	}

	void ToQuaternion(Mat4Param matrix, QuatPtr quaternion)
	{
		ErrorIf(quaternion == NULL, "Math - Null pointer passed for quaternion.");

		if (matrix.m00 + matrix.m11 + matrix.m22 > real(0.0))
		{
			real t = matrix.m00 + matrix.m11 + matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[3] = s * t;
			(*quaternion)[2] = (matrix.m10 - matrix.m01) * s;
			(*quaternion)[1] = (matrix.m02 - matrix.m20) * s;
			(*quaternion)[0] = (matrix.m21 - matrix.m12) * s;
		}
		else if (matrix.m00 > matrix.m11 && matrix.m00 > matrix.m22)
		{
			real t = matrix.m00 - matrix.m11 - matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[0] = s * t;
			(*quaternion)[1] = (matrix.m10 + matrix.m01) * s;
			(*quaternion)[2] = (matrix.m02 + matrix.m20) * s;
			(*quaternion)[3] = (matrix.m21 - matrix.m12) * s;
		}
		else if (matrix.m11 > matrix.m22)
		{
			real t = -matrix.m00 + matrix.m11 - matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[1] = s * t;
			(*quaternion)[0] = (matrix.m10 + matrix.m01) * s;
			(*quaternion)[3] = (matrix.m02 - matrix.m20) * s;
			(*quaternion)[2] = (matrix.m21 + matrix.m12) * s;
		}
		else
		{
			real t = -matrix.m00 - matrix.m11 + matrix.m22 + real(1.0);
			real s = Math::Rsqrt(t) * real(0.5);

			(*quaternion)[2] = s * t;
			(*quaternion)[3] = (matrix.m10 - matrix.m01) * s;
			(*quaternion)[0] = (matrix.m02 + matrix.m20) * s;
			(*quaternion)[1] = (matrix.m21 + matrix.m12) * s;
		}
	}

	Quaternion ToQuaternion(Vec3Param facing, Vec3Param up)
	{
		return ToQuaternion(ToMatrix3(facing, up));
	}

	Quaternion ToQuaternion(Vec3Param facing, Vec3Param up, Vec3Param right)
	{
		return ToQuaternion(ToMatrix3(facing, up, right));
	}

	Quaternion ToQuaternion(Vec3Param eulerVector)
	{
		return ToQuaternion(EulerAngles(eulerVector.x, eulerVector.y, eulerVector.z, Math::EulerOrders::XYZs));
	}

	Quaternion ToQuaternion(real x, real y, real z)
	{
		Mat3 rotMat = ToMatrix3(EulerAngles(x, y, z, Math::EulerOrders::XYZs));
		return ToQuaternion(rotMat);
	}

	Quaternion RotationQuaternionBetween(Vec3Param start, Vec3Param end)
	{
		Vec3 a = start;
		a.AttemptNormalize();
		Vec3 b = end;
		b.AttemptNormalize();
		Vec3 axis = Math::Cross(a, b);
		float length = axis.AttemptNormalize();
		float dot = Dot(a, b);
		float angle = Math::ArcCos(Dot(a, b));
		if (length == 0)
			return Quat::cIdentity;

		return ToQuaternion(axis, angle);
	}

	///Generates a set of orthonormal vectors from the given vectors, modifying u 
	///and v.
	void GenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v)
	{
		ErrorIf(u == NULL, "Math - Null pointer passed for vector U.");
		ErrorIf(v == NULL, "Math - Null pointer passed for vector V.");

		if ((Math::Abs(w.x) >= Math::Abs(w.y)) && (Math::Abs(w.x) >= Math::Abs(w.z)))
		{
			u->x = -w.y;
			u->y = w.x;
			u->z = real(0.0);
		}
		else
		{
			u->x = real(0.0);
			u->y = w.z;
			u->z = -w.y;
		}
		Normalize(u);
		*v = Cross(w, *u);
		Normalize(v);
	}

	///Generates a set of orthonormal vectors from the given vectors while using 
	///debug checks, modifies u and v
	void DebugGenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v)
	{
		ErrorIf(u == NULL, "Math - Null pointer passed for vector U.");
		ErrorIf(v == NULL, "Math - Null pointer passed for vector V.");

		if ((Math::Abs(w.x) >= Math::Abs(w.y)) && (Math::Abs(w.x) >= Math::Abs(w.z)))
		{
			u->x = -w.y;
			u->y = w.x;
			u->z = real(0.0);
		}
		else
		{
			u->x = real(0.0);
			u->y = w.z;
			u->z = -w.y;
		}
		AttemptNormalize(u);
		*v = Cross(w, *u);
		AttemptNormalize(v);
	}

	///Perform the dot product with the specified basis vector of the 3x3 matrix and
	///the given vector.
	real BasisNDot(Mat3Param matrix, uint basisIndex, Vec3Param vector)
	{
		return Dot(vector, matrix.Basis(basisIndex));
	}

	///Perform the dot product with the specified basis vector of the 3x3 matrix and
	///the given vector.
	real BasisNDot(Mat4Param matrix, uint basisIndex, Vec4Param vector)
	{
		return Dot(vector, matrix.Basis(basisIndex));
	}

	///Perform the dot product with the basis vector of the 3x3 matrix that 
	///represents the x-axis (if the matrix is pure rotation) and the given vector.
	real BasisXDot(Mat3Param matrix, Vec3Param vector)
	{
		return Dot(vector, matrix.BasisX());
	}

	///Perform the dot product with the basis vector of the 3x3 matrix that 
	///represents the y-axis (if the matrix is pure rotation) and the given vector.
	real BasisYDot(Mat3Param matrix, Vec3Param vector)
	{
		return Dot(vector, matrix.BasisY());
	}

	///Perform the dot product with the basis vector of the 3x3 matrix that 
	///represents the z-axis (if the matrix is pure rotation) and the given vector.
	real BasisZDot(Mat3Param matrix, Vec3Param vector)
	{
		return Dot(vector, matrix.BasisZ());
	}

	///Perform the dot product with the basis vector of the 4x4 matrix that 
	///represents the x-axis (if the matrix is pure rotation) and the given vector.
	real BasisXDot(Mat4Param matrix, Vec4Param vector)
	{
		return Dot(vector, matrix.BasisX());
	}

	///Perform the dot product with the basis vector of the 4x4 matrix that 
	///represents the y-axis (if the matrix is pure rotation) and the given vector.
	real BasisYDot(Mat4Param matrix, Vec4Param vector)
	{
		return Dot(vector, matrix.BasisY());
	}

	///Perform the dot product with the basis vector of the 4x4 matrix that 
	///represents the z-axis (if the matrix is pure rotation) and the given vector.
	real BasisZDot(Mat4Param matrix, Vec4Param vector)
	{
		return Dot(vector, matrix.BasisZ());
	}

	///Converts a 32-bit float into a compressed 16-bit floating point value;
	///referenced from Insomniac Games math library.
	half ToHalf(float value)
	{
		//------------------------------------------------------------------ Constants
		//Base value for the exponent part of the 32-bit floating point number
		const s32 cFloatExponentBase = 127;

		//Base value for the exponent part of the 16-bit floating point number
		const s32 cHalfExponentBase = 15;

		//Number of bits needed to move the float's sign to the half's sign spot
		const s32 cSignShift = 16;

		//Mask to only have the shifted sign portion of the float
		const s32 cShiftedSignMask = 0x00008000;

		//Number of bits needed to move the float's exponent bits such that they 
		//occupy
		const s32 cExponentShift = 23;

		//Mask to only have the shifted exponent portion of the float
		const s32 cShiftedExponentMask = 0x000000FF;

		//The value to subtract from the exponent portion to map it to the 4-bit 
		//format
		const s32 cExponentBaseChange = cFloatExponentBase - cHalfExponentBase;

		//Mask to only have the mantissa portion of the float
		const s32 cMantissaMask = 0x007FFFFF;

		//Bit that would be set if the mantissa overflowed into the exponent portion
		const s32 cMantissaOverflowBit = 0x00800000;

		//Bit used to check if the mantissa needs to be rounded up or not, checks the
		//least significant bit of the final shifted mantissa
		const s32 cMantissaRoundingBit = 0x00001000;

		//Value used when rounding floating point values up
		const s32 cMantissaRoundingValue = 0x00002000;

		//Number of bits needed to move the mantissa bits in order for them to fit in
		//the half-float format
		const s32 cMantissaShift = 13;

		//Value of the fully shifted exponent bit-combination (all bits are set)
		const s32 cFullShiftedExponent = 0x0000008F;

		//Used to check if a float is set to infinity
		const s32 cInfinityCheck = 0x0000000;

		//Value, for half-floats, of all the exponent bits set
		const s32 cFullExponent = 0x00007C00;

		//Redundant value used for clarification
		const s32 cZeroMantissa = 0x00000000;
		//----------------------------------------------------------------------------

		//Bit interpretation of the floating point value
		s32 v = *reinterpret_cast<s32*>(&value);

		//Sign
		s32 s = (v >> cSignShift) & cShiftedSignMask;

		//Exponent
		s32 e = ((v >> cExponentShift) & cShiftedExponentMask) - cExponentBaseChange;

		//Mantissa
		s32 m = v & cMantissaMask;

		//Handle values in the range [0,1] (negative exponent)
		if (e <= 0)
		{
			//If the exponent part is too small then treat value as 0
			if (e < -10)
			{
				return 0;
			}

			//Since the number is so small, attempt to round it
			m = (m | cMantissaOverflowBit) >> (1 - e);

			//Check to see if rounding is needed
			if (m & cMantissaRoundingBit)
			{
				m += cMantissaRoundingValue;
			}

			return static_cast<half>(s | (m >> cMantissaShift));
		}
		//Handle infinity and NaN
		else if (e == cFullShiftedExponent)
		{
			//Result is either positive or negative infinity
			if (m == cInfinityCheck)
			{
				return static_cast<half>(s | cFullExponent | cZeroMantissa);
			}
			//Result is NaN
			else
			{
				return static_cast<half>(s | cFullExponent | (m >> cMantissaShift));
			}
		}
		else
		{
			//Check if rounding is needed
			if (m & cMantissaRoundingBit)
			{
				m += cMantissaRoundingValue;

				//Check if the rounding has overflowed into the exponent part
				if (m & cMantissaOverflowBit)
				{
					m = 0;
					e += 1;
				}
			}

			//Check to see if all of the exponent bits are set
			if (e > 30)
			{
				//Returns a signed infinity
				return static_cast<half>(s | (e << 10) | (m >> cMantissaShift));
			}

			//Normal half
			return static_cast<half>(s | (e << 10) | (m >> cMantissaShift));
		}
	}

	///Converts a 16-bit compressed floating point value back into a 32-bit float;
	///referenced from Insomniac Games math library.
	float ToFloat(half value)
	{
		//------------------------------------------------------------------ Constants
		//Base value for the exponent part of the 32-bit floating point number
		const s32 cFloatExponentBase = 127;

		//Base value for the exponent part of the 16-bit floating point number
		const s32 cHalfExponentBase = 15;

		//The value to subtract from the exponent portion to map it to the 4-bit 
		//format
		const s32 cExponentBaseChange = cFloatExponentBase - cHalfExponentBase;

		//Bit mask to ensure that the shifted sign is the only value in the bit field
		s32 cShiftedSignMask = 0x00000001;

		//Bit mask to ensure that the shifted exponent is the only value in the bit
		//field
		s32 cShiftedExponentMask = 0x0000001F;

		//Bit mask to ensure that the mantissa is the only value in the bit field
		s32 cMantissaMask = 0x000003FF;

		//Bit mask to check against the most significant bit in the mantissa
		s32 cMantissaMsbMask = 0x00000400;

		//Bit mask to ensure all the exponent bits are set
		s32 cFullExponent = 0x7F800000;
		//----------------------------------------------------------------------------

		//Sign
		s32 s = (value >> 15) & cShiftedSignMask;

		//Exponent
		s32 e = (value >> 10) & cShiftedExponentMask;

		//Mantissa
		s32 m = value & cMantissaMask;

		//No exponent, denormalized OR zero
		if (e == 0)
		{
			//Positive or negative zero
			if (m == 0)
			{
				uint result = s << 31;
				return *reinterpret_cast<float*>(&result);
			}
			//Denormalized number
			else
			{
				//Continuously move the mantissa until the most significant bit of the
				//mantissa has been set
				while (!(m & cMantissaMsbMask))
				{
					m <<= 1;
					e -= 1;
				}
				e += 1;

				//Make sure the most significant bit of the mantissa is cleared
				m &= ~cMantissaMsbMask;
			}
		}
		//Full exponent
		else if (e == 31)
		{
			//Positive or negative infinity
			if (m == 0)
			{
				uint result = (s << 31) | cFullExponent;
				return *reinterpret_cast<float*>(&result);
			}
			//NaN
			else
			{
				uint result = (s << 31) | cFullExponent | (m << 13);
				return *reinterpret_cast<float*>(&result);
			}
		}

		//Normalized number
		e += cExponentBaseChange;
		m <<= 13;

		//Create the float
		uint result = (s << 31) | (e << 23) | m;
		return *reinterpret_cast<float*>(&result);
	}

	//----------------------------------------------------------- Rotation Functions
	real Angle(Vec2Param a, Vec2Param b)
	{
		real dot = Dot(a, b);
		dot = Math::Clamp(dot, real(-1.0), real(1.0));
		return Math::ArcCos(dot);
	}

	real Angle(Vec3Param a, Vec3Param b)
	{
		real dot = Dot(a, b);
		dot = Math::Clamp(dot, real(-1.0), real(1.0));
		return Math::ArcCos(dot);
	}

	real Angle(QuatParam a, QuatParam b)
	{
		real dot = Dot(a, b);
		dot = Math::Clamp(dot, real(-1.0), real(1.0));
		//quaternions are a 2-1 mapping, so we could get a rotation that is 400 degrees
		//instead of 40 degrees, to fix this we can simply abs the dot product. This works
		//out because we convert our initial [0,360] range to [0,180] then scale up by 2 (2-1 mapping).
		real correctedDot = Math::Abs(dot);
		real angle = real(2.0) * Math::ArcCos(correctedDot);
		return angle;
	}

	real Angle2D(Vec3Param a)
	{
		return ArcTan2(a.y, a.x);
	}

	Vector2 Slerp(Vec2Param start, Vec2Param end, real t)
	{
		real dot = Dot(start, end);
		real theta = Math::ArcCos(dot) * t;
		Vector2 relativeVec = end - start * dot;
		relativeVec.Normalize();
		return (start * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
	}

	Vector2 SafeSlerp(Vec2Param start, Vec2Param end, real t)
	{
		real dot = Dot(start, end);
		real theta = Math::ArcCos(dot) * t;

		Vector2 relativeVec;
		//if end is the negative of start, no direction is better to interpolate than
		//another, so generate a random perpendicular vector to rotate towards
		if (dot == -real(1.0))
			relativeVec = Vec2(-start.y, start.x);
		else
			relativeVec = end - start * dot;
		//attempt normalize (zero vectors and start == end)
		relativeVec.AttemptNormalize();
		return (start * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
	}

	Vector3 Slerp(Vec3Param start, Vec3Param end, real t)
	{
		real dot = Dot(start, end);
		real theta = Math::ArcCos(dot) * t;
		Vector3 relativeVec = end - start * dot;
		relativeVec.Normalize();
		return (start * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
	}

	Vector3 SafeSlerp(Vec3Param start, Vec3Param end, real t)
	{
		Vec3 normalizedStart = start.AttemptNormalized();
		Vec3 normalizedEnd = end.AttemptNormalized();

		real dot = Dot(normalizedStart, normalizedEnd);
		//Safeguard for non-normalized and slight floating point errors
		dot = Math::Clamp(dot, real(-1.0), real(1.0));
		real theta = Math::ArcCos(dot) * t;

		Vector3 relativeVec;
		//if end is the negative of start, no direction is better to interpolate than
		//another, so generate a random perpendicular vector to rotate towards
		if (dot == -real(1.0))
		{
			//unfortunately, a 3d perpendicular vector is not as simple, so try doing the 2d
			//perpendicular with [x,y], but if x is zero then switch to [y,z] instead
			if (normalizedStart.x != real(0.0))
				relativeVec = Vec3(-normalizedStart.y, normalizedStart.x, normalizedStart.z);
			else
				relativeVec = Vec3(normalizedStart.x, -normalizedStart.z, normalizedStart.y);
		}
		else
			relativeVec = normalizedEnd - normalizedStart * dot;
		//attempt normalize (zero vectors and start == end)
		relativeVec.AttemptNormalize();
		return (normalizedStart * Math::Cos(theta)) + (relativeVec * Math::Sin(theta));
	}

	template<typename type>
	type GenericTowards(const type& a, const type& b, real maxAngle)
	{
		const real cAngleEpsilon = real(0.0000001);

		real angle = Angle(a, b);

		if (angle > Math::cPi)
		{
			angle -= Math::cTwoPi;
		}

		angle = Math::Abs(angle);
		if (angle > cAngleEpsilon)
		{
			real t = maxAngle / angle;
			if (t > real(1.0))
			{
				t = real(1.0);
			}
			return Slerp(a, b, t);
		}
		else
		{
			return b;
		}
	}

	template<typename type>
	type SafeGenericTowards(const type& a, const type& b, real maxAngle)
	{
		const real cAngleEpsilon = real(0.0000001);

		real angle = Angle(a, b);

		if (angle > Math::cPi)
		{
			angle -= Math::cTwoPi;
		}

		angle = Math::Abs(angle);
		if (angle > cAngleEpsilon)
		{
			real t = maxAngle / angle;
			if (t > real(1.0))
			{
				t = real(1.0);
			}
			return SafeSlerp(a, b, t);
		}
		else
		{
			return b;
		}
	}

	Vector2 RotateTowards(Vec2Param a, Vec2Param b, real maxAngle)
	{
		Vec2 an = a.Normalized();
		Vec2 bn = b.Normalized();
		return GenericTowards(an, bn, maxAngle);
	}

	Vector2 SafeRotateTowards(Vec2Param a, Vec2Param b, real maxAngle)
	{
		Vec2 an = a;
		Vec2 bn = b;
		an.AttemptNormalize();
		bn.AttemptNormalize();
		return SafeGenericTowards(an, bn, maxAngle);
	}

	Vector3 RotateTowards(Vec3Param a, Vec3Param b, real maxAngle)
	{
		Vec3 an = a.Normalized();
		Vec3 bn = b.Normalized();
		return GenericTowards(an, bn, maxAngle);
	}

	Vector3 SafeRotateTowards(Vec3Param a, Vec3Param b, real maxAngle)
	{
		Vec3 an = a;
		Vec3 bn = b;
		an.AttemptNormalize();
		bn.AttemptNormalize();
		return SafeGenericTowards(an, bn, maxAngle);
	}

	Quat RotateTowards(QuatParam a, QuatParam b, float maxAngle)
	{
		return GenericTowards(a, b, maxAngle);
	}

	// Get the rotation angle between two vectors (in radians)
	real SignedAngle(Vec3Param a, Vec3Param b, Vec3Param up)
	{
		// Get the right vector
		Vec3 right = Math::Cross(a, up);
		right.AttemptNormalize();

		// Get the forward and right dot products
		real forwardDot = Math::Clamp(Math::Dot(a, b), real(-1.0), real(1.0));
		real rightDot = Math::Clamp(Math::Dot(right, b), real(-1.0), real(1.0));

		// Get the actual angle from the forward dot product
		real finalAngle = Math::ArcCos(forwardDot);

		// If we're actually on the left side...
		if (rightDot > real(0.0))
		{
			// Compute the real final angle given the quadrant it's in (kinda like atan2)
			finalAngle = -finalAngle;
		}

		// Return the finally computed angle
		return finalAngle;
	}

	Vector3 RotateVector(Vec3Param a, Vec3Param axis, real radians)
	{
		Mat3 rot = Math::ToMatrix3(axis, radians);
		return Math::Transform(rot, a);
	}

	Quat EulerDegreesToQuat(Vec3Param eulerDegrees)
	{
		Math::EulerAngles angle(Math::DegToRad(eulerDegrees[0]),
			Math::DegToRad(eulerDegrees[1]),
			Math::DegToRad(eulerDegrees[2]),
			Math::EulerOrders::XYZs);

		return Math::ToQuaternion(angle);
	}

	Vector3 QuatToEulerDegrees(QuatParam rotation)
	{
		Math::EulerAngles angles(rotation, Math::EulerOrders::XYZs);
		Vector3 newData = Vector3::cZero;
		newData[0] = Math::Round(Math::RadToDeg(angles[0]), -1);
		newData[1] = Math::Round(Math::RadToDeg(angles[1]), -1);
		newData[2] = Math::Round(Math::RadToDeg(angles[2]), -1);
		return newData;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix2.hpp
/// Implementation of the Matrix 2 structure.
///
/// Authors: Joshua Davis
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <cmath>

namespace Math
{

	const Matrix2 Matrix2::cIdentity(real(1.0), real(0.0),
		real(0.0), real(1.0));

	Matrix2::Matrix2(real p00, real p01,
		real p10, real p11)
	{
		m00 = p00; m01 = p01;
		m10 = p10; m11 = p11;
	}

	Matrix2::Matrix2(ConstRealPointer data_)
	{
		m00 = data_[0]; m01 = data_[1];
		m10 = data_[2]; m11 = data_[3];
	}

	Vec2Ref Matrix2::operator[](uint index)
	{
		return ((Vector2*)this)[index];
	}

	Vec2Param Matrix2::operator[](uint index) const
	{
		return ((Vector2*)this)[index];
	}

	ConstRealPointer Matrix2::Begin() const
	{
		return array;
	}

	ConstRealPointer Matrix2::End() const
	{
		return array + 4;
	}

	RealPointer Matrix2::Begin()
	{
		return array;
	}

	RealPointer Matrix2::End()
	{
		return array + 4;
	}

	//////////////////////////////////////////////////////////////////////////
	//BINARY ASSIGNMENT OPERATORS (realS)
	//////////////////////////////////////////////////////////////////////////

	void Matrix2::operator*=(real rhs)
	{
		Matrix2& self = *this;
		self[0] *= rhs;
		self[1] *= rhs;
	}

	void Matrix2::operator/=(real rhs)
	{
		Matrix2& self = *this;
		self[0] /= rhs;
		self[1] /= rhs;
	}

	//////////////////////////////////////////////////////////////////////////
	//BINARY OPERATORS (realS)
	//////////////////////////////////////////////////////////////////////////

	Matrix2 Matrix2::operator*(real rhs) const
	{
		Matrix2 ret = *this;
		ret *= rhs;
		return ret;
	}

	Matrix2 Matrix2::operator/(real rhs) const
	{
		Matrix2 ret = *this;
		ret /= rhs;
		return ret;
	}

	//////////////////////////////////////////////////////////////////////////
	//BINARY ASSIGNMENT OPERATOR (MATRICES)
	//////////////////////////////////////////////////////////////////////////

	void Matrix2::operator+=(Mat2Param rhs)
	{
		Matrix2& self = *this;
		self[0] += rhs[0];
		self[1] += rhs[1];
	}

	void Matrix2::operator-=(Mat2Param rhs)
	{
		Matrix2& self = *this;
		self[0] -= rhs[0];
		self[1] -= rhs[1];
	}

	//////////////////////////////////////////////////////////////////////////
	//BINARY OPERATORS (MATRICES)
	//////////////////////////////////////////////////////////////////////////

	Matrix2 Matrix2::operator+(Mat2Param rhs) const
	{
		Matrix2 ret = *this;
		ret += rhs;
		return ret;
	}

	Matrix2 Matrix2::operator-(Mat2Param rhs) const
	{
		Matrix2 ret = *this;
		ret -= rhs;
		return ret;
	}

	Matrix2 Matrix2::operator*(Mat2Param rhs) const
	{
		return Concat(rhs);
	}

	//////////////////////////////////////////////////////////////////////////
	//BINARY COMPARISONS
	//////////////////////////////////////////////////////////////////////////

	bool Matrix2::operator==(Mat2Param rhs) const
	{
		Mat2Param self = *this;
		return self[0] == rhs[0] &&
			self[1] == rhs[1];
	}

	bool Matrix2::operator!=(Mat2Param rhs) const
	{
		return !(*this == rhs);
	}

	real Matrix2::operator()(uint r, uint c) const
	{
		return array[c + r * 2];
	}

	real& Matrix2::operator()(uint r, uint c)
	{
		return array[c + r * 2];
	}

	Matrix2 Matrix2::Transposed() const
	{
		Matrix2 ret;

		ret.m00 = m00;
		ret.m01 = m10;
		ret.m10 = m01;
		ret.m11 = m11;

		return ret;
	}

	Matrix2 Matrix2::Inverted()
	{
		Matrix2 inverse;
		inverse.m00 = m11;
		inverse.m01 = -m01;
		inverse.m10 = -m10;
		inverse.m11 = m00;
		inverse *= real(1.0) / Determinant();

		return inverse;
	}

	Matrix2 Matrix2::Concat(Mat2Param rhs) const
	{
		Matrix2 ret;

		ret.m00 = Dot(Cross(0), Vector2(rhs.m00, rhs.m10));
		ret.m01 = Dot(Cross(0), Vector2(rhs.m01, rhs.m11));

		ret.m10 = Dot(Cross(1), Vector2(rhs.m00, rhs.m10));
		ret.m11 = Dot(Cross(1), Vector2(rhs.m01, rhs.m11));

		return ret;
	}

	Mat2Ref Matrix2::Identity()
	{
		Mat2Ref self = *this;
		self[0].Set(real(1.0), real(0.0));
		self[1].Set(real(0.0), real(1.0));
		return *this;
	}

	Mat2Ref Matrix2::SetIdentity()
	{
		return Identity();
	}

	Mat2Ref Matrix2::ZeroOut()
	{
		Mat2Ref self = *this;
		self[0].ZeroOut();
		self[1].ZeroOut();
		return *this;
	}

	float Matrix2::Determinant() const
	{
		return m00 * m11 - m01 * m10;
	}

	bool Matrix2::Valid() const
	{
		Mat2Param self = *this;
		return self[0].Valid() && self[1].Valid();
	}

	void Matrix2::Rotate(real radians)
	{
		real c0 = Math::Cos(radians);
		real s0 = Math::Sin(radians);
		m00 = c0; m01 = -s0;
		m10 = s0; m11 = c0;
	}

	void Matrix2::Scale(real x, real y)
	{
		m00 = x; m01 = 0;
		m10 = 0; m11 = y;
	}

	void Matrix2::Scale(Vec2Param rhs)
	{
		Scale(rhs[0], rhs[1]);
	}

	Vector2 Matrix2::Transform(Vec2Param vector) const
	{
		real x = Dot(Cross(0), vector);
		real y = Dot(Cross(1), vector);
		return Vector2(x, y);
	}

	void Matrix2::TransformVector(Vec2Ref vector) const
	{
		Vec2 ret = Transform(vector);
		vector = ret;
	}

	Vector2 Matrix2::BasisVector(u32 index) const
	{
		//Could be optimized but I don't want to rely on the order of the elements in 
		//the matrix
		switch (index)
		{
		case 0:
			return Vector2(m00, m10);

		case 1:
			return Vector2(m01, m11);

		default:
			//ErrorIf(index > 2, "Invalid index given, matrix dimension is too low.");
			return Vector2(real(0.0), real(0.0));
		}
	}

	Vector2 Matrix2::Basis(uint index) const
	{
		return BasisVector(index);
	}

	Vector2 Matrix2::Cross(uint index) const
	{
		switch (index)
		{
		case 0:
			return Vector2(m00, m01);

		case 1:
			return Vector2(m10, m11);

		default:
			//ErrorIf(index > 2, "Invalid index given, matrix dimension is too low.");
			return Vector2(real(0.0), real(0.0));
		}
	}

	Matrix2 operator*(real lhs, Mat2Param rhs)
	{
		return rhs * lhs;
	}

	Matrix2 Concat(Mat2Param lhs, Mat2Param rhs)
	{
		return lhs.Concat(rhs);
	}

	Vector2 Transform(Mat2Param mat, Vec2Param vector)
	{
		return mat.Transform(vector);
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix3.cpp
/// Implementation of the Matrix 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <cmath>

namespace Math
{

	const Matrix3 Matrix3::cIdentity(real(1.0), real(0.0), real(0.0),
		real(0.0), real(1.0), real(0.0),
		real(0.0), real(0.0), real(1.0));

	Matrix3::Matrix3(real p00, real p01, real p02,
		real p10, real p11, real p12,
		real p20, real p21, real p22)
	{
		m00 = p00;  m01 = p01;  m02 = p02;
		m10 = p10;  m11 = p11;  m12 = p12;
		m20 = p20;  m21 = p21;  m22 = p22;
	}

	Matrix3::Matrix3(ConstRealPointer data_)
	{
		m00 = data_[0]; m01 = data_[1]; m02 = data_[2];
		m10 = data_[3]; m11 = data_[4]; m12 = data_[5];
		m20 = data_[6]; m21 = data_[7]; m22 = data_[8];
	}

	//------------------------------------------ Binary Assignment Operators (reals)

	void Matrix3::operator*=(real rhs)
	{
		Matrix3& self = *this;
		self[0] *= rhs;
		self[1] *= rhs;
		self[2] *= rhs;
	}

	void Matrix3::operator/=(real rhs)
	{
		Matrix3& self = *this;
		ErrorIf(Math::IsZero(rhs), "Matrix3 - Division by zero.");
		self[0] /= rhs;
		self[1] /= rhs;
		self[2] /= rhs;
	}

	//----------------------------------------------------- Binary Operators (reals)

	Matrix3 Matrix3::operator*(real rhs) const
	{
		Matrix3 ret = *this;
		ret *= rhs;
		return ret;
	}

	Matrix3 Matrix3::operator/(real rhs) const
	{
		ErrorIf(Math::IsZero(rhs), "Matrix3 - Division by zero.");
		Matrix3 ret = *this;
		ret /= rhs;
		return ret;
	}

	//---------------------------------------- Binary Assignment Operator (Matrices)

	void Matrix3::operator+=(Mat3Param rhs)
	{
		Matrix3& self = *this;
		self[0] += rhs[0];
		self[1] += rhs[1];
		self[2] += rhs[2];
	}

	void Matrix3::operator-=(Mat3Param rhs)
	{
		Matrix3& self = *this;
		self[0] -= rhs[0];
		self[1] -= rhs[1];
		self[2] -= rhs[2];
	}

	//-------------------------------------------------- Binary Operators (Matrices)

	Matrix3 Matrix3::operator+(Mat3Param rhs) const
	{
		Matrix3 ret = *this;
		ret += rhs;
		return ret;
	}

	Matrix3 Matrix3::operator-(Mat3Param rhs) const
	{
		Matrix3 ret = *this;
		ret -= rhs;
		return ret;
	}

	Matrix3 Matrix3::operator*(Mat3Param rhs) const
	{
		return Concat(rhs);
	}

	//----------------------------------------------------------- Binary Comparisons

	bool Matrix3::operator==(Mat3Param rhs) const
	{
		const Matrix3& self = *this;
		return self[0] == rhs[0] &&
			self[1] == rhs[1] &&
			self[2] == rhs[2];
	}

	bool Matrix3::operator!=(Mat3Param rhs) const
	{
		return !(*this == rhs);
	}

	real Matrix3::operator()(uint r, uint c) const
	{
		ErrorIf(r > 2, "Matrix3 - Index out of range.");
		ErrorIf(c > 2, "Matrix3 - Index out of range.");

#if ColumnBasis == 1
		return array[c + r * 3];
#else
		return array[r + c * 3];
#endif
	}

	real& Matrix3::operator()(uint r, uint c)
	{
		ErrorIf(r > 2, "Matrix3 - Index out of range.");
		ErrorIf(c > 2, "Matrix3 - Index out of range.");

#if ColumnBasis == 1
		return array[c + r * 3];
#else
		return array[r + c * 3];
#endif
	}

	Vector3& Matrix3::operator[](uint index)
	{
		return ((Vector3*)this)[index];
	}

	const Vector3& Matrix3::operator[](uint index) const
	{
		return ((Vector3*)this)[index];
	}

	Matrix3 Matrix3::Transposed(void) const
	{
		Matrix3 ret;

		ret.m00 = m00;
		ret.m01 = m10;
		ret.m02 = m20;
		ret.m10 = m01;
		ret.m11 = m11;
		ret.m12 = m21;
		ret.m20 = m02;
		ret.m21 = m12;
		ret.m22 = m22;

		return ret;
	}

	Mat3Ref Matrix3::Transpose(void)
	{
		Math::Swap(m01, m10);
		Math::Swap(m02, m20);
		Math::Swap(m12, m21);
		return *this;
	}

	Matrix3 Matrix3::Inverted(void) const
	{
		Matrix3 result(*this);
		result.Invert();
		return result;
	}

	Mat3Ref Matrix3::Invert(void)
	{
		real determinant = Determinant();
		ErrorIf(determinant == real(0.0), "Matrix3 - Uninvertible matrix.");
		determinant = real(1.0) / determinant;
		real t00 = (m11 * m22 - m12 * m21) * determinant;
		real t01 = (m02 * m21 - m01 * m22) * determinant;
		real t02 = (m01 * m12 - m02 * m11) * determinant;
		real t10 = (m12 * m20 - m10 * m22) * determinant;
		real t11 = (m00 * m22 - m02 * m20) * determinant;
		real t12 = (m02 * m10 - m00 * m12) * determinant;
		real t20 = (m10 * m21 - m11 * m20) * determinant;
		real t21 = (m01 * m20 - m00 * m21) * determinant;
		real t22 = (m00 * m11 - m01 * m10) * determinant;

		m00 = t00;  m01 = t01;  m02 = t02;
		m10 = t10;  m11 = t11;  m12 = t12;
		m20 = t20;  m21 = t21;  m22 = t22;
		return *this;
	}

	Matrix3 Matrix3::SafeInverted()
	{
		Matrix3 result(*this);
		result.SafeInvert();
		return result;
	}

	void Matrix3::SafeInvert()
	{
		real determinant = Determinant();
		if (determinant < Math::PositiveMin())
			determinant = Math::PositiveMin();

		determinant = real(1.0) / determinant;
		real t00 = (m11 * m22 - m12 * m21) * determinant;
		real t01 = (m02 * m21 - m01 * m22) * determinant;
		real t02 = (m01 * m12 - m02 * m11) * determinant;
		real t10 = (m12 * m20 - m10 * m22) * determinant;
		real t11 = (m00 * m22 - m02 * m20) * determinant;
		real t12 = (m02 * m10 - m00 * m12) * determinant;
		real t20 = (m10 * m21 - m11 * m20) * determinant;
		real t21 = (m01 * m20 - m00 * m21) * determinant;
		real t22 = (m00 * m11 - m01 * m10) * determinant;

		m00 = t00;  m01 = t01;  m02 = t02;
		m10 = t10;  m11 = t11;  m12 = t12;
		m20 = t20;  m21 = t21;  m22 = t22;
	}

	Matrix3 Matrix3::Concat(Mat3Param rhs) const
	{
		Matrix3 ret;

		ret.m00 = Dot(Cross(0), rhs.Basis(0));
		ret.m01 = Dot(Cross(0), rhs.Basis(1));
		ret.m02 = Dot(Cross(0), rhs.Basis(2));

		ret.m10 = Dot(Cross(1), rhs.Basis(0));
		ret.m11 = Dot(Cross(1), rhs.Basis(1));
		ret.m12 = Dot(Cross(1), rhs.Basis(2));

		ret.m20 = Dot(Cross(2), rhs.Basis(0));
		ret.m21 = Dot(Cross(2), rhs.Basis(1));
		ret.m22 = Dot(Cross(2), rhs.Basis(2));

		return ret;
	}

	Mat3Ref Matrix3::SetIdentity(void)
	{
		Matrix3& self = *this;
		self[0].Set(real(1.0), real(0.0), real(0.0));
		self[1].Set(real(0.0), real(1.0), real(0.0));
		self[2].Set(real(0.0), real(0.0), real(1.0));
		return *this;
	}

	Mat3Ref Matrix3::ZeroOut(void)
	{
		Matrix3& self = *this;
		self[0].ZeroOut();
		self[1].ZeroOut();
		self[2].ZeroOut();
		return *this;
	}

	real Matrix3::Determinant(void) const
	{
		return (m00 * m11 * m22 + m10 * m21 * m02 + m01 * m12 * m20)
			- (m02 * m11 * m20 + m10 * m01 * m22 + m00 * m21 * m12);
	}

	bool Matrix3::Valid(void) const
	{
		const Matrix3& self = *this;
		return self[0].Valid() && self[1].Valid() && self[2].Valid();
	}

	void Matrix3::Scale(real x, real y, real z)
	{
		SetIdentity();
		m00 = x;
		m11 = y;
		m22 = z;
	}

	void Matrix3::Scale(Vec3Param rhs)
	{
		Scale(rhs[0], rhs[1], rhs[2]);
	}

	void Matrix3::Rotate(real x, real y, real z, real radian)
	{
		real c0 = Math::Cos(radian);
		real n1C0 = real(1.0) - c0;
		real s0 = Math::Sin(radian);

		//| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
		//| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
		//| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
		m00 = x * x * n1C0 + c0;
		m01 = x * y * n1C0 - z * s0;
		m02 = x * z * n1C0 + y * s0;

		m10 = x * y * n1C0 + z * s0;
		m11 = y * y * n1C0 + c0;
		m12 = y * z * n1C0 - x * s0;

		m20 = x * z * n1C0 - y * s0;
		m21 = y * z * n1C0 + x * s0;
		m22 = z * z * n1C0 + c0;
	}

	void Matrix3::Rotate(Vec3Param rhs, real radian)
	{
		Rotate(rhs.x, rhs.y, rhs.z, radian);
	}

	void Matrix3::Translate(real x, real y)
	{
		m00 = real(1.0);  m01 = real(0.0);  m02 = x;
		m10 = real(0.0);  m11 = real(1.0);  m12 = y;
		m20 = real(0.0);  m21 = real(0.0);  m22 = real(1.0);
	}

	void Matrix3::Translate(Vec2Param rhs)
	{
		Translate(rhs.x, rhs.y);
	}

	void Matrix3::BuildTransform(Vec2Param translate, real radians, Vec2Param scale)
	{
		//Translation
		m02 = translate.x;
		m12 = translate.y;
		m22 = real(1.0);

		//Rotation
		m00 = Math::Cos(radians);
		m01 = -Math::Sin(radians);
		m10 = -m01;
		m11 = m00;

		//Scale
		m00 *= scale.x;
		m10 *= scale.x;
		m01 *= scale.y;
		m11 *= scale.y;

		m20 = m21 = real(0.0);
	}

	void Matrix3::BuildTransform(QuatParam rotate, Vec3Param scale)
	{
		//Rotational component
		real xx = rotate.x * rotate.x;
		real xy = rotate.x * rotate.y;
		real xz = rotate.x * rotate.z;
		real yy = rotate.y * rotate.y;
		real yz = rotate.y * rotate.z;
		real zz = rotate.z * rotate.z;
		real zw = rotate.z * rotate.w;
		real yw = rotate.y * rotate.w;
		real xw = rotate.x * rotate.w;

		m00 = real(1.0) - real(2.0) * (yy + zz);
		m01 = real(2.0) * (xy - zw);
		m02 = real(2.0) * (xz + yw);

		m10 = real(2.0) * (xy + zw);
		m11 = real(1.0) - real(2.0) * (xx + zz);
		m12 = real(2.0) * (yz - xw);

		m20 = real(2.0) * (xz - yw);
		m21 = real(2.0) * (yz + xw);
		m22 = real(1.0) - real(2.0) * (xx + yy);

		//Scale component
		m00 *= scale.x;
		m10 *= scale.x;
		m20 *= scale.x;

		m01 *= scale.y;
		m11 *= scale.y;
		m21 *= scale.y;

		m02 *= scale.z;
		m12 *= scale.z;
		m22 *= scale.z;
	}

	Mat3Ref Matrix3::Orthonormalize(void)
	{
		Vector3 basis[3] = { BasisX(), BasisY(), BasisZ() };
		Normalize(&(basis[0]));

		basis[1].AddScaledVector(basis[0], -Dot(basis[1], basis[0]));
		Normalize(&(basis[1]));

		basis[2].AddScaledVector(basis[0], -Dot(basis[2], basis[0]));
		basis[2].AddScaledVector(basis[1], -Dot(basis[2], basis[1]));
		Normalize(&(basis[2]));

		SetBasis(cX, basis[0]);
		SetBasis(cY, basis[1]);
		SetBasis(cZ, basis[2]);
		return *this;
	}

	Matrix3::BasisVector Matrix3::Basis(uint index) const
	{
		ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
		return Vector3(array[index], array[3 + index], array[6 + index]);
#else
		const Matrix3& self = *this;
		return self[index];
#endif
	}

	Matrix3::BasisVector Matrix3::BasisX(void) const
	{
#if ColumnBasis == 1
		return Vector3(array[0], array[3], array[6]);
#else
		const Matrix3& self = *this;
		return self[0];
#endif
	}

	Matrix3::BasisVector Matrix3::BasisY(void) const
	{
#if ColumnBasis == 1
		return Vector3(array[1], array[4], array[7]);
#else
		const Matrix3& self = *this;
		return self[1];
#endif
	}

	Matrix3::BasisVector Matrix3::BasisZ(void) const
	{
#if ColumnBasis == 1
		return Vector3(array[2], array[5], array[8]);
#else
		const Matrix3& self = *this;
		return self[2];
#endif
	}

	Matrix3::CrossVector Matrix3::Cross(uint index) const
	{
		ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
		Mat3Param self = *this;
		return self[index];
#else
		return Vector3(array[index], array[3 + index], array[6 + index]);
#endif
	}

	void Matrix3::SetBasis(uint index, Vec3Param basisVector)
	{
		SetBasis(index, basisVector[0], basisVector[1], basisVector[2]);
	}

	void Matrix3::SetBasis(uint index, real x, real y, real z)
	{
		ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
		array[index] = x;
		array[3 + index] = y;
		array[6 + index] = z;
#else
		Matrix3& self = *this;
		self[index].Set(x, y, z);
#endif
	}

	void Matrix3::SetCross(uint index, Vec3Param crossVector)
	{
		SetCross(index, crossVector[0], crossVector[1], crossVector[2]);
	}

	void Matrix3::SetCross(uint index, real x, real y, real z)
	{
		ErrorIf(index > 2, "Matrix3 - Index out of range.");
#if ColumnBasis == 1
		Matrix3& self = *this;
		self[index].Set(x, y, z);
#else
		array[index] = x;
		array[3 + index] = y;
		array[6 + index] = z;
#endif
	}

	Matrix3 operator*(real lhs, Mat3Param rhs)
	{
		return rhs * lhs;
	}

	Matrix3 Concat(Mat3Param lhs, Mat3Param rhs)
	{
		return lhs.Concat(rhs);
	}

	Matrix3 BuildTransform(Vec2Param translate, real radians, Vec2Param scale)
	{
		Matrix3 matrix;
		matrix.BuildTransform(translate, radians, scale);
		return matrix;
	}

	Matrix3 BuildTransform(QuatParam rotate, Vec3Param scale)
	{
		Matrix3 matrix;
		matrix.BuildTransform(rotate, scale);
		return matrix;
	}

	Vector3 Transform(Mat3Param matrix, Vec3Param vector)
	{
		real x = Dot(matrix.Cross(0), vector);
		real y = Dot(matrix.Cross(1), vector);
		real z = Dot(matrix.Cross(2), vector);
		return Vector3(x, y, z);
	}

	void Transform(Mat3Param matrix, Vec3Ptr vector)
	{
		ErrorIf(vector == NULL, "Matrix3 - Null pointer passed for vector.");
		real x = Dot(matrix.Cross(0), *vector);
		real y = Dot(matrix.Cross(1), *vector);
		real z = Dot(matrix.Cross(2), *vector);
		vector->Set(x, y, z);
	}

	Vector2 TransformPoint(Mat3Param matrix, Vec2Param vector)
	{
		real x = Dot(*(Vector2*)&matrix[0], vector) + matrix[0][2];
		real y = Dot(*(Vector2*)&matrix[1], vector) + matrix[1][2];
		return Vector2(x, y);
	}

	Vector2 TransformNormal(Mat3Param matrix, Vec2Param normal)
	{
		real x = Dot(*(Vector2*)&matrix[0], normal);
		real y = Dot(*(Vector2*)&matrix[1], normal);
		return Vector2(x, y);
	}

	Vector3 TransposedTransform(Mat3Param matrix, Vec3Param vector)
	{
		real x = Dot(matrix.Basis(0), vector);
		real y = Dot(matrix.Basis(1), vector);
		real z = Dot(matrix.Basis(2), vector);
		return Vector3(x, y, z);
	}

	void TransposedTransform(Mat3Param matrix, Vec3Ptr vector)
	{
		ErrorIf(vector == NULL, "Matrix3 - Null pointer passed for vector.");
		real x = Dot(matrix.Basis(0), *vector);
		real y = Dot(matrix.Basis(1), *vector);
		real z = Dot(matrix.Basis(2), *vector);
		vector->Set(x, y, z);
	}

	real Trace(Mat3Param matrix)
	{
		return matrix.m00 + matrix.m11 + matrix.m22;
	}

	real Cofactor(Mat3Param matrix, uint row, uint column)
	{
		ErrorIf(row > 2, "Matrix3 - Row index out of range.");
		ErrorIf(column > 2, "Matrix3 - Column index out of range.");

		//Negative if r+c is odd, positive if even
		real sign = ((row + column) % 2) == 1 ? real(-1.0) : real(1.0);

		real matrix2[4];
		uint i = 0;
		for (uint r = 0; r < 3; ++r)
		{
			if (r != row)
			{
				for (uint c = 0; c < 3; ++c)
				{
					if (c != column)
					{
						matrix2[i] = matrix(r, c);
						++i;
					}
				}
			}
		}

		return sign * ((matrix2[0] * matrix2[3]) - (matrix2[1] * matrix2[2]));
	}

	///Diagonalizes a symmetric matrix (M = M^T)
	void Diagonalize(Mat3Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Matrix3 - Null pointer passed for matrix.");

		Matrix3 quatMatrix = ToMatrix3(CreateDiagonalizer(*matrix));
		*matrix = Concat(Concat(quatMatrix, *matrix), quatMatrix.Transposed());
	}

	Matrix3 Diagonalized(Mat3Param matrix)
	{
		Matrix3 newMatrix = matrix;
		Diagonalize(&newMatrix);
		return newMatrix;
	}

	void Invert(Mat3Ptr matrix)
	{
		matrix->Invert();
	}

	Matrix3 Inverted(Mat3Param matrix)
	{
		return matrix.Inverted();
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix4.cpp
/// Implementation of the Matrix 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const Matrix4 Matrix4::cIdentity(real(1.0), real(0.0), real(0.0), real(0.0),
		real(0.0), real(1.0), real(0.0), real(0.0),
		real(0.0), real(0.0), real(1.0), real(0.0),
		real(0.0), real(0.0), real(0.0), real(1.0));

	Matrix4::Matrix4(ConstRealPointer data_)
	{
		m00 = data_[0];  m01 = data_[1];  m02 = data_[2];  m03 = data_[3];
		m10 = data_[4];  m11 = data_[5];  m12 = data_[6];  m13 = data_[7];
		m20 = data_[8];  m21 = data_[9];  m22 = data_[10];  m23 = data_[11];
		m30 = data_[12];  m31 = data_[13];  m32 = data_[14];  m33 = data_[15];
	}

	Matrix4::Matrix4(real p00, real p01, real p02, real p03, real p10, real p11,
		real p12, real p13, real p20, real p21, real p22, real p23,
		real p30, real p31, real p32, real p33)
	{
		m00 = p00;  m01 = p01;  m02 = p02;  m03 = p03;
		m10 = p10;  m11 = p11;  m12 = p12;  m13 = p13;
		m20 = p20;  m21 = p21;  m22 = p22;  m23 = p23;
		m30 = p30;  m31 = p31;  m32 = p32;  m33 = p33;
	}

	Matrix4::Matrix4(Vec4Param basisX, Vec4Param basisY,
		Vec4Param basisZ, Vec4Param basisW)
	{
		SetBasis(0, basisX);
		SetBasis(1, basisY);
		SetBasis(2, basisZ);
		SetBasis(3, basisW);
	}

	////////// Binary Assignment Operators (reals) /////////////////////////////////

	void Matrix4::operator*=(real rhs)
	{
		Matrix4& self = *this;
		self[0] *= rhs;
		self[1] *= rhs;
		self[2] *= rhs;
		self[3] *= rhs;
	}

	void Matrix4::operator/=(real rhs)
	{
		Matrix4& self = *this;
		ErrorIf(Math::IsZero(rhs), "Matrix4 - Division by zero.");
		self[0] /= rhs;
		self[1] /= rhs;
		self[2] /= rhs;
		self[3] /= rhs;
	}

	////////// Binary Operators (reals) ////////////////////////////////////////////

	Matrix4 Matrix4::operator*(real rhs) const
	{
		Matrix4 ret = *this;
		ret *= rhs;
		return ret;
	}

	Matrix4 Matrix4::operator/(real rhs) const
	{
		ErrorIf(Math::IsZero(rhs), "Matrix4 - Division by zero.");
		Matrix4 ret = *this;
		ret /= rhs;
		return ret;
	}

	////////// Binary Assignment Operator (Matrices) ///////////////////////////////

	void Matrix4::operator+=(Mat4Param rhs)
	{
		Matrix4& self = *this;
		self[0] += rhs[0];
		self[1] += rhs[1];
		self[2] += rhs[2];
		self[3] += rhs[3];
	}

	void Matrix4::operator-=(Mat4Param rhs)
	{
		Matrix4& self = *this;
		self[0] -= rhs[0];
		self[1] -= rhs[1];
		self[2] -= rhs[2];
		self[3] -= rhs[3];
	}

	////////// Binary Operators (Matrices) /////////////////////////////////////////

	Matrix4 Matrix4::operator+(Mat4Param rhs) const
	{
		Matrix4 ret = *this;
		ret += rhs;
		return ret;
	}

	Matrix4 Matrix4::operator-(Mat4Param rhs) const
	{
		Matrix4 ret = *this;
		ret -= rhs;
		return ret;
	}

	Matrix4 Matrix4::operator*(Mat4Param rhs) const
	{
		return Concat(rhs);
	}

	////////// Binary Comparisons //////////////////////////////////////////////////

	bool Matrix4::operator==(Mat4Param rhs) const
	{
		const Matrix4& self = *this;
		return self[0] == rhs[0] &&
			self[1] == rhs[1] &&
			self[2] == rhs[2] &&
			self[3] == rhs[3];
	}

	bool Matrix4::operator!=(Mat4Param rhs) const
	{
		return !(*this == rhs);
	}

	real Matrix4::operator()(uint r, uint c) const
	{
		ErrorIf(r > 3, "Matrix4 - Index out of range.");
		ErrorIf(c > 3, "Matrix4 - Index out of range.");

#if ColumnBasis == 1
		return array[c + r * 4];
#else
		return array[r + c * 4];
#endif
	}

	real& Matrix4::operator()(uint r, uint c)
	{
		ErrorIf(r > 3, "Matrix4 - Index out of range.");
		ErrorIf(c > 3, "Matrix4 - Index out of range.");

#if ColumnBasis == 1
		return array[c + r * 4];
#else
		return array[r + c * 4];
#endif
	}

	Matrix4 Matrix4::Transposed(void) const
	{
		Matrix4 ret = *this;
		ret.Transpose();
		return ret;
	}

	Mat4Ref Matrix4::Transpose(void)
	{
		Math::Swap(m01, m10);
		Math::Swap(m02, m20);
		Math::Swap(m03, m30);
		Math::Swap(m12, m21);
		Math::Swap(m13, m31);
		Math::Swap(m23, m32);
		return *this;
	}

	Matrix4 Matrix4::Inverted(void) const
	{
		Matrix4 inverted;
		real determinant = Determinant();
		ErrorIf(Math::IsZero(determinant), "Matrix4 - Uninvertible matrix.");
		determinant = real(1.0) / determinant;
		inverted.m00 = m12 * m23 * m31 - m13 * m22 * m31;
		inverted.m00 += m13 * m21 * m32 - m11 * m23 * m32;
		inverted.m00 += m11 * m22 * m33 - m12 * m21 * m33;
		inverted.m00 *= determinant;

		inverted.m01 = m03 * m22 * m31 - m02 * m23 * m31;
		inverted.m01 += m01 * m23 * m32 - m03 * m21 * m32;
		inverted.m01 += m02 * m21 * m33 - m01 * m22 * m33;
		inverted.m01 *= determinant;

		inverted.m02 = m02 * m13 * m31 - m03 * m12 * m31;
		inverted.m02 += m03 * m11 * m32 - m01 * m13 * m32;
		inverted.m02 += m01 * m12 * m33 - m02 * m11 * m33;
		inverted.m02 *= determinant;

		inverted.m03 = m03 * m12 * m21 - m02 * m13 * m21;
		inverted.m03 += m01 * m13 * m22 - m03 * m11 * m22;
		inverted.m03 += m02 * m11 * m23 - m01 * m12 * m23;
		inverted.m03 *= determinant;

		inverted.m10 = m13 * m22 * m30 - m12 * m23 * m30;
		inverted.m10 += m10 * m23 * m32 - m13 * m20 * m32;
		inverted.m10 += m12 * m20 * m33 - m10 * m22 * m33;
		inverted.m10 *= determinant;

		inverted.m11 = m02 * m23 * m30 - m03 * m22 * m30;
		inverted.m11 += m03 * m20 * m32 - m00 * m23 * m32;
		inverted.m11 += m00 * m22 * m33 - m02 * m20 * m33;
		inverted.m11 *= determinant;

		inverted.m12 = m03 * m12 * m30 - m02 * m13 * m30;
		inverted.m12 += m00 * m13 * m32 - m03 * m10 * m32;
		inverted.m12 += m02 * m10 * m33 - m00 * m12 * m33;
		inverted.m12 *= determinant;

		inverted.m13 = m02 * m13 * m20 - m03 * m12 * m20;
		inverted.m13 += m03 * m10 * m22 - m00 * m13 * m22;
		inverted.m13 += m00 * m12 * m23 - m02 * m10 * m23;
		inverted.m13 *= determinant;

		inverted.m20 = m11 * m23 * m30 - m13 * m21 * m30;
		inverted.m20 += m13 * m20 * m31 - m10 * m23 * m31;
		inverted.m20 += m10 * m21 * m33 - m11 * m20 * m33;
		inverted.m20 *= determinant;

		inverted.m21 = m03 * m21 * m30 - m01 * m23 * m30;
		inverted.m21 += m00 * m23 * m31 - m03 * m20 * m31;
		inverted.m21 += m01 * m20 * m33 - m00 * m21 * m33;
		inverted.m21 *= determinant;

		inverted.m22 = m01 * m13 * m30 - m03 * m11 * m30;
		inverted.m22 += m03 * m10 * m31 - m00 * m13 * m31;
		inverted.m22 += m00 * m11 * m33 - m01 * m10 * m33;
		inverted.m22 *= determinant;

		inverted.m23 = m03 * m11 * m20 - m01 * m13 * m20;
		inverted.m23 += m00 * m13 * m21 - m03 * m10 * m21;
		inverted.m23 += m01 * m10 * m23 - m00 * m11 * m23;
		inverted.m23 *= determinant;

		inverted.m30 = m12 * m21 * m30 - m11 * m22 * m30;
		inverted.m30 += m10 * m22 * m31 - m12 * m20 * m31;
		inverted.m30 += m11 * m20 * m32 - m10 * m21 * m32;
		inverted.m30 *= determinant;

		inverted.m31 = m01 * m22 * m30 - m02 * m21 * m30;
		inverted.m31 += m02 * m20 * m31 - m00 * m22 * m31;
		inverted.m31 += m00 * m21 * m32 - m01 * m20 * m32;
		inverted.m31 *= determinant;

		inverted.m32 = m02 * m11 * m30 - m01 * m12 * m30;
		inverted.m32 += m00 * m12 * m31 - m02 * m10 * m31;
		inverted.m32 += m01 * m10 * m32 - m00 * m11 * m32;
		inverted.m32 *= determinant;

		inverted.m33 = m01 * m12 * m20 - m02 * m11 * m20;
		inverted.m33 += m02 * m10 * m21 - m00 * m12 * m21;
		inverted.m33 += m00 * m11 * m22 - m01 * m10 * m22;
		inverted.m33 *= determinant;

		return inverted;
	}

	Mat4Ref Matrix4::Invert(void)
	{
		*this = Inverted();
		return *this;
	}

	Matrix4 Matrix4::Concat(Mat4Param rhs) const
	{
		Matrix4 ret;

		ret.m00 = Dot(Cross(0), rhs.Basis(0));
		ret.m01 = Dot(Cross(0), rhs.Basis(1));
		ret.m02 = Dot(Cross(0), rhs.Basis(2));
		ret.m03 = Dot(Cross(0), rhs.Basis(3));

		ret.m10 = Dot(Cross(1), rhs.Basis(0));
		ret.m11 = Dot(Cross(1), rhs.Basis(1));
		ret.m12 = Dot(Cross(1), rhs.Basis(2));
		ret.m13 = Dot(Cross(1), rhs.Basis(3));

		ret.m20 = Dot(Cross(2), rhs.Basis(0));
		ret.m21 = Dot(Cross(2), rhs.Basis(1));
		ret.m22 = Dot(Cross(2), rhs.Basis(2));
		ret.m23 = Dot(Cross(2), rhs.Basis(3));

		ret.m30 = Dot(Cross(3), rhs.Basis(0));
		ret.m31 = Dot(Cross(3), rhs.Basis(1));
		ret.m32 = Dot(Cross(3), rhs.Basis(2));
		ret.m33 = Dot(Cross(3), rhs.Basis(3));

		return ret;
	}

	Mat4Ref Matrix4::SetIdentity(void)
	{
		Matrix4& self = *this;
		self[0].Set(real(1.0), real(0.0), real(0.0), real(0.0));
		self[1].Set(real(0.0), real(1.0), real(0.0), real(0.0));
		self[2].Set(real(0.0), real(0.0), real(1.0), real(0.0));
		self[3].Set(real(0.0), real(0.0), real(0.0), real(1.0));
		return *this;
	}

	Mat4Ref Matrix4::ZeroOut(void)
	{
		Matrix4& self = *this;
		self[0].ZeroOut();
		self[1].ZeroOut();
		self[2].ZeroOut();
		self[3].ZeroOut();
		return *this;
	}

	real Matrix4::Determinant(void) const
	{
		real det = m03 * m12 * m21 * m30 - m02 * m13 * m21 * m30;
		det += m01 * m13 * m22 * m30 - m03 * m11 * m22 * m30;
		det += m02 * m11 * m23 * m30 - m01 * m12 * m23 * m30;
		det += m02 * m13 * m20 * m31 - m03 * m12 * m20 * m31;
		det += m03 * m10 * m22 * m31 - m00 * m13 * m22 * m31;
		det += m00 * m12 * m23 * m31 - m02 * m10 * m23 * m31;
		det += m03 * m11 * m20 * m32 - m01 * m13 * m20 * m32;
		det += m00 * m13 * m21 * m32 - m03 * m10 * m21 * m32;
		det += m01 * m10 * m23 * m32 - m00 * m11 * m23 * m32;
		det += m01 * m12 * m20 * m33 - m02 * m11 * m20 * m33;
		det += m02 * m10 * m21 * m33 - m00 * m12 * m21 * m33;
		det += m00 * m11 * m22 * m33 - m01 * m10 * m22 * m33;
		return det;
	}

	bool Matrix4::Valid(void) const
	{
		const Matrix4& self = *this;
		return self[0].Valid() && self[1].Valid() &&
			self[2].Valid() && self[3].Valid();
	}

	void Matrix4::Scale(real x, real y, real z)
	{
		m00 = real(x);    m01 = real(0.0);  m02 = real(0.0);  m03 = real(0.0);
		m10 = real(0.0);  m11 = real(y);    m12 = real(0.0);  m13 = real(0.0);
		m20 = real(0.0);  m21 = real(0.0);  m22 = real(z);    m23 = real(0.0);
		m30 = real(0.0);  m31 = real(0.0);  m32 = real(0.0);  m33 = real(1.0);
	}

	void Matrix4::Scale(Vec3Param axis)
	{
		Scale(axis.x, axis.y, axis.z);
	}

	void Matrix4::Rotate(real x, real y, real z, real radians)
	{
		real c0 = Math::Cos(radians);
		real n1C0 = real(1.0) - c0;
		real s0 = Math::Sin(radians);

		//| x^2(1-c0)+c0  xy(1-c0)-zs0  xz(1-c0)+ys0 |
		//| xy(1-c0)+zs0  y^2(1-c0)+c0  yz(1-c0)-xs0 |
		//| xz(1-c0)-ys0  yz(1-c0)+xs0  z^2(1-c0)+c0 |
		SetCross(cX, x*x*n1C0 + c0, x*y*n1C0 - z*s0, x*z*n1C0 + y*s0, real(0.0));
		SetCross(cY, x*y*n1C0 + z*s0, y*y*n1C0 + c0, y*z*n1C0 - x*s0, real(0.0));
		SetCross(cZ, x*z*n1C0 - y*s0, y*z*n1C0 + x*s0, z*z*n1C0 + c0, real(0.0));
		SetCross(cW, real(0.0), real(0.0), real(0.0), real(1.0));
	}

	void Matrix4::Rotate(Vec3Param axis, real radians)
	{
		Rotate(axis.x, axis.y, axis.z, radians);
	}

	void Matrix4::Translate(real x, real y, real z)
	{
		m00 = real(1.0);  m01 = real(0.0);  m02 = real(0.0);  m03 = real(x);
		m10 = real(0.0);  m11 = real(1.0);  m12 = real(0.0);  m13 = real(y);
		m20 = real(0.0);  m21 = real(0.0);  m22 = real(1.0);  m23 = real(z);
		m30 = real(0.0);  m31 = real(0.0);  m32 = real(0.0);  m33 = real(1.0);
	}

	void Matrix4::Translate(Vec3Param axis)
	{
		Translate(axis.x, axis.y, axis.z);
	}

	void Matrix4::BuildTransform(Vec3Param translate, QuatParam rotate,
		Vec3Param scale)
	{
		//Translation component
		m03 = translate.x;
		m13 = translate.y;
		m23 = translate.z;
		m33 = real(1.0);

		//Rotational component
		real xx = rotate.x * rotate.x;
		real xy = rotate.x * rotate.y;
		real xz = rotate.x * rotate.z;
		real yy = rotate.y * rotate.y;
		real yz = rotate.y * rotate.z;
		real zz = rotate.z * rotate.z;
		real zw = rotate.z * rotate.w;
		real yw = rotate.y * rotate.w;
		real xw = rotate.x * rotate.w;

		m00 = real(1.0) - real(2.0) * (yy + zz);
		m01 = real(2.0) * (xy - zw);
		m02 = real(2.0) * (xz + yw);

		m10 = real(2.0) * (xy + zw);
		m11 = real(1.0) - real(2.0) * (xx + zz);
		m12 = real(2.0) * (yz - xw);

		m20 = real(2.0) * (xz - yw);
		m21 = real(2.0) * (yz + xw);
		m22 = real(1.0) - real(2.0) * (xx + yy);

		//Scale component
		m00 *= scale.x;
		m10 *= scale.x;
		m20 *= scale.x;

		m01 *= scale.y;
		m11 *= scale.y;
		m21 *= scale.y;

		m02 *= scale.z;
		m12 *= scale.z;
		m22 *= scale.z;

		m30 = m31 = m32 = real(0.0);
	}

	void Matrix4::BuildTransform(Vec3Param translate, Mat3Param rotate,
		Vec3Param scale)
	{
		//Translation component
		m03 = translate.x;
		m13 = translate.y;
		m23 = translate.z;
		m33 = real(1.0);

		//Rotational component
		m00 = rotate.m00;
		m01 = rotate.m01;
		m02 = rotate.m02;

		m10 = rotate.m10;
		m11 = rotate.m11;
		m12 = rotate.m12;

		m20 = rotate.m20;
		m21 = rotate.m21;
		m22 = rotate.m22;

		//Scale component
		m00 *= scale.x;
		m10 *= scale.x;
		m20 *= scale.x;

		m01 *= scale.y;
		m11 *= scale.y;
		m21 *= scale.y;

		m02 *= scale.z;
		m12 *= scale.z;
		m22 *= scale.z;

		m30 = m31 = m32 = real(0.0);
	}

	void Matrix4::Decompose(Vec3Ptr scale, Mat3Ptr rotate, Vec3Ptr translate) const
	{
		Vector3 shear;
		Decompose(scale, &shear, rotate, translate);
	}

	//Shear values that are calculated are XY, XZ, and YZ. They are stored as the 
	//element their name does not contain, so shear->x would have YZ in it
	void Matrix4::Decompose(Vec3Ptr scale, Vec3Ptr shear, Mat3Ptr rotate,
		Vec3Ptr translate) const
	{
		ErrorIf(scale == NULL, "Matrix4 - Null pointer passed for scale.");
		ErrorIf(shear == NULL, "Matrix4 - Null pointer passed for shear.");
		ErrorIf(rotate == NULL, "Matrix4 - Null pointer passed for rotation.");
		ErrorIf(translate == NULL, "Matrix4 - Null pointer passed for translation.");

		//Translation is the last basis vector
		translate->x = m03;
		translate->y = m13;
		translate->z = m23;

		//X' == first basis vector
		//Y' == second basis vector
		//Z' == third basis vector

		//       X'                  Y'                  Z'
		rotate->m00 = m00;  rotate->m01 = m01;  rotate->m02 = m02;
		rotate->m10 = m10;  rotate->m11 = m11;  rotate->m12 = m12;
		rotate->m20 = m20;  rotate->m21 = m21;  rotate->m22 = m22;

		//ScaleX is the magnitude of X'
		scale->x = Math::Sqrt(Math::Sq(m00) + Math::Sq(m10) + Math::Sq(m20));

		//X' is normalized
		rotate->m00 /= scale->x;
		rotate->m10 /= scale->x;
		rotate->m20 /= scale->x;

		//ShearXY is the dot product of X' and Y'
		shear->z = rotate->m00 * rotate->m01 +
			rotate->m10 * rotate->m11 +
			rotate->m20 * rotate->m21;

		//Make Y' orthogonal to X' by " Y' = Y' - (ShearXY * X') "
		rotate->m01 -= shear->z * rotate->m00;
		rotate->m11 -= shear->z * rotate->m10;
		rotate->m21 -= shear->z * rotate->m20;

		//ScaleY is the magnitude of the modified Y'
		scale->y = Math::Sqrt(Math::Sq(m01) + Math::Sq(m11) + Math::Sq(m21));

		//Y' is normalized
		rotate->m01 /= scale->y;
		rotate->m11 /= scale->y;
		rotate->m21 /= scale->y;

		//ShearXY is divided by ScaleY to get it's final value
		shear->z /= scale->y;

		//ShearXZ is the dot product of X' and Z'
		shear->y = rotate->m00 * rotate->m02 +
			rotate->m10 * rotate->m12 +
			rotate->m20 * rotate->m22;

		//ShearYZ is the dot product of Y' and Z'
		shear->x = rotate->m01 * rotate->m02 +
			rotate->m11 * rotate->m12 +
			rotate->m21 * rotate->m22;

		//Make Z' orthogonal to X' by " Z' = Z' - (ShearXZ * X') "
		rotate->m02 -= shear->y * rotate->m00;
		rotate->m12 -= shear->y * rotate->m10;
		rotate->m22 -= shear->y * rotate->m20;

		//Make Z' orthogonal to Y' by " Z' = Z' - (ShearYZ * Y') "
		rotate->m02 -= shear->x * rotate->m01;
		rotate->m12 -= shear->x * rotate->m11;
		rotate->m22 -= shear->x * rotate->m21;

		//ScaleZ is the magnitude of the modified Z'
		scale->z = Math::Sqrt(Math::Sq(m02) + Math::Sq(m12) + Math::Sq(m22));

		//Z' is normalized
		rotate->m02 /= scale->z;
		rotate->m12 /= scale->z;
		rotate->m22 /= scale->z;

		//ShearXZ is divided by ScaleZ to get it's final value
		shear->y /= scale->z;

		//ShearYZ is divided by ScaleZ to get it's final value
		shear->x /= scale->z;

		//If the determinant is negative, then the rotation and scale contain a flip
		Vector3 v = Vector3(rotate->m11 * rotate->m22 - rotate->m21 * rotate->m12,
			rotate->m21 * rotate->m02 - rotate->m01 * rotate->m22,
			rotate->m01 * rotate->m12 - rotate->m11 * rotate->m02);
		real dot = v.x * rotate->m00 + v.y * rotate->m10 + v.z * rotate->m20;
		if (dot < real(0.0))
		{
			(*rotate) *= real(-1.0);
			Negate(scale);
		}
	}

	Matrix4::BasisVector Matrix4::Basis(uint index) const
	{
		ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
		return Vector4(array[index], array[4 + index],
			array[8 + index], array[12 + index]);
#else
		Mat4Param self = *this;
		return self[index];
#endif
	}

	Matrix4::BasisVector Matrix4::BasisX(void) const
	{
#if ColumnBasis == 1
		return Vector4(array[0], array[4], array[8], array[12]);
#else
		Mat4Param self = *this;
		return self[0];
#endif
	}

	Matrix4::BasisVector Matrix4::BasisY(void) const
	{
#if ColumnBasis == 1
		return Vector4(array[1], array[5], array[9], array[13]);
#else
		Mat4Param self = *this;
		return self[1];
#endif
	}

	Matrix4::BasisVector Matrix4::BasisZ(void) const
	{
#if ColumnBasis == 1
		return Vector4(array[2], array[6], array[10], array[14]);
#else
		Mat4Param self = *this;
		return self[2];
#endif
	}

	Matrix4::BasisVector Matrix4::BasisW(void) const
	{
#if ColumnBasis == 1
		return Vector4(array[3], array[7], array[11], array[15]);
#else
		Mat4Param self = *this;
		return self[3];
#endif
	}

	Matrix4::CrossVector Matrix4::Cross(uint index) const
	{
		ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
		Mat4Param self = *this;
		return self[index];
#else
		return Vector4(array[index], array[4 + index],
			array[8 + index], array[12 + index]);
#endif
	}

	void Matrix4::SetBasis(uint index, Vec4Param basisVector)
	{
		SetBasis(index, basisVector.x, basisVector.y, basisVector.z, basisVector.w);
	}

	void Matrix4::SetBasis(uint index, Vec3Param basisVector3, real w)
	{
		SetBasis(index, basisVector3.x, basisVector3.y, basisVector3.z, w);
	}

	void Matrix4::SetBasis(uint index, real x, Vec3Param basisVector3)
	{
		SetBasis(index, x, basisVector3.x, basisVector3.y, basisVector3.z);
	}

	void Matrix4::SetBasis(uint index, real x, real y, real z, real w)
	{
		ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
		array[index] = x;
		array[4 + index] = y;
		array[8 + index] = z;
		array[12 + index] = w;
#else
		Mat4Param self = *this;
		self[index].Set(x, y, z, w);
#endif
	}

	void Matrix4::SetCross(uint index, Vec4Param crossVector)
	{
		SetCross(index, crossVector.x, crossVector.y, crossVector.z, crossVector.w);
	}

	void Matrix4::SetCross(uint index, Vec3Param crossVector3, real w)
	{
		SetCross(index, crossVector3.x, crossVector3.y, crossVector3.z, w);
	}

	void Matrix4::SetCross(uint index, real x, real y, real z, real w)
	{
		ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
		Mat4Ref self = *this;
		self[index].Set(x, y, z, w);
#else
		array[index] = x;
		array[4 + index] = y;
		array[8 + index] = z;
		array[12 + index] = w;
#endif
	}

	Vector3 Matrix4::Basis3(uint index) const
	{
		ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
		return Vector3(array[index], array[4 + index], array[8 + index]);
#else
		Mat4Param self = *this;
		return Vector3(self[index].x, self[index].y, self[index].z);
#endif
	}

	Vector3 Matrix4::Basis3X(void) const
	{
#if ColumnBasis == 1
		return Vector3(array[0], array[4], array[8]);
#else
		Mat4Param self = *this;
		return Vector3(self[0].x, self[0].y, self[0].z);
#endif
	}

	Vector3 Matrix4::Basis3Y(void) const
	{
#if ColumnBasis == 1
		return Vector3(array[1], array[5], array[9]);
#else
		Mat4Param self = *this;
		return Vector3(self[1].x, self[1].y, self[1].z);
#endif
	}

	Vector3 Matrix4::Basis3Z(void) const
	{
#if ColumnBasis == 1
		return Vector3(array[2], array[6], array[10]);
#else
		Mat4Param self = *this;
		return Vector3(self[2].x, self[2].y, self[2].z);
#endif
	}

	Vector3 Matrix4::Basis3W(void) const
	{
#if ColumnBasis == 1
		return Vector3(array[3], array[7], array[11]);
#else
		Mat4Param self = *this;
		return Vector3(self[3].x, self[3].y, self[3].z);
#endif
	}

	Vector3 Matrix4::Cross3(uint index) const
	{
		ErrorIf(index > 3, "Matrix4 - Index out of range.");
#if ColumnBasis == 1
		Mat4Param self = *this;
		return Vector3(self[index].x, self[index].y, self[index].z);
#else
		return Vector3(array[index], array[4 + index], array[8 + index]);
#endif
	}

	Matrix4 operator*(real lhs, Mat4Param rhs)
	{
		return rhs * lhs;
	}

	Matrix4 Concat(Mat4Param lhs, Mat4Param rhs)
	{
		return lhs.Concat(rhs);
	}

	Vector4 Transform(Mat4Param mat, Vec4Param vector)
	{
		real x = Dot(mat.Cross(0), vector);
		real y = Dot(mat.Cross(1), vector);
		real z = Dot(mat.Cross(2), vector);
		real w = Dot(mat.Cross(3), vector);
		return Vector4(x, y, z, w);
	}

	void Transform(Mat4Param mat, Vec4Ptr vector)
	{
		ErrorIf(vector == NULL, "Matrix4 - Null pointer passed for vector.");
		real x = Dot(mat.Cross(0), *vector);
		real y = Dot(mat.Cross(1), *vector);
		real z = Dot(mat.Cross(2), *vector);
		real w = Dot(mat.Cross(3), *vector);
		vector->Set(x, y, z, w);
	}

	Matrix4 BuildTransform(Vec3Param translate, QuatParam rotate, Vec3Param scale)
	{
		Matrix4 newMatrix;
		newMatrix.BuildTransform(translate, rotate, scale);
		return newMatrix;
	}

	Matrix4 BuildTransform(Vec3Param translate, Mat3Param rotate, Vec3Param scale)
	{
		Matrix4 newMatrix;
		newMatrix.BuildTransform(translate, rotate, scale);
		return newMatrix;
	}

	Vector3 TransformPoint(Mat4Param matrix, Vec3Param point)
	{
		real x = Dot(*(Vector3*)&matrix[0], point) + matrix[0][3];
		real y = Dot(*(Vector3*)&matrix[1], point) + matrix[1][3];
		real z = Dot(*(Vector3*)&matrix[2], point) + matrix[2][3];
		return Vector3(x, y, z);
	}

	Vector3 TransformNormal(Mat4Param matrix, Vec3Param normal)
	{
		real x = Dot(*(Vector3*)&matrix[0], normal);
		real y = Dot(*(Vector3*)&matrix[1], normal);
		real z = Dot(*(Vector3*)&matrix[2], normal);
		return Vector3(x, y, z);
	}

	Vector3 TransformPointProjected(Mat4Param matrix, Vec3Param point)
	{
		real x = Dot(*(Vector3*)&matrix[0], point) + matrix[3][0];
		real y = Dot(*(Vector3*)&matrix[1], point) + matrix[3][1];
		real z = Dot(*(Vector3*)&matrix[2], point) + matrix[3][2];
		real w = Dot(*(Vector3*)&matrix[3], point) + matrix[3][3];
		return Vector3(x / w, y / w, z / w);
	}

	Vector3 TransformNormalCol(Mat4Param matrix, Vec3Param normal)
	{
		real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), normal);
		real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), normal);
		real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), normal);
		return Vector3(x, y, z);
	}

	Vector3 TransformPointCol(Mat4Param matrix, Vec3Param point)
	{
		real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), point) + matrix[3][0];
		real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), point) + matrix[3][1];
		real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), point) + matrix[3][2];
		return Vector3(x, y, z);
	}

	Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point)
	{
		real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), point) + matrix[3][0];
		real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), point) + matrix[3][1];
		real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), point) + matrix[3][2];
		real w = Dot(Vector3(matrix.m03, matrix.m13, matrix.m23), point) + matrix[3][3];
		return Vector3(x / w, y / w, z / w);
	}

	Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point, real* wOut)
	{
		real x = Dot(Vector3(matrix.m00, matrix.m10, matrix.m20), point) + matrix[3][0];
		real y = Dot(Vector3(matrix.m01, matrix.m11, matrix.m21), point) + matrix[3][1];
		real z = Dot(Vector3(matrix.m02, matrix.m12, matrix.m22), point) + matrix[3][2];
		real w = Dot(Vector3(matrix.m03, matrix.m13, matrix.m23), point) + matrix[3][3];
		*wOut = w;
		return Vector3(x / w, y / w, z / w);
	}

	real Trace(Mat4Param matrix)
	{
		return matrix.m00 + matrix.m11 + matrix.m22 + matrix.m33;
	}

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
///  \file Numerical.cpp
///  Contains the implementation of the functions that operate on numerical data
///  as functions.
///
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	namespace
	{

		const uint cRootIterations = 2;

		//------------------------------------------------------------------------------
		real Cubed(real x)
		{
			return x * x * x;
		}

		//------------------------------------------------------------------------------
		real ToThe4th(real x)
		{
			return x * x * x * x;
		}

		//------------------------------------------------------------------------------
		real CubeRoot(real x)
		{
			real sign = Math::GetSign(x);
			return sign * Math::Pow(Math::Abs(x), real(1.0 / 3.0));
		}

		//------------------------------------------------------------------------------
		void MinMaxInPlace(real& x, real& y)
		{
			if (y < x)
			{
				Swap(x, y);
			}
		}

		//------------------------------------------------------------------------------
		void MinMaxInPlace(real& x, real& y, real& z)
		{
			MinMaxInPlace(x, y);
			MinMaxInPlace(x, z);
			MinMaxInPlace(y, z);
		}

		//------------------------------------------------------------------------------
		void MinMaxInPlace(real& x, real& y, real& z, real& w)
		{
			MinMaxInPlace(x, y);
			MinMaxInPlace(x, z);
			MinMaxInPlace(x, w);
			MinMaxInPlace(y, z);
			MinMaxInPlace(y, w);
			MinMaxInPlace(z, w);
		}

		//------------------------------------------------------------------------------
		void MinMaxInPlace(uint count, real* values)
		{
			switch (count)
			{
			case 2:
			{
				MinMaxInPlace(values[0], values[1]);
			}
			break;

			case 3:
			{
				MinMaxInPlace(values[0], values[1], values[2]);
			}
			break;

			case 4:
			{
				MinMaxInPlace(values[0], values[1], values[2], values[3]);
			}
			break;
			}
		}

	}// namespace

	///Evaluates the quadratic polynomial at the given x-value.
	///                          a2 * x^2 + a1 * x + a0
	real EvaluateQuadratic(real x, real a0, real a1, real a2)
	{
		return a0 + x * (a1 + x * a2);
	}

	///Evaluates the cubic polynomial at the given x-value.
	///                    a3 * x^3 + a2 * x^2 + a1 * x + a0
	real EvaluateCubic(real x, real a0, real a1, real a2, real a3)
	{
		return a0 + x * (a1 + x * (a2 + x * a3));
	}

	///Evaluates the quartic polynomial at the given x-value.
	///               a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0
	real EvaluateQuartic(real x, real a0, real a1, real a2, real a3, real a4)
	{
		return a0 + x * (a1 + x * (a2 + x * (a3 + x * a4)));
	}

	///Evaluates the polynomial at the given x-value.
	///             a[count] * x^(count) + ... + a[1] * x + a[0]
	real EvaluatePolynomial(real x, real* coefficients, uint coefficientCount)
	{
		ErrorIf(coefficientCount == 0, "Math - No coefficients passed for the " \
			"polynomial.");
		ErrorIf(coefficients == NULL, "Math - No coefficients passed for the "  \
			"polynomial.");

		uint n = coefficientCount - 1;
		real result = coefficients[n];
		for (int i = n - 1; i > -1; --i)
		{
			result = coefficients[i] + x * result;
		}
		return result;
	}

	///Solves the quadratic polynomial
	///                        a2 * x^2 + a1 * x + a0 = 0
	///returns the number of real roots found and stores the roots (if any) in the 
	///last parameter. If the last parameter is null, the roots will not be 
	///calculated.
	uint SolveQuadratic(real a0, real a1, real a2, real* roots)
	{
		real p = a1 / (real(2.0) * a2);
		real q = a0 / a2;
		real discr = p * p - q;
		if (Math::IsZero(discr))
		{
			if (roots != NULL)
			{
				roots[0] = -p;
			}
			return 1;
		}
		else if (discr > real(0.0))
		{
			if (roots != NULL)
			{
				discr = Math::Sqrt(discr);
				roots[0] = -discr - p;
				roots[1] = discr - p;
			}
			return 2;
		}
		return 0;
	}

	///Solves the cubic polynomial 
	///                 a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
	///returns the number of real roots found and stores the roots (if any) in the 
	///last parameter. If the last parameter is null, the roots will not be 
	///calculated.
	uint SolveCubic(real a0, real a1, real a2, real a3, real* roots)
	{
		real r[3] = { real(0.0) };
		uint rootCount = 0;

		//Solve the cubic equation
		if (a3 != real(0.0))
		{
			const real inv3 = real(1.0 / 3.0);
			const real invA = real(1.0) / a3;
			const real s = -a2 * inv3 * invA;
			const real ss = s * s;
			real p = a1 * inv3 * invA - ss;
			p = p * p * p;
			real q = real(0.5) * (real(2.0) * ss * s - (a1 * s + a0) * invA);
			real discr = q * q + p;
			if (discr < real(0.0))
			{
				if (roots == NULL)
				{
					return 3;
				}

				rootCount = 3;
				real arg = q / Math::Sqrt(-p);
				real phi;
				//This can be optimized to remove the trig functions!
				if (arg < real(-1.0))
				{
					phi = cPi * inv3;
				}
				else if (arg > real(1.0))
				{
					phi = real(0.0);
				}
				else
				{
					phi = Math::ArcCos(arg) * inv3;
				}
				p = real(2.0) * Math::Pow(-p, real(1.0 / 6.0));
				r[0] = p * Math::Cos(phi) + s;
				r[1] = p * Math::Cos(phi + real(2.0 / 3.0) * cPi) + s;
				r[2] = p * Math::Cos(phi + real(4.0 / 3.0) * cPi) + s;
			}
			else
			{
				if (roots == NULL)
				{
					return 1;
				}

				rootCount = 1;
				discr = Math::Sqrt(discr);
				r[0] = CubeRoot(q + discr) + CubeRoot(q - discr) + s;
			}
		}
		//Solve the quadratic equation
		else if (a2 != real(0.0))
		{
			real invB = real(1.0) / a2;
			real p = real(0.5) * a1 * invB;
			real discr = p * p - a0 * invB;
			if (discr > real(0.0))
			{
				if (roots == NULL)
				{
					return 2;
				}

				rootCount = 2;
				discr = Sqrt(discr);
				r[0] = -discr - p;
				r[1] = discr - p;
			}
			else
			{
				return 0;
			}
		}
		//Solve the linear equation
		else if (a1 != real(0.0))
		{
			if (roots == NULL)
			{
				return 1;
			}

			rootCount = 1;
			r[0] = a0 / a1;
		}

		const real two = real(2.0);
		const real three = real(3.0);
		roots[2] = r[2];
		roots[1] = r[1];
		roots[0] = r[0];
		MinMaxInPlace(rootCount, roots);
		//Clean up the roots with one iteration of Newton's method.
		switch (rootCount)
		{
		case 3:
			roots[2] = roots[2] - Math::EvaluateCubic(roots[2], a0, a1, a2, a3) /
				Math::EvaluateQuadratic(roots[2], a1, two * a2, three * a3);
		case 2:
			roots[1] = roots[1] - Math::EvaluateCubic(roots[1], a0, a1, a2, a3) /
				Math::EvaluateQuadratic(roots[1], a1, two * a2, three * a3);
		case 1:
			roots[0] = roots[0] - Math::EvaluateCubic(roots[0], a0, a1, a2, a3) /
				Math::EvaluateQuadratic(roots[0], a1, two * a2, three * a3);
		case 0:
			break;
		}
		return rootCount;
	}

	bool NearZero(float value)
	{
		return Math::Abs(value) < 0.00001f;
	}

	///Solves the quartic polynomial 
	///             a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
	///returns the number of real roots found and stores the roots (if any) in the 
	///last parameter. If the last parameter is null, the roots will not be 
	///calculated.
	uint SolveQuartic(real a0, real a1, real a2, real a3, real a4, real* roots)
	{
		if (a4 == real(0.0))
		{
			return SolveCubic(a0, a1, a2, a3, roots);
		}

		if (a4 != real(1.0))
		{
			a3 /= a4;
			a2 /= a4;
			a1 /= a4;
			a0 /= a4;
		}

		real p = real(-3.0 / 8.0) * Math::Sq(a3) + a2;
		real q = Cubed(a3) / real(8.0) - (a3 * a2) / real(2.0) + a1;
		real r = real(-3.0 / 256.0) * Math::Sq(a3) * Math::Sq(a3) +
			(Math::Sq(a3) * a2) / real(16.0) - (a3 * a1) / real(4.0) + a0;

		uint rootCount = 0;
		//Find solution to: y^3 - p/2 * y^2 - r * y + (4 * r * p - q^2)/8 = 0
		real c = (real(4.0) * r * p - (q * q)) / real(8.0);
		rootCount = SolveCubic(c, -r, -p / real(2.0), real(1.0), roots);

		//Use the result of the cubic polynomial to solve the two quadratics
		const real z = roots[0];

		real u = z * z - r;
		real v = real(2.0) * z - p;

		if (NearZero(u))
			u = 0.0f;
		else if (u > real(0.0))
			u = Math::Sqrt(u);
		else
			return 0;

		if (NearZero(v))
			v = 0.0f;
		else if (v > real(0.0))
			v = Math::Sqrt(v);
		else
			return 0;

		//Solve the roots for the two quadratic equations
		if (q >= real(0.0))
		{
			rootCount = SolveQuadratic(z - u, v, real(1.0), roots);
			rootCount += SolveQuadratic(z + u, -v, real(1.0),
				roots + (roots == NULL ? 0 : rootCount));
		}
		else
		{
			rootCount = SolveQuadratic(z + u, v, real(1.0), roots);
			rootCount += SolveQuadratic(z - u, -v, real(1.0),
				roots + (roots == NULL ? 0 : rootCount));
		}
		if (roots == NULL)
		{
			return rootCount;
		}

		//Get the roots in the order of most negative to most positive
		MinMaxInPlace(rootCount, roots);

		//Calculate the t-values for the quartic roots
		for (uint i = 0; i < rootCount; ++i)
		{
			roots[i] -= a3 / real(4.0);
		}

		//Clean up the roots with one iteration of Newton's method.
		const real two = real(2.0);
		const real three = real(3.0);
		const real four = real(4.0);
		for (uint i = 0; i < cRootIterations; ++i)
		{
			switch (rootCount)
			{
			case 4:
				roots[3] = roots[3] -
					Math::EvaluateQuartic(roots[3], a0, a1, a2, a3, a4) /
					Math::EvaluateCubic(roots[3], a1, two * a2, three * a3,
					four * a4);
			case 3:
				roots[2] = roots[2] -
					Math::EvaluateQuartic(roots[2], a0, a1, a2, a3, a4) /
					Math::EvaluateCubic(roots[2], a1, two * a2, three * a3,
					four * a4);
			case 2:
				roots[1] = roots[1] -
					Math::EvaluateQuartic(roots[1], a0, a1, a2, a3, a4) /
					Math::EvaluateCubic(roots[1], a1, two * a2, three * a3,
					four * a4);
			case 1:
				roots[0] = roots[0] -
					Math::EvaluateQuartic(roots[0], a0, a1, a2, a3, a4) /
					Math::EvaluateCubic(roots[0], a1, two * a2, three * a3,
					four * a4);
				break;

			case 0:
				return 0;
			}
		}
		return rootCount;
	}
}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///
/// \file Quaternion.cpp
/// Implementation of the Quaternion structure.
///
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{
	typedef Quaternion Quat;

	const Quaternion Quaternion::cIdentity = Quaternion(real(0.0), real(0.0),
		real(0.0), real(1.0));

	Quaternion::Quaternion(real xx, real yy, real zz, real ww)
	{
		x = xx;
		y = yy;
		z = zz;
		w = ww;
	}

	void Quaternion::operator=(QuatParam rhs)
	{
		x = rhs.x;
		y = rhs.y;
		z = rhs.z;
		w = rhs.w;
	}

	void Quaternion::operator+=(QuatParam rhs)
	{
		x += rhs.x;
		y += rhs.y;
		z += rhs.z;
		w += rhs.w;
	}

	void Quaternion::operator-=(QuatParam rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
		z -= rhs.z;
		w -= rhs.w;
	}

	void Quaternion::operator*=(QuatParam rhs)
	{
		Quat lhs(*this);
		x = lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y;
		y = lhs.w * rhs.y + lhs.y * rhs.w + lhs.z * rhs.x - lhs.x * rhs.z;
		z = lhs.w * rhs.z + lhs.z * rhs.w + lhs.x * rhs.y - lhs.y * rhs.x;
		w = lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
	}

	void Quaternion::operator*=(real rhs)
	{
		x *= rhs;
		y *= rhs;
		z *= rhs;
		w *= rhs;
	}

	void Quaternion::operator/=(real rhs)
	{
		ErrorIf(Math::IsZero(rhs), "Quaternion - Division by zero.");
		real reciprocal = real(1.0) / rhs;
		x *= reciprocal;
		y *= reciprocal;
		z *= reciprocal;
		w *= reciprocal;
	}

	Quaternion Quaternion::operator-(void) const
	{
		return Quaternion(-x, -y, -z, -w);
	}

	Quaternion Quaternion::operator*(QuatParam quat) const
	{
		return Quat(w * quat.x + x * quat.w + y * quat.z - z * quat.y,
			w * quat.y + y * quat.w + z * quat.x - x * quat.z,
			w * quat.z + z * quat.w + x * quat.y - y * quat.x,
			w * quat.w - x * quat.x - y * quat.y - z * quat.z);
	}

	Quaternion Quaternion::operator+(QuatParam rhs) const
	{
		return Quat(x + rhs.x, y + rhs.y, z + rhs.z, w + rhs.w);
	}

	Quaternion Quaternion::operator-(QuatParam rhs) const
	{
		return Quat(x - rhs.x, y - rhs.y, z - rhs.z, w - rhs.w);
	}

	Quaternion Quaternion::operator*(real rhs) const
	{
		return Quat(x * rhs, y * rhs, z * rhs, w * rhs);
	}

	Quaternion Quaternion::operator/(real rhs) const
	{
		ErrorIf(Math::IsZero(rhs), "Quaternion - Division by zero.");
		real reciprocal = real(1.0) / rhs;
		return Quat(x * reciprocal, y * reciprocal, z * reciprocal, w * reciprocal);
	}

	bool Quaternion::operator==(QuatParam rhs) const
	{
		return Equal(x, rhs.x) &&
			Equal(y, rhs.y) &&
			Equal(z, rhs.z) &&
			Equal(w, rhs.w);
	}

	bool Quaternion::operator!=(QuatParam rhs) const
	{
		return !(*this == rhs);
	}

	real& Quaternion::operator[](uint index)
	{
		ErrorIf(index > 3, "Quaternion - Subscript out of range.");
		return V4()[index];
	}

	real Quaternion::operator[](uint index) const
	{
		ErrorIf(index > 3, "Quaternion - Subscript out of range.");
		return V4()[index];
	}

	void Quaternion::Set(real xx, real yy, real zz, real ww)
	{
		x = xx;
		y = yy;
		z = zz;
		w = ww;
	}

	void Quaternion::Integrate(Vec3Param vector, real scalar)
	{
		Quat q(vector.x * scalar, vector.y * scalar, vector.z * scalar, real(0.0));

		q *= *this;

		x += real(0.5) * q.x;
		y += real(0.5) * q.y;
		z += real(0.5) * q.z;
		w += real(0.5) * q.w;
	}

	real Quaternion::Normalize(void)
	{
		real length = LengthSq();

		if (Math::Equal(length, real(0.0)))
		{
			x = real(0.0);
			y = x;
			z = x;
			w = real(1.0);
			return real(0.0);
		}
		else
		{
			length = Math::Rsqrt(length);
			*this *= length;
			return length;
		}
	}

	Quaternion Quaternion::Normalized(void) const
	{
		real length = LengthSq();

		if (Math::Equal(length, real(0.0)))
		{
			return Quat(real(0.0), real(0.0), real(0.0), real(1.0));
		}
		else
		{
			length = Math::Rsqrt(length);
			return (*this) * length;
		}
	}

	real Quaternion::Dot(QuatParam rhs) const
	{
		return V4().Dot(rhs.V4());
	}

	real Quaternion::Length(void) const
	{
		return Math::Sqrt(LengthSq());
	}

	real Quaternion::LengthSq(void) const
	{
		return V4().LengthSq();
	}

	void Quaternion::Conjugate(void)
	{
		x *= -real(1.0);
		y *= -real(1.0);
		z *= -real(1.0);
	}

	Quaternion Quaternion::Conjugated(void) const
	{
		return Quat(-x, -y, -z, w);
	}

	void Quaternion::Invert(void)
	{
		Conjugate();
		real lengthSq = LengthSq();

		ErrorIf(Math::IsZero(lengthSq), "Quaternion - Division by zero.");
		*this /= lengthSq;
	}

	Quaternion Quaternion::Inverted(void) const
	{
		real lengthSq = LengthSq();
		ErrorIf(Math::IsZero(lengthSq), "Quaternion - Division by zero.");
		lengthSq = real(1.0) / lengthSq;
		return Quat(-x * lengthSq, -y * lengthSq, -z * lengthSq, w * lengthSq);
	}

	Quaternion Quaternion::Exponent(void) const
	{
		real angle = V3().Length();
		Quat quaternion(x, y, z, real(0.0));

		if (Math::Abs(angle) > Math::Epsilon())
		{
			quaternion.w = Math::Cos(angle);
			angle = Math::Sin(angle) / angle;
			quaternion.x *= angle;
			quaternion.y *= angle;
			quaternion.z *= angle;
		}
		return quaternion;
	}

	Quaternion Quaternion::Logarithm(void) const
	{
		Quat quaternion(x, y, z, real(0.0));
		real theta = Math::ArcCos(w);
		real sinTheta = Math::Sin(theta);

		if (Math::Abs(sinTheta) > Math::Epsilon())
		{
			theta = theta / sinTheta;
			quaternion.x *= theta;
			quaternion.y *= theta;
			quaternion.z *= theta;
		}
		return quaternion;
	}

	void Quaternion::RotateVector(Vec3Ptr vector)
	{
		Quat tempVec = Quat(vector->x, vector->y, vector->z, real(0.0));
		Quat conjugate(-x, -y, -z, w);
		Quat result(*this);
		result *= tempVec;
		result *= conjugate;
		vector->Set(result.x, result.y, result.z);
	}

	Vector3 Quaternion::RotatedVector(Vec3Param vector) const
	{
		Quat tempVec = Quat(vector.x, vector.y, vector.z, real(0.0));
		Quat conjugate(-x, -y, -z, w);
		Quat result(*this);
		result *= tempVec;
		result *= conjugate;
		return Vector3(result.x, result.y, result.z);
	}

	void Quaternion::ZeroOut(void)
	{
		V3().ZeroOut();
		w = real(1.0);
	}

	bool Quaternion::Valid(void) const
	{
		return Math::IsValid(x) && Math::IsValid(y) &&
			Math::IsValid(z) && Math::IsValid(w);
	}

	Vector3& Quaternion::V3()
	{
		return *(Vector3*)this;
	}

	Vector4& Quaternion::V4()
	{
		return *(Vector4*)this;
	}

	const Vector3& Quaternion::V3() const
	{
		return *(Vector3*)this;
	}

	const Vector4& Quaternion::V4() const
	{
		return *(Vector4*)this;
	}

	Quaternion operator*(real lhs, QuatParam rhs)
	{
		return rhs * lhs;
	}

	void Normalize(QuatPtr quaternion)
	{
		quaternion->Normalize();
	}

	Quaternion Normalized(QuatParam quaternion)
	{
		return quaternion.Normalized();
	}

	real Dot(QuatParam lhs, QuatParam rhs)
	{
		return lhs.Dot(rhs);
	}

	real Length(QuatParam quaternion)
	{
		return quaternion.Length();
	}

	real LengthSq(QuatParam quaternion)
	{
		return quaternion.LengthSq();
	}

	Quaternion Lerp(QuatParam start, QuatParam end, real tValue)
	{
		WarnIf(!Math::InRange(tValue, real(0.0), real(1.0)),
			"Quaternion - Interpolation value is not in the range of [0, 1]");
		real alpha = tValue;
		real oneMinusAlpha = real(1.0) - alpha;
		Quat quaternion(start.x * oneMinusAlpha + end.x * alpha,
			start.y * oneMinusAlpha + end.y * alpha,
			start.z * oneMinusAlpha + end.z * alpha,
			start.w * oneMinusAlpha + end.w * alpha);
		Normalize(&quaternion);
		return quaternion;
	}

	Quaternion Slerp(QuatParam start, QuatParam end, real tValue)
	{
		WarnIf(!Math::InRange(tValue, real(0.0), real(1.0)),
			"Quaternion - Interpolation value is not in the range of [0, 1]");

		//
		// Quaternion Interpolation With Extra Spins, pp. 96f, 461f
		// Jack Morrison, Graphics Gems III, AP Professional
		//

		const real cSlerpEpsilon = real(0.00001);

		bool flip;

		real cosTheta = Dot(start, end);

		//Check to ensure that the shortest path is taken (cosine of the angle between 
		//the two quaternions is positive).
		flip = cosTheta < real(0.0);
		if (flip)
		{
			cosTheta = -cosTheta;
		}

		real startVal, endVal;
		if ((real(1.0) - cosTheta) > cSlerpEpsilon)
		{
			real theta = Math::ArcCos(cosTheta);
			real sinTheta = Math::Sin(theta);
			startVal = real(Math::Sin((real(1.0) - tValue) * theta) / sinTheta);
			endVal = real(Math::Sin(tValue * theta) / sinTheta);
		}
		else
		{
			startVal = real(1.0) - tValue;
			endVal = real(tValue);
		}

		if (flip)
		{
			endVal = -endVal;
		}

		return Quaternion(startVal * start.x + endVal * end.x,
			startVal * start.y + endVal * end.y,
			startVal * start.z + endVal * end.z,
			startVal * start.w + endVal * end.w);
	}

	Quaternion CreateDiagonalizer(Mat3Param matrix)
	{
		const uint cMaxSteps = 50;

		Quaternion quat(real(0.0), real(0.0), real(0.0), real(1.0));
		Matrix3 quatMatrix;
		Matrix3 diagMatrix;
		for (uint i = 0; i < cMaxSteps; ++i)
		{
			ToMatrix3(quat, &quatMatrix);
			diagMatrix = Concat(Concat(quatMatrix, matrix), quatMatrix.Transposed());

			//Elements not on the diagonal
			Vector3 offDiag(diagMatrix(1, 2), diagMatrix(0, 2), diagMatrix(0, 1));

			//Magnitude of the off-diagonal elements
			Vector3 magDiag = Abs(offDiag);

			//Index of the largest element 
			uint k = ((magDiag.x > magDiag.y) && (magDiag.x > magDiag.z)) ? 0 :
				((magDiag.y > magDiag.z) ? 1 : 2);
			uint k1 = (k + 1) % 3;
			uint k2 = (k + 2) % 3;

			//Diagonal already
			if (offDiag[k] == real(0.0))
			{
				break;
			}

			real theta = (diagMatrix(k2, k2) - diagMatrix(k1, k1)) /
				(real(2.0) * offDiag[k]);
			real sign = Math::GetSign(theta);

			//Make theta positive
			theta *= sign;

			//Large term in T
			real thetaTerm = theta < real(1e6) ? Math::Sqrt(Math::Sq(theta) + real(1.0))
				: theta;

			//Sign(T) / (|T| + sqrt(T^2 + 1))
			real t = sign / (theta + thetaTerm);

			//c = 1 / (t^2 + 1)      t = s / c
			real c = real(1.0) / Math::Sqrt(Math::Sq(t) + real(1.0));

			//No room for improvement - reached machine precision.
			if (c == real(1.0))
			{
				break;
			}

			//Jacobi rotation for this iteration
			Quaternion jacobi(real(0.0), real(0.0), real(0.0), real(0.0));

			//Using 1/2 angle identity sin(a/2) = sqrt((1-cos(a))/2)
			jacobi[k] = sign * Math::Sqrt((real(1.0) - c) / real(2.0));

			//Since our quat-to-matrix convention was for v*M instead of M*v
			jacobi.w = Math::Sqrt(real(1.0) - Math::Sq(jacobi[k]));

			//Reached limits of floating point precision
			if (jacobi.w == real(1.0))
			{
				break;
			}

			quat *= jacobi;
			Normalize(&quat);
		}

		return quat;
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file StressRandom.cpp
/// Implementation of the random number and vector generation functions.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
//The following comment is required to use the Mersenne Twister
/*
A C-program for MT19937, with initialization improved 2002/1/26.
Coded by Takuji Nishimura and Makoto Matsumoto.

Before using, initialize the state by using init_genrand(seed)
or init_by_array(init_key, key_length).

Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

3. The names of its contributors may not be used to endorse or promote
products derived from this software without specific prior written
permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Any feedback is very welcome.
http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

#include <ctime>

using Zero::String;

namespace Math
{

	namespace
	{
		//----------------------------------------------- Mersenne Twister Magic Numbers
		const uint cM = 397;                //Period parameter.
		const uint cMatrixA = 0x9908B0DF;   //Constant vector A.
		const uint cUpperMask = 0x80000000; //Most significant w-r bits.
		const uint cLowerMask = 0x7FFFFFFF; //Least significant r bits.
		const uint cAllMask = 0xFFFFFFFF;   //All the bits.
	}

	//----------------------------------------------------------------------- Random
	uint Random::mGlobalSeed = 1299827;

	Random::Random(void)
	{
		//we need something with higher precision than seconds (such as time(0)),
		//so use clock which is the number of clock ticks since the program was executed.
		mSeed = clock();
		mSeed ^= mGlobalSeed;

		// Call next once just to jumble it up a bit
		Next();
	}

	Random::Random(int initialSeed)
		: mSeed(initialSeed)
	{
		//
	}

	uint Random::GetSeed()
	{
		return mSeed;
	}

	void Random::SetSeed(uint seed)
	{
		mSeed = seed;
	}

	uint Random::Next(void)
	{
		mSeed = 214013 * mSeed + 2531011;
		mGlobalSeed = mSeed;
		return (mSeed >> 16) & cRandMax;
	}

	u32 Random::Uint32(void)
	{
		return (Next() << 16) | Next();
	}

	u64 Random::Uint64(void)
	{
		u64 a = Uint32();
		a = a << 32;
		a |= Uint32();
		return a;
	}

	float Random::Float(void)
	{
		return Next() / float(cRandMax);
	}

	bool Random::Bool(void)
	{
		return IntRangeInIn(0, 1) == 1;
	}

	int Random::IntRangeInIn(int min, int max)
	{
		if (min > max)
		{
			String msg = String::Format("The min value '%d' must be less than or equal to the max value '%d'", min, max);
			//DoNotifyException("Invalid range", msg);
			return min;
		}

		ErrorIf(min > max, "Invalid range.");
		int range = max - min;
		return int(Uint32() % (range + 1)) + min;
	}

	int Random::IntRangeInEx(int min, int max)
	{
		if (min >= max)
		{
			String msg = String::Format("The min value '%d' must be less than the max value '%d'", min, max);
			//DoNotifyException("Invalid range", msg);
			return min;
		}

		ErrorIf(min > max, "Invalid range.");
		int range = max - min;
		return (Next() % range) + min;
	}

	int Random::IntVariance(int base, int variance)
	{
		if (variance < 0)
		{
			String msg = String::Format("The variance value '%d' cannot be negative.", variance);
			//DoNotifyException("Invalid variance", msg);
			return base;
		}

		return IntRangeInIn(base - variance, base + variance);
	}

	float Random::FloatRange(float min, float max)
	{
		ErrorIf(min > max, "Invalid range.");
		float range = max - min;
		return (Float() * range) + min;
	}

	float Random::FloatVariance(float base, float variance)
	{
		//Map from [0.0f, 1.0f] to [-0.5f, 0.5f]
		float val = Float() - 0.5f;

		//Map from [-0.5f, 0.5f] to [-variance, variance)
		val *= variance * 2.0f;

		//Map from [base - variance, base + variance]
		val += base;

		return val;
	}

	Vector2 Random::PointOnUnitCircle(void)
	{
		const float cTwoPi = float(Math::cTwoPi);
		real angle = real(cTwoPi * Float());
		return Vector2(Math::Cos(angle), Math::Sin(angle));
	}

	//Returns a point on a unit circle with the x-axis going through the center
	//of the circle.
	Vector3 Random::PointOnUnitCircleX(void)
	{
		Vector2 point = PointOnUnitCircle();
		return Vector3(real(0.0), point.y, point.x);
	}

	//Returns a point on a unit circle with the y-axis going through the center
	//of the circle.
	Vector3 Random::PointOnUnitCircleY(void)
	{
		Vector2 point = PointOnUnitCircle();
		return Vector3(point.x, real(0.0), point.y);
	}

	//Returns a point on a unit circle with the z-axis going through the center
	//of the circle.
	Vector3 Random::PointOnUnitCircleZ(void)
	{
		Vector2 point = PointOnUnitCircle();
		return Vector3(point.x, point.y, real(0.0));
	}

	Vector3 Random::PointOnUnitSphere(void)
	{
		Vector3 v = Vector3(real(0.0), real(0.0), FloatRange(real(-1.0), real(1.0)));
		const real t = FloatRange(-cPi, cPi);
		const real radius = Sqrt(real(1.0) - (v.z * v.z));
		v.x = Cos(t) * radius;
		v.y = Sin(t) * radius;
		return Normalized(v);
	}

	Vector3 Random::PointInUnitSphere(void)
	{
		real cubeRoot = real(1.0 / 3.0);
		real scalar = Float();
		return PointOnUnitSphere() * Math::Pow(scalar, cubeRoot);
	}

	//Generate uniform random quaternion
	Quaternion Random::RotationQuaternion(void)
	{
		//This algorithm generates a Gaussian deviate for each coordinate, so the
		//total effect is to generate a symmetric 4-D Gaussian distribution, by
		//separability. Projecting onto the surface of the hypersphere gives a uniform
		//distribution
		float x = FloatRange(-1.0f, 1.0f);
		float y = FloatRange(-1.0f, 1.0f);
		float z = FloatRange(-1.0f, 1.0f);
		float w = FloatRange(-1.0f, 1.0f);

		float s1;
		while ((s1 = x * x + y * y) > 1.0f)
		{
			x = FloatRange(-1.0f, 1.0f);
			y = FloatRange(-1.0f, 1.0f);
		}

		float s2;
		while ((s2 = z * z + w * w) > 1.0f)
		{
			z = FloatRange(-1.0f, 1.0f);
			w = FloatRange(-1.0f, 1.0f);
		}

		//Now the point (x, y) is uniformly distributed in the unit disk, so is the 
		//point (z, w), independently
		float num1 = -2.0f * float(Math::Log(s1));
		float num2 = -2.0f * float(Math::Log(s2));

		//Now "x * sqrt(num1 / s2)" is Gaussian distributed, using polar method.
		//Similarly for y, z, and w, and all are independent
		float r = num1 + num2;  //Sum of squares of four Gaussians
		float root1 = float(Math::Sqrt(num1 / (s1 * r)));
		float root2 = float(Math::Sqrt(num2 / (s2 * r)));

		//Normalizing onto unit sphere gives uniform unit quaternion
		return Quaternion(x * root1, y * root1, z * root2, w * root2);
	}

	Vector2 Random::ScaledVector2(float minLength, float maxLength)
	{
		real size = maxLength - minLength;
		real scalar = Float();
		return PointOnUnitCircle() * (minLength + size * Math::Sqrt(scalar));
	}

	Vector3 Random::ScaledVector3(float minLength, float maxLength)
	{
		real cubeRoot = 1.0f / 3.0f;
		real size = maxLength - minLength;
		real scalar = Float();
		return PointOnUnitSphere() * (minLength + size * Math::Pow(scalar, cubeRoot));
	}

	//Generate uniform random matrix
	Matrix3 Random::RotationMatrix(void)
	{
		Matrix3 matrix;
		RotationMatrix(&matrix);
		return matrix;
	}

	void Random::RotationMatrix(Mat3Ptr matrix)
	{
		ErrorIf(matrix == NULL, "Invalid matrix provided.");
		Quaternion quat = RotationQuaternion();
		ToMatrix3(quat, matrix);
	}

	int Random::DieRoll(uint sides)
	{
		if (sides == 0)
		{
			//DoNotifyException("Invalid die roll", "Cannot roll a zero sided die");
			return 0;
		}
		return IntRangeInEx(0, sides) + 1;
	}

	float Random::BellCurve(float center, float range, float standardDeviation)
	{
		float randVal = 0.0f;
		do
		{
			//This is the box-muller normal distribution algorithm.
			float u1, u2, s;
			do
			{
				//get two random floats in the range [-1,1]
				u1 = (Float() - .5f) * 2.0f;
				u2 = (Float() - .5f) * 2.0f;
				s = u1 * u1 + u2 * u2;
			} while (s >= 1.0f || s == 0.0f);

			//this technically generates 2 random for every call but we're only saving one now.
			//the other one generated is u2 * multiplier
			float multiplier = Math::Sqrt(-2.0f * Math::Log(s) / s);
			randVal = u1 * multiplier;

			//alter the standard deviation
			randVal *= standardDeviation;
			//Since the user gave us a range, restart if we don't have a value within
			//the valid range. a normal distribution can return a value at an infinite
			//range technically, and clamping the value will alter our probability.
			//Restarting is the only way to properly deal with this.
		} while (randVal < -3.0f || randVal > 3.0f);

		//shift over to the center and remap the [-3,3] range to [center - range, center + range]
		randVal = randVal * (range / 3.0f) + center;

		return randVal;
	}

	//------------------------------------------------------------- Mersenne Twister
	///Seeds with a call to the "time" function.
	MersenneTwister::MersenneTwister(void)
		: mIndex(cN + 1)
	{
		Initialize(uint(time(NULL)));
	}

	///Initializes the internal array with a seed.
	MersenneTwister::MersenneTwister(uint seed)
		: mIndex(cN + 1)
	{
		Initialize(seed);
	}

	///Initialize by an array with array-length. "keys" is the array for 
	///initializing keys. "keyLength" is its length.
	MersenneTwister::MersenneTwister(uint keys[], uint keyLength)
		: mIndex(cN + 1)
	{
		Initialize(keys, keyLength);
	}

	///Initializes the values with a seed.
	void MersenneTwister::Initialize(uint seed)
	{
		const uint cMultiplier = 1812433253;
		uint& i = mIndex;
		mValues[0] = seed & cAllMask;
		for (i = 1; i < cN; ++i)
		{
			//See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. In the previous 
			//versions, MSBs of the seed affect only MSBs of the array mValues[].
			mValues[i] = cMultiplier * (mValues[i - 1] ^ (mValues[i - 1] >> 30)) + i;

			//For >32 bit machines
			mValues[i] &= cAllMask;
		}
	}

	///Initialize by an array with array-length. "keys" is the array for 
	///initializing keys. "keyLength" is its length.
	void MersenneTwister::Initialize(uint keys[], uint keyLength)
	{
		const uint cInitialSeed = 19650218;

		Initialize(cInitialSeed);
		uint i = 1;
		uint j = 0;
		uint k = cN > keyLength ? cN : keyLength;
		for (/* k */; k != 0; k--)
		{
			const uint h = i - 1;

			//Non-linear
			mValues[i] = (mValues[i] ^ ((mValues[h] ^ (mValues[h] >> 30)) * 1664525)) +
				keys[j] + j;
			mValues[i] &= cAllMask; //for WORDSIZE > 32 machines
			++i;
			++j;
			if (i >= cN)
			{
				mValues[0] = mValues[cN - 1];
				i = 1;
			}
			if (j >= keyLength)
			{
				j = 0;
			}
		}
		for (k = cN - 1; k != 0; --k)
		{
			const uint h = i - 1;

			//Non-linear
			mValues[i] = (mValues[i] ^ ((mValues[h] ^ (mValues[h] >> 30)) * 1566083941)) - i;
			mValues[i] &= cAllMask; //for WORDSIZE > 32 machines
			++i;
			if (i >= cN)
			{
				mValues[0] = mValues[cN - 1];
				i = 1;
			}
		}
		mValues[0] = cUpperMask;  //MSB is 1; assuring non-zero initial array.
	}

	///Generates a random number on the [-2,147,483,648, 2,147,483,648] interval.
	int MersenneTwister::Int(void)
	{
		uint i = Uint();
		return *reinterpret_cast<int*>(&i);
	}

	///Generates a random number on the [0, 4,294,967,295] interval.
	uint MersenneTwister::Uint(void)
	{
		//mag01[x] = x * cMatrixA for x = 0, 1
		static uint mag01[2] = { 0x0, cMatrixA };

		//Generate N words at one time.
		if (mIndex >= cN)
		{
			//If "Initialize" has not been called, a default initial seed is used.
			if (mIndex == cN + 1)
			{
				Initialize(5489);
			}

			uint y;
			int kk;
			for (kk = 0; kk < cN - cM; ++kk)
			{
				y = (mValues[kk] & cUpperMask) | (mValues[kk + 1] & cLowerMask);
				mValues[kk] = mValues[kk + cM] ^ (y >> 1) ^ mag01[y & 0x1];
			}
			for (/*kk*/; kk < cN - 1; ++kk)
			{
				y = (mValues[kk] & cUpperMask) | (mValues[kk + 1] & cLowerMask);
				mValues[kk] = mValues[kk + (cM - cN)] ^ (y >> 1) ^ mag01[y & 0x1];
			}
			y = (mValues[cN - 1] & cUpperMask) | (mValues[0] & cLowerMask);
			mValues[cN - 1] = mValues[cM - 1] ^ (y >> 1) ^ mag01[y & 0x1];

			mIndex = 0;
		}

		uint y = mValues[mIndex++];

		//Tempering
		y ^= (y >> 11);
		y ^= (y << 7) & 0x9D2C5680;
		y ^= (y << 15) & 0xEFC60000;
		y ^= (y >> 18);
		return y;
	}

	///Generates a random number on the [0,1)-real-interval.
	float MersenneTwister::Float(void)
	{
		//Divided by 2^32
		return float(Uint()) * (1.0f / 4294967295.0f);
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Reals.cpp
/// Implementation of the real typedef and utility functions.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <cmath>
#include <limits>
#include <cstdio>
#include <cstdlib>
#include <cfloat>

namespace Math
{

	namespace
	{
		const real cTemp = real(-0.0);
		const uint cSignBit = *reinterpret_cast<uint const*>(&cTemp);
		const real cNegative = real(-1.0);
		const real cPositive = real(1.0);

		real gZeroForInf = real(0.0);
		real gInfinite = real(1.0) / gZeroForInf;
	}

	const real& cInfinite = gInfinite;

	real Epsilon(void)
	{
		return real(0.00000001);
	}

	real PositiveMax(void)
	{
		return FLT_MAX;
	}

	real PositiveMin()
	{
		return FLT_MIN;
	}

	bool Equal(real lhs, real rhs)
	{
		return Abs(lhs - rhs) <= Epsilon() * (Abs(lhs) + Abs(rhs) + real(1.0));
	}

	bool Equal(real lhs, real rhs, real epsilon)
	{
		return Abs(lhs - rhs) <= epsilon * (Abs(lhs) + Abs(rhs) + real(1.0));
	}

	bool NotEqual(real lhs, real rhs)
	{
		return !Equal(lhs, rhs);
	}

	bool IsZero(real val)
	{
		return Abs(val) <= Epsilon();
	}

	bool IsNegative(real number)
	{
		return GetSign(number) == cNegative;
	}

	bool IsPositive(real number)
	{
		return GetSign(number) == cPositive;
	}

	bool LessThan(real lhs, real rhs)
	{
		return lhs < rhs;
	}

	bool LessThanOrEqual(real lhs, real rhs)
	{
		return lhs <= rhs;
	}

	bool GreaterThan(real lhs, real rhs)
	{
		return lhs > rhs;
	}

	bool GreaterThanOrEqual(real lhs, real rhs)
	{
		return lhs >= rhs;
	}

	real Sqrt(real val)
	{
		return std::sqrt(val);
	}

	bool SafeSqrt(real val, real& result)
	{
		if (val < 0)
			return false;

		result = Sqrt(val);
		return true;
	}

	real Rsqrt(real val)
	{
		return real(1.0) / std::sqrt(val);
	}

	real Sq(real sqrt)
	{
		return sqrt * sqrt;
	}

	real Pow(real base, real exp)
	{
		return std::pow(base, exp);
	}

	real Log(real val)
	{
		return std::log(val);
	}

	real Log(real val, real base)
	{
		return Log(val) / Log(base);
	}

	real Log10(real val)
	{
		return std::log10(val);
	}

	real Log2(real val)
	{
		//log(2) is a constant (and actually calling log(2.0) caused a linker crash so use the constant)
		real log2 = real(0.30102999566);
		return Log(val) / log2;
	}

	real Exp(real val)
	{
		return std::exp(val);
	}

	real Exp2(real val)
	{
		return Pow(2, val);
	}

	real Abs(real val)
	{
		return std::abs(val);
	}

	int Abs(int val)
	{
		return std::abs(val);
	}

	real FMod(real dividend, real divisor)
	{
		return std::fmod(dividend, divisor);
	}

	bool SafeFMod(real dividend, real divisor, real& result)
	{
		if (divisor == 0)
			return false;

		result = FMod(dividend, divisor);
		return true;
	}

	real GetSign(real val)
	{
		return (*reinterpret_cast<uint*>(&val) & cSignBit) != 0 ? cNegative
			: cPositive;
		//return lhs >= real(0.0) ? real(1.0) : real(-1.0);
	}

	int Sign(real val)
	{
		if (val < 0)
			return -1;
		return 1;
	}

	int Sign(int val)
	{
		if (val < 0)
			return -1;
		return 1;
	}

	real Cos(real val)
	{
		return std::cos(val);
	}

	real Sin(real val)
	{
		return std::sin(val);
	}

	real Tan(real angle)
	{
		return std::tan(angle);
	}

	real Cosh(real val)
	{
		return std::cosh(val);
	}

	real Sinh(real val)
	{
		return std::sinh(val);
	}

	real Tanh(real angle)
	{
		return std::tanh(angle);
	}

	real ArcCos(real angle)
	{
		angle = Math::ClampIfClose(angle, real(-1.0), real(1.0), real(0.00001));
		return std::acos(angle);
	}

	real ArcSin(real angle)
	{
		angle = Math::ClampIfClose(angle, real(-1.0), real(1.0), real(0.00001));
		return std::asin(angle);
	}

	real ArcTan(real angle)
	{
		return std::atan(angle);
	}

	real ArcTan2(real y, real x)
	{
		return std::atan2(y, x);
	}

	bool SafeArcCos(real radians, real& result)
	{
		bool isSafe = Math::TryClampIfClose(radians, -1.0f, 1.0f, 0.00001f);
		if (isSafe)
			result = Math::ArcCos(radians);
		return isSafe;
	}

	bool SafeArcSin(real radians, real& result)
	{
		bool isSafe = Math::TryClampIfClose(radians, -1.0f, 1.0f, 0.00001f);
		if (isSafe)
			result = Math::ArcSin(radians);
		return isSafe;
	}

	real RadToDeg(real radians)
	{
		return (real(180.0) / cPi) * radians;
	}

	real DegToRad(real degrees)
	{
		return (cPi / real(180.0)) * degrees;
	}

	bool IsValid(real val)
	{
#ifdef _MSC_VER
		return _finite(val) != 0;
#else
		return val == val;
#endif
	}

	real Round(real value)
	{
		return std::floor(value + real(0.5));
	}

	real Round(real value, int places)
	{
		return Round(value, places, 10);
	}

	real Round(real value, int places, int base)
	{
		real scale = std::pow(real(base), places);
		return Round(value / scale) * scale;
	}

	real Truncate(real value)
	{
		return (real)(int)value;
	}

	real Truncate(real value, int places)
	{
		return Truncate(value, places, 10);
	}

	real Truncate(real value, int places, int base)
	{
		real scale = std::pow(real(base), places);
		return Truncate(value / scale) * scale;
	}

	real Fractional(real val)
	{
		real signedFrac = val - Truncate(val);
		return Abs(signedFrac);
	}

	real Ceil(real value)
	{
		return std::ceil(value);
	}

	real Ceil(real value, int places)
	{
		return Ceil(value, places, 10);
	}

	real Ceil(real value, int places, int base)
	{
		real scale = std::pow(real(base), places);
		return Ceil(value / scale) * scale;
	}

	real Floor(real value)
	{
		return std::floor(value);
	}

	real Floor(real value, int places)
	{
		return Floor(value, places, 10);
	}

	real Floor(real value, int places, int base)
	{
		real scale = std::pow(real(base), places);
		return Floor(value / scale) * scale;
	}

	real Step(real y, real x)
	{
		return (x >= y) ? real(1.0) : real(0.0);
	}

	int CountBits(int value)
	{
		uint count = 0;
		//trick that is O(k) where k is the number of bits set
		while (value != 0)
		{
			value = (value - 1) & value;
			++count;
		}
		return count;
	}

}// namespace Math

///
///  \file Vector2.cpp
///  Implementation of the Vector 2 structure.
///
///  Authors: Joshua Davis, Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const Vector2 Vector2::cZero(real(0.0), real(0.0));
	const Vector2 Vector2::cXAxis(real(1.0), real(0.0));
	const Vector2 Vector2::cYAxis(real(0.0), real(1.0));
	const Vector2 Vector2::Axes[] = { Vector2::cXAxis, Vector2::cYAxis };

	Vector2::Vector2(real x_, real y_)
	{
		x = x_;
		y = y_;
	}

	Vector2::Vector2(real xy)
	{
		x = xy;
		y = xy;
	}

	Vector2::Vector2(ConstRealPointer data)
	{
		array[0] = data[0];
		array[1] = data[1];
	}

	real& Vector2::operator[](uint index)
	{
		ErrorIf(index > 1, "Math::Vector2 - Subscript out of range.");
		return array[index];
	}

	real Vector2::operator[](uint index) const
	{
		ErrorIf(index > 1, "Math::Vector2 - Subscript out of range.");
		return array[index];
	}

	////////// Unary Operators /////////////////////////////////////////////////////

	Vector2 Vector2::operator-(void) const
	{
		return Vector2(-x, -y);
	}

	////////// Binary Assignment Operators (reals) /////////////////////////////////

	void Vector2::operator*=(real rhs)
	{
		x *= rhs;
		y *= rhs;
	}

	void Vector2::operator/=(real rhs)
	{
		ErrorIf(Math::IsZero(rhs), "Math::Vector2 - Division by zero.");
		x /= rhs;
		y /= rhs;
	}

	////////// Binary Operators (reals) ////////////////////////////////////////////

	Vector2 Vector2::operator*(real rhs) const
	{
		return Vector2(x * rhs, y * rhs);
	}

	Vector2 Vector2::operator/(real rhs) const
	{
		ErrorIf(Math::IsZero(rhs), "Math::Vector2 - Division by zero.");
		return Vector2(x / rhs, y / rhs);
	}

	////////// Binary Assignment Operators (Vectors) ///////////////////////////////

	void Vector2::operator+=(Vec2Param rhs)
	{
		x += rhs.x;
		y += rhs.y;
	}

	void Vector2::operator-=(Vec2Param rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
	}

	////////// Binary Operators (Vectors) //////////////////////////////////////////

	Vector2 Vector2::operator+(Vec2Param rhs) const
	{
		return Vector2(x + rhs.x, y + rhs.y);
	}

	Vector2 Vector2::operator-(Vec2Param rhs) const
	{
		return Vector2(x - rhs.x, y - rhs.y);
	}

	////////// Binary Vector Comparisons ///////////////////////////////////////////

	bool Vector2::operator==(Vec2Param rhs) const
	{
		return Equal(x, rhs.x) &&
			Equal(y, rhs.y);
	}

	bool Vector2::operator!=(Vec2Param rhs) const
	{
		return !(*this == rhs);
	}

	BoolVec2 Vector2::operator< (Vec2Param rhs) const
	{
		return BoolVec2(x < rhs.x,
			y < rhs.y);
	}

	BoolVec2 Vector2::operator<=(Vec2Param rhs) const
	{
		return BoolVec2(x <= rhs.x,
			y <= rhs.y);
	}

	BoolVec2 Vector2::operator>(Vec2Param rhs) const
	{
		return BoolVec2(x > rhs.x,
			y > rhs.y);
	}

	BoolVec2 Vector2::operator>=(Vec2Param rhs) const
	{
		return BoolVec2(x >= rhs.x,
			y >= rhs.y);
	}

	void Vector2::Set(real x_, real y_)
	{
		x = x_;
		y = y_;
	}

	void Vector2::ZeroOut(void)
	{
		array[0] = real(0.0);
		array[1] = real(0.0);
	}

	Vector2 Vector2::Reflect(Vec2Param rhs) const
	{
		Vector2 reflect = rhs;
		reflect *= (*this).Dot(rhs);
		reflect *= real(2.0);
		reflect -= *this;
		return reflect;
	}

	void Vector2::AddScaledVector(Vec2Param vector, real scalar)
	{
		x += vector.x * scalar;
		y += vector.y * scalar;
	}

	real Vector2::Dot(Vec2Param rhs) const
	{
		return x * rhs.x + y * rhs.y;
	}

	Vector2 Vector2::operator/(Vec2Param rhs) const
	{
		ErrorIf(rhs.x == real(0.0) || rhs.y == real(0.0),
			"Vector2 - Division by zero.");
		return Vector2(x / rhs.x, y / rhs.y);
	}

	void Vector2::operator*=(Vec2Param rhs)
	{
		x *= rhs.x;
		y *= rhs.y;
	}

	void Vector2::operator/=(Vec2Param rhs)
	{
		x /= rhs.x;
		y /= rhs.y;
	}

	Vector2 Vector2::operator*(Vec2Param rhs) const
	{
		return Vector2(x * rhs.x, y * rhs.y);
	}

	real Vector2::Length(void) const
	{
		return Sqrt(LengthSq());
	}

	real Vector2::LengthSq(void) const
	{
		return Dot(*this);
	}

	Vector2 Vector2::Normalized(void) const
	{
		Vector2 ret = *this;
		ret /= Length();
		return ret;
	}

	real Vector2::Normalize(void)
	{
		real length = Length();
		*this /= length;
		return length;
	}

	real Vector2::AttemptNormalize(void)
	{
		real lengthSq = LengthSq();
		if (Math::IsZero(lengthSq) == false)
		{
			lengthSq = Sqrt(lengthSq);
			*this /= lengthSq;
		}
		return lengthSq;
	}

	Vec2Ref Vector2::Negate(void)
	{
		(*this) *= real(-1.0);
		return *this;
	}

	bool Vector2::Valid(void) const
	{
		return IsValid(x) && IsValid(y);
	}

	void Vector2::Splat(real value)
	{
		x = y = value;
	}

	Vector2 operator*(real lhs, Vec2Param rhs)
	{
		return rhs * lhs;
	}

	real Distance(Vec2Param lhs, Vec2Param rhs)
	{
		return (rhs - lhs).Length();
	}

	real Dot(Vec2Param lhs, Vec2Param rhs)
	{
		return lhs.Dot(rhs);
	}

	real Cross(Vec2Param lhs, Vec2Param rhs)
	{
		return lhs.x * rhs.y - rhs.x * lhs.y;
	}

	real Length(Vec2Param vect)
	{
		return vect.Length();
	}

	real LengthSq(Vec2Param vect)
	{
		return vect.LengthSq();
	}

	Vector2 Normalized(Vec2Param vect)
	{
		return vect.Normalized();
	}

	real Normalize(Vec2Ptr vect)
	{
		ErrorIf(vect == NULL, "Vector2 - Null pointer passed for vector.");
		return vect->Normalize();
	}

	real AttemptNormalize(Vec2Ptr vect)
	{
		ErrorIf(vect == NULL, "Vector2 - Null pointer passed for vector.");
		return vect->AttemptNormalize();
	}

	void Negate(Vec2Ptr vec)
	{
		ErrorIf(vec == NULL, "Vector2 - Null pointer passed for vector.");
		*vec *= real(-1.0);
	}

	Vector2 Negated(Vec2Param vec)
	{
		return Vector2(-vec.x, -vec.y);
	}

	Vector2 Abs(Vec2Param vec)
	{
		return Vector2(Math::Abs(vec.x), Math::Abs(vec.y));
	}

	Vector2 Min(Vec2Param lhs, Vec2Param rhs)
	{
		return Vector2(Math::Min(lhs.x, rhs.x),
			Math::Min(lhs.y, rhs.y));
	}

	Vector2 Max(Vec2Param lhs, Vec2Param rhs)
	{
		return Vector2(Math::Max(lhs.x, rhs.x),
			Math::Max(lhs.y, rhs.y));
	}

	Vector2 Lerp(Vec2Param start, Vec2Param end, real tValue)
	{
		WarnIf(!Math::InRange(tValue, real(0.0), real(1.0)),
			"Vector2 - Interpolation value is not in the range of [0, 1]");
		return Vector2(start[0] + tValue * (end[0] - start[0]),
			start[1] + tValue * (end[1] - start[1]));
	}

	void Clamp(Vec2Ptr vec, real min, real max)
	{
		ErrorIf(vec == NULL, "Null pointer passed into function.");
		vec->x = Math::Clamp(vec->x, min, max);
		vec->y = Math::Clamp(vec->y, min, max);
	}

	Vector2 DebugClamp(Vec2Param vec, real min, real max, bool& wasClamped)
	{
		Vector2 result;
		bool xClamped, yClamped;
		result.x = DebugClamp(vec.x, min, max, xClamped);
		result.y = DebugClamp(vec.y, min, max, yClamped);
		wasClamped = xClamped || yClamped;
		return result;
	}

	Vector2 GetBisector(Vec2Param v0, Vec2Param v1)
	{
		// Get the perpendicular of each vector
		Vector2 perp0 = Vector2(v0.y, -v0.x);
		Vector2 perp1 = Vector2(v1.y, -v1.x);

		AttemptNormalize(&perp0);
		AttemptNormalize(&perp1);

		Vector2 dir = (perp0 + perp1) * 0.5f;
		return Normalized(dir);
	}

	Vector2 GetPerpendicular(Vec2Param vec)
	{
		return Vector2(vec.y, -vec.x);
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector3.cpp
/// Implementation of the Vector 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const Vector3 Vector3::cZero(real(0.0), real(0.0), real(0.0));
	const Vector3 Vector3::cXAxis(real(1.0), real(0.0), real(0.0));
	const Vector3 Vector3::cYAxis(real(0.0), real(1.0), real(0.0));
	const Vector3 Vector3::cZAxis(real(0.0), real(0.0), real(1.0));
	const Vector3 Vector3::Axes[] = { Vector3::cXAxis, Vector3::cYAxis, Vector3::cZAxis };

	Vector3::Vector3(real xx, real yy, real zz)
	{
		x = xx;
		y = yy;
		z = zz;
	}

	Vector3::Vector3(real xyz)
	{
		x = xyz;
		y = xyz;
		z = xyz;
	}

	Vector3::Vector3(Vec2Param rhs, real zz)
	{
		x = rhs.x;
		y = rhs.y;
		z = zz;
	}

	Vector3::Vector3(ConstRealPointer data)
	{
		array[0] = data[0];
		array[1] = data[1];
		array[2] = data[2];
	}

	real& Vector3::operator[](uint index)
	{
		ErrorIf(index > 2, "Math::Vector3 - Subscript out of range.");
		return array[index];
	}

	real Vector3::operator[](uint index) const
	{
		ErrorIf(index > 2, "Math::Vector3 - Subscript out of range.");
		return array[index];
	}

	//---------------------------------------------------- Binary Vector Comparisons
	bool Vector3::operator==(Vec3Param rhs) const
	{
		return Math::Equal(x, rhs.x) &&
			Math::Equal(y, rhs.y) &&
			Math::Equal(z, rhs.z);
	}

	bool Vector3::operator!=(Vec3Param rhs) const
	{
		return !(*this == rhs);
	}

	BoolVec3 Vector3::operator< (Vec3Param rhs) const
	{
		return BoolVec3(x < rhs.x,
			y < rhs.y,
			z < rhs.z);
	}

	BoolVec3 Vector3::operator<=(Vec3Param rhs) const
	{
		return BoolVec3(x <= rhs.x,
			y <= rhs.y,
			z <= rhs.z);
	}

	BoolVec3 Vector3::operator>(Vec3Param rhs) const
	{
		return BoolVec3(x > rhs.x,
			y > rhs.y,
			z > rhs.z);
	}

	BoolVec3 Vector3::operator>=(Vec3Param rhs) const
	{
		return BoolVec3(x >= rhs.x,
			y >= rhs.y,
			z >= rhs.z);
	}

	void Vector3::Set(real x_, real y_, real z_)
	{
		x = x_;
		y = y_;
		z = z_;
	}

	void Vector3::Splat(real xyz)
	{
		x = y = z = xyz;
	}

	void Vector3::ScaleByVector(Vec3Param rhs)
	{
		x *= rhs.x;
		y *= rhs.y;
		z *= rhs.z;
	}

	void Vector3::ZeroOut(void)
	{
		array[0] = real(0.0);
		array[1] = real(0.0);
		array[2] = real(0.0);
	}

	void Vector3::AddScaledVector(Vec3Param vector, real scalar)
	{
		x += vector.x * scalar;
		y += vector.y * scalar;
		z += vector.z * scalar;
	}

	Vector3 Vector3::Reflect(Vec3Param rhs) const
	{
		Vector3 reflect = rhs;
		reflect *= (*this).Dot(rhs);
		reflect *= real(2.0);
		reflect -= *this;
		return reflect;
	}

	Vector3 Vector3::Project(Vec3Param axis) const
	{
		real dot = Dot(axis);
		return axis * dot;
	}

	real Vector3::Length(void) const
	{
		return Sqrt(LengthSq());
	}

	real Vector3::LengthSq(void) const
	{
		return Dot(*this);
	}

	Vector3 Vector3::Normalized(void) const
	{
		Vector3 ret = *this;;
		ret /= Length();
		return ret;
	}

	real Vector3::Normalize()
	{
		real length = Length();
		*this /= length;
		return length;
	}

	void Vector3::Ceil(void)
	{
		x = Math::Ceil(x);
		y = Math::Ceil(y);
		z = Math::Ceil(z);
	}

	void Vector3::Floor(void)
	{
		x = Math::Floor(x);
		y = Math::Floor(y);
		z = Math::Floor(z);
	}

	void Vector3::Truncate(void)
	{
		x = real(int(x));
		y = real(int(y));
		z = real(int(z));
	}

	void Vector3::RoundToExtremes()
	{
		x = (x > 0) ? Math::Ceil(x) : Math::Floor(x);
		y = (y > 0) ? Math::Ceil(y) : Math::Floor(y);
		z = (z > 0) ? Math::Ceil(z) : Math::Floor(z);
	}

	void Vector3::Round(void)
	{
		x = Math::Round(x);
		y = Math::Round(y);
		z = Math::Round(z);
	}

	real Vector3::AttemptNormalize(void)
	{
		real lengthSq = LengthSq();

		//Although the squared length may not be zero, the sqrt of a small number
		//may be truncated to zero, causing a divide by zero crash.  This is why
		//we check to make sure that it is larger than our epsilon squared.
		if (lengthSq >= Epsilon() * Epsilon())
		{
			lengthSq = Sqrt(lengthSq);
			*this /= lengthSq;
		}
		return lengthSq;
	}

	Vector3 Vector3::AttemptNormalized() const
	{
		Vector3 result = *this;
		result.AttemptNormalize();
		return result;
	}

	Vec3Ref Vector3::Negate(void)
	{
		(*this) *= real(-1.0);
		return *this;
	}

	bool Vector3::Valid(void) const
	{
		return IsValid(x) && IsValid(y) && IsValid(z);
	}

	Vector3 Vector3::Cross(Vec3Param rhs) const
	{
		Vector3 ret;
		ret.x = y * rhs.z - z * rhs.y;
		ret.y = z * rhs.x - x * rhs.z;
		ret.z = x * rhs.y - y * rhs.x;
		return ret;
	}

	void Vector3::InvertComponents(void)
	{
		x = real(1.0) / x;
		y = real(1.0) / y;
		z = real(1.0) / z;
	}

	//------------------------------------------------------------- Global Functions
	Vector3 operator*(real lhs, Vec3Param rhs)
	{
		return rhs * lhs;
	}

	bool Equal(Vec3Param lhs, Vec3Param rhs, real epsilon)
	{
		return Math::Equal(lhs.x, rhs.x, epsilon) &&
			Math::Equal(lhs.y, rhs.y, epsilon) &&
			Math::Equal(lhs.z, rhs.z, epsilon);
	}

	real Distance(Vec3Param lhs, Vec3Param rhs)
	{
		return Length(rhs - lhs);
	}

	Vector3 ScaledByVector(Vec3Param lhs, Vec3Param rhs)
	{
		return lhs * rhs;
	}

	Vector3 DividedByVector(Vec3Param lhs, Vec3Param rhs)
	{
		return lhs / rhs;
	}

	real Length(Vec3Param vect)
	{
		return vect.Length();
	}

	real LengthSq(Vec3Param vect)
	{
		return vect.LengthSq();
	}

	Vector3 Normalized(Vec3Param vect)
	{
		return vect.Normalized();
	}

	real Normalize(Vec3Ptr vect)
	{
		ErrorIf(vect == NULL, "Vector3 - Null pointer passed for vector.");
		return vect->Normalize();
	}

	real AttemptNormalize(Vec3Ptr vect)
	{
		ErrorIf(vect == NULL, "Vector3 - Null pointer passed for vector.");
		return vect->AttemptNormalize();
	}

	Vector3 Cross(Vec3Param lhs, Vec3Param rhs)
	{
		return lhs.Cross(rhs);
	}

	Vector3 Cross2d(Vec3Param lhs, Vec3Param rhs)
	{
		Vector3 result = Vector3::cZero;
		result.z = lhs.x * rhs.y - rhs.x * lhs.y;
		return result;
	}

	void ZeroOut(Vec3Ptr vec)
	{
		ErrorIf(vec == NULL, "Vector3 - Null pointer passed for vector.");
		vec->ZeroOut();
	}

	void Negate(Vec3Ptr vec)
	{
		ErrorIf(vec == NULL, "Vector3 - Null pointer passed for vector.");
		*vec *= real(-1.0);
	}

	Vector3 Negated(Vec3Param vec)
	{
		return Vector3(-vec.x, -vec.y, -vec.z);
	}

	Vector3 Abs(Vec3Param vec)
	{
		return Vector3(Math::Abs(vec.x), Math::Abs(vec.y), Math::Abs(vec.z));
	}

	Vector3 Min(Vec3Param lhs, Vec3Param rhs)
	{
		return Vector3(Math::Min(lhs.x, rhs.x),
			Math::Min(lhs.y, rhs.y),
			Math::Min(lhs.z, rhs.z));
	}

	Vector3 Max(Vec3Param lhs, Vec3Param rhs)
	{
		return Vector3(Math::Max(lhs.x, rhs.x),
			Math::Max(lhs.y, rhs.y),
			Math::Max(lhs.z, rhs.z));
	}

	Vector3 Lerp(Vec3Param start, Vec3Param end, real tValue)
	{
		return Vector3(start[0] + tValue * (end[0] - start[0]),
			start[1] + tValue * (end[1] - start[1]),
			start[2] + tValue * (end[2] - start[2]));
	}

	void Clamp(Vec3Ptr vec, real min, real max)
	{
		ErrorIf(vec == NULL, "Vector3 - Null pointer passed for vector.");
		vec->x = Math::Clamp(vec->x, min, max);
		vec->y = Math::Clamp(vec->y, min, max);
		vec->z = Math::Clamp(vec->z, min, max);
	}

	Vector3 Clamped(Vec3Param vec, real min, real max)
	{
		Vector3 results;
		results[0] = Math::Clamp(vec[0], min, max);
		results[1] = Math::Clamp(vec[1], min, max);
		results[2] = Math::Clamp(vec[2], min, max);
		return results;
	}

	Vector3 DebugClamp(Vec3Param vec, real min, real max, bool& wasClamped)
	{
		Vector3 result;
		bool xClamped, yClamped, zClamped;
		result.x = DebugClamp(vec.x, min, max, xClamped);
		result.y = DebugClamp(vec.y, min, max, yClamped);
		result.z = DebugClamp(vec.z, min, max, zClamped);
		wasClamped = xClamped || yClamped || zClamped;
		return result;
	}

	bool AllLess(Vec3Param lhs, Vec3Param rhs)
	{
		return (lhs.x < rhs.x && lhs.y < rhs.y && lhs.z < rhs.z);
	}

	bool AnyLess(Vec3Param lhs, Vec3Param rhs)
	{
		return (lhs.x < rhs.x || lhs.y < rhs.y || lhs.z < rhs.z);
	}

	bool AllGreater(Vec3Param lhs, Vec3Param rhs)
	{
		return (lhs.x > rhs.x && lhs.y > rhs.y && lhs.z > rhs.z);
	}

	bool AnyGreater(Vec3Param lhs, Vec3Param rhs)
	{
		return (lhs.x > rhs.x || lhs.y > rhs.y || lhs.z > rhs.z);
	}

	real DistanceToLineSq(Vec3Param start, Vec3Param end, Vec3Param point)
	{
		// describes the line segment
		Vec3 d = end - start;
		Vec3 n = d.Normalized();
		// vector from the point to the start of the line
		Vec3 ptoa = start - point;
		// project the point onto the line segment d
		Vec3 proj = ptoa.Dot(n) * n;
		// check to see if the projected point is before start on the line
		if (n.Dot(proj) > 0)
		{
			return ptoa.LengthSq();
		}
		// check to see if the projected point is after end on the line
		if (proj.LengthSq() > d.LengthSq())
		{
			// proj is passed the end so we subtract the length of d
			// since proj is relative to start
			return ptoa.LengthSq() - d.LengthSq();
		}
		// otherwise the projected point is within the line segment d
		return (ptoa - proj).Length();
	}

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector4.cpp
/// Implementation of the Vector 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Math
{

	const Vector4 Vector4::cZero(real(0.0), real(0.0), real(0.0), real(0.0));
	const Vector4 Vector4::cXAxis(real(1.0), real(0.0), real(0.0), real(0.0));
	const Vector4 Vector4::cYAxis(real(0.0), real(1.0), real(0.0), real(0.0));
	const Vector4 Vector4::cZAxis(real(0.0), real(0.0), real(1.0), real(0.0));
	const Vector4 Vector4::cWAxis(real(0.0), real(0.0), real(0.0), real(1.0));
	const Vector4 Vector4::Axes[] = { Vector4::cXAxis, Vector4::cYAxis, Vector4::cZAxis, Vector4::cWAxis };

	Vector4::Vector4(real x_, real y_, real z_, real w_)
	{
		x = x_;
		y = y_;
		z = z_;
		w = w_;
	}

	Vector4::Vector4(ConstRealPointer data)
	{
		array[0] = data[0];
		array[1] = data[1];
		array[2] = data[2];
		array[3] = data[3];
	}

	Vector4::Vector4(real xyzw)
	{
		x = y = z = w = xyzw;
	}

	real& Vector4::operator[](uint index)
	{
		ErrorIf(index > 3, "Math::Vector4 - Subscript out of range.");
		return array[index];
	}

	real Vector4::operator[](uint index) const
	{
		ErrorIf(index > 3, "Math::Vector4 - Subscript out of range.");
		return array[index];
	}

	////////// Unary Operators /////////////////////////////////////////////////////

	Vector4 Vector4::operator-(void) const
	{
		return Vector4(-x, -y, -z, -w);
	}

	////////// Binary Assignment Operators (reals) /////////////////////////////////

	void Vector4::operator*=(real rhs)
	{
		x *= rhs;
		y *= rhs;
		z *= rhs;
		w *= rhs;
	}

	void Vector4::operator/=(real rhs)
	{
		ErrorIf(Math::IsZero(rhs), "Math::Vector4 - Division by zero.");
		x /= rhs;
		y /= rhs;
		z /= rhs;
		w /= rhs;
	}

	////////// Binary Operators (reals) ////////////////////////////////////////////

	Vector4 Vector4::operator*(real rhs) const
	{
		return Vector4(x * rhs, y * rhs, z * rhs, w * rhs);
	}

	Vector4 Vector4::operator/(real rhs) const
	{
		ErrorIf(Math::IsZero(rhs), "Math::Vector4 - Division by zero.");
		return Vector4(x / rhs, y / rhs, z / rhs, w / rhs);
	}

	////////// Binary Assignment Operator (Vectors) ////////////////////////////////

	void Vector4::operator+=(Vec4Param rhs)
	{
		x += rhs.x;
		y += rhs.y;
		z += rhs.z;
		w += rhs.w;
	}

	void Vector4::operator-=(Vec4Param rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
		z -= rhs.z;
		w -= rhs.w;
	}

	void Vector4::operator*=(Vec4Param rhs)
	{
		x *= rhs.x;
		y *= rhs.y;
		z *= rhs.z;
		w *= rhs.w;
	}

	void Vector4::operator/=(Vec4Param rhs)
	{
		x /= rhs.x;
		y /= rhs.y;
		z /= rhs.z;
		w /= rhs.w;
	}

	////////// Binary Operators (Vectors) //////////////////////////////////////////

	Vector4 Vector4::operator+(Vec4Param rhs) const
	{
		return Vector4(x + rhs.x, y + rhs.y, z + rhs.z, w + rhs.w);
	}

	Vector4 Vector4::operator-(Vec4Param rhs) const
	{
		return Vector4(x - rhs.x, y - rhs.y, z - rhs.z, w - rhs.w);
	}

	///////// Binary Vector Comparisons ////////////////////////////////////////////

	bool Vector4::operator==(Vec4Param rhs) const
	{
		return Equal(x, rhs.x) &&
			Equal(y, rhs.y) &&
			Equal(z, rhs.z) &&
			Equal(w, rhs.w);
	}

	bool Vector4::operator!=(Vec4Param rhs) const
	{
		return !(*this == rhs);
	}

	BoolVec4 Vector4::operator< (Vec4Param rhs) const
	{
		return BoolVec4(x < rhs.x,
			y < rhs.y,
			z < rhs.z,
			w < rhs.w);
	}

	BoolVec4 Vector4::operator<=(Vec4Param rhs) const
	{
		return BoolVec4(x <= rhs.x,
			y <= rhs.y,
			z <= rhs.z,
			w <= rhs.w);
	}

	BoolVec4 Vector4::operator> (Vec4Param rhs) const
	{
		return BoolVec4(x > rhs.x,
			y > rhs.y,
			z > rhs.z,
			w > rhs.w);
	}

	BoolVec4 Vector4::operator>=(Vec4Param rhs) const
	{
		return BoolVec4(x >= rhs.x,
			y >= rhs.y,
			z >= rhs.z,
			w >= rhs.w);
	}

	void Vector4::Set(real x_, real y_, real z_, real w_)
	{
		x = x_;
		y = y_;
		z = z_;
		w = w_;
	}

	void Vector4::Splat(real xyzw)
	{
		x = y = z = w = xyzw;
	}

	//Do a component-wise scaling of this vector with the given vector.
	void Vector4::ScaleByVector(Vec4Param rhs)
	{
		*this *= rhs;
	}

	Vector4 Vector4::ScaledByVector(Vec4Param rhs) const
	{
		return *this * rhs;
	}

	Vector4 Vector4::operator*(Vec4Param rhs) const
	{
		return Vector4(x * rhs.x, y * rhs.y, z * rhs.z, w * rhs.w);
	}

	Vector4 Vector4::operator/(Vec4Param rhs) const
	{
		ErrorIf(rhs.x == real(0.0) || rhs.y == real(0.0) ||
			rhs.z == real(0.0) || rhs.w == real(0.0),
			"Vector4 - Division by Zero.");
		return Vector4(x / rhs.x, y / rhs.y, z / rhs.z, w / rhs.w);
	}

	void Vector4::ZeroOut(void)
	{
		array[0] = real(0.0);
		array[1] = real(0.0);
		array[2] = real(0.0);
		array[3] = real(0.0);
	}

	void Vector4::AddScaledVector(Vec4Param vector, real scalar)
	{
		x += vector.x * scalar;
		y += vector.y * scalar;
		z += vector.z * scalar;
		w += vector.w * scalar;
	}

	real Vector4::Dot(Vec4Param rhs) const
	{
		return x * rhs.x + y * rhs.y + z * rhs.z + w * rhs.w;
	}

	real Vector4::Length(void) const
	{
		return Sqrt(LengthSq());
	}

	real Vector4::LengthSq(void) const
	{
		return Dot(*this);
	}

	Vector4 Vector4::Normalized(void) const
	{
		Vector4 ret = *this;
		ret /= Length();
		return ret;
	}

	real Vector4::Normalize(void)
	{
		real length = Length();
		*this /= length;
		return length;
	}

	real Vector4::AttemptNormalize(void)
	{
		real lengthSq = LengthSq();
		if (Math::IsZero(lengthSq) == false)
		{
			lengthSq = Sqrt(lengthSq);
			*this /= lengthSq;
		}
		return lengthSq;
	}

	Vec4Ref Vector4::Negate(void)
	{
		(*this) *= real(-1.0);
		return *this;
	}

	bool Vector4::Valid(void) const
	{
		return IsValid(x) && IsValid(y) && IsValid(z) && IsValid(w);
	}

	Vector4 operator*(real lhs, Vec4Param rhs)
	{
		return rhs * lhs;
	}

	real Dot(Vec4Param lhs, Vec4Param rhs)
	{
		return lhs.Dot(rhs);
	}

	real Length(Vec4Param vect)
	{
		return vect.Length();
	}

	real LengthSq(Vec4Param vect)
	{
		return vect.LengthSq();
	}

	Vector4 Normalized(Vec4Param vect)
	{
		return vect.Normalized();
	}

	real Normalize(Vec4Ptr vect)
	{
		ErrorIf(vect == NULL, "Vector4 - Null pointer passed for vector.");
		return vect->Normalize();
	}

	real AttemptNormalize(Vec4Ptr vect)
	{
		ErrorIf(vect == NULL, "Vector4 - Null pointer passed for vector.");
		return vect->AttemptNormalize();
	}

	void Negate(Vec4Ptr vec)
	{
		ErrorIf(vec == NULL, "Vector4 - Null pointer passed for vector.");
		*vec *= real(-1.0);
	}

	Vector4 Negated(Vec4Param vec)
	{
		return Vector4(-vec.x, -vec.y, -vec.z, -vec.w);
	}

	Vector4 Abs(Vec4Param vec)
	{
		return Vector4(Math::Abs(vec.x), Math::Abs(vec.y),
			Math::Abs(vec.z), Math::Abs(vec.w));
	}

	Vector4 Min(Vec4Param lhs, Vec4Param rhs)
	{
		return Vector4(Math::Min(lhs.x, rhs.x),
			Math::Min(lhs.y, rhs.y),
			Math::Min(lhs.z, rhs.z),
			Math::Min(lhs.w, rhs.w));
	}

	Vector4 Max(Vec4Param lhs, Vec4Param rhs)
	{
		return Vector4(Math::Max(lhs.x, rhs.x),
			Math::Max(lhs.y, rhs.y),
			Math::Max(lhs.z, rhs.z),
			Math::Max(lhs.w, rhs.w));
	}

	Vector4 Clamped(Vec4Param vec, real min, real max)
	{
		Vector4 results;
		results[0] = Math::Clamp(vec[0], min, max);
		results[1] = Math::Clamp(vec[1], min, max);
		results[2] = Math::Clamp(vec[2], min, max);
		results[3] = Math::Clamp(vec[3], min, max);
		return results;
	}

	Vector4 Lerp(Vec4Param start, Vec4Param end, real tValue)
	{
		return Vector4(start[0] + tValue * (end[0] - start[0]),
			start[1] + tValue * (end[1] - start[1]),
			start[2] + tValue * (end[2] - start[2]),
			start[3] + tValue * (end[3] - start[3]));
	}

}// namespace Math

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file DebugClassMap.cpp
/// Implementation of the file class for Windows.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for windows library.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#ifdef _MSC_VER
#define CStringCopy(dest, destSize, source, sourceSize) strncpy_s(dest, (destSize), source, sourceSize);
#else 
#define CStringCopy(dest, destSize, source, sourceSize) strncpy(dest, source, sourceSize);
#endif

//Include the windows header.

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Windows.hpp
/// Includes Windows Header
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#ifdef ZERO
#pragma message("Including Windows...")
#ifdef _WINDOWS_
#error Windows has already been included!
#else
#define STRICT
#endif
#endif

//Prevent including winsock1.
#define _WINSOCKAPI_

//Only include frequently used elements.
#define WIN32_LEAN_AND_MEAN
#define NOCOMM

//Minimum version is Windows XP.
//#define WINVER 0x0501
//#define _WIN32_WINNT 0x0501

//Prevent MIN ans MAX macros from being defined.
#ifndef NOMINMAX
#define NOMINMAX
#endif

// Get rid of an annoying gcc warning that is incorrect
// (complains about winsock being included after windows, it's not)
#ifndef _MSC_VER
#ifdef _WINSOCKAPI_
#undef _WINSOCKAPI_
#endif
#endif
#include <winsock2.h> // Includes windows.h (we get a warning in gcc otherwise)
#include <Ws2tcpip.h>
#include <Wspiapi.h>
#include <Mmsystem.h>
#include <Regstr.h>
#include <WinBase.h>

//Undef windows defines that overlap with core functions
#undef CopyFile
#undef MoveFile
#undef DeleteFile
#undef CreateDirectory

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file WindowsError.hpp
/// Declaration of Windows error handling.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

const uint cMaxErrorMessageSize = 1024;
// Convert a windows error code to a human readable string. If the errorCode
// is zero uses the last error.
uint ToErrorString(char* messageBuffer, uint bufferSize, uint errorCode = 0);
// Check success and send error on failure.
uint CheckWindowsErrorCode(uint success, ::cstr format = 0, ...);
// Get string from exception code. Unknown will return NULL.
cstr GetWindowsExceptionCode(int exceptionCode);

// Windows Error Macros (always output, even in release, so we get error messages in logs).
#define VerifyWin(expression, ...) do { if(!(expression)) CheckWindowsErrorCode(FALSE, ## __VA_ARGS__); } while(gConditionalFalseConstant)
#define CheckWin(expression, ... ) VerifyWin(expression, ## __VA_ARGS__)

#define WinReturnIf(command, ...) \
{ uint success = command;  if(!success) { VerifyWin(success, ## __VA_ARGS__  ); return (uint)-1; } }

#endif

#include <new>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <cstdio>

#endif

// Only compile this on the MSVC compiler (not supported by other compilers on Windows)
#ifdef _MSC_VER

#define _NO_CVCONST_H
#include <dbghelp.h>

#pragma comment(lib, "dbghelp.lib")

namespace Zero
{

	enum DataKind
	{
		DataIsUnknown,
		DataIsLocal,
		DataIsStaticLocal,
		DataIsParam,
		DataIsObjectPtr,
		DataIsFileStatic,
		DataIsGlobal,
		DataIsMember,
		DataIsStaticMember,
		DataIsConstant
	};

	class TypeModule
	{
	public:
		UINT mModuleBase;
		HANDLE mProcess;

		TypeModule()
		{
			mModuleBase = 0;
			mProcess = GetCurrentProcess();
		}

		String GetSymbolName(uint classIndex)
		{
			wchar_t* text = L"";
			VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)classIndex, TI_GET_SYMNAME, &text));

			char* asciiText = (char*)alloca(MAX_SYM_NAME);
			ConvertUnicodeToAscii(asciiText, MAX_SYM_NAME, text, wcslen(text));

			return asciiText;
		}

		uint GetDataKind(uint classIndex)
		{
			DWORD dataKind = 0;
			VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)classIndex, TI_GET_DATAKIND, &dataKind));
			return dataKind;
		}

		uint GetTag(uint classIndex)
		{
			DWORD tag = 0;
			SymGetTypeInfo(mProcess, mModuleBase, (ULONG)classIndex, TI_GET_SYMTAG, &tag);
			return tag;
		}

		uint GetOffset(uint index)
		{
			DWORD offset;
			VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_OFFSET, &offset));
			return offset;
		}

		uint GetClassParent(uint index)
		{
			DWORD classIndex = 0;
			VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_CLASSPARENTID, &classIndex));
			return classIndex;
		}

		uint GetSize(uint index)
		{
			DWORD size;
			VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_LENGTH, &size));
			return size;
		}

		uint GetType(uint index)
		{
			DWORD typeId;
			VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_TYPEID, &typeId));
			return typeId;
		}

		uint GetChildCount(uint index)
		{
			DWORD count;
			VerifyWin(SymGetTypeInfo(mProcess, mModuleBase, (ULONG)index, TI_GET_CHILDRENCOUNT, &count));
			return count;
		}
	};

	struct MemberVariable
	{
		FixedString<100> Name;
		uint Offset;
		uint String;
		uint Size;
	};

	struct ClassMap
	{
		ClassMap()
			:IsValid(true)
		{
		}

		FixedString<100> Name;
		bool IsValid;
		uint TypeIndex;
		ClassMap* BaseClass;
		Array<MemberVariable> mVariables;
	};

	//Class used to clean up class maps.
	struct ClassStorage
	{
		HashMap<String, ClassMap*> Classes;

		ClassStorage()
		{
			AddInvalid("Zero::LinearAxisJoint");
		}

		void AddInvalid(String fullClassName)
		{
			ClassMap* notFound = new ClassMap();
			notFound->IsValid = false;
			Classes.insert(fullClassName, notFound);
		}

		~ClassStorage()
		{
			DeleteObjectsInContainer(Classes);
		}
	} gClassStorage;

	ClassMap* BuildMap(TypeModule& types, uint typeIndex)
	{
		String name = types.GetSymbolName(typeIndex);

		ClassMap* classMap = gClassStorage.Classes.findValue(name, NULL);

		//Locally cache the class map of members to avoid constanly
		//have to class api functions.
		if (classMap)
			return classMap;

		classMap = new ClassMap();

		classMap->BaseClass = NULL;

		classMap->TypeIndex = typeIndex;

		gClassStorage.Classes.insert(name, classMap);

		classMap->Name = name;

		DWORD childCount = (DWORD)types.GetChildCount(typeIndex);

		DWORD findChildrenSize = sizeof(TI_FINDCHILDREN_PARAMS) + childCount*sizeof(ULONG);

		TI_FINDCHILDREN_PARAMS* findChildren = (TI_FINDCHILDREN_PARAMS*)alloca(findChildrenSize);

		memset(findChildren, 0, findChildrenSize);

		findChildren->Count = childCount;

		VerifyWin(SymGetTypeInfo(types.mProcess, types.mModuleBase, (ULONG)typeIndex, TI_FINDCHILDREN, findChildren));

		for (uint i = 0; i<childCount; ++i)
		{
			uint childTypeIndex = findChildren->ChildId[i];
			DWORD symTag = (DWORD)types.GetTag(childTypeIndex);

			if (symTag == SymTagBaseClass)
			{
				classMap->BaseClass = BuildMap(types, childTypeIndex);
			}
			else if (symTag == SymTagData)
			{
				uint kind = types.GetDataKind(childTypeIndex);
				String symbolName = types.GetSymbolName(childTypeIndex);

				if (kind == DataIsMember)
				{
					uint offset = types.GetOffset(childTypeIndex);

					uint classType = types.GetType(childTypeIndex);

					uint size = types.GetSize(classType);

					MemberVariable& member = classMap->mVariables.push_back();

					member.Name = symbolName;
					member.Offset = offset;
					member.Size = size;
				}
			}
		}

		return classMap;
	}

	void Check(TypeModule& typeModule, cstr className, byte* classMemory, uint typeIndex)
	{

		//Get the class map
		ClassMap* classMap = BuildMap(typeModule, typeIndex);

		//Check all member variables for uninitialized memory
		forRange(MemberVariable& var, classMap->mVariables.all())
		{
			const byte DebugByte = 0xCD;
			bool good = false;
			uint dwords = var.Size;
			for (uint i = 0; i<var.Size; ++i)
			{
				if (classMemory[var.Offset + i] != DebugByte)
				{
					good = true;
					break;
				}
			}

			if (!good)
			{
				ErrorIf(true, "On Class '%s' member '%s::%s' was not initialized ", className, classMap->Name.c_str(), var.Name.c_str());
			}
		}

		if (classMap->BaseClass)
			Check(typeModule, className, classMemory, classMap->BaseClass->TypeIndex);
	}

	bool SymbolsLoaded = false;
	bool CanScanSymbols = true;

	void CheckClassMemory(cstr className, byte* classMemory)
	{
		if (!CanScanSymbols)
			return;

		HANDLE process = GetCurrentProcess();

		if (!SymbolsLoaded)
		{
			SymbolsLoaded = true;
			DWORD Options = SymGetOptions();

			Options |= SYMOPT_DEBUG & SYMOPT_UNDNAME;

			SymSetOptions(Options);

			UINT moduleBase = 0;

			if (!SymInitialize(process, NULL, TRUE))
			{
				return;
			}
		}

		TypeModule typeModule;

		String fullClassName = BuildString("Zero::", className);
		String constructorFunc = BuildString(fullClassName, "::", className);
		uint moduleBase = 0;

		uint totalSize = sizeof(SYMBOL_INFO) + (MAX_SYM_NAME - 1) * sizeof(CHAR);
		SYMBOL_INFO* symbolInfo = (SYMBOL_INFO*)alloca(totalSize);
		ZeroMemory(symbolInfo, totalSize);
		symbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
		symbolInfo->MaxNameLen = MAX_SYM_NAME;

		ClassMap* classMap = gClassStorage.Classes.findValue(fullClassName, NULL);

		//Check for invalid class to avoid stalls
		if (classMap && !classMap->IsValid)
			return;

		//dbghelp used to by only able to look up functions and data so classes can not be looked up (as far as I know)
		//so look up the class by its constructor. Until this is called the class is not around...
		uint success = SymFromName(process, constructorFunc.c_str(), symbolInfo);

		if (!success)
		{
			gClassStorage.AddInvalid(fullClassName);
			ErrorIf(true, "Could not find class %s. This causes a stall on load.", fullClassName.c_str());
			return;
		}

		DWORD typeId = 0;
		BOOL test = SymGetTypeInfo(process, moduleBase, symbolInfo->TypeIndex, TI_GET_TYPE, &typeId);

		//It seems that many versions of dbghelp do not work need to investigate why
		if (!test)
		{
			CanScanSymbols = false;
			return;
		}

		//With the index of the construtor use the parent id to find is class id;
		DWORD typeIndex = 0;
		VerifyWin(SymGetTypeInfo(process, moduleBase, symbolInfo->TypeIndex, TI_GET_CLASSPARENTID, &typeIndex));

		String foundClassName = typeModule.GetSymbolName(typeIndex);
		//Now check the classes memory
		Check(typeModule, className, classMemory, typeIndex);
	}

}
#endif

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file DirectoryWatcher.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadIo.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	//Io control structure is used to control
	//Overlapped blocking IO. This is a unified
	//way of waiting for both the terminate event.
	//and for the operation to be complete.
	struct IoControl
	{
		OVERLAPPED IoOverlap;
		OsHandle TerminateEvent;
		OsHandle IoCompletedEvent;
	};

	inline void InitIoControl(IoControl& ioControl, OsEvent& terminateEvent)
	{
		//Zero the structure
		ZeroMemory(&ioControl, sizeof(IoControl));
		//Create the event used to signal that the overlapped io is complete.
		ioControl.IoCompletedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
		ioControl.IoOverlap.hEvent = ioControl.IoCompletedEvent;
		//Store the terminate event
		ioControl.TerminateEvent = terminateEvent.GetHandle();
	}

	inline OVERLAPPED* IoGetOverlap(IoControl& ioControl)
	{
		return &ioControl.IoOverlap;
	}

	inline void IoReset(IoControl& ioControl)
	{
		ResetEvent(ioControl.IoCompletedEvent);
	}

	inline void CleanUpIoControl(IoControl& ioControl)
	{
		CloseHandle(ioControl.IoCompletedEvent);
	}

	const OsInt IoFinished = WAIT_OBJECT_0;
	const OsInt IoTerminated = WAIT_OBJECT_0 + 1;

	inline OsInt WaitForIoCompletion(IoControl& ioControl)
	{
		OsHandle events[2] = { ioControl.IoOverlap.hEvent, ioControl.TerminateEvent };
		return WaitForMultipleObjects(2, events, FALSE, INFINITE);
	}

}//namespace Zero

#endif

namespace Zero
{

	DirectoryWatcher::DirectoryWatcher(cstr directoryToWatch, CallbackFunction callback, void* callbackInstance)
	{
		CStringCopy(mDirectoryToWatch, File::MaxPath, directoryToWatch, strlen(directoryToWatch));

		mCallbackInstance = callbackInstance;
		mCallback = callback;

		mWorkThread.Initialize(Thread::ObjectEntryCreator<DirectoryWatcher, &DirectoryWatcher::RunThreadEntryPoint>, this, "DirectoryWatcherWorker");
		mWorkThread.Resume();
		mCancelEvent.Initialize(true, false);
	}

	DirectoryWatcher::~DirectoryWatcher()
	{
		Shutdown();
	}

	void DirectoryWatcher::Shutdown()
	{
		mCancelEvent.Signal();
		mWorkThread.WaitForCompletion();
	}

	OsInt DirectoryWatcher::RunThreadEntryPoint()
	{
		//Do not prevent others from using the directory.
		const OsInt shareAll = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

		//Create a directory handle which in windows is done with CreateFile
		//FILE_LIST_DIRECTORY is an access right required for ReadDirectoryChangesW to operate.
		//FILE_FLAG_OVERLAPPED is required to use overlaps with the handle.
		//FILE_FLAG_BACKUP_SEMANTICS is required to create a directory handle.
		const OsInt flags = FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS;

		//Create the directory handle
		OsHandle dirHandle = CreateFileA(mDirectoryToWatch, FILE_LIST_DIRECTORY, shareAll, NULL, OPEN_EXISTING, flags, NULL);
		CheckWin(dirHandle != INVALID_HANDLE_VALUE, "Failed to create directory handle.");
		if (dirHandle == INVALID_HANDLE_VALUE)
			return (OsInt)-1;

		//4k buffer for directory events.
		const OsInt cBufferSize = 1024 * 4;
		byte fileNotifyBuffer[cBufferSize];

		//Create Io control so the directory watcher can be canceled.
		IoControl readDir;
		InitIoControl(readDir, mCancelEvent);

		//Loop until cancel
		for (;;)
		{
			OsInt bytesReturned = 0;

			//Looking for file updates, additions, and removal.
			OsInt filterFlags = FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE;

			ReadDirectoryChangesW(dirHandle, fileNotifyBuffer, cBufferSize, TRUE, filterFlags, &bytesReturned, IoGetOverlap(readDir), NULL);
			OsInt result = WaitForIoCompletion(readDir);

			if (result == IoFinished)
			{
				//Overlapped Io has finished process events.
				OsInt overlapResult = GetOverlappedResult(dirHandle, IoGetOverlap(readDir), &bytesReturned, TRUE);

				//Iterate through the directory event buffer.
				byte* buffer = (byte*)fileNotifyBuffer;
				for (;;)
				{
					const OsInt cFileNameBufferSize = MAX_PATH;
					char asciFilename[cFileNameBufferSize];
					FILE_NOTIFY_INFORMATION& notify = *(FILE_NOTIFY_INFORMATION*)buffer;

					// FileNameLength is in bytes so divide by size of WCHAR
					uint characterLength = notify.FileNameLength / sizeof(WCHAR);
					WideCharToMultiByte(CP_ACP, 0, notify.FileName, notify.FileNameLength, asciFilename, cFileNameBufferSize, "?", NULL);

					FileOperationInfo info;
					info.FileName = asciFilename;

					switch (notify.Action)
					{
					case FILE_ACTION_ADDED:
						info.Operation = Added;
						(*mCallback)(mCallbackInstance, info);
						break;
					case FILE_ACTION_REMOVED:
						info.Operation = Removed;
						(*mCallback)(mCallbackInstance, info);
						break;
					case FILE_ACTION_MODIFIED:
						info.Operation = Modified;
						(*mCallback)(mCallbackInstance, info);
						break;
					}

					if (notify.NextEntryOffset == 0)
					{
						//No more entries in this read.
						break;
					}
					else
					{
						//Move to the next file notification. FILE_NOTIFY_INFORMATION can be variably size
						//due to the filename so the stride between structures is given with the field NextEntryOffset.
						//When the size is zero it is the last message.
						buffer = buffer + notify.NextEntryOffset;
					}
				}
			}
			else if (result == IoTerminated)
			{
				CancelIo(dirHandle);
				CloseHandle(dirHandle);
				CleanUpIoControl(readDir);
				return 0;//Exit the thread
			}
		}
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExternalLibrary.cpp
/// Implementation of the ExternalLibrary class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	ExternalLibrary::ExternalLibrary()
	{
		mHandle = NULL;
	}

	ExternalLibrary::~ExternalLibrary()
	{
		Unload();
	}

	bool ExternalLibrary::IsValid()
	{
		return mHandle != NULL;
	}

	void ExternalLibrary::Load(cstr filePath)
	{
		mHandle = (void*)LoadLibraryA(filePath);
	}

	void ExternalLibrary::Unload()
	{
		if (mHandle == NULL)
			return;
		FreeLibrary((HMODULE)mHandle);
		mHandle = NULL;
	}

	void* ExternalLibrary::GetFunctionByName(cstr name)
	{
		ReturnIf(mHandle == NULL, NULL, "Attempting to get a function from an invalid library");

		return (void*)GetProcAddress((HMODULE)mHandle, name);
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.cpp
/// Implementation of the file class for Windows.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	const int File::PlatformMaxPath = MAX_PATH;

	struct FilePrivateData
	{
		HANDLE mHandle;
		size_t mFileSize;
		FixedString<MAX_PATH> mFilePath;
	};

	const DWORD NoSharing = 0;
	const DWORD ReadSharing = FILE_SHARE_READ;
	SECURITY_ATTRIBUTES* NOSECURITY = NULL;

	cstr cBadFileMessage = "The file is missing, not in that location, or is protected.";

	DataBlock ReadFileIntoDataBlock(cstr path)
	{
		DataBlock block;
		block.Data = ReadFileIntoMemory(path, block.Size, 0);
		return block;
	}

	byte * ReadFileIntoMemory(cstr filePath, size_t& fileSize, size_t extra)
	{
		HANDLE fileHandle = ::CreateFileA(filePath, GENERIC_READ, ReadSharing,
			NOSECURITY, OPEN_EXISTING, 0, 0);

		CheckWin(fileHandle != INVALID_HANDLE_VALUE, "Failed to open file %s.", filePath);

		ReturnIf(fileHandle == INVALID_HANDLE_VALUE, NULL,
			"Failed to open file '%s'. %s", filePath, cBadFileMessage);

		DWORD fileSizeInBytes = ::GetFileSize(fileHandle, NULL);
		byte* fileBuffer = (byte*)zAllocate(fileSizeInBytes + extra);
		if (fileBuffer == NULL)
		{
			ErrorIf(fileBuffer == NULL,
				"Could not allocate enough memory for file '%s' into memory.",
				filePath);

			delete fileBuffer;
			fileBuffer = nullptr;
			::CloseHandle(fileHandle);
			return NULL;
		}
		else
		{
			fileSize = fileSizeInBytes;
			DWORD bytesRead;
			BOOL readResult = ::ReadFile(fileHandle, fileBuffer, (DWORD)fileSize,
				&bytesRead, NULL);
			ErrorIf(!readResult, "Could not Read file '%s'.", filePath);
		}
		::CloseHandle(fileHandle);
		return fileBuffer;
	}

	size_t WriteToFile(cstr filePath, byte * pData, size_t bufferSize)
	{
		HANDLE fileHandle = ::CreateFileA(filePath, GENERIC_WRITE, NoSharing,
			NOSECURITY, CREATE_ALWAYS, 0, 0);
		ReturnIf(fileHandle == INVALID_HANDLE_VALUE, 0, "Failed to open destination "
			"file '%s'. %s", filePath, cBadFileMessage);

		DWORD bytesWritten = 0;
		BOOL writeResult = WriteFile(fileHandle, pData, (DWORD)bufferSize,
			&bytesWritten, 0);
		::CloseHandle(fileHandle);

		ReturnIf(writeResult == 0, 0, "Failed to write to destination file '%s'.",
			filePath);

		return bufferSize;
	}

	DWORD ToWindowsFileMode(FileMode::Enum mode)
	{
		switch (mode)
		{
		case FileMode::Read:
			return GENERIC_READ;

		case FileMode::Append:
		case FileMode::Write:
			return GENERIC_WRITE;

		case FileMode::ReadWrite:
			return GENERIC_READ | GENERIC_WRITE;
		}
		return 0;
	}

	//Convert File Relative position to windows constant
	DWORD ToWindowsRelative(FileOrigin::Enum relative)
	{
		switch (relative)
		{
		case FileOrigin::Begin:
			return FILE_BEGIN;

		case FileOrigin::End:
			return FILE_END;

		case FileOrigin::Current:
			return FILE_CURRENT;
		}
		return FILE_CURRENT;
	}

	DWORD ToWindowsDisposition(FileMode::Enum mode, FileAccessPattern::Enum pattern)
	{
		DWORD disposition = 0;
		if (mode == FileMode::Write)
			disposition = CREATE_ALWAYS;
		else if (mode == FileMode::Append)
			disposition = OPEN_ALWAYS;
		else
			disposition = OPEN_EXISTING;
		return disposition;
	}

	DWORD ToWindowsFlags(FileMode::Enum mode, FileAccessPattern::Enum pattern)
	{
		DWORD flags = 0;
		if (pattern == FileAccessPattern::Sequential)
			flags |= FILE_FLAG_SEQUENTIAL_SCAN;
		else
			flags |= FILE_FLAG_RANDOM_ACCESS;

		return flags;
	}

	//------------------------------------------------------------------------- File
	File::File()
	{
		ZeroConstructPrivateData(FilePrivateData);
		self->mHandle = INVALID_HANDLE_VALUE;
		self->mFileSize = 0;
	}

	File::~File()
	{
		Close();
		ZeroDestructPrivateData(FilePrivateData);
	}

	size_t File::Size()
	{
		ZeroGetPrivateData(FilePrivateData);
		return self->mFileSize;
	}

	bool File::Open(cstr filePath, FileMode::Enum mode, FileAccessPattern::Enum accessPattern)
	{
		ZeroGetPrivateData(FilePrivateData);

		DWORD fileMode = ToWindowsFileMode(mode);
		DWORD flags = ToWindowsFlags(mode, accessPattern);
		DWORD disposition = ToWindowsDisposition(mode, accessPattern);
		DWORD sharingMode = NoSharing;
		if (mode == FileMode::Read)
			sharingMode = ReadSharing;

		self->mHandle = ::CreateFileA(filePath, fileMode, sharingMode, NOSECURITY, disposition,
			flags, NULL);

		CheckWin(self->mHandle != INVALID_HANDLE_VALUE, "Failed to open file %s.", filePath);

		ReturnIf(self->mHandle == INVALID_HANDLE_VALUE, false,
			"Failed to open file '%s'. %s", filePath, cBadFileMessage);
		self->mFileSize = ::GetFileSize(self->mHandle, NULL);
		self->mFilePath = filePath;

		if (mode == FileMode::Append)
			Seek(self->mFileSize);

		return true;
	}

	bool File::IsOpen()
	{
		ZeroGetPrivateData(FilePrivateData);
		return self->mHandle != INVALID_HANDLE_VALUE;
	}

	void File::Close()
	{
		ZeroGetPrivateData(FilePrivateData);
		if (self->mHandle != INVALID_HANDLE_VALUE)
		{
			CloseHandle(self->mHandle);
			self->mHandle = INVALID_HANDLE_VALUE;
		}
	}

	FilePosition File::Tell()
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");

		LARGE_INTEGER move;
		move.QuadPart = 0;

		LARGE_INTEGER newPosition;
		BOOL success = SetFilePointerEx(self->mHandle, move, &newPosition, FILE_CURRENT);

		return newPosition.QuadPart;
	}

	void File::Seek(FilePosition pos, FileOrigin::Enum rel)
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
		LARGE_INTEGER move;
		move.QuadPart = pos;

		uint winRel = ToWindowsRelative(rel);

		LARGE_INTEGER newPosition;
		BOOL success = SetFilePointerEx(self->mHandle, move, &newPosition, winRel);
	}

	size_t File::Write(byte* data, size_t sizeInBytes)
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
		DWORD bytesWritten = 0;
		WriteFile(self->mHandle, data, sizeInBytes, &bytesWritten, NULL);
		return bytesWritten;
	}

	size_t File::Read(byte* data, size_t sizeInBytes)
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
		DWORD bytesRead = 0;
		ReadFile(self->mHandle, data, sizeInBytes, &bytesRead, NULL);
		return bytesRead;
	}

	void File::Flush()
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == INVALID_HANDLE_VALUE, "File handle is not valid.");
		FlushFileBuffers(self->mHandle);
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FileOperations.cpp
/// Implementation of the file system functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <direct.h>
#include <stdlib.h>
#include <stdio.h>
#include <shlobj.h>

#include <shellapi.h>

#pragma comment(lib, "Shell32.lib")

namespace Zero
{
	const char  cDirectorySeparatorChar = '\\';
	const char* cDirectorySeparatorCstr = "\\";

	void InitFileSystem()
	{

	}

	void ShutdownFileSystem()
	{

	}

	String GetWorkingDirectory()
	{
		char temp[MAX_PATH + 1];
		_getcwd(temp, MAX_PATH);
		StrCat(temp, MAX_PATH + 1, cDirectorySeparatorCstr);
		return String(temp);
	}

	void SetWorkingDirectory(String path)
	{
		_chdir(path.c_str());
	}

	String GetUserLocalDirectory()
	{
		char temp[MAX_PATH + 1];
		SHGetSpecialFolderPath(NULL, temp, CSIDL_LOCAL_APPDATA, FALSE);
		return String(temp);
	}

	String GetUserDocumentsDirectory()
	{
		char temp[MAX_PATH + 1];
		SHGetSpecialFolderPath(NULL, temp, CSIDL_PERSONAL, FALSE);
		return String(temp);
	}

	String GetApplicationDirectory()
	{
		char temp[MAX_PATH + 1];
		GetModuleFileName(NULL, temp, MAX_PATH);
		String fileName = String(temp);

		///FIX ME LATER!!!
		//return Zero::FilePath::GetDirectoryPath(fileName);
		uint dirIndex = fileName.FindLastOf(cDirectorySeparatorChar);
		if (dirIndex == String::InvalidIndex)
			return StringRange();

		return fileName.sub_string(0, dirIndex);
	}

	String GetApplication()
	{
		char temp[MAX_PATH + 1];
		GetModuleFileName(NULL, temp, MAX_PATH);
		return temp;
	}

	String GetTemporaryDirectory()
	{
		char tempPath[MAX_PATH];
		GetTempPath(MAX_PATH, tempPath);
		return tempPath;
	}

	bool FileExists(StringRef filePath)
	{
		DWORD attributes = GetFileAttributes(filePath.c_str());
		return (attributes != INVALID_FILE_ATTRIBUTES);
	}

	bool FileWritable(StringRef filePath)
	{
		DWORD attributes = GetFileAttributes(filePath.c_str());
		if (attributes == INVALID_FILE_ATTRIBUTES)
			return false;
		else
			return !(attributes & FILE_ATTRIBUTE_READONLY);
	}

	bool DirectoryExists(StringRef filePath)
	{
		DWORD attributes = GetFileAttributes(filePath.c_str());
		return (attributes != INVALID_FILE_ATTRIBUTES);
	}

	bool IsDirectory(StringRef filePath)
	{
		DWORD attributes = GetFileAttributes(filePath.c_str());
		return (attributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
	}

	void CreateDirectory(StringRef dest)
	{
		BOOL success = ::CreateDirectoryA(dest.c_str(), NULL);
		if (!success)
		{
			DWORD lastErr = GetLastError();
			if (lastErr != ERROR_ALREADY_EXISTS)
				VerifyWin(success, "Failed to create the directory '%s'.", dest.c_str());
		}
	}

	void CreateDirectoryAndParents(StringRef directory)
	{
		char directoryPath[MAX_PATH];
		StrCpy(directoryPath, MAX_PATH, directory.c_str());
		uint size = directory.size();

		for (uint c = 0; c < size; ++c)
		{
			//When there is a directory separator
			if (directoryPath[c] == cDirectorySeparatorChar)
			{
				//Null terminate
				directoryPath[c] = '\0';
				//Create directory
				::CreateDirectoryA(directoryPath, NULL);
				//remove null terminator
				directoryPath[c] = cDirectorySeparatorChar;
			}
		}

		//directories no longer have a trailing '/' so we have to
		//explicitly create the final directory
		CreateDirectory(directory);
	}

	bool CopyFile(StringRef dest, StringRef source)
	{
		BOOL success = ::CopyFileA(source.c_str(), dest.c_str(), FALSE);
		VerifyWin(success, "Failed to copy file. %s to %s.", source.c_str(), dest.c_str());
		return success != 0;
	}

	bool MoveFile(StringRef dest, StringRef source)
	{
		BOOL success = ::MoveFileEx(source.c_str(), dest.c_str(), MOVEFILE_REPLACE_EXISTING);
		VerifyWin(success, "Failed to move file. %s to %s.", source.c_str(), dest.c_str());
		return success != 0;
	}

	bool DeleteFile(StringRef file)
	{
		BOOL success = ::DeleteFileA(file.c_str());
		VerifyWin(success, "Failed to delete file %s.", file.c_str());
		return success != 0;
	}

	bool DeleteDirectory(StringRef directory)
	{
		FileRange range(directory);
		for (; !range.empty(); range.popFront())
		{
			String name = range.front();
			String fullName = BuildString(directory, cDirectorySeparatorCstr, name);
			if (IsDirectory(fullName))
				DeleteDirectory(fullName);
			else
				DeleteFile(fullName);
		}

		//this is the only part that needs to be updated platform specific
		BOOL success = ::RemoveDirectoryA(directory.c_str());
		VerifyWin(success, "Failed to delete directory %s.", directory.c_str());
		return success != 0;
	}

	TimeType SystemTimeToTimeType(SYSTEMTIME& systemTime)
	{
		//Build a TimeType using mktime and systemTime
		tm newTime;
		memset(&newTime, 0, sizeof(tm));
		//tm_year is based at 1900
		newTime.tm_year = systemTime.wYear - 1900;
		//tm_mday is zero based
		newTime.tm_mon = systemTime.wMonth - 1;
		newTime.tm_mday = systemTime.wDay;
		newTime.tm_hour = systemTime.wHour;
		newTime.tm_min = systemTime.wMinute;
		newTime.tm_sec = systemTime.wSecond;
		return mktime(&newTime);
	}

	TimeType GetFileModifiedTime(StringRef filename)
	{
		WIN32_FILE_ATTRIBUTE_DATA fileInfo;
		BOOL success = GetFileAttributesEx(filename.c_str(), GetFileExInfoStandard, (void*)&fileInfo);
		CheckWin(success, "Failed to get GetFileAttributesEx.");

		// Convert to system time so the time can be parsed
		SYSTEMTIME modifiedSystemTime;
		FileTimeToSystemTime(&fileInfo.ftLastWriteTime, &modifiedSystemTime);

		// Convert and return
		return SystemTimeToTimeType(modifiedSystemTime);
	}

	int SetFileToCurrentTime(StringRef filename)
	{
		// Need a file handle to do file time operations
		StackHandle sourceFile;
		sourceFile = CreateFile(filename.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL,
			OPEN_EXISTING, 0, NULL);

		FILETIME fileTime;
		SYSTEMTIME systemTime;
		BOOL result;

		// Gets the current system time
		GetSystemTime(&systemTime);
		// Converts the current system time to file time format
		SystemTimeToFileTime(&systemTime, &fileTime);

		// Sets last-write time of the file 
		// to the converted current system time 
		result = SetFileTime(sourceFile,
			(LPFILETIME)NULL,
			(LPFILETIME)NULL,
			&fileTime);

		VerifyWin(result, "Failed to set file time.");

		return result;
	}

	u32 GetFileSize(StringRef fileName)
	{
		WIN32_FILE_ATTRIBUTE_DATA fileInfo;
		BOOL success = GetFileAttributesEx(fileName.c_str(), GetFileExInfoStandard, (void*)&fileInfo);
		CheckWin(success, "Failed to get GetFileAttributesEx.");
		if (!success)
			return 0;
		return (u32)fileInfo.nFileSizeLow;
	}

	int CheckFileTime(StringRef dest, StringRef source)
	{
		// Source should always exist
		WIN32_FILE_ATTRIBUTE_DATA sourceInfo;
		BOOL success = GetFileAttributesEx(source.c_str(), GetFileExInfoStandard, (void*)&sourceInfo);
		// If their was some error still return dest is older
		if (!success) return -1;

		WIN32_FILE_ATTRIBUTE_DATA destInfo;
		success = GetFileAttributesEx(dest.c_str(), GetFileExInfoStandard, (void*)&destInfo);
		// If dest does not exist it is older
		if (!success) return -1;

		// Do file time comparison
		int result = CompareFileTime(&destInfo.ftLastWriteTime, &sourceInfo.ftLastWriteTime);

		return result;
	}

	struct FileRangePrivateData
	{
		cstr mCurrent;
		HANDLE mHandle;
		WIN32_FIND_DATA mFindData;
	};

	FileRange::FileRange(StringRef stringPath)
	{
		ZeroConstructPrivateData(FileRangePrivateData);

		if (stringPath.empty())
		{
			Error("Cannot create a file range from an empty directory/path string (working directory as empty string not supported)");
			self->mHandle = NULL;
			return;
		}

		// Copy String into temporary
		uint size = stringPath.size();
		char path[MAX_PATH];
		CStringCopy(path, MAX_PATH, stringPath.c_str(), stringPath.size());

		// Check for trailing slash and add if not there
		if (path[size - 1] != '\\')
			StrCat(path, MAX_PATH, "\\");

		// Add the wildcard to get all files in directory
		StrCat(path, MAX_PATH, "*");

		// Begin Windows file iteration
		self->mHandle = FindFirstFile(path, &self->mFindData);

		if (self->mHandle == INVALID_HANDLE_VALUE)
		{
			self->mHandle = NULL;
		}
		else
		{
			//Skip rid of "." and ".." directory results.
			if (strcmp(self->mFindData.cFileName, ".") == 0)
				this->popFront();
			if (self->mHandle && strcmp(self->mFindData.cFileName, "..") == 0)
				this->popFront();
		}
	}

	FileRange::~FileRange()
	{
		ZeroGetPrivateData(FileRangePrivateData);

		if (self->mHandle)
			FindClose(self->mHandle);

		ZeroDestructPrivateData(FileRangePrivateData);
	}

	bool FileRange::empty()
	{
		ZeroGetPrivateData(FileRangePrivateData);
		return self->mHandle == NULL;
	}

	cstr FileRange::front()
	{
		ZeroGetPrivateData(FileRangePrivateData);
		return self->mFindData.cFileName;
	}

	void FileRange::popFront()
	{
		ZeroGetPrivateData(FileRangePrivateData);
		BOOL hasNext = FindNextFile(self->mHandle, &self->mFindData);

		if (!hasNext)
		{
			// No more files
			FindClose(self->mHandle);
			self->mHandle = NULL;
		}
	}

	String UniqueFileId(StringRef fullpath)
	{
#ifdef FILE_NAME_NORMALIZED
		StackHandle fileHandle;

		fileHandle = CreateFile(fullpath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL,
			OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

		if (fileHandle == INVALID_HANDLE_VALUE)
		{
			//no file just return path.
			return fullpath;
		}

		char fixedFullPath[MAX_PATH + 1] = { 0 };
		DWORD size = GetFinalPathNameByHandle(fileHandle, fixedFullPath, MAX_PATH, FILE_NAME_NORMALIZED);

		if (size == 0)
			return fullpath;

		return fixedFullPath;
#else
		return fullpath;
#endif
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FpControl.hpp
/// Implementation of the ScpeFpuExceptions, ScoplessFpuExceptions and
/// FpuControlSystem classes.
///
/// Authors: Joshua Davis
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <float.h>

namespace Zero
{

	// If this is the Microsoft compiler
#ifdef _MSC_VER

	///by default, we want all of the fpu exceptions apart from inexact
	///(inexact happens in lots of odd places...) and underflow
	uint FpuControlSystem::DefaultMask = _EM_INEXACT | _EM_UNDERFLOW;
	///Stores that by default floating point exceptions are enabled
	bool FpuControlSystem::Active = true;

	ScopeFpuExceptionsEnabler::ScopeFpuExceptionsEnabler()
	{
		///only scope change if the fpu control system is active
		if (FpuControlSystem::Active == false)
			return;

		//*NOTE: _clearfp must be called between _controlfp_s calls. If two
		// _controlfp_s calls are made close to each other then an exception
		//will be thrown. Seemingly, _clearfp clears a busy bit on the cpu
		//which will prevent the cpu from thinking the state is being changed
		//while it is busy.

		unsigned int currState;
		//get the old state so we know what to go back to
		_clearfp();
		_controlfp_s(&mOldState, _MCW_EM, _MCW_EM);
		//set the new state
		_clearfp();
		_controlfp_s(&currState, FpuControlSystem::DefaultMask, _MCW_EM);
	}

	ScopeFpuExceptionsEnabler::~ScopeFpuExceptionsEnabler()
	{
		///only scope change if the fpu control system is active
		if (FpuControlSystem::Active == false)
			return;

		//set the old state back
		unsigned int currState;
		_clearfp();
		_controlfp_s(&currState, mOldState, _MCW_EM);
	}

	ScopeFpuExceptionsDisabler::ScopeFpuExceptionsDisabler()
	{
		///only scope change if the fpu control system is active
		if (FpuControlSystem::Active == false)
			return;

		//get the old state
		_controlfp_s(&mOldState, _MCW_EM, _MCW_EM);
		//set all of the exception flags which disables all fp exceptions.
		_controlfp_s(0, _MCW_EM, _MCW_EM);
	}

	ScopeFpuExceptionsDisabler::~ScopeFpuExceptionsDisabler()
	{
		///only scope change if the fpu control system is active
		if (FpuControlSystem::Active == false)
			return;

		//clear any pending fp exceptions otherwise there may be a
		//'deferred crash' as soon as the exceptions are enabled.
		_clearfp();

		//now reset the exceptions to what they were
		_controlfp_s(0, mOldState, _MCW_EM);
	}

	// Any other compiler
#else

	///the mask is 0 in the generic system since we aren't funning any fp exceptions.
	uint FpuControlSystem::DefaultMask = 0;
	///The system is not active because we're on some random platform
	bool FpuControlSystem::Active = false;

	ScopeFpuExceptionsEnabler::ScopeFpuExceptionsEnabler()
	{
	}

	ScopeFpuExceptionsEnabler::~ScopeFpuExceptionsEnabler()
	{
	}

	ScopeFpuExceptionsDisabler::ScopeFpuExceptionsDisabler()
	{
	}

	ScopeFpuExceptionsDisabler::~ScopeFpuExceptionsDisabler()
	{
	}

#endif

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file OsShared.cpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	void StackHandle::Close()
	{
		if (mHandle != cInvalidHandle)
			CloseHandle(mHandle);
		mHandle = cInvalidHandle;
	}

}

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Process.cpp
/// Implementation of the Process class and support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	struct ProcessPrivateData
	{
		HANDLE mStdIn;
		HANDLE mStdOut;
		HANDLE mProcess;
	};

	//---------------------------------------------------------------------- Process
	Process::Process()
	{
		ZeroConstructPrivateData(ProcessPrivateData);
		self->mProcess = NULL;
		self->mStdOut = NULL;
		self->mStdIn = NULL;
		mTextStream = NULL;
		mDebugName[0] = '\0';
	}

	Process::~Process()
	{
		Shutdown();
		ZeroDestructPrivateData(ProcessPrivateData);
	}

	//This code is a bit verbose. The purpose is the create a process and redirect its stdio
	//to this hosting process. 
	//Implementation referenced from
	//MSDN http://support.microsoft.com/kb/q190351/
	//Code Project http://www.codeproject.com/KB/threads/redir.aspx

	uint Process::ExecProcess(cstr debugName, cstr commandLine,
		TextStream* textStream, bool showWindow)
	{
		ZeroGetPrivateData(ProcessPrivateData);
		CStringCopy(mDebugName, cDebugNameMax, debugName, strlen(debugName));

		mTextStream = textStream;

		//Error Handling : WinReturnIf macro will signal an error and
		//return if the os call failed. Then  Stack handles will 
		//automatically close all valid handles cleaning up any references.

		StackHandle stdInRead;
		StackHandle stdOutWrite;
		StackHandle stdErrOut;

		StackHandle finalStdInWrite;
		StackHandle finalStdOutRead;

		OsHandle currentProcess = GetCurrentProcess();

		{
			SECURITY_ATTRIBUTES security;
			security.nLength = sizeof(SECURITY_ATTRIBUTES);
			security.lpSecurityDescriptor = NULL;
			security.bInheritHandle = TRUE;

			StackHandle stdOutReadTmp;
			StackHandle stdInWriteTmp;

			//Create the child output pipe.
			WinReturnIf(CreatePipe(stdOutReadTmp, stdOutWrite, &security, 0),
				"Failed to create output pipe for %s", mDebugName);

			// MSDN: Create a duplicate of the output write handle for the std error
			// write handle. This is necessary in case the child application
			// closes one of its std output handles.
			WinReturnIf(DuplicateHandle(currentProcess,
				stdOutWrite,
				currentProcess,
				stdErrOut,
				0, TRUE,
				DUPLICATE_SAME_ACCESS));

			//Create the child input pipe.
			WinReturnIf(CreatePipe(stdInRead, stdInWriteTmp, &security, 0),
				"Failed to create input pipe %s", mDebugName);

			// MSDN: Create new output read handle and the input write handles. Set
			// the Properties to FALSE. Otherwise, the child inherits the
			// properties and, as a result, non-closeable handles to the pipes
			// are created.
			WinReturnIf(DuplicateHandle(currentProcess,
				stdOutReadTmp,
				currentProcess,
				finalStdOutRead,
				0, FALSE,// Make it uninheritable.
				DUPLICATE_SAME_ACCESS));

			WinReturnIf(DuplicateHandle(currentProcess,
				stdInWriteTmp,
				currentProcess,
				finalStdInWrite,
				0, FALSE,// Make it uninheritable.
				DUPLICATE_SAME_ACCESS));

			// Close inheritable copies of the handles you do not want to be
			// inherited.
			stdOutReadTmp.Close();
			stdInWriteTmp.Close();
		}

		STARTUPINFO startUpInfo;
		ZeroMemory(&startUpInfo, sizeof(STARTUPINFO));
		startUpInfo.cb = sizeof(STARTUPINFO);
		startUpInfo.hStdOutput = stdOutWrite;
		startUpInfo.hStdInput = stdInRead;
		startUpInfo.hStdError = stdErrOut;

		if (showWindow)
			startUpInfo.wShowWindow = SW_SHOWDEFAULT;
		else
			startUpInfo.wShowWindow = SW_HIDE;//no window

		startUpInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

		PROCESS_INFORMATION processInfo;
		WinReturnIf(CreateProcess(NULL,
			(LPTSTR)commandLine,
			NULL, NULL,
			TRUE,
			CREATE_NEW_CONSOLE,
			NULL,
			NULL,
			&startUpInfo,
			&processInfo),
			"Failed to create process for process %s. \nCommand line '%s'",
			mDebugName,
			commandLine);

		// MSDN: Close pipe handles (do not continue to modify the parent).
		// You need to make sure that no handles to the write end of the
		// output pipe are maintained in this process or else the pipe will
		// not close when the child process exits and the ReadFile will hang.
		stdOutWrite.Close();
		stdInRead.Close();
		stdErrOut.Close();

		//Store the handles that are needed for input and output
		//that are not inheritable
		self->mStdIn = finalStdInWrite.Transfer();
		self->mStdOut = finalStdOutRead.Transfer();

		//Store the process
		self->mProcess = processInfo.hProcess;

		//Close unused thread handle
		CloseHandle(processInfo.hThread);

		//Create a cancel event for reading operations
		//so the hosting process can shutdown the read thread.
		mCancelEvent.Initialize(true, false);

		//Create the thread that will read input.
		mReadThread.Initialize(Thread::ObjectEntryCreator<Process, &Process::ReadThreadEntryPoint>,
			this, mDebugName);

		//Starting reading input
		mReadThread.Resume();

		return 0;
	}

	void Process::WriteToStdIn(cstr text, int size)
	{
		ZeroGetPrivateData(ProcessPrivateData);
		OsInt bytesWritten;
		WriteFile(self->mStdIn, (LPCTSTR)text, size, &bytesWritten, NULL);
	}

	void Process::Shutdown()
	{
		ZeroGetPrivateData(ProcessPrivateData);
		//Shutdown read thread with event.
		if (mReadThread.IsValid())
		{
			mCancelEvent.Signal();
			mReadThread.WaitForCompletion();
		}

		if (self->mProcess)
		{
			CloseHandle(self->mProcess);
			CloseHandle(self->mStdOut);
			CloseHandle(self->mStdIn);
		}
		self->mProcess = NULL;
		self->mStdOut = NULL;
		self->mStdIn = NULL;
	}

	void Process::WaitForClose()
	{
		ZeroGetPrivateData(ProcessPrivateData);
		WaitForSingleObject(self->mProcess, INFINITE);
		WaitForSingleObject(mReadThread.GetThreadHandle(), INFINITE);
	}

	int Process::GetExitCode()
	{
		ZeroGetPrivateData(ProcessPrivateData);
		OsInt exitCode = 0;
		GetExitCodeProcess(self->mProcess, &exitCode);
		return exitCode;
	}

	void Process::Terminate()
	{
		ZeroGetPrivateData(ProcessPrivateData);
		TerminateProcess(self->mProcess, (UINT)-1);
	}

	OsInt Process::ReadThreadEntryPoint()
	{
		ZeroGetPrivateData(ProcessPrivateData);
		// For debugging process issues
		const bool PrintDebugProcess = false;

		const OsInt cReadBufferSize = 1024;//1k
		byte readBuffer[cReadBufferSize + 1];//+1 for null terminator

		// Set up overlapped io on std out so reads can be checked with other handles
		// in WaitForMulitipleObjects
		OVERLAPPED readOverlapped;
		ZeroMemory(&readOverlapped, sizeof(readOverlapped));
		readOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

		// Start asynchronous overlapped read on std out
		DWORD bytesRead = 0;
		ReadFile(self->mStdOut, readBuffer, cReadBufferSize, &bytesRead, &readOverlapped);

		// Block until data can be read, the process is terminated or this process
		// is canceled.
		// Note: Check for readOverlapped first to make sure that any
		// std writes that happen at the same time the process is terminated
		// are still read.
		OsHandle waitHandles[] = { readOverlapped.hEvent, self->mProcess, mCancelEvent.GetHandle() };
		for (;;)
		{
			OsInt bytesRead = 0;
			OsInt bytesAvialable = 0;
			OsInt waitResult = WaitForMultipleObjects(3, waitHandles, FALSE, 60000L);

			switch (waitResult)
			{
			case WAIT_OBJECT_0:
			{
				if (PrintDebugProcess)
					ZPrint("%s : StdOut\n", mDebugName);

				// Get the number of bytes that were read
				BOOL success = GetOverlappedResult(self->mStdOut,
					&readOverlapped,
					&bytesRead,
					FALSE);
				if (success && bytesRead)
				{
					// Null terminate
					readBuffer[bytesRead] = '\0';
					// Write them out to the TextConsole interface
					if (mTextStream)
						mTextStream->Write((char*)readBuffer);
				}

				// Start another overlapped read
				ReadFile(self->mStdOut, readBuffer, cReadBufferSize, &bytesRead, &readOverlapped);
			}
			break;

			case WAIT_OBJECT_0 + 1:
			{
				if (PrintDebugProcess)
					DebugPrint("The process %s has terminated.\n", mDebugName);
				return 0;
			}
			break;

			case WAIT_OBJECT_0 + 2:
			{
				if (PrintDebugProcess)
					DebugPrint("Io on Process %s has been canceled.\n", mDebugName);
				return 0;
			}
			break;

			case WAIT_TIMEOUT:
			{
				//On timeout just try again.
				if (PrintDebugProcess)
					DebugPrint("Time out.\n", mDebugName);
			}
			break;

			case WAIT_FAILED:
			{
				VerifyWin(FALSE, "Failed to wait on process %s.", mDebugName);
			}
			}
		}
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Resolution.cpp
/// Resolution support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	Resolution GetDesktopResolution()
	{
		Resolution desktopRes;
		//Enumerate the display settings for the default device so we can
		//get the desktop resolution
		DEVMODE data;
		data.dmSize = sizeof(DEVMODE);
		data.dmDriverExtra = 0;
		EnumDisplaySettings(NULL, ENUM_REGISTRY_SETTINGS, &data);
		desktopRes.Width = data.dmPelsWidth;
		desktopRes.Height = data.dmPelsHeight;
		return desktopRes;
	}

	void Enumerate(Array<Resolution>& resolutions, uint bitDepth, Resolution aspect)
	{
		HashSet<Resolution> ResolutionMap;

		resolutions.clear();
		// Enumerate all display modes for the default display adapter.
		DEVMODE Win32Mode;
		Win32Mode.dmSize = sizeof(DEVMODE);
		for (int index = 0; EnumDisplaySettings(NULL, index, &Win32Mode); ++index)
		{
			Resolution resolution(Win32Mode.dmPelsWidth, Win32Mode.dmPelsHeight);
			// Check bit depth
			if (bitDepth == 0 || Win32Mode.dmBitsPerPel == bitDepth)
				// Check aspect ratio
				if (resolution.SameAspect(aspect))
				{
					ResolutionMap.insert(resolution);
				}
		}

		//push all in array
		PushAll(resolutions, ResolutionMap.all());
		//sort
		sort(resolutions.all());
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Socket.cpp
/// Declaration of the Socket class.
///
/// Authors: Trevor Sundberg
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma comment(lib, "ws2_32.lib")

namespace Zero
{
	SocketAddress::SocketAddress()
	{
		mSize = 0;
		ZeroMemClearPrivateData(sockaddr);
	}

	SocketAddress::~SocketAddress()
	{
	}

	void FailOnError(Status& status, int errorCode)
	{
		char* errorString = NULL;
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL, WSAGetLastError(),
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(LPSTR)&errorString, 0, NULL);

		status.SetFailed(errorString, errorCode);
		LocalFree(errorString);
	}

	void FailOnWsaLastError(Status& status)
	{
		int errorCode = WSAGetLastError();
		FailOnError(status, errorCode);
	}

	void SocketAddressInitialize(Status& status, SocketAddress& address, cstr host, int port, SocketAddressFamily::Enum family, int flags)
	{
		sockaddr* self = (sockaddr*)address.mPrivateData;

		addrinfo hints;

		ZeroMemory(&hints, sizeof(hints));
		hints.ai_family = family;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = IPPROTO_TCP;
		hints.ai_flags = flags;

		char buffer[128] = { 0 };
		/*UNSAFE*/std::sprintf(buffer, "%d", port);

		addrinfo* result = NULL;
		int wasError = getaddrinfo(host, buffer, &hints, &result);
		if (wasError != 0)
			return FailOnWsaLastError(status);

		*self = *result->ai_addr;
		address.mSize = result->ai_addrlen;

		freeaddrinfo(result);
	}

	SocketAddressFamily::Enum SocketAddress::GetAddressFamily()
	{
		ZeroGetPrivateData(sockaddr);
		return (SocketAddressFamily::Enum)self->sa_family;
	}

	void SocketAddress::InitializeInterNetwork(Status& status, StringParam host, int port)
	{
		SocketAddressInitialize(status, *this, host.c_str(), port, SocketAddressFamily::Unspecified, 0);
	}

	void SocketAddress::InitializeLocalInterNetwork4Any(Status& status, int port)
	{
		SocketAddressInitialize(status, *this, NULL, port, SocketAddressFamily::InterNetworkV4, AI_PASSIVE);
	}

	void SocketAddress::InitializeLocalInterNetwork6Any(Status& status, int port)
	{
		SocketAddressInitialize(status, *this, NULL, port, SocketAddressFamily::InterNetworkV6, AI_PASSIVE);
	}

	Socket::Socket()
	{
		mAddressFamily = SocketAddressFamily::Unspecified;
		mSocketType = SocketType::Unspecified;
		mProtocolType = SocketProtocolType::Tcp;
		mHandle = (OsHandle)INVALID_SOCKET;

		WSADATA wsaData;
		int errorCode = WSAStartup(MAKEWORD(2, 2), &wsaData);
		if (errorCode != 0)
		{
			Status status;
			FailOnError(status, errorCode);
			Error("WSAStartup failed: %s", status.Message.c_str());
		}
	}

	Socket::~Socket()
	{
		if (mHandle != (OsHandle)INVALID_SOCKET)
		{
			Status status;
			Shutdown(status, SocketIo::Both);
			Close(status);

			if (status.Failed())
				Error("Socket destructor / close failed: %s", status.Message.c_str());
		}

		int errorCode = WSACleanup();
		if (errorCode == SOCKET_ERROR)
		{
			Status status;
			FailOnWsaLastError(status);
			Error("WSACleanup failed: %s", status.Message.c_str());
		}
	}

	bool Socket::IsReceiveCloseError(int extendedErrorCode)
	{
		switch (extendedErrorCode)
		{
		case WSAENETRESET:
		case WSAECONNABORTED:
		case WSAECONNRESET:
			return true;
		}

		return false;
	}

	bool Socket::IsAcceptRemoteError(int extendedErrorCode)
	{
		return (extendedErrorCode == WSAECONNRESET);
	}

	void Socket::NetworkByteOrderSwap(const byte* input, size_t size, byte* output)
	{
		// Allocate a temporary in case the output and input overlap
		byte* tempData = (byte*)alloca(size);

		// If we're already in network-byte-order (big endian)
		if (IsBigEndian())
		{
			// There's nothing to do!
			memcpy(tempData, input, size);
		}
		else
		{
			// Copy the bytes in reverse
			for (size_t i = 0; i < size; ++i)
			{
				tempData[i] = input[size - i - 1];
			}
		}

		memcpy(output, tempData, size);
	}

	bool Socket::IsValid()
	{
		return mHandle != (OsHandle)INVALID_SOCKET;
	}

	void Socket::Initialize(Status& status, SocketAddressFamily::Enum addressFamily, SocketType::Enum type, SocketProtocolType::Enum protocol)
	{
		if (IsValid())
			Close(status);

		mAddressFamily = addressFamily;
		mSocketType = type;
		mProtocolType = protocol;

		mHandle = (OsHandle)socket(addressFamily, type, protocol);

		if (mHandle == (OsHandle)INVALID_SOCKET)
			return FailOnWsaLastError(status);

		// For the moment, we always disable the Nagle algorithm
		if (protocol == SocketProtocolType::Tcp)
		{
			BOOL value = 1;
			setsockopt((SOCKET)mHandle, IPPROTO_TCP, TCP_NODELAY, (const char*)&value, sizeof(value));
		}
	}

	void Socket::Bind(Status& status, const SocketAddress& address)
	{
		int wasError = ::bind((SOCKET)mHandle, (sockaddr*)address.mPrivateData, address.mSize);
		if (wasError != 0)
			return FailOnWsaLastError(status);
	}

	int Socket::GetMaxConnectionBacklog()
	{
		return SOMAXCONN;
	}

	void Socket::Listen(Status& status, int backlog)
	{
		int wasError = listen((SOCKET)mHandle, backlog);
		if (wasError != 0)
			return FailOnWsaLastError(status);
	}

	void Socket::Accept(Status& status, Socket* socketOut, SocketAddress* addressOut)
	{
		sockaddr address;
		ZeroMemory(&address, sizeof(address));
		addressOut->mSize = sizeof(sockaddr);

		SOCKET newSocket = accept((SOCKET)mHandle, &address, &addressOut->mSize);
		if (newSocket == INVALID_SOCKET)
			return FailOnWsaLastError(status);

		socketOut->mHandle = (OsHandle)newSocket;
		socketOut->mAddressFamily = (SocketAddressFamily::Enum)address.sa_family;

		// We should probably set the socket type and protocol here too...
		*((sockaddr*)addressOut->mPrivateData) = address;
	}

	void Socket::Connect(Status& status, const SocketAddress& remoteAddress)
	{
		int wasError = connect((SOCKET)mHandle, (sockaddr*)remoteAddress.mPrivateData, remoteAddress.mSize);
		if (wasError != 0)
			return FailOnWsaLastError(status);
	}

	void Socket::Close(Status& status)
	{
		int wasError = closesocket((SOCKET)mHandle);
		mHandle = (OsHandle)INVALID_SOCKET;
		if (wasError != 0)
			return FailOnWsaLastError(status);
	}

	void Socket::Shutdown(Status& status, SocketIo::Enum io)
	{
		int wasError = shutdown((SOCKET)mHandle, (int)io);
		if (wasError != 0)
			return FailOnWsaLastError(status);
	}

	int Socket::Send(Status& status, const byte* data, int length, SocketFlags::Enum flags)
	{
		int result = send((SOCKET)mHandle, (const char*)data, length, (int)flags);
		if (result == SOCKET_ERROR)
		{
			FailOnWsaLastError(status);
			return 0;
		}
		return result;
	}

	int Socket::SendTo(Status& status, const byte* data, int length, SocketFlags::Enum flags, const SocketAddress& to)
	{
		int result = sendto((SOCKET)mHandle, (const char*)data, length, (int)flags, (sockaddr*)to.mPrivateData, to.mSize);
		if (result == SOCKET_ERROR)
		{
			FailOnWsaLastError(status);
			return 0;
		}
		return result;
	}

	int Socket::Receive(Status& status, byte* dataOut, int length, SocketFlags::Enum flags)
	{
		int result = recv((SOCKET)mHandle, (char*)dataOut, length, (int)flags);
		if (result == SOCKET_ERROR)
		{
			FailOnWsaLastError(status);
			return 0;
		}
		return result;
	}

	int Socket::ReceiveFrom(Status& status, byte* dataOut, int length, SocketFlags::Enum flags, SocketAddress& from)
	{
		int result = recvfrom((SOCKET)mHandle, (char*)dataOut, length, (int)flags, (sockaddr*)from.mPrivateData, &from.mSize);
		if (result == SOCKET_ERROR)
		{
			FailOnWsaLastError(status);
			return 0;
		}
		return result;
	}

	bool Socket::Select(Status& status, SocketSelect::Enum selectMode, float timeoutSeconds)
	{
		// Construct a time span from our floating point seconds
		timeval timeout;
		timeout.tv_sec = (long)timeoutSeconds;
		timeout.tv_usec = (long)((timeoutSeconds - timeout.tv_sec) * 1000000L);

		fd_set set;
		set.fd_count = 1;
		set.fd_array[0] = (SOCKET)mHandle;

		int count = 0;

		switch (selectMode)
		{
		case SocketSelect::Read:
			count = select(0, &set, NULL, NULL, &timeout);
			break;
		case SocketSelect::Write:
			count = select(0, NULL, &set, NULL, &timeout);
			break;
		case SocketSelect::Error:
			count = select(0, NULL, NULL, &set, &timeout);
			break;
		}

		if (count == SOCKET_ERROR)
		{
			FailOnWsaLastError(status);
			return false;
		}

		return (count != 0);
	}

}
#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.cpp
/// Implementation of the Thread class.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#ifdef _MSC_VER

///Used to set the thread name in Visual Studio. This raises an exception that 
//Visual Studio catches and then sets the thread name.
typedef struct tagTHREADNAME_INFO
{
	DWORD dwType;     // must be 0x1000
	LPCSTR szName;    // pointer to name (in user addr space)
	DWORD dwThreadID; // thread ID (-1=caller thread)
	DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

inline void SetThreadDebugName(DWORD dwThreadID, LPCSTR szThreadName)
{
	THREADNAME_INFO info;
	info.dwType = 0x1000;
	info.szName = szThreadName;
	info.dwThreadID = dwThreadID;
	info.dwFlags = 0;

	//Yes this looks strange but it works for VS
	__try
	{
		RaiseException(0x406D1388, 0, sizeof(info) / sizeof(DWORD), (CONST ULONG_PTR*)&info);
	}
	__except (EXCEPTION_CONTINUE_EXECUTION)
	{
	}
}

#else

inline void SetThreadDebugName(DWORD dwThreadID, LPCSTR szThreadName)
{
}

#endif

namespace Zero
{
	const bool ThreadingEnabled = true;

	struct ThreadPrivateData
	{
		OsInt mThreadId;
		OsHandle mHandle;
	};

	Thread::Thread()
	{
		ZeroConstructPrivateData(ThreadPrivateData);

		self->mHandle = NULL;
		self->mThreadId = 0;
	}

	Thread::~Thread()
	{
		Close();
		ZeroDestructPrivateData(ThreadPrivateData);
	}

	OsHandle Thread::GetThreadHandle()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		return self->mHandle;
	}

	bool Thread::Initialize(EntryFunction entry, void* instance, cstr threadName)
	{
		ZeroGetPrivateData(ThreadPrivateData);

		CStringCopy(mThreadName, cDebugNameMax, threadName, strlen(threadName));

		const int cStackSize = 65536;
		self->mHandle = ::CreateThread(NULL, //No Security
			cStackSize,
			(LPTHREAD_START_ROUTINE)entry,
			(LPVOID)instance,
			CREATE_SUSPENDED,
			&self->mThreadId);

		CheckWin(self->mHandle != INVALID_HANDLE_VALUE,
			"Failed to create thread named %s", threadName);

		if (self->mHandle != INVALID_HANDLE_VALUE)
		{
			SetThreadDebugName(self->mThreadId, threadName);
			return true;
		}
		else
		{
			self->mHandle = NULL;
			return false;
		}
	}

	bool Thread::IsValid()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		return self->mHandle != NULL;
	}

	void Thread::Resume()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		if (IsValid())
			VerifyWin(ResumeThread(self->mHandle), "Failed to resume thread. Thread name: %",
			mThreadName);
	}

	void Thread::Suspend()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		if (IsValid())
			VerifyWin(SuspendThread(self->mHandle),
			"Failed to suspend thread. Thread name: %", mThreadName);
	}

	//Close the thread handle. 
	void Thread::Close()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		if (IsValid())
			VerifyWin(CloseHandle(self->mHandle),
			"Failed to close thread handle. Thread name: %", mThreadName);
		self->mHandle = NULL;
	}

	OsHandle Thread::Detach()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		OsHandle handle = self->mHandle;
		self->mHandle = NULL;
		return handle;
	}

	OsInt Thread::WaitForCompletion()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		if (!IsValid())
			return (OsInt)-1;

		DWORD result = WaitForSingleObject(self->mHandle, INFINITE);
		if (result != WAIT_OBJECT_0)
		{
			DebugPrint("Failed to wait on on thread. Thread name: %s", mThreadName);
			return (OsInt)-1;
		}
		else
		{
			OsInt returnCode;
			GetExitCodeThread(self->mHandle, &returnCode);
			return returnCode;
		}
	}

	bool Thread::IsCompleted()
	{
		ZeroGetPrivateData(ThreadPrivateData);
		if (!IsValid())
			return true;

		OsInt returnCode = 0;
		GetExitCodeThread(self->mHandle, &returnCode);
		bool threadActive = (returnCode == STILL_ACTIVE);
		return !threadActive;
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadSync.cpp
/// Implementation of Thread synchronization classes.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	ThreadLock::ThreadLock()
	{
		ZeroConstructPrivateData(CRITICAL_SECTION);
		::InitializeCriticalSection(self);
	}

	ThreadLock::~ThreadLock()
	{
		ZeroGetPrivateData(CRITICAL_SECTION);
		::DeleteCriticalSection(self);
		ZeroDestructPrivateData(CRITICAL_SECTION);
	}

	void ThreadLock::Lock()
	{
		ZeroGetPrivateData(CRITICAL_SECTION);
		::EnterCriticalSection(self);
	}

	void ThreadLock::Unlock()
	{
		ZeroGetPrivateData(CRITICAL_SECTION);
		::LeaveCriticalSection(self);
	}

	OsEvent::OsEvent()
		:mHandle(NULL)
	{
	}

	OsEvent::~OsEvent()
	{
		Close();
	}

	void OsEvent::Initialize(bool manualReset, bool startSignaled)
	{
		mHandle = CreateEvent(NULL, manualReset, startSignaled, NULL);
		CheckWin(mHandle != INVALID_HANDLE_VALUE, "Failed to create event.");
	}

	void OsEvent::Close()
	{
		if (mHandle != NULL)
		{
			VerifyWin(CloseHandle(mHandle), "Failed to close event.");
		}
	}

	void OsEvent::Signal()
	{
		VerifyWin(SetEvent(mHandle), "Failed to Signal event.");
	}

	void OsEvent::Wait()
	{
		DWORD result = WaitForSingleObject(mHandle, INFINITE);
		if (result == WAIT_FAILED)
		{
			VerifyWin(0, "Failed to Signal event.");
		}
	}

	void OsEvent::Reset()
	{
		VerifyWin(ResetEvent(mHandle), "Failed to Reset event.");
	}

	Semaphore::Semaphore()
	{
		mHandle = CreateSemaphore(NULL, 0, MaxSemaphoreCount, NULL);
	}

	Semaphore::~Semaphore()
	{
		VerifyWin(CloseHandle(mHandle), "Failed to close Semaphore handle");
	}

	void Semaphore::Increment()
	{
		VerifyWin(ReleaseSemaphore(mHandle, 1, NULL), "Failed to increment semaphore");
	}

	void Semaphore::Decrement()
	{
		WaitForSingleObject(mHandle, 0);
	}

	void Semaphore::Reset()
	{
		VerifyWin(CloseHandle(mHandle), "Failed to close Semaphore handle");
		mHandle = CreateSemaphore(NULL, 0, MaxSemaphoreCount, NULL);
	}

	void Semaphore::WaitAndDecrement()
	{
		OsInt result = WaitForSingleObject(mHandle, INFINITE);
		if (result != WAIT_OBJECT_0)
		{
		}
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Timer.cpp
/// Implementation of the Os Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{
	struct TimerPrivateData
	{
		long long mStartCount;
		long long mCurrentTickCount;
		long long mCurrentTickDelta;
		double mFrequency;
		double mCurTimeDelta;
		double mCurTime;
	};

	Timer::Timer()
	{
		ZeroConstructPrivateData(TimerPrivateData);

		LARGE_INTEGER  Frequency;
		QueryPerformanceFrequency(&Frequency);
		//mInvFrequency = 1.0 / (double)Frequency.QuadPart;
		self->mFrequency = (double)Frequency.QuadPart;
		Reset();
	}

	Timer::~Timer()
	{
		ZeroDestructPrivateData(TimerPrivateData);
	}

	void Timer::Reset()
	{
		ZeroGetPrivateData(TimerPrivateData);
		LARGE_INTEGER Count;
		QueryPerformanceCounter(&Count);
		self->mStartCount = Count.QuadPart;

		self->mCurrentTickCount = 0;
		self->mCurrentTickDelta = 0;
		self->mCurTimeDelta = 0;
		self->mCurTime = 0;
	}

	void Timer::Update()
	{
		ZeroGetPrivateData(TimerPrivateData);
		TickType lastTickCount = self->mCurrentTickCount;
		LARGE_INTEGER CurrCount;
		QueryPerformanceCounter(&CurrCount);
		self->mCurrentTickCount = (CurrCount.QuadPart - self->mStartCount);
		self->mCurrentTickDelta = self->mCurrentTickCount - lastTickCount;

		//mCurTime =  mCurrentTickCount * mInvFrequency;
		self->mCurTime = self->mCurrentTickCount / self->mFrequency;
		//mCurTimeDelta = mCurrentTickDelta * mInvFrequency;
		self->mCurTimeDelta = self->mCurrentTickDelta / self->mFrequency;
	}

	double Timer::TimeNoUpdate() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		LARGE_INTEGER CurrCount;
		QueryPerformanceCounter(&CurrCount);
		TickType TempTicks = (CurrCount.QuadPart - self->mStartCount);
		//return (double)(TempTicks * mInvFrequency);
		return (double)(TempTicks / self->mFrequency);
	}

	Timer::TickType Timer::GetTickTime() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		LARGE_INTEGER CurrCount;
		QueryPerformanceCounter(&CurrCount);
		return CurrCount.QuadPart - self->mStartCount;
	}

	double Timer::TicksToSeconds(TickType ticks) const
	{
		ZeroGetPrivateData(TimerPrivateData);
		//return (double)(ticks* mInvFrequency);
		return (double)(ticks / self->mFrequency);
	}

	double Timer::UpdateAndGetTime()
	{
		Update();
		return Time();
	}
	double Timer::Time() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		return self->mCurTime;
	}
	double Timer::TimeDelta() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		return self->mCurTimeDelta;
	}

}//namespace Zero

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Utilities.cpp
/// Implementation of the Utilities class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <Lmcons.h>
#include <shellapi.h>
#include <iptypes.h>
#include <iphlpapi.h>
#pragma comment(lib, "IPHLPAPI.lib")
#pragma comment(lib, "Winmm.lib")
#pragma comment(lib, "Advapi32.lib")

namespace Zero
{

	namespace Os
	{

		void Sleep(uint ms)
		{
			::Sleep(ms);
		}

		void SetTimerFrequency(uint ms)
		{
			::timeBeginPeriod(ms);
		}

		String UserName()
		{
			char buffer[UNLEN + 1];
			DWORD size = UNLEN + 1;
			GetUserName(buffer, &size);
			return String(buffer);
		}

		String ComputerName()
		{
			char buffer[MAX_COMPUTERNAME_LENGTH + 1];
			DWORD size = MAX_COMPUTERNAME_LENGTH + 1;
			GetComputerName(buffer, &size);
			return String(buffer);
		}

#ifndef _MSC_VER
		BOOL CheckRemoteDebuggerPresent(HANDLE, PBOOL pbDebuggerPresent)
		{
			*pbDebuggerPresent = FALSE;
			return FALSE;
		}
#endif

		// Check if a debugger is attached
		bool IsDebuggerAttached()
		{
			return IsDebuggerPresent() == TRUE;
		}

		u64 GetMacAddress()
		{
			static u64 macAddress = 0;

			if (macAddress == 0)
			{
				IP_ADAPTER_INFO adapterInfoBuffer[16];
				OsInt sizeOfBuffer = sizeof(adapterInfoBuffer);
				OsInt status = GetAdaptersInfo(adapterInfoBuffer, &sizeOfBuffer);

				u64 address = 0;
				for (uint i = 0; i<5; ++i)
				{
					u64 val = adapterInfoBuffer[0].Address[5 - i];
					val = val << i * 8;
					address += val;
				}

				macAddress = address;
			}

			return macAddress;
		}

		// Debug break (only if a debugger is attached)
		void DebugBreak()
		{
			// If the debugger is attached...
			if (IsDebuggerAttached() == true)
			{
				// Trigger a break point!
				ZERO_DEBUG_BREAK;
			}
		}

		cstr windowsVerbNames[] = { NULL, "open", "edit", "run" };
		void SystemOpenFile(cstr file, uint verb, cstr parameters,
			cstr workingDirectory)
		{
			Status status;
			SystemOpenFile(status, file, verb, parameters, workingDirectory);
		}

		bool SystemOpenFile(Status& status, cstr file, uint verb, cstr parameters, cstr workingDirectory)
		{
			HINSTANCE success = ShellExecute(NULL, windowsVerbNames[verb], file, parameters, workingDirectory, TRUE);

			const HINSTANCE shellSucceed = (HINSTANCE)32;
			if (success > shellSucceed)
				return true;

			int errorCode = (int)(long long)success;
			char buffer[1024];
			ToErrorString(buffer, 1024, errorCode);
			status.SetFailed("Failed to execute shell command. ", errorCode);

			return false;
		}

		String GetEnvironmentalVariable(StringRef variable)
		{
			char* envVarValue = getenv(variable.c_str());

			if (envVarValue)
				return envVarValue;
			else
				return String();

		}

		//---------------------------------------------------------------- Memory Status 
		void GetMemoryStatus(MemoryInfo& data)
		{
			size_t pageRegion = 0;
			size_t foundPage = 1;
			while (foundPage)
			{
				MEMORY_BASIC_INFORMATION memoryInfo;
				//VirtualQueryEx return the size of the MEMORY_BASIC_INFORMATION if it 
				//succeeds or zero if no more pages are found.
				foundPage = VirtualQueryEx(GetCurrentProcess(), (void*)pageRegion,
					&memoryInfo, sizeof(memoryInfo));
				if (foundPage)
				{
					if (memoryInfo.State & MEM_FREE)
					{
						data.Free += memoryInfo.RegionSize;
					}
					else
					{
						if (memoryInfo.State & MEM_RESERVE)
							data.Reserve += memoryInfo.RegionSize;

						if (memoryInfo.State & MEM_COMMIT)
							data.Commit += memoryInfo.RegionSize;
					}

					//Move past this region to find another page.
					pageRegion += memoryInfo.RegionSize;
				}
			}
		}

		String TranslateErrorCode(int errorCode)
		{
			//Try exception codes
			cstr exceptionCode = GetWindowsExceptionCode(errorCode);
			if (exceptionCode)
				return exceptionCode;

			//Try windows formating
			char message[MAX_PATH] = { 0 };
			ToErrorString(message, MAX_PATH, errorCode);
			return message;
		}

		typedef void (WINAPI *GetNativeSystemInfoPtr)(LPSYSTEM_INFO);

		String GetVersionString()
		{
			OSVERSIONINFOEX osvi;
			SYSTEM_INFO si;

			ZeroMemory(&si, sizeof(SYSTEM_INFO));
			ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

			osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

			// The function 'GetVersionEx' still works on Windows 8.1 but is deprecated, so if the build
			// is made on windows 8.1 this can often cause errors
#pragma warning(push)
#pragma warning(disable: 4996)
			BOOL bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi);
#pragma warning(pop)

			StringBuilder builder;

			if (!bOsVersionInfoEx) return String();

			// Call GetNativeSystemInfo if supported or GetSystemInfo otherwise.
			// This gets more information to determine 64bit vs 32bit but
			// is only available on later versions.

			GetNativeSystemInfoPtr pGNSI = (GetNativeSystemInfoPtr)GetProcAddress(
				GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");

			if (pGNSI != NULL)
				pGNSI(&si);
			else
				GetSystemInfo(&si);

			if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && osvi.dwMajorVersion > 4)
			{
				builder << "Microsoft ";

				// Test for the specific product.
				if (osvi.dwMajorVersion == 6)
				{
					if (osvi.dwMinorVersion == 0)
					{
						if (osvi.wProductType == VER_NT_WORKSTATION)
							builder << "Windows Vista ";
						else
							builder << "Windows Server 2008 ";
					}

					if (osvi.dwMinorVersion == 1)
					{
						if (osvi.wProductType == VER_NT_WORKSTATION)
							builder << "Windows 7 ";
						else
							builder << "Windows Server 2008 R2 ";
					}

					if (osvi.dwMinorVersion == 2)
					{
						builder << "Windows 8 ";
					}

				}

				if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)
				{
					if (GetSystemMetrics(SM_SERVERR2))
						builder << "Windows Server 2003 R2";
					else if (osvi.wSuiteMask & VER_SUITE_STORAGE_SERVER)
						builder << "Windows Storage Server 2003";
					else if (osvi.wSuiteMask & VER_SUITE_WH_SERVER)
						builder << "Windows Home Server";
					else if (osvi.wProductType == VER_NT_WORKSTATION &&
						si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
						builder << "Windows XP Professional x64 Edition";
					else
						builder << "Windows Server 2003";
				}

				if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
				{
					builder << "Windows XP ";
					if (osvi.wSuiteMask & VER_SUITE_PERSONAL)
						builder << "Home Edition";
					else
						builder << "Professional";
				}

				if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
				{
					builder << "Windows 2000 ";
				}

				// Include service pack (if any) and build number.

				if (strlen(osvi.szCSDVersion) > 0)
				{
					builder << (const char*)osvi.szCSDVersion;
				}

				builder << " (Build " << int(osvi.dwBuildNumber) << ")";

				if (osvi.dwMajorVersion >= 6)
				{
					if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
						builder << ", 64-bit";
					else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
						builder << ", 32-bit";
				}

				return builder.ToString();
			}

			else
			{
				return String("Unknown");
			}
		}

	}

	u64 GenerateUniqueId64()
	{
		//Get the mac address of the machine
		static u64 cachedMacAdress = (Os::GetMacAddress() << 16);

		u64 newId = cachedMacAdress;

		///Get the low part of the the performance counter
		LARGE_INTEGER performanceCounter;
		BOOL status = QueryPerformanceCounter(&performanceCounter);
		u64 lowCount = performanceCounter.LowPart;

		//Get the current system time (since 1970)
		time_t systemTimeT;
		time(&systemTimeT);

		u64 systemTime = systemTimeT;

		//combine the two time parts
		u64 lowId = (u64(systemTime) << 32) | (lowCount);

		//Keep incrementing the low value
		static uint shiftCount = 0;
		++shiftCount;
		lowId += shiftCount;

		//Or it with the mac part
		newId ^= lowId;

		return newId;
	}
}

#endif

#if defined(PLATFORM_WINDOWS)
///////////////////////////////////////////////////////////////////////////////
///
/// \file WindowsError.cpp
/// Implementation of Windows error handling.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#pragma comment(lib, "user32.lib")

uint ToErrorString(char* messageBuffer, uint bufferSize, uint errorCode)
{
	//If no error code was provided default to the last error
	//that occurred.
	DWORD error = errorCode != 0 ? errorCode : GetLastError();

	// Look up windows error string.
	DWORD numberOfChars = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		error,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		messageBuffer,
		bufferSize,
		NULL);

	return numberOfChars;
}

uint CheckWindowsErrorCode(uint success, cstr format, ...)
{
	if (!success)
	{
		char errorMessage[cMaxErrorMessageSize] = { 0 };
		ToErrorString(errorMessage, cMaxErrorMessageSize, GetLastError());
		char emptyBuffer[1] = { 0 };
		char* messageBuffer = emptyBuffer;

		if (format)
		{
			//Use va args to print text
			va_list args;
			va_start(args, format);
			//Get the number of characters needed
			int characters;
			VSPrintfCount(format, args, 1, characters);
			if (characters > 0)
			{
				messageBuffer = (char*)alloca(characters + 1);
				messageBuffer[characters] = '\0';
				VSPrintf(messageBuffer, characters + 1, format, args);
			}
			va_end(args);
		}

		// Combine both message and windows error into message.
		ZPrint("%s Windows Error: %s", messageBuffer, errorMessage);

		ErrorIf(true, "%s Windows Error: %s", messageBuffer, errorMessage);
	}
	return success;
}

cstr GetWindowsExceptionCode(int exceptionCode)
{
	//take from Bruce Dawson's article http://www.altdevblogaday.com/2012/04/20/exceptional-floating-point/
	switch ((DWORD)exceptionCode)
	{
	case STATUS_FLOAT_INVALID_OPERATION:
		return "Float Invalid Operation";
	case STATUS_FLOAT_DIVIDE_BY_ZERO:
		return "Float Divide by Zero";
	case STATUS_FLOAT_OVERFLOW:
		return "Float Overflow";
	case STATUS_FLOAT_MULTIPLE_TRAPS:
		return "Float Multiple Traps (sse float exception)";
	case STATUS_INTEGER_DIVIDE_BY_ZERO:
		return "Integer Division by Zero";
	case STATUS_ACCESS_VIOLATION:
		return "Access Violation";
	case STATUS_STACK_OVERFLOW:
		return "Stack Overflow";
	case STATUS_ILLEGAL_INSTRUCTION:
		return "Illegal Instruction";
	case STATUS_BREAKPOINT:
		return "Debug Breakpoint";
	case STATUS_DATATYPE_MISALIGNMENT:
		return "Data Type Misalignment (likely sse not aligned)";
	case STATUS_PRIVILEGED_INSTRUCTION:
		return "Privileged Instruction";
	default:
		return NULL;
	}
}
#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file DirectoryWatcher.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for posix library.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#ifdef __APPLE__
#include <CoreServices/CoreServices.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#endif

#include <new>
#include <cstdlib>
#include <cstdio>
#include <ctime>
#include <cctype>
#include <sys/stat.h>
#include <fcntl.h>
using namespace std;

#endif

namespace Zero
{

	DirectoryWatcher::DirectoryWatcher(cstr directoryToWatch, CallbackFunction callback, void* callbackInstance)
	{
		CStringCopy(mDirectoryToWatch, File::MaxPath, directoryToWatch, strlen(directoryToWatch));
		mCallbackInstance = callbackInstance;
		mCallback = callback;
	}

	DirectoryWatcher::~DirectoryWatcher()
	{

	}

	void DirectoryWatcher::Shutdown()
	{

	}

	OsInt DirectoryWatcher::RunThreadEntryPoint()
	{
		return 0;
	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.cpp
/// Implementation of the Os file class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma warning(disable: 4996)

namespace Zero
{
	struct FilePrivateData
	{
		FILE* mHandle;
		uint mFileSize;
		FixedString<File::MaxPath> mFilePath;
	};

	cstr cBadFileMessage = "The file is missing, not in that location, or is "
		"protected.";

	uint GetFileSize(FILE* file)
	{
		int fd = fileno(file);
		struct stat st;
		fstat(fd, &st);
		return (uint)st.st_size;
	}

	DataBlock ReadFileIntoDataBlock(cstr filePath)
	{
		FILE* file = fopen(filePath, "rb");
		if (file)
		{
			uint fileSize = GetFileSize(file);
			byte* buffer = (byte*)zAllocate(fileSize);
			fread(buffer, 1, fileSize, file);
			fclose(file);
			return DataBlock(buffer, fileSize);
		}

		return DataBlock();
	}

	byte * ReadFileIntoMemory(cstr filePath, size_t& fileSize, size_t extra)
	{
		FILE* file = fopen(filePath, "rb");
		if (file)
		{
			fileSize = GetFileSize(file);
			byte* buffer = (byte*)zAllocate(fileSize + extra);
			fread(buffer, 1, fileSize, file);
			fclose(file);
			return buffer;
		}
		return NULL;
	}

	size_t WriteToFile(cstr filePath, byte* buffer, size_t bufferSize)
	{
		FILE* file = fopen(filePath, "wb");
		if (file)
		{
			fwrite(buffer, 1, bufferSize, file);
			fclose(file);
			return bufferSize;
		}
		return 0;
	}

	cstr ToFileMode(FileMode::Enum mode)
	{
		switch (mode)
		{
		case FileMode::Read:
			return "rb";

		case FileMode::Append:
			return "ab";

		case FileMode::Write:
			return "wb";

		case FileMode::ReadWrite:
			return "r+b";
		}
		return "";
	}

	//Convert File Relative position to windows constant
	uint ToOrigin(FileOrigin::Enum origin)
	{
		switch (origin)
		{
		case FileOrigin::Begin:
			return SEEK_SET;
		case FileOrigin::End:
			return SEEK_END;
		case FileOrigin::Current:
			return SEEK_CUR;
		}
		return SEEK_CUR;
	}

	File::File()
	{
		ZeroConstructPrivateData(FilePrivateData);
		self->mHandle = NULL;
	}

	bool File::Open(cstr filePath, FileMode::Enum mode, FileAccessPattern::Enum accessPattern)
	{
		ZeroGetPrivateData(FilePrivateData);
		cstr fmode = ToFileMode(mode);

		self->mHandle = fopen(filePath, fmode);
		ReturnIf(self->mHandle == NULL, false,
			"Failed to open file '%s'. %s", filePath, cBadFileMessage);

		self->mFileSize = GetFileSize(self->mHandle);
		self->mFilePath = filePath;

		if (mode == FileMode::Append)
			Seek(self->mFileSize);
		return true;
	}

	void File::Close()
	{
		ZeroGetPrivateData(FilePrivateData);
		if (self->mHandle != NULL)
		{
			fclose(self->mHandle);
			self->mHandle = NULL;
		}
	}

	bool File::IsOpen()
	{
		ZeroGetPrivateData(FilePrivateData);
		return self->mHandle != NULL;
	}


	File::~File()
	{
		Close();
	}

	FilePosition File::Tell()
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == NULL, "File handle is not valid.");
		return ftell(self->mHandle);
	}

	size_t File::Size()
	{
		ZeroGetPrivateData(FilePrivateData);
		return self->mFileSize;
	}

	void File::Seek(FilePosition pos, FileOrigin::Enum origin)
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == NULL, "File handle is not valid.");
		fseek(self->mHandle, (long)pos, ToOrigin(origin));
	}

	size_t File::Write(byte* data, size_t sizeInBytes)
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == NULL, "File handle is not valid.");
		return fwrite(data, 1, sizeInBytes, self->mHandle);
	}

	size_t File::Read(byte* data, size_t sizeInBytes)
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == NULL, "File handle is not valid.");
		return fread(data, 1, sizeInBytes, self->mHandle);
	}

	void File::Flush()
	{
		ZeroGetPrivateData(FilePrivateData);
		ErrorIf(self->mHandle == NULL, "File handle is not valid.");
		fflush(self->mHandle);
	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FileSystem.cpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <errno.h>

namespace Zero
{

	const char  cDirectorySeparatorChar = '/';
	const char* cDirectorySeparatorCstr = "/";

	void InitFileSystem()
	{

	}

	void ShutdownFileSystem()
	{

	}

	bool CopyFile(StringRef dest, StringRef source)
	{
		FILE* sourceFile = fopen(source.c_str(), "rb");
		if (sourceFile == NULL)
			return false;

		FILE* destFile = fopen(dest.c_str(), "wb");
		if (destFile == NULL)
		{
			fclose(sourceFile);
			return false;
		}

		const int bufferSize = 4096;

		char buf[bufferSize];
		for (;;)
		{
			ssize_t bytesRead = fread(buf, 1, bufferSize, sourceFile);
			int written = fwrite(buf, bytesRead, 1, destFile);
			if (bytesRead != bufferSize)
				break;
		}

		fclose(sourceFile);
		fclose(destFile);
		return true;
	}

	bool VerifyPosix(int returnCode, cstr operation)
	{
		if (returnCode != 0)
		{
			ZPrint("While: %s Error: %s\n", operation, strerror(errno));
			return false;
		}
		else
		{
			return true;
		}
	}

	bool MoveFile(StringRef dest, StringRef source)
	{
		return  VerifyPosix(rename(source.c_str(), dest.c_str()), "MoveFile");
	}

	bool DeleteFile(StringRef filename)
	{
		return VerifyPosix(unlink(filename.c_str()), "DeleteFile");
	}

	bool DeleteDirectory(StringRef name)
	{
		return VerifyPosix(rmdir(name.c_str()), "DeleteDirectory");
	}

	void CreateDirectory(StringRef dest)
	{
		int failCode = mkdir(dest.c_str(),
			S_IRUSR | S_IWUSR | S_IXUSR |
			S_IRGRP | S_IWGRP | S_IXGRP |
			S_IROTH | S_IXOTH);

		if (failCode != 0)
		{
			// If the error is anything except already exists
			if (errno != EEXIST)
				ZPrint("Failed to create directory %s Error: %s\n", dest.c_str(), strerror(errno));
		}
	}

	void CreateDirectoryAndParents(StringRef directory)
	{
		char directoryPath[File::MaxPath];
		strcpy(directoryPath, directory.c_str());
		uint size = strlen(directoryPath);
		for (uint c = 0; c<size; ++c)
		{
			//When their is a directory separator
			if (directoryPath[c] == cDirectorySeparatorChar && c > 0)
			{
				//Null terminate
				directoryPath[c] = '\0';
				//Create directory
				CreateDirectory(directoryPath);
				//remove null terminator
				directoryPath[c] = cDirectorySeparatorChar;
			}
		}

		// Finally create the directory
		CreateDirectory(directoryPath);
	}

	int CheckFileTime(StringRef dest, StringRef source)
	{
		struct stat destStat;
		if (stat(dest.c_str(), &destStat) != 0)
			return -1;

		struct stat sourceStat;
		if (stat(source.c_str(), &sourceStat) != 0)
			return 1;

		if (destStat.st_mtime > sourceStat.st_mtime)
			return 1;

		if (destStat.st_mtime == sourceStat.st_mtime)
			return 0;
		else
			return -1;
	}

	time_t GetFileModifiedTime(StringRef file)
	{
		struct stat fileStat;
		if (stat(file.c_str(), &fileStat) != 0)
			return (time_t)fileStat.st_mtime;
		return 0;
	}

	int SetFileToCurrentTime(StringRef filename)
	{
		return VerifyPosix(utimensat(AT_FDCWD, filename.c_str(), NULL, 0), "Updating File Time");
	}

	u32 GetFileSize(StringRef fileName)
	{
		struct stat st;
		stat(fileName.c_str(), &st);
		return (uint)st.st_size;
	}

	bool FileExists(StringRef filePath)
	{
		struct stat st;
		return stat(filePath.c_str(), &st) != -1;
	}

	bool DirectoryExists(StringRef directoryPath)
	{
		struct stat st;
		if (stat(directoryPath.c_str(), &st) == 0 && S_ISDIR(st.st_mode))
			return true;
		return false;
	}

	// Return true if it is directory path and it exists
	bool IsDirectory(StringRef directoryPath)
	{
		struct stat st;
		if (stat(directoryPath.c_str(), &st) == 0 && S_ISDIR(st.st_mode))
			return true;
		return false;
	}

	bool FileWritable(StringRef filePath)
	{
		return access(filePath.c_str(), R_OK) == 0;
	}

	String UniqueFileId(StringRef fullpath)
	{
		char buffer[File::MaxPath] = { 0 };
		realpath(fullpath.c_str(), buffer);

		//on unix the path is unique
		return fullpath;
	}

	String GetWorkingDirectory()
	{
		char temp[File::MaxPath + 1];
		getcwd(temp, File::MaxPath);
		return temp;
	}

	void SetWorkingDirectory(String path)
	{
		chdir(path.c_str());
	}

	String GetUserLocalDirectory()
	{
		// Use the standard ~/.cache location
		char local[File::MaxPath + 1] = { 0 };
		StrCpy(local, File::MaxPath, getenv("HOME"));
		StrCat(local, File::MaxPath, "/.cache");
		return local;
	}

	String GetUserDocumentsDirectory()
	{
		return getenv("HOME");
	}

	String GetTemporaryDirectory()
	{
		return "/tmp";
	}

	String GetApplication()
	{
		return String();
	}

	String GetApplicationDirectory()
	{
		return String();
	}

	struct FileRangePrivateData
	{
		DIR* mDir;
		struct dirent* mEntry;
	};

	FileRange::FileRange(StringRef search)
	{
		ZeroConstructPrivateData(FileRangePrivateData);
		DIR* dir = opendir(search.c_str());
		if (dir)
		{
			self->mDir = dir;
			self->mEntry = readdir(dir);
		}
		else
		{
			self->mDir = NULL;
			self->mEntry = NULL;
		}
	}

	FileRange::~FileRange()
	{
		ZeroGetPrivateData(FileRangePrivateData);
		closedir(self->mDir);
	}

	bool FileRange::empty()
	{
		ZeroGetPrivateData(FileRangePrivateData);
		return self->mEntry == NULL;
	}

	cstr FileRange::front()
	{
		ZeroGetPrivateData(FileRangePrivateData);
		return self->mEntry->d_name;
	}

	void FileRange::popFront()
	{
		ZeroGetPrivateData(FileRangePrivateData);
		self->mEntry = readdir(self->mDir);

		//Get rid of "." and ".." directory results.
		if (!empty() && strcmp(front(), ".") == 0)
			popFront();

		if (!empty() && strcmp(front(), "..") == 0)
			popFront();
	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file FpControl.hpp
/// Implementation of the ScpeFpuExceptions, ScoplessFpuExceptions and
/// FpuControlSystem classes.
///
/// Authors: Joshua Davis
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <float.h>

namespace Zero
{

	///the mask is 0 in the generic system since we aren't running any fp exceptions.
	uint FpuControlSystem::DefaultMask = 0;
	///The system is not active because we're on some random platform
	bool FpuControlSystem::Active = false;

	ScopeFpuExceptionsEnabler::ScopeFpuExceptionsEnabler()
	{
	}

	ScopeFpuExceptionsEnabler::~ScopeFpuExceptionsEnabler()
	{
	}

	ScopeFpuExceptionsDisabler::ScopeFpuExceptionsDisabler()
	{
	}

	ScopeFpuExceptionsDisabler::~ScopeFpuExceptionsDisabler()
	{
	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.cpp
/// Generates the precompiled header file.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Process.cpp
///
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	Process::Process()
	{
	}

	Process::~Process()
	{
	}

	uint Process::ExecProcess(cstr debugName, cstr commandLine, TextStream* stream, bool showWindow)
	{
		String fullLine = String::Format("wine %s", commandLine);
		int returnCode = system(fullLine.c_str());
		if (returnCode != 0)
		{
			ZERO_DEBUG_BREAK;
		}
		return 0;
	}

	void Process::WriteToStdIn(cstr text, int size)
	{
	}

	void Process::Shutdown()
	{
	}

	void Process::WaitForClose()
	{
	}

	int Process::GetExitCode()
	{
		return 0;
	}

	OsInt Process::ReadThreadEntryPoint()
	{
		return 0;
	}

}

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Resolution.cpp
/// Resolution support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	Resolution GetDesktopResolution()
	{
		Resolution desktopRes;
		desktopRes.Width = 800;
		desktopRes.Height = 600;
		return desktopRes;
	}

	void Enumerate(Array<Resolution>& resolutions, int bitDepth, Resolution aspect)
	{

	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)

namespace Zero
{

	SocketAddress::SocketAddress()
	{
	}

	SocketAddress::~SocketAddress()
	{
	}

	void SocketAddress::InitializeInterNetwork(Status& status, StringParam host, int port)
	{
	}

	void SocketAddress::InitializeLocalInterNetwork4Any(Status& status, int port)
	{
	}

	void SocketAddress::InitializeLocalInterNetwork6Any(Status& status, int port)
	{
	}

	SocketAddressFamily::Enum SocketAddress::GetAddressFamily()
	{
		return SocketAddressFamily::Unix;
	}

	Socket::Socket()
	{
	}

	Socket::~Socket()
	{
	}

	int Socket::GetMaxConnectionBacklog()
	{
		return 0;
	}

	bool Socket::IsReceiveCloseError(int extendedErrorCode)
	{
		return false;
	}

	void Socket::NetworkByteOrderSwap(const byte* input, size_t size, byte* output)
	{
	}

	bool Socket::IsValid()
	{
		return false;
	}

	void Socket::Initialize(Status& status, SocketAddressFamily::Enum addressFamily, SocketType::Enum type, SocketProtocolType::Enum protocol)
	{
	}

	void Socket::Bind(Status& status, const SocketAddress& address)
	{
	}

	void Socket::Listen(Status& status, int backlog)
	{
	}

	void Socket::Accept(Status& status, Socket* socketOut, SocketAddress* addressOut)
	{
	}

	void Socket::Connect(Status& status, const SocketAddress& remoteAddress)
	{
	}

	void Socket::Close(Status& status)
	{
	}

	void Socket::Shutdown(Status& status, SocketIo::Enum io)
	{
	}

	int Socket::Send(Status& status, const byte* data, int length, SocketFlags::Enum flags)
	{
		return 0;
	}

	int Socket::SendTo(Status& status, const byte* data, int length, SocketFlags::Enum flags, const SocketAddress& to)
	{
		return 0;
	}

	int Socket::Receive(Status& status, byte* dataOut, int length, SocketFlags::Enum flags)
	{
		return 0;
	}

	int Socket::ReceiveFrom(Status& status, byte* dataOut, int length, SocketFlags::Enum flags, SocketAddress& from)
	{
		return 0;
	}

	bool Socket::Select(Status& status, SocketSelect::Enum selectMode, float timeoutSeconds)
	{
		return false;
	}

}

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.cpp
/// Declaration of the Thread class.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	const bool ThreadingEnabled = false;

	Thread::Thread()
	{
	}

	Thread::~Thread()
	{
	}

	bool Thread::IsValid()
	{
		return true;
	}

	bool Thread::Initialize(EntryFunction entry, void* instance, cstr threadName)
	{
		return true;
	}

	void Thread::Resume()
	{
	}

	void Thread::Suspend()
	{
	}

	void Thread::Close()
	{

	}

	OsInt Thread::WaitForCompletion()
	{
		return 0;
	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadSync.cpp
/// Implementation of Thread synchronization classes.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	ThreadLock::ThreadLock()
	{

	}

	ThreadLock::~ThreadLock()
	{

	}

	void ThreadLock::Lock()
	{

	}

	void ThreadLock::Unlock()
	{

	}

	OsEvent::OsEvent()
	{
	}

	OsEvent::~OsEvent()
	{
	}

	void OsEvent::Initialize(bool manualReset, bool startSignaled)
	{

	}

	void OsEvent::Close()
	{

	}

	void OsEvent::Signal()
	{

	}

	void OsEvent::Reset()
	{

	}

	void OsEvent::Wait()
	{

	}

	Semaphore::Semaphore()
	{

	}

	Semaphore::~Semaphore()
	{

	}

	void Semaphore::Increment()
	{

	}

	void Semaphore::Decrement()
	{

	}

	void Semaphore::Reset()
	{

	}

	void Semaphore::WaitAndDecrement()
	{

	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Utilties.cpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

namespace Zero
{

	u64 SecondToNanosecond = 1000000000;
	double NanosecondToSecond = 1.0 / double(SecondToNanosecond);

	u64 GetTimeNanosecond()
	{
		// Apple OSes do not implement 'clock_gettime'
#ifdef __APPLE__
		// https://developer.apple.com/library/mac/qa/qa1398/_index.html
		uint64_t time = mach_absolute_time();
		// 'AbsoluteTime' is guaranteed to be a 64 bit wide value, however it's a struct, not a primitive 64 bit value
		Nanoseconds nanoseconds = AbsoluteToNanoseconds(*(AbsoluteTime*)&time);
		return *(uint64_t *)&nanoseconds;
#else
		timespec time;
		clock_gettime(CLOCK_MONOTONIC, &time);
		return (u64(time.tv_sec) * SecondToNanosecond + time.tv_nsec);
#endif
	}

	Timer::Timer()
	{
		Reset();
	}

	Timer::~Timer()
	{
	}

	struct TimerPrivateData
	{
		Timer::TickType mStart;
		Timer::TickType mLast;
		Timer::TickType mCurrent;
	};

	void Timer::Reset()
	{
		ZeroGetPrivateData(TimerPrivateData);
		self->mStart = GetTimeNanosecond();
		self->mCurrent = self->mStart;
		self->mLast = self->mStart;
	}

	void Timer::Update()
	{
		ZeroGetPrivateData(TimerPrivateData);
		self->mLast = self->mCurrent;
		self->mCurrent = GetTimeNanosecond();
	}

	double Timer::Time() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		return double(self->mCurrent - self->mStart) * NanosecondToSecond;
	}

	double Timer::TimeDelta() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		return double(self->mCurrent - self->mLast) * NanosecondToSecond;
	}

	double Timer::UpdateAndGetTime()
	{
		Update();
		return Time();
	}

	double Timer::TimeNoUpdate() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		u64 current = GetTimeNanosecond();
		return double(current - self->mStart) * NanosecondToSecond;
	}

	Timer::TickType Timer::GetTickTime() const
	{
		ZeroGetPrivateData(TimerPrivateData);
		return self->mCurrent;
	}

	double Timer::TicksToSeconds(TickType ticks) const
	{
		return double(ticks) * NanosecondToSecond;
	}

}//namespace Zero

#endif

#if defined(PLATFORM_POSIX)
///////////////////////////////////////////////////////////////////////////////
///
/// \file Timer.cpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#include <unistd.h>
#include <pwd.h>

namespace Zero
{

	namespace Os
	{

		void Sleep(uint ms)
		{
			usleep(ms * 1000);
		}

		void DebugBreak()
		{
			__builtin_trap();
		}

		void SystemOpenFile(cstr file, uint verb, cstr workingDirectory)
		{
			if (workingDirectory)
				SetWorkingDirectory(workingDirectory);
			system(file);
		}

		String TranslateErrorCode(int errorCode)
		{
			return "None";
		}

		String GetEnvironmentalVariable(StringRef variable)
		{
			return getenv(variable.c_str());
		}

		bool IsDebuggerAttached()
		{
			return true;
		}

		void SystemOpenFile(cstr file, uint verb, cstr parameters, cstr workingDirectory)
		{

		}

		String UserName()
		{
			return getlogin();
		}

		// Get the computer name
		String ComputerName()
		{
			char hostname[1024];
			hostname[1023] = '\0';
			gethostname(hostname, 1023);
			return hostname;
		}

		u64 GetMacAddress()
		{
			return 0;
		}

		void SetTimerFrequency(uint ms)
		{
			// Not available on linux
		}

	}//End os

	u64 GenerateUniqueId64()
	{
		static u64 idGen = 0;
		++idGen;
		return idGen + rand();
	}

	void CheckClassMemory(cstr className, byte* classMemory)
	{

	}

	void FatalError(int exitCode)
	{
		exit(exitCode);
	}

}//namespace Zero

#endif
