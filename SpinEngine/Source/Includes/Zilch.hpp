/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Note: This header is typically used as a precompiled header

// Include protection
#pragma once
#ifndef ZILCH_COMMON_HPP
#define ZILCH_COMMON_HPP

// This needs to be included before anything else
// since it disables warnings and defines macros we use
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_GENERAL_HPP
#define ZILCH_GENERAL_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_LOCAL_BUILD_HPP
#define ZILCH_LOCAL_BUILD_HPP

// For the published build of zilch, we remove 'todo' statements as
// they are annoying (and are akin to warnings). For our own local
// build, we enable them by removing the below macro
#define ZilchTodo(text)

// End header protection
#endif

#ifdef _DEBUG
#pragma warning( disable : 4005 4244 )
#endif

namespace Zilch
{
  // Defines
  #ifndef ZilchLoop
    #define ZilchLoop for (;;)
  #endif

  // Don't allow copying of a type
  #define ZilchNoCopy(type)       \
    private:                      \
    type& operator=(const type&); \
    type(const type&);

  // Don't allow copying of a type
  #define ZilchNoDefaultConstructor(type) \
    private:                              \
    type();

  // Helper macros
  #define ZilchStringDeref(text) #text
  #define ZilchStringize(text) ZilchStringDeref(text)

  // Shows a todo message
  #ifndef ZilchTodo
    #define ZilchTodo(text) __pragma(message(__FILE__ "(" ZilchStringize(__LINE__) ") : Todo: " text))
  #endif

  // MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
  // MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
  // MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
  // MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
  // MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
  // MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
  // MSVC++ 7.0  _MSC_VER == 1300
  // MSVC++ 6.0  _MSC_VER == 1200
  // MSVC++ 5.0  _MSC_VER == 1100

  // Thread local storage is supported by everything but clang on Windows
  #if !(defined(__clang__) && (defined(_WIN32) || defined(WIN32)))
    #define ZilchSupportsThreadLocalStorage
  #endif

  // If we're running 0x features in gcc, or the C++ version is defined, or we're in VS2010 or later...
  #if defined(__GXX_EXPERIMENTAL_CXX0X__) ||  __cplusplus >= 201103L || _MSC_VER >= 1600
    #define ZilchSupportsDecltypeAuto
    #define ZilchSupportsNullptr
    #define ZilchSupportsStaticAssert
  #endif

  // This just changes how we do auto, theoretically the same (it's all wrapped in a macro anyways...)
  //#define ZilchUseDeclTypeForAuto

  // *************** Compiler Specific Warnings ***************

  // If we're on Clang or Gcc...
  #if defined(__clang__) || defined(__GNUC__)
    #if defined(__clang__)
      // Ignore unknown pragma warnings...
      #pragma clang diagnostic ignored "-Wunknown-pragmas"
    #else
      // Ignore unknown pragma warnings...
      #pragma GCC diagnostic ignored "-Wpragmas"
    #endif

    // We have many valid switch statements that don't handle all values
    #pragma GCC diagnostic ignored "-Wswitch"

    // We use offsetof, which is technically compiler specific and undefined, but works on all supported platforms
    #pragma GCC diagnostic ignored "-Winvalid-offsetof"

    // This should be investigated for a better method (generally it's for shoving values into void* user data)
    #pragma GCC diagnostic ignored "-Wint-to-pointer-cast"

    // When we force inline some functions, gcc has a very complicated way of determining if a function can be inlined or not
    // If it decides the function does not get inlined, and the function was actually implemented in the cpp (not the header, link time code-gen)
    // then it complains about the function being unused (which it's absolutely not, seems like a gcc bug)
    #pragma GCC diagnostic ignored "-Wunused-function"

    // We declare typedefs that may be useful for people using Zilch, but we don't use them ourselves
    #pragma GCC diagnostic ignored "-Wunused-local-typedefs"

  #endif

  // If we're on the Microsoft compiler (MSVC)...
  #ifdef _MSC_VER
    // We don't want to get warned about security
    #ifndef _CRT_SECURE_NO_WARNINGS
      #define _CRT_SECURE_NO_WARNINGS
    #endif

    // We don't consider unreferenced parameters to be an error
    #pragma warning(disable : 4100)

    // Unfortunately, local variable initialized but not referenced is actually a very
    // useful warning, however there are cases where we only initialize variables to be
    // used in debug checks, which this will complain / error in release
    // There are also other cases where we explicitly invoke destructors for class binding
    // and if the destructor is trivial, it complains that the self parameter is not used
    #pragma warning(disable : 4189)

    // We get a warning about an outer structure being padded due to inner members having alignment specifications
    // An example of this is using jmp_buf anywhere (such as in PerFrameData) especially with 64-bit compatability warnings
    #pragma warning(disable : 4324)

    // We really don't care about C++ initializing POD types to zero
    #pragma warning(disable : 4345)

    // Disable the 'this' in base initializer, since we use it to track owners
    #pragma warning(disable : 4355)

    // Ignore the warning about a non-standard extension for 'override'
    // It really is way too useful (both for documentation and error checking)
    #pragma warning(disable : 4481)

    // Disable the execption handling warning. We don't use exceptions in Zilch
    // because many console and embedded systems do not support them)
    #pragma warning(disable : 4530)

    // For virtual function binding we need to ignore warnings about no constructors
    // being generated, as well as warnings about a class not being able to be instantiated
    #pragma warning(disable : 4510)
    #pragma warning(disable : 4610)

    // Disable "Interaction between '_setjmp' and C++ object destruction is non-portable"
    // We use setjmp / longjmp for exception handling, and we make sure to properly handle
    // destruction of objects
    #pragma warning(disable : 4611)

    // Disable warnings about deprecated function calls (primarily WIN32)
    // It's nice to know these are deprecated, but we'll deal with them when they become actual errors
    #pragma warning(disable : 4996)

    // Static analysis complains about passing a 'char' into isspace and similar functions
    // For some weird reason it requires casting the char to an 'unsigned char', even though isspace is defined to take an int
    // This is well formed C and C++ code, static analysis is complaining about it
    #pragma warning(disable : 6330)

    // Static analysis also complains about the use of alloca, which has a well defined meaning
    // It recommends the usage of _malloca, a completely non-standard MSVC only function which functions EXACTLY the same in Release mode
    #pragma warning(disable : 6255)

    // Disabling the local declaration hiding, for now (this one is the most valid, but we have valid cases for it)
    #pragma warning(disable : 6246)

    // Static analysis also complains about 'Dereferencing NULL pointer' for every single instance we use in-place new, which is simply not correct
    #pragma warning(disable : 6011)

    // Comparing a constant to another constant (not caught by the W4 via templates) is considered bad by static analysis, even though
    // it completly makes sense and will be optimized out if it is in fact a constant
    #pragma warning(disable : 6326)

    // This particular warning complains about the dereferencing a null pointer because it implied
    // that a variable could be null (assigned to another variable, check that variable)
    // The entire warning is fundamentally flawed:
    //  Player* foundPlayer = nullptr;
    //  if (SomeCondition)
    //  {
    //    Player* globalPlayer = GrabGlobalPlayer();
    //    if (globalPlayer->IsAlive()) <--- Here it complains that 'globalPlayer' could be null, simply because of the below line
    //      foundPlayer = globalPlayer;
    //  }
    //  if (foundPlayer != nullptr) <--- It sees that 'foundPlayer' is being checked for null, and because foundPlayer
    //    ...                            is assigned from nearestPlayer, then it thinks 'globalPlayer' could be null
    #pragma warning(disable : 28182)

    // Standard examples (such as setting thread name) from Microsoft's own documentation cause the static analysis to complain
    // about __try and __catch (about continuing from the exception possibly causing an infinite loop, which it does not)
    #pragma warning(disable : 6312)
    #pragma warning(disable : 6322)

    // We don't care about using deprecated Windows code, we'll change it later if we care
    #pragma warning(disable : 28159)

    ZilchTodo("These must be fixed / examined");
    #pragma warning(disable : 6201)
    #pragma warning(disable : 6031)

    // These static analysis warnings are literally happening inside Microsoft's own 'wspiapi.h'
    #pragma warning(disable : 6101)
    #pragma warning(disable : 6102)
    #pragma warning(disable : 6387)
    #pragma warning(disable : 6386)
    #pragma warning(disable : 28196)

  #endif

  // *************** Compiler Specific Macros ***************

  // If we're on the Microsoft compiler...
  #ifdef _MSC_VER
    
    // When we want to declare a thread local variable
    // This must be used in the declaration (after static or extern if applicable)
    // and also in the cpp file before anything
    // Thread locals cannot be initialized
    #define ZilchThreadLocal __declspec(thread)

    // On some compilers we need to define static thread locals (as members of a class)
    // This macro will remove any of its contents for compilers that don't need it
    #define ZilchDefineStaticThreadLocal(StaticVariableDefinition) StaticVariableDefinition
    
    // Atttempts to trigger a breakpoint in the debugger
    #define ZilchDebugBreak() __debugbreak()

    // Converts a string to a double integer
    #define ZilchStrToDoubleInteger(CStr, Base) _strtoui64(CStr, nullptr, Base)

    // Forces a function to be inlined for optimization purposes
    #define ZilchForceInline __forceinline

    // Forces a function to not be inlined (only used to debug, and unfortunately to fix true linker bugs)
    #define ZilchNoInline __declspec(noinline)

  #else
    #ifndef override
      // We don't have access to the 'override' keyword
      #define override
    #endif
    
    // When we want to declare a thread local variable
    // This must be used in the declaration (after static or extern if applicable)
    // and also in the cpp file before anything
    // Thread locals cannot be initialized
    #ifdef ZilchSupportsThreadLocalStorage
      #define ZilchThreadLocal __thread
    #else
      #define ZilchThreadLocal
    #endif

    // On some compilers we still need to define static thread locals (as members of a class)
    // This macro will remove any of its contents for compilers that don't need it
    #define ZilchDefineStaticThreadLocal(StaticVariableDefinition)

    // Atttempts to trigger a breakpoint in the debugger
    #define ZilchDebugBreak()

    // Converts a string to a double integer
    #define ZilchStrToDoubleInteger(CStr, Base) strtoull(CStr, nullptr, Base)

    // Forces a function to be inlined for optimization purposes
    // There seems to be issues with __attribute__((always_inline)) wit GCC linking
    #define ZilchForceInline inline

    // Forces a function to not be inlined (only used to debug, and unfortunately to fix true linker bugs)
    #define ZilchNoInline

  #endif

  #ifdef ZilchSupportsDecltypeAuto
    // Most modern compilers support decltype...
    #define ZilchTypeOf(Expression) decltype(Expression)

    #ifdef ZilchUseDeclTypeForAuto

      template <typename T>
      class StripRef
      {
      public:
        typedef T Type;
      };

      template <typename T>
      class StripRef<T&>
      {
      public:
        typedef T Type;
      };

      // We can use decltype for auto, but the big issue is that normally auto requires you to specify
      // if it's a reference or not (&). The decltype always infers the reference, so we have to strip it
      #define ZilchAutoVal(VariableName, Expression) StripRef<decltype(Expression)>::Type VariableName = Expression;
      #define ZilchAutoRef(VariableName, Expression)          decltype(Expression)&       VariableName = Expression;

    #else
      // Infer the type of an expression and store within a variable
      // Used for some template situations where determining the expression's type is tedious
      #define ZilchAutoVal(VariableName, Expression) auto  VariableName = Expression;
      #define ZilchAutoRef(VariableName, Expression) auto& VariableName = Expression;
    #endif

  #else
    // A few really really bad/archaic compilers don't (hopefully they have typeof!)
    #define ZilchTypeOf(Expression) typeof(Expression)

    // Infer the type of an expression and store within a variable
    // Used for some template situations where determining the expression's type is tedious
    #define ZilchAutoVal(VariableName, Expression) typeof(Expression)  VariableName = Expression;
    #define ZilchAutoRef(VariableName, Expression) typeof(Expression)& VariableName = Expression;
  #endif

  // Visual Studio 2010's (and maybe other compilers) decltype has an issue with getting the type
  // of the address of a function template instantiation (decltype(Lerp<Real>) for instance).
  // This template and macro are a work around for doing this.
  template <typename T>
  T ZilchFunctionPointerPassThrough(T);
  #define ZilchTypeOfFunctionPointer(FunctionPointer)  ZilchTypeOf(ZilchFunctionPointerPassThrough(FunctionPointer))

  // If we support static assert (otherwise there's an alternative not as clear way)
  #ifdef ZilchSupportsStaticAssert
    #define ZilchStaticAssert(ConstantExpression, StringMessage, OldMessageName)  \
      static_assert(ConstantExpression, StringMessage)
  #else
    #define ZilchStaticAssert(ConstantExpression, StringMessage, OldMessageName)  \
      static const int OldMessageName = (sizeof(char[1 - 2 * !(ConstantExpression)]))
  #endif

  // Macro for figuring out the size of a fixed C-array
  #define ZilchCArrayCount(x) ((sizeof(x) / sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))

  // A class we use when we're either debugging or refactoring
  // This class attempts to act as a placeholder for any other class
  template <typename ToEmulate>
  class DebugPlaceholder
  {
  public:

    DebugPlaceholder()
    {
    }

    template <typename T>
    DebugPlaceholder(const T&)
    {
    }

    operator ToEmulate()
    {
      return ToEmulate();
    }

    template <typename T>
    T& operator=(T& value)
    {
      return value;
    }

    template <typename T>
    const T& operator=(const T& value)
    {
      return value;
    }

    template <typename T>
    bool operator==(const T&) const
    {
      return false;
    }

    template <typename T>
    bool operator!=(const T&) const
    {
      return false;
    }
  };
}

// End header protection
#endif

// C Standard Library
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
#include <ctime>
#include <limits>

// Zero includes
///////////////////////////////////////////////////////////////////////////////
///
/// \file String.hpp
/// Declaration of the Referenced counted string class.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file Hashing.hpp
/// HahsedContainer Container used to implement of HashMap and HashSet.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once
///////////////////////////////////////////////////////////////////////////////
///
/// \file ContainerCommon.hpp
/// Container Support.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once
///////////////////////////////////////////////////////////////////////////////
///
/// \file Standard.hpp
/// Include standard header files.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Compiler Errors / Warnings

#ifdef _MSC_VER
  #define ZNestedTemplate

  #ifndef _DEBUG
  #define _SECURE_SCL 0
  #endif

  // Enable these warnings by setting them to level 3
  // Enable warning function does not override any base class virtual member function
  // this is useful to catch renaming virtual functions
  #pragma warning(3: 4263)

  // Enable warning level 3 Conversion of an Enum to a integral type
  #pragma warning(3: 4239)

  // We don't care about 'behavior change - pod constructors'
  #pragma warning(disable: 4345)

  // Ignore the warning about placement-new for POD data
  #pragma warning(disable: 4345)

  // Constants in 'if' and 'while' are used for debug macros
  #pragma warning(disable: 4127)

  // Disable the warning 'this' in base initializer
  #pragma warning(disable: 4355)

  // We use the nameless struct/union extension and it is legal
  // on other compilers
  #pragma warning(disable: 4201)

  // Disable deprecation warnings
  #pragma warning(disable:4996)

#ifdef WIN64
  // Temporary 64-bit support (ignore size_t conversion warnings)
  #pragma warning(disable: 4244)
  #pragma warning(disable: 4267)
  #pragma warning(disable: 4309)
#endif

#else

  // gcc requires this keyword with a templated class that
  // returns another templated class inside of itself
  #define ZNestedTemplate template

  // Make override empty
  #define override
#endif

// A temporary non-thread safe buffer that is only used for counting the lengths of printfs
extern char gDiscardBuffer[2];

// These functions are specific to all compilers on Windows
#if defined(_WIN32) || defined(WIN32)
  #define VSPrintfCount(format, pargs, extraSize, resultSize) resultSize = _vscprintf(format, pargs) + extraSize
  #define SPrintfCount(format, ...) _scprintf(format, __VA_ARGS__)
#endif

// Printing Macros
#ifdef _MSC_VER

  #define VSPrintf(destination, bufferSizeBytes, format, args) \
    vsprintf_s(destination, bufferSizeBytes, format, args)

  #define SPrintf(destination, bufferSizeBytes, format, ...) \
    sprintf_s(destination, bufferSizeBytes, format, __VA_ARGS__)

  #define StrCat(destination, bufferSizeBytes, source) \
    strcat_s(destination, bufferSizeBytes, source)

  #define StrCpy(destination, bufferSizeBytes, source) \
    strcpy_s(destination, bufferSizeBytes, source)

  #define CStringCopy(dest, destSize, source, sourceSize) \
    strncpy_s(dest, (destSize), source, sourceSize);

#if _MSC_VER < 1800
  #define va_copy(dest, source) \
    dest = source;
#endif

#else

// If these functions weren't defined above, define them now
#ifndef VSPrintfCount
  #define VSPrintfCount(format, pargs, extraSize, resultSize)               \
  do                                                                        \
  {                                                                         \
    va_list sizeArgs;                                                       \
    va_copy(sizeArgs, pargs);                                               \
    resultSize = vsnprintf(gDiscardBuffer, 1, format, sizeArgs) + extraSize; \
  }                                                                         \
  while (false)

  #define SPrintfCount(format, ...) snprintf(gDiscardBuffer, 1, format, __VA_ARGS__)

#endif

  #define VSPrintf(destination, bufferSizeBytes, format, args) \
    vsnprintf(destination, bufferSizeBytes, format, args)

  #define SPrintf(destination, bufferSizeBytes, format, ...) \
    snprintf(destination, bufferSizeBytes, format, __VA_ARGS__)

  #define StrCat(destination, bufferSizeBytes, source) \
    strncat(destination, source, bufferSizeBytes)

  #define StrCpy(destination, bufferSizeBytes, source) \
    strncpy(destination, source, bufferSizeBytes)

  #define CStringCopy(dest, destSize, source, sourceSize) \
    strncpy(dest, source, sourceSize);
#endif

// Includes for alloca
// This behavior changes per platform rather than per compiler (Clang on Windows still uses malloc.h)
#if !defined(WIN64) &&  !defined(WIN32) && !defined(_WIN64) &&  !defined(_WIN32)
#include <alloca.h>
#elif defined(CAFE)
#include <alloca.h>
#else
#include <malloc.h>
#endif

#if defined(__GXX_EXPERIMENTAL_CXX0X) ||  __cplusplus >= 201103L || _MSC_VER >= 1600
  #define ZeroSupportsDecltypeAuto
  #define ZeroSupportsNullptr
  #define ZeroSupportsStaticAssert
#endif

#ifdef ZeroSupportsDecltypeAuto
#define TypeOf(type) decltype(type)
#else
#define TypeOf(type) typeof(type)
#endif

// Visual Studio 2010's (and maybe other compilers) decltype has an issue with getting the type
// of the address of a function template instantiation (decltype(Lerp<Real>) for instance).
// This template and macro are a work around for doing this.
template <typename T>
T FunctionPointerPassThrough(T);
#define TypeOfFunctionPointer(type) TypeOf(FunctionPointerPassThrough(type))

#if _MSC_VER
  #define ZeroHasTypeOf 0
  #if _MSC_VER >= 1600
    #define ZeroHasAuto 1
  #else 
    #define ZeroHasAuto 0
#endif
#else
  #define ZeroHasTypeOf 1
  #define ZeroHasAuto 0
#endif

#if ZeroHasAuto
  #define AutoDeclare(varName, expression) \
    auto varName = expression

  #define AutoDeclareReference(varName, expression) \
    auto& varName = expression
#else
  #define AutoDeclare(varName, expression) \
    TypeOf(expression) varName = expression

  #define AutoDeclareReference(varName, expression) \
    TypeOf(expression)& varName = expression
#endif

#ifdef _MSC_VER
#define SupportsMoveSemantics
#define SupportsStaticAsserts
#elif __cplusplus >= 201103L
#define SupportsMoveSemantics
#define SupportsStaticAsserts
#endif

#ifdef _MSC_VER
#define ZeroThreadLocal __declspec(thread)
#else
#define ZeroThreadLocal __thread
#endif

///////////////////////////////////////////////////////////////////////////////
///
/// \file Typedefs.hpp
/// Common typedefs used throughout the projects.
///
/// Authors: Benjamin Strukus
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

typedef signed    char    s8;
typedef unsigned  char    u8;
typedef unsigned  char    byte;
typedef signed    short   s16;
typedef unsigned  short   u16;
typedef signed    int     s32;
typedef unsigned  int     u32;
typedef unsigned  int     uint;
typedef float             f32;
typedef double            f64;
typedef const char*       cstr;
typedef signed long long  s64;
typedef unsigned long long u64;

///////////////////////////////////////////////////////////////////////////////
///
/// \file Diagnostic.hpp
/// Declaration of the basic debug diagnostic functions.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

/*

These macros are only for displaying information to developers. 
For informing a user of errors use the notification system.

Warn/WarnIf: Indicates an problem has occurred but execution will continue
             normally. The problem will be handled locally but may also have 
             to be handled by the caller. By default in a development build this 
             will trigger a debug break but execution can continue.
             Examples: Scripting Errors, File Not Found, Bad Sound Name, etc 

ReturnIf: Operates the same as Warn except that the it will cause the current 
          block to return with the provided parameter if expression if true. 
          Used as a shorthand instead of
          if(a) { Warn(a,"message") return errorCode; }

Error/ErrorIf: Indicates that a problem has occurred and if execution continues 
               it will put the program in a invalid state and most likely crash.
               The equivalent of assert this always triggers a break point expect
               in the final build where the program will crash.

Verify(): Runs the function and generates an error if the function returns non
          zero. When diagnostic disabled the function call will remain but the
          error code will be removed.
*/

#ifdef _MSC_VER
  #define ZERO_DEBUG_BREAK __debugbreak()
#else
  #define ZERO_DEBUG_BREAK
#endif

namespace Zero
{

//---------------------------------------------------------------- Error Signaler
class ErrorSignaler
{
public:

  enum SignalErrorType { Warning, Error, FileError };

  //--------------------------------------------------------------- Error Data
  struct ErrorData
  {
    int Line;
    cstr Expression;
    cstr File;
    cstr Message;
    SignalErrorType ErrorType;
  };

  //The error handler can display Ui, filter errors, or other processing
  //Return true to debug break.
  typedef bool (*ErrorHandler)(ErrorData& errorData);
  static void SetErrorHandler(ErrorHandler newHandler){activeErrorHandler = newHandler; }
  static ErrorHandler GetErrorHandler() { return activeErrorHandler; }
  
  static bool SignalError(SignalErrorType erroType, cstr exp, cstr file,
                          int line, cstr msg = 0, ...);
private:
  static ErrorHandler activeErrorHandler;
};

}//namespace Zero

#if !defined(ZERO_ENABLE_ERROR) 
#   if defined(_DEBUG)
#       define ZERO_ENABLE_ERROR 1
#   else
#       define ZERO_ENABLE_ERROR 0
#   endif
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1600
  #define StaticAssert(name, Expression, error) \
    static_assert(Expression, error)
#else
  #define StaticAssert(name, Expression, error) \
    static int name = (sizeof(char[1 - 2 * !(Expression)]))
#endif

static int gConditionalFalseConstant = 0;

#if ZERO_ENABLE_ERROR

#define UnusedParameter(param) param

#define WarnIf(Expression, ...) \
do { if((Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Warning,#Expression, __FILE__, __LINE__,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define ErrorIf(Expression, ...) \
  do { if((Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Error,#Expression, __FILE__, __LINE__,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define Assert(Expression, ...) \
do { if(!(Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Error,#Expression, __FILE__, __LINE__,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define Error(...)\
do { if(Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Error,"", __FILE__, __LINE__,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define Warn(...)\
do { if(Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::Warning,"", __FILE__, __LINE__,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalFalseConstant)

#define FileErrorIf(Expression, file, Line, ...) \
do { if((Expression) && Zero::ErrorSignaler::SignalError(Zero::ErrorSignaler::FileError,#Expression, file, Line,##__VA_ARGS__)) \
  ZERO_DEBUG_BREAK; } while(gConditionalConstant)

#define Verify(funccall) ErrorIf(funcall != 0);

#else

#define UnusedParameter(param)
#define WarnIf(...) ((void)0)
#define ErrorIf(...) ((void)0)
#define Assert(...) ((void)0)
#define Error(...) ((void)0)
#define Warn(...) ((void)0)
#define FileErrorIf(...) ((void)0)
#define Verify(funccall) funccall

#endif

#define ReturnIf(Expression , whatToReturn, ...) \
  do { if(Expression) {                          \
    WarnIf(Expression, __VA_ARGS__);             \
    return whatToReturn;                         \
  } } while(gConditionalFalseConstant)

#define ReturnFileErrorIf(Expression , whatToReturn , file , Line , ...)  \
  do { if(Expression) {                                                   \
    FileErrorIf(Expression, file , Line , __VA_ARGS__);                   \
    return whatToReturn;                                                  \
  } } while(gConditionalFalseConstant)

///////////////////////////////////////////////////////////////////////////////
///
/// \file Console.hpp
/// Declaration of the Console
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <stdarg.h>

namespace Zero
{

//Console Filtering
typedef unsigned int FilterType;
namespace Filter
{
enum Enum
{
  DefaultFilter     = 0x0001, //No filter provided
  UserFilter        = 0x0002, //Filter for object creation.
  ErrorFilter       = 0x0004, //Filter for all Error and warnings
  ResourceFilter    = 0x0008, //Filter for Resource Operations
  EngineFilter      = 0x0010, //Filter for Core Engine Operations
  ActiveFilter      = 0x0020, //Filter for debugging
  PerformanceFilter = 0x0040, //Filter for performance (Framerate, etc)
  PhysicsFilter     = 0x0080, //Filter for Physics
};
}//namespace Filter

//------------------------------------------------------------- Console Listener
//LogFilter Interface
class ConsoleListener
{
public:
  // ConsoleListener Interface

  // Print a null terminated message.
  virtual void Print(FilterType filterType, cstr message) = 0;
  // Flush out output (Called when crashing)
  virtual void Flush(){}
  // Auto remove on destructor
  virtual ~ConsoleListener();
};

//---------------------------------------------------------------------- Console
// The Console for debugging, diagnostic, and displaying engine status.
// Uses C Style output semantics.
// Example: DebugPrint("Finished loading Node %d\n", 56);
class Console
{
public:
  static void Print(Filter::Enum filter, cstr format, ...);
  static void PrintRaw(Filter::Enum filter, cstr data);
  static void Add(ConsoleListener* listener);
  static void Remove(ConsoleListener* lister);
  static void FlushAll();
private:
  static void PrintVa(Filter::Enum, cstr format, va_list va);
};

}//namespace Zero

//Enable print of debug messages to the console
#if !defined(ZERO_ENABLE_DEBUG_CONSOLE) 
#   if defined(_DEBUG)
#       define ZERO_ENABLE_DEBUG_CONSOLE 1
#   else
#       define ZERO_ENABLE_DEBUG_CONSOLE 0
#   endif
#endif

#define ZPrintFilter(filter, ...) ::Zero::Console::Print(filter, __VA_ARGS__)
#define ZPrint(...) ::Zero::Console::Print(Zero::Filter::DefaultFilter, __VA_ARGS__)

// Debug printing functions will only print in debug builds

#if ZERO_ENABLE_DEBUG_CONSOLE

#define DebugPrintFilter(filter, ...) ::Zero::Console::Print(filter, __VA_ARGS__)
#define DebugPrint(...) ::Zero::Console::Print(Zero::Filter::DefaultFilter, __VA_ARGS__)
#define DebugTrace(format, ...) ::Zero::Console::Print(Zero::Filter::DefaultFilter, "%s(%d) : " format , __FILE__ , __LINE__, __VA_ARGS__)

#else

#define DebugPrintFilter(...)  ((void)0)
#define DebugPrint(...) ((void)0)
#define DebugTrace(...) ((void)0)

#endif

///////////////////////////////////////////////////////////////////////////////
///
/// \file Misc.hpp
/// Miscellaneous functions.
///
/// Authors: 
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <stddef.h>
#include <string.h>
#include <time.h>
#include <limits.h>

namespace Zero
{

//Smaller of two is put in the top 32 bits.
u64 GetLexicographicId(u32 id1, u32 id2);
//Unpacks the pair id into the two ids. Id1 is the lower 32 bits.
void UnPackLexicographicId(u32& id1, u32& id2, u64 pairId);

template<typename RefType>
void SafeRelease(RefType& interfacePtr)
{
  if(interfacePtr)
    interfacePtr->Release();
  interfacePtr = NULL;
}

template<typename RefType>
void SafeDelete(RefType& objectPtr)
{
  if(objectPtr)
    delete objectPtr;
  objectPtr = NULL;
}

template<typename RefType>
void SafeDeleteArray(RefType& objectPtr)
{
  if(objectPtr)
    delete[] objectPtr;
  objectPtr = NULL;
}

template<typename type>
void SafeDestroy(type*& instance)
{
  if(instance)
    instance->Destroy();
  instance = NULL;
}

template<typename type>
void ZeroClassMemory(type& classRef)
{
  memset(&classRef, 0, sizeof(type));
}

typedef time_t TimeType;
const TimeType cTimeMax = LONG_MAX;

/// Test if the current machine is big or little endian
bool IsBigEndian();

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file NullPtr.hpp
///
/// Authors: Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#if defined(__GXX_EXPERIMENTAL_CXX0X__) ||  __cplusplus >= 201103L || _MSC_VER >= 1600

#include <cstddef>

// In the case we need to initialize thread locals and similar things to null, they must be considered a 'constant expression'
#define nullptr_constant nullptr

#else // CAFE and older versions of GCC / Clang

namespace std
{
// A class to serve as a proxy for nullptr when the compiler doesn't support it
class nullptr_t
{
public:
  // Convertible to any type of null non-member pointer
  template<class T>        
  operator T*() const
  {
    return NULL;
  }

  // Or any type of null member pointer
  template<class C, class T> 
  operator T C::*() const
  {
    return NULL;
  }

  // Make sure sizeof is correct
  void* Size;

private:
  // Make it so we can't take the address of this class
  void operator&() const;
};

// Technically the compiler should be fine with T* conversion everywhere above
// but GCC gets mad about comparing to member function pointers, so we added these:
template<class T> 
bool operator ==(T value, nullptr_t)
{
  return value == NULL;
}
template<class T> 
bool operator ==(nullptr_t, T value)
{
  return value == NULL;
}
template<class T> 
bool operator !=(T value, nullptr_t)
{
  return value != NULL;
}
template<class T> 
bool operator !=(nullptr_t, T value)
{
  return value != NULL;
}

}//namespace std

// Create an instance of the null pointer type
const std::nullptr_t nullptr = std::nullptr_t();

// In the case we need to initialize thread locals and similar things to null, they must be considered a 'constant expression'
#define nullptr_constant NULL

#endif

///////////////////////////////////////////////////////////////////////////////
///
/// \file TypeTraits.hpp
/// Type Traits for containers.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Zero
{

//TR1 integral constant
template<typename integerType, integerType ConstantValue>
struct integral_constant {
  static const integerType value = ConstantValue;
  typedef integerType value_type;
  typedef integral_constant<integerType, value> type;
};

template<typename integerType, integerType ConstantValue> 
const integerType integral_constant<integerType, ConstantValue>::value;

typedef integral_constant<bool, true>  true_type;
typedef integral_constant<bool, false> false_type;

template<typename T> struct is_pointer : public false_type {};
template<typename T> struct is_pointer<T*> : public true_type {};

template<typename T> struct is_reference : public false_type {};
template<typename T> struct is_reference<T&> : public true_type {};

template<typename T> struct is_integral : public false_type {};
template<> struct is_integral<int> : public true_type {};
template<> struct is_integral<unsigned int> : public true_type {};
template<> struct is_integral<unsigned long long> : public true_type {};
template<> struct is_integral<long long> : public true_type {};
template<> struct is_integral<unsigned long> : public true_type {};
template<> struct is_integral<long> : public true_type {};
template<> struct is_integral<unsigned short> : public true_type {};
template<> struct is_integral<short> : public true_type {};
template<> struct is_integral<unsigned char> : public true_type {};
template<> struct is_integral<char> : public true_type {};

template<typename T> struct is_floating_point : public false_type {};
template<> struct is_floating_point<float> : public true_type {};
template<> struct is_floating_point<double> : public true_type {};

template<typename T> 
struct is_pod : public integral_constant<bool, (is_integral<T>::value || is_floating_point<T>::value || is_pointer<T>::value ) > {};

template<typename T> struct has_trivial_constructor : public integral_constant<bool, is_pod<T>::value> {};
template<typename T> struct has_trivial_copy : public integral_constant<bool, is_pod<T>::value> {};
template<typename T> struct has_trivial_assign : public integral_constant<bool, is_pod<T>::value> {};
template<typename T> struct has_trivial_destructor : public integral_constant<bool, is_pod<T>::value> {};

template<typename T>
struct StandardTraits
{
  typedef is_pod<T> is_pod_;
  typedef has_trivial_constructor<T> has_trivial_constructor_;
  typedef has_trivial_copy<T> has_trivial_copy_;
  typedef has_trivial_assign<T> has_trivial_assign_;
  typedef has_trivial_destructor<T> has_trivial_destructor_;
};

struct PodOverride
{
  typedef true_type is_pod_;
  typedef true_type has_trivial_copy_;
  typedef true_type has_trivial_assign_;
  typedef true_type has_trivial_constructor_;
  typedef true_type has_trivial_destructor_;
};

#define ISPODTYPE(typeName) \
template<> struct is_pod<typeName> : public true_type {};

}//namespace zero

//For placement new
#include <new>
//For size_t
#include <stddef.h>
//For memmove, memcpy
#include <string.h>

namespace Zero
{

///Base class for containers that use allocators.
template<typename AllocatorType>
class AllocationContainer
{
public:
  typedef AllocatorType allocator_type;
  allocator_type& get_allocator(){return mAllocator;}
  void set_allocator(const allocator_type& allocator) { mAllocator = allocator; }
protected:
  allocator_type mAllocator;
};

///A Pair of objects.
template<typename type0, typename type1>
struct Pair
{
  typedef type0 first_type;
  typedef type1 second_type;
  typedef Pair<type0, type1> this_type;
  type0 first;
  type1 second;

  Pair(const type0& value0, const type1& value1)
    : first(value0), second(value1)
  {
  }

  Pair(const Pair& other)
    : first(other.first), second(other.second)
  {
  }

  Pair()
    : first(), second()
  {
  }

  void swap(Pair& right)
  {
    if(this != &right)
    {
      swap(first, right.first);
      swap(second, right.second);
    }
  }

  size_t Hash() const;

  friend inline bool operator == (const this_type& left, const this_type& right)
  {
    return left.first == right.first && left.second == right.second;
  }
};

template<typename type0, typename type1>
Pair<type0,type1> make_pair(const type0& first, const type1& second)
{
  return Pair<type0,type1>(first, second);
}

//Standard swap function
template<typename type> 
inline void Swap(type& a, type& b)
{
  type c(a);
  a = b;
  b = c;
}

template<typename type>
struct MoveOperator
{
  static inline void Move(type* dest, type* source)
  {
    //Use copy constructor
    new(dest) type(*source);
    //Destroy the original
    source->~type();
  }
};

template<typename first, typename second>
struct MoveOperator< Pair<first, second> >
{
  static inline void Move(Pair<first, second>* dest, 
                          Pair<first, second>* source)
  {
    MoveOperator<first>::Move(&dest->first, &source->first);
    MoveOperator<second>::Move(&dest->second, &source->second);
  }
};

//Move values from source array to new array
//using move
template<typename type>
inline void uninitialized_move(type* dest, type* source, size_t size, 
                               false_type /*ispod*/)
{
  type* destEnd = dest + size;
  while(dest != destEnd)
  {
    MoveOperator<type>::Move(dest, source);
    ++dest;
    ++source;
  }
}

template<typename type>
inline void uninitialized_move(type* dest, type* source, size_t size, 
                               true_type /*ispod*/)
{
  memmove(dest, source, sizeof(type)*size);
}

template<typename type>
inline void uninitialized_moveRev(type* dest, type* source, size_t size, 
                                  false_type /*ispod*/)
{
  type* destEnd = dest + size;
  type* sourceEnd = source + size;
  while(size != 0)
  {
    --destEnd;
    --sourceEnd;
    MoveOperator<type>::Move(destEnd, sourceEnd);
    --size;
  }
}

template<typename type>
inline void uninitialized_moveRev(type* dest, type* source, size_t size, 
                                  true_type /*ispod*/)
{
  memmove(dest, source, sizeof(type)*size);
}

template<typename type>
inline void uninitialized_copy(type* dest, type* source, size_t size, 
                               false_type /*ispod*/)
{
  type* destEnd = dest + size;
  while(dest != destEnd)
  {
    new(dest) type(*source);
    ++dest;
    ++source;
  }
}

template<typename type>
inline void uninitialized_copy(type* dest, type* source, size_t size, 
                               true_type /*ispod*/)
{
  memcpy(dest, source, sizeof(type)*size);
}

template<typename type, typename initType>
inline void constructWith(type* elem, const initType& source)
{
  new(elem) type(source);
}

template<typename type>
inline void construct(type* elem, false_type /*ispod*/)
{
  new(elem) type();
}

template<typename type>
inline void construct(type* /*elem*/, true_type /*ispod*/)
{
  //do nothing for pod
}

template<typename type>
inline void destroy(type* dest, false_type /*ispod*/)
{
  dest->~type();
}

template<typename type>
inline void destroy(type* /*dest*/, true_type /*ispod*/)
{
  //do nothing for pod types
}

template<typename type>
inline void uninitialized_fill(type* dest, size_t size, const type& source)
{
  type* destEnd = dest+size;
  while(dest!=destEnd)
  {
    new(dest) type(source);
    ++dest;
  }
}

template<typename type>
inline void uninitialized_fill(type* dest, size_t size, false_type /*ispod*/)
{
  type* destEnd = dest+size;
  while(dest!=destEnd)
  {
    new(dest) type();
    ++dest;
  }
}

template<typename type>
inline void uninitialized_fill(type* /*dest*/, size_t /*size*/, 
                               true_type /*ispod*/)
{
  //do nothing for pod types
}

template<typename type>
inline void destroyElements(type* begin, size_t size, false_type /*ispod*/)
{
  type* end = begin+size;
  while(begin!=end)
  {
    begin->~type();
    ++begin;
  }
}

template<typename type>
inline void destroyElements(type* /*begin*/, size_t /*size*/,
                            true_type /*ispod*/)
{
  //do nothing for pod types
}

//Forms a range with iterators.
template<typename containerType>
struct IteratorRange
{
  typedef typename containerType::iterator iterator;
  typedef typename containerType::reference reference;

  IteratorRange(iterator pbegin, iterator pend)
    : begin(pbegin) , end(pend)
  {
  }

  reference front() { return *begin; }
  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  bool empty() { return begin == end; }
  size_t length() { return end - begin; }
  iterator begin;
  iterator end;
};

//Forms a range with iterators.
template<typename iteratorType>
struct IteratorTypedRange
{
  typedef iteratorType iterator;
  typedef typename iteratorType::reference reference;

  IteratorTypedRange(iterator pbegin, iterator pend)
    : begin(pbegin), end(pend)
  {
  }

  reference front() { return *begin; }
  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  bool empty() { return begin == end; }
  size_t length() { return end - begin; }
  iterator begin;
  iterator end;
};

//Pointer Range. Forms a range between two pointers.
template<typename type>
struct PointerRange
{
  typedef const type* iterator;

  //Construct a range with two pointers.
  PointerRange(iterator pbegin, iterator pend)
    : begin(pbegin), end(pend)
  {
  }

  //Construct a range with a pointer and a size.
  PointerRange(iterator pbegin, size_t size)
    : begin(pbegin), end(pbegin + size)
  {
  }

  const type& front() { return *begin; }
  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  bool empty() { return begin == end; }
  size_t length() { return end - begin; }
  iterator begin;
  iterator end;
};

template<typename iteratorType>
IteratorTypedRange<iteratorType> BuildRange(iteratorType begin, 
                                            iteratorType end)
{
  return IteratorTypedRange<iteratorType>(begin, end);
}

template<typename elementType>
PointerRange<elementType> BuildRange(elementType* begin, elementType* end)
{
  return PointerRange<elementType>(begin, end);
}

template< typename type>
inline void DeleteOp(type* pointer) { delete pointer; }

template<typename keytype, typename type>
inline void DeleteOp(Pair<const keytype,type>& entry) { delete entry.second; }

template<typename keytype, typename type>
inline void DeleteOp(Pair<keytype,type>& entry) { delete entry.second; }

template<typename rangeType>
void DeleteObjectsIn(rangeType range)
{
  for(; !range.empty(); range.popFront())
  {
    DeleteOp(range.front());
  }
}

template<typename containerType>
void DeleteObjectsInContainer(containerType& container)
{
  DeleteObjectsIn(container.all());
  container.clear();
}

#ifdef DEBUG
  //Prevents an empty class from being the debug heap value.
  #define EmptyClass(className)       \
    byte SingleByte;                    \
    className():SingleByte(0){}         
#else
  #define EmptyClass(className)
#endif  

struct DataBlock
{
  DataBlock():Data(NULL), Size(0) {};
  DataBlock(byte* data, size_t size):Data(data), Size(size) {};
  operator bool(){return Data!=NULL;}
  byte* Data;
  size_t Size;
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Allocator.hpp
/// Declaration of the  Allocator interface and the Default Allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef UseMemoryGraph
#define UseMemoryGraph 1
#endif

#if UseMemoryGraph

///////////////////////////////////////////////////////////////////////////////
///
/// \file Graph.hpp
/// Declaration of the Memory Graph.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once
///////////////////////////////////////////////////////////////////////////////
///
/// \file Memory.hpp
/// 
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

typedef size_t MemCounterType;
typedef void* MemPtr;

MemPtr zAllocate(size_t numberOfBytes);
void zDeallocate(MemPtr);
MemPtr zStaticAllocate(size_t size);

#define UseStaticMemory()                                                \
  static void* operator new(size_t size){return zStaticAllocate(size);}  \
  static void operator delete(void* /*pMem*/, size_t /*size*/){}

#define OverloadedNew()                                             \
  static void* operator new(size_t size);                           \
  static void  operator delete(void* pMem, size_t size);            \
  static void* operator new (size_t size, void* ptr){return ptr;};  \
  static void  operator delete(void* mem, void* ptr){};

#define ImplementOverloadedNewWithAllocator(ClassName, AllocatorObj)                                 \
  void* ClassName::operator new(size_t size) { return AllocatorObj->Allocate(size); };               \
  void  ClassName::operator delete(void* pMem, size_t size) { AllocatorObj->Deallocate(pMem, size); }

}

///////////////////////////////////////////////////////////////////////////////
///
/// \file InList.hpp
/// Definition of the Intrusively linked list container.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

//For ptrdiff
#include <cstddef>

namespace Zero
{

const int ObjListPtrDebugValue = 0xFFFFDEAD;

#ifndef DEBUGLINKS
#if _DEBUG
#define DEBUGLINKS 1
#else
#define DEBUGLINKS 0
#endif
#endif

template<typename type>
struct Link
{
#if DEBUGLINKS
  Link() : Next((type*)ObjListPtrDebugValue) , Prev((type*)ObjListPtrDebugValue) {};
#endif
  type* Next;
  type* Prev;
};

#ifdef _MSC_VER
///Intrusive is used for debugging in Visual Studio
#define IntrusiveLink(objectType, linkName) \
union{ \
  struct{Link<objectType> linkName;}; \
  struct{objectType* Next; objectType* Prev;}; \
};
#else
#define IntrusiveLink(objectType, linkName) \
  Link<objectType> linkName;
#endif

class LinkBase
{
public:
  IntrusiveLink(LinkBase, link);
};

template<typename Parent, typename Member>
inline ptrdiff_t PointerToMemberOffset(const Member Parent::* ptrToMember)
{
  return *(unsigned int*)(void*)&ptrToMember;
}

typedef const char * const cstrc;

cstrc cBadRemoveError = "Prev object next pointer does not match current object."
          "Most likely the prev object has been deleted or improperly removed.";
cstrc cBadLinkInsertError = "Link value is not set to debug value. "
"Probably a double insert or not yet removed from another list.";

cstrc cBadRemovedAlready = "Object has already been erased or was never added.";

///Intrusively linked list container. 
///Does not own the objects in contains (they are implicitly pointers)
///Objects can link and unlink without using the container.
template<typename type, typename refType, Link<type> type::* PtrToMember = &type::link>
class BaseInList
{
public:
  //Should InList be value type or pointer to value typed?
  //pointer to value type make the interface the same as vector<type*>
  //value_typed make the iterator act just like a pointer which is useful.
  typedef type value_type;
  typedef type* pointer;

  typedef type& reference;
  typedef const type* const_pointer;
  typedef const type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type; 
  typedef BaseInList<type, refType, PtrToMember> this_type;

  typedef refType& sub_reference;

  BaseInList()
  {
    SetEmpty();
  }

  ~BaseInList()
  {
    //ObjList does not own the object it contains so this is a no op
  }

  class range
  {
  public:
    typedef refType value_type;

    ///Default range is an empty range. Can only be checked for empty.
    range()
      : begin(NULL) , end(NULL)
    {
    }

    range(pointer pbegin, pointer pend)
      : begin(pbegin) , end(pend)
    {
    }

    sub_reference front(){return *static_cast<refType*>(begin);}
    sub_reference back(){return *static_cast<refType*>(Prev(end));}

    void popFront()
    {
      ErrorIf(empty(),"Popped empty range.");
      begin = Next(begin);
    }

    void popBack()
    {
      ErrorIf(empty(),"Popped empty range.");
      end = Prev(end);
    }

    bool empty(){return begin==end;}

    void spliceFront(pointer dest)
    {
      begin = splice(dest, begin);
    }

    pointer begin;
    pointer end;
  };

  range all()
  {
    return range(Next(GetHeader()), GetHeader());
  }

  class iterator
  {
  public:
    friend class BaseInList;
    iterator(){};
    iterator(pointer ptr) : mPtr(ptr) {}
    void operator--(){mPtr = Prev(mPtr);}
    void operator++(){mPtr = Next(mPtr);}
    sub_reference front(){return *static_cast<refType*>(mPtr);}
    refType* operator->(){return static_cast<refType*>(mPtr);}
    refType* operator*(){return static_cast<refType*>(mPtr);}
    bool operator==(const iterator& it){return mPtr == it.mPtr;}
    bool operator!=(const iterator& it){return mPtr != it.mPtr;}
    operator bool(){return mPtr!=NULL;}
    operator pointer(){return mPtr;}
  private:
    pointer mPtr;
  };

  iterator begin(){return iterator(Next(GetHeader()));};
  iterator end(){return iterator(GetHeader());}
  iterator rbegin(){return iterator(Prev(GetHeader()));};
  //End is the same as forward because of sentinel node)
  iterator rend(){return iterator(GetHeader());}

  ///True if the list does not contain any nodes.
  bool empty()
  {
    return header.Next == GetHeader();
  }

  static inline bool VerifyUnlinked(pointer element)
  {
#if DEBUGLINKS
    pointer prev = Prev(element);
    pointer next = Next(element);
    if(prev == (type*)ObjListPtrDebugValue && next == (pointer)ObjListPtrDebugValue)
      return true;
    else
      return false;
#endif
    return true;
  }

  static inline iterator Unlink(pointer element)
  {
    pointer prev = Prev(element);
    pointer next = Next(element);

#if DEBUGLINKS
    ErrorIf(prev == (pointer)ObjListPtrDebugValue, cBadRemovedAlready);
    ErrorIf(next == (pointer)ObjListPtrDebugValue, cBadRemovedAlready);
#endif

    ErrorIf(Next(prev) != element, cBadLinkInsertError);
    ErrorIf(Prev(next) != element, cBadLinkInsertError);

    Next(prev) = next;
    Prev(next) = prev;

#if DEBUGLINKS
    Prev(element) = (pointer)ObjListPtrDebugValue;
    Next(element) = (pointer)ObjListPtrDebugValue;
#endif
    return next;
  }

  ///Inserts object in list BEFORE where.
  void insert_before(pointer where, pointer obj)
  {
    insert(where, obj);
  }

  ///Inserts object in list BEFORE where.
  void insert(pointer where, pointer obj)
  {

#if DEBUGLINKS
    ErrorIf(Next(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
    ErrorIf(Prev(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
#endif

    Next(obj) = where;
    Prev(obj) = Prev(where);
    Next(Prev(where)) = obj;
    Prev(where) = obj;
  }

  ///Inserts object in list after where.
  void insert_after(pointer where, pointer obj)
  {
#if DEBUGLINKS
    ErrorIf(Next(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
    ErrorIf(Prev(obj) != (type*)ObjListPtrDebugValue, cBadLinkInsertError);
#endif

    Next(obj) = Next(where);
    Prev(obj) = where;
    Prev(Next(where)) = obj;
    Next(where) = obj;
  }

  ///Adds the object to the end of the list.
  void push_back(pointer obj)
  {
    pointer header = GetHeader();
    insert(header, obj);
  };

  void pop_back()
  {
    Unlink(&back());
  };

  ///Adds the object to the beginning of the list
  void push_front(pointer obj)
  {
    insert_after(GetHeader(), obj);
  };

  void pop_front()
  {
    Unlink(&front());
  };

  ///Removes all the objects from the list. It will
  ///unlink the individual objects internal pointers
  ///only in debug mode.
  void clear()
  {
#if DEBUGLINKS
    iterator it = begin();
    while(it != end())
    {
      it = erase(it);
    }
#endif
    SetEmpty();
  };

  sub_reference front()
  {
    return *static_cast<refType*>(Next(GetHeader()));
  }

  sub_reference back()
  {
    return *static_cast<refType*>(Prev(GetHeader()));
  }

  //Swaps one list elements with another this also must
  //fix the prev and next pointers of the first and
  //last objects located in the list
  void swap(this_type& other)
  {
    Swap(header.Next, other.header.Next);
    Swap(header.Prev, other.header.Prev);

    //If the list contained pointers fix them
    if(header.Next != other.GetHeader())
    {
      Prev(header.Next) = GetHeader();
      Next(header.Prev) = GetHeader();
    }
    else
    {
      SetEmpty();
    }

    if(other.header.Next != GetHeader())
    {
      Prev(other.header.Next) = other.GetHeader();
      Next(other.header.Prev) = other.GetHeader();
    }
    else
    {
      other.SetEmpty();
    }
  }

  ///Unlinks the object from the list. Does not destroy it.
  //returns the next item in the list.
  iterator erase(iterator it)
  {
    return Unlink(it);
  }

  iterator eraseAndGetPrev(iterator it)
  {
    iterator prev = Prev(it);
    erase(it);
    return prev;
  }

  //Function for iterating over the list when performing destructive
  //operations (operations that would break the next pointer) such
  //as erase and delete
  template<typename unaryFunction>
  void safeForEach(iterator begin, iterator end, unaryFunction op)
  {
    while(begin != end)
    {
      iterator next = Next(begin);
      op(begin);
      begin = next;
    }
  }

  void erase(range eraseRange)
  {
    iterator begin = eraseRange.begin;
    iterator end = eraseRange.end;
    while(begin != end)
      begin = erase(begin);
  }

  ///Splices the range with the provided 
  ///into the list BEFORE where.
  static void splice(iterator where, range right)
  {
    ErrorIf(right.empty(), "Cannot splice and empty range.");

    Next(Prev(right.begin)) = right.end;
    Next(Prev(right.end)) = where;
    Next(Prev(where)) = right.begin;
    pointer prevNode = Prev(where);
    Prev(where) = Prev(right.end);
    Prev(right.end) = Prev(right.begin);
    Prev(right.begin) = prevNode;
  }

  ///Splices a single object from 'from'
  static iterator splice(iterator where, iterator from)
  {
    pointer next = Next(from);
    splice(where, range(from, next));
    return next;
  }

  //Splices entire list leaving right empty
  void splice(iterator where, this_type& right)
  {
    splice(where, right.all());
  }

  template<typename Comparer>
  void merge(this_type& right, Comparer comparer)
  {
    range leftR = all();
    range rightR = right.all();

    while(!leftR.empty() && !rightR.empty())
    {
      if(comparer(rightR.front(), leftR.front()))
      {
        //right is 'greater' than left
        //move a right node into list
        rightR.spliceFront(leftR.begin);
      }
      else
      {
        leftR.popFront();
      }
    }

    if(!rightR.empty())
      splice(leftR.begin, rightR);
  }

  template<typename Comparer>
  void sort(Comparer comparer)
  {
    //If there is more than two nodes sort the list
    if(header.Next != header.Prev)
    {
      const size_t cMaxBins = 25;
      this_type temp;
      this_type bins[cMaxBins+1];
      size_t maxBin = 0;

      while(!empty())
      {
        //Move a single elements onto the temp list
        temp.splice(temp.begin() , range(begin(), Next(begin())));

        size_t curBin = 0;
        for(; curBin < maxBin && !bins[curBin].empty();++curBin)
        {
          bins[curBin].merge(temp, comparer);
          bins[curBin].swap(temp);
        }

        if(curBin == cMaxBins)
          bins[curBin-1].merge(temp, comparer);
        else
        {
          bins[curBin].swap(temp);
          if(curBin == maxBin)
            ++maxBin;
        }
      }

      //All elements are now in bins merge all bins together
      for(size_t mergeBin=1; mergeBin<maxBin; ++mergeBin)
      {
        //Merge previous into current bin
        bins[mergeBin].merge(bins[mergeBin-1], comparer);
      }

      //move back to list
      splice(begin(), bins[maxBin-1]);

    }

  }

  template<typename Comparer>
  void insert_sorted(iterator where, pointer valueInInsert, Comparer comparer)
  {
    while(where!= end())
    {
      if(comparer(*valueInInsert, *where))
        break;
      ++where;
    }
    insert(where, valueInInsert);
  }

  void SetEmpty()
  {
    header.Next = GetHeader();
    header.Prev = GetHeader();
  }

  inline static pointer& Next(pointer obj){ return ToLink(obj).Next; }
  inline static pointer& Prev(pointer obj){ return ToLink(obj).Prev; }
  
  iterator NextWrap(iterator iter)
  { 
    // Increment the iterator
    iterator i = iter;
    ++i;

    // If it's the end, increment passed the sentinel
    if(i == end())
      ++i;

    return i;
  }

  iterator PrevWrap(iterator iter)
  { 
    // Decrement the iterator
    iterator i = iter;
    --i;

    // If it's the end, decrement passed the sentinel
    if(i == end())
      --i;

    return i;
  }

protected:

  //InList is not copyable (not really a valid operation)
  BaseInList(const BaseInList&){}
  void operator=(const BaseInList&){}

  inline static pointer ToNode(Link<type>& link)
  {return (pointer)((unsigned char*)&link - PointerToMemberOffset(PtrToMember));}
  inline static Link<type>& ToLink(pointer obj)
  {return obj->*PtrToMember; }

  pointer GetHeader(){return ToNode(header);}
  Link<type> header;

};

template<typename type, Link<type> type::* PtrToMember = &type::link>
class InList : public BaseInList<type, type, PtrToMember>
{
public:

  InList()
  {

  }

private:

  //InList is not copyable (not really a valid operation)
  InList(const InList&){}
  void operator=(const InList&){}
};

template<typename type, typename baseLinkType = LinkBase>
class InListBaseLink : public BaseInList<baseLinkType, type, &baseLinkType::link>
{
public:
  InListBaseLink()
  {

  }

private:

  //InList is not copyable (not really a valid operation)
  InListBaseLink(const InListBaseLink&){}
  void operator=(const InListBaseLink&){}
};

template<typename type, Link<type> type::* PtrToMember>
void EraseAndDelete(type* element)
{
  InList<type, PtrToMember>::Unlink(element);
  delete element;
}

//Erase helper  function
template<typename type, Link<type> type::* PtrToMember>
void DeleteObjectsIn(InList<type, PtrToMember>& container)
{
  container.safeForEach(container.begin(), container.end(), EraseAndDelete<type,PtrToMember>);
}

template<typename type, Link<type> type::* PtrToMember>
void OnlyDeleteObjectIn(InList<type, PtrToMember>& container)
{
  container.safeForEach(container.begin(), container.end(), DeleteOp<type>);
}

template<typename type, typename basetype>
void EraseAndDeleteBase(basetype* element)
{
  InListBaseLink<type, basetype>::Unlink(element);
  delete static_cast<type*>(element);
}

template<typename type, typename baseLinkType>
void DeleteObjectsIn(InListBaseLink<type, baseLinkType>& container)
{
  container.safeForEach(container.begin(), container.end(), EraseAndDeleteBase<type, baseLinkType>);
}

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file FixedString.hpp
/// Declaration of FixedArray, FixedString, and String Range.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string.h>
#include <ctype.h>

namespace Zero
{

template<typename type, size_t maxSize>
class FixedArray
{
public:
  typedef type value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef FixedArray<type, maxSize> this_type;
  typedef PointerRange<type> range;

  explicit FixedArray()
    : mSize(0)
  {}

  explicit FixedArray(size_type size)
    : mSize(size)
  {}

  FixedArray(pointer data, size_type size)
    : mSize(size)
  {
    if(mSize > maxSize) mSize = maxSize;
    uninitialized_copy(mData, data, mSize, true_type());
  }

  range all() { return range(mData, mSize); }
  bool empty()const { return mSize == 0; }
  const_pointer data() const { return mData; }
  size_type size() const { return mSize; }

  reference front()
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }

  const_reference front() const
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }

  reference back()
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }

  const_reference back() const
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }

  void push_back(type& element)
  {
    ErrorIf(mSize>=maxSize, "Array at max size");
    mData[mSize] = element;
    ++mSize;
  }

  type& push_back()
  {
    ErrorIf(mSize>=maxSize, "Array at max size");
    ++mSize;
    return *(mData+(mSize-1));
  }

  //Removes the last element in the array.
  void pop_back()
  {
    ErrorIf(mSize == 0,"Empty array, can not pop back element.");
    --mSize;
  }

  void eraseIndex(uint index)
  {
    ErrorIf(index>mSize, "Index out of bounds.");
    //Shift over values
    uint lastValid = mSize-1;
    for(uint i=index;index<lastValid;++i)
      mData[i] = mData[i+1];
    //decrement size
    --mSize;
  }

  //simple erase value
  void erase_value(type& value)
  {
    for(uint i=0;i<mSize;++i)
    {
      if(mData[i] == value)
      {
        //value found remove it
        eraseIndex(i);
        return;
      }
    }
  }

protected:
  type mData[maxSize];
  size_type mSize;
};

const char* const cEmpty = "";

class StringRange
{
public:
  typedef char value_type;
  typedef const char* iterator;

  static const size_t InvalidIndex = (uint)-1;

  StringRange()
    : begin(cEmpty), end(cEmpty)
  {
  }

  StringRange(iterator cstring)
  {
    begin = cstring;
    end = cstring + strlen(begin);
  }

  StringRange(iterator pbegin, iterator pend)
    : begin(pbegin), end(pend)
  {
  }

  StringRange(iterator pbegin, size_t len)
    : begin(pbegin), end(pbegin + len)
  {
  }

  const char& front() const
  {
    return *begin;
  }

  const char& back() const
  {
    return *(end - 1);
  }

  void popFront()
  {
    ErrorIf(empty(), "Popped empty range.");
    ++begin;
  }

  void popFront(size_t n)
  {
    ErrorIf(size() < n, "Popped too many elements.");
    begin+=n;
  }

  void popBack()
  {
    ErrorIf(empty(), "Popped empty range.");
    --end;
  }

  bool contains(iterator pos)
  {
    return pos >= begin && pos < end;
  }

  bool operator==(const StringRange& right) const
  {
    return size() == right.size() &&
           strncmp(begin, right.begin, size()) == 0;
  }

  bool operator<(const StringRange& right) const
  {
    size_t min = size() < right.size() ? size() : right.size();
    int result = strncmp(begin, right.begin, min);
    if (result == 0)
      return size() < right.size();
    else
      return result < 0;
  }

  bool operator==(char c) const
  {
    ErrorIf(empty(), "No elements in range.");
    return *begin == c;
  }

  bool operator!=(char c) const
  {
    ErrorIf(empty(), "No elements in range.");
    return *begin != c;
  }

  char operator[](size_t index)
  {
    ErrorIf(index >= size(), "Invalid index out of range.");
    return begin[index];
  }

  uint FindFirstOf(byte value)
  {
    for (uint i = 0; i < size(); ++i)
    {
      if (begin[i] == value)
        return i;
    }

    return InvalidIndex;
  }

  uint FindFirstOf(const StringRange& value) const
  {
    size_t rangeSize = size();
    size_t valueSize = value.size();

    if (!valueSize || valueSize > rangeSize)
      return InvalidIndex;

    for (uint i = 0; i <= rangeSize - valueSize; ++i)
    {
      uint j;
      for (j = 0; j < valueSize; ++j)
      {
        if (begin[i + j] != value.begin[j])
          break;
      }

      if (j == valueSize)
        return i;
    }

    return InvalidIndex;
  }

  uint FindLastOf(byte value)
  {
    if(size() == 0)
      return InvalidIndex;

    size_t last = size() - 1;

    for (size_t i = 0; i <= last; ++i)
    {
      if (begin[last - i] == value)
        return last - i;
    }

    return InvalidIndex;
  }

  uint FindLastOf(const StringRange& value)
  {
    size_t rangeSize = size();
    size_t valueSize = value.size();

    if (!valueSize || valueSize > rangeSize)
      return InvalidIndex;

    size_t last = rangeSize - valueSize;

    for (size_t i = 0; i <= last; ++i)
    {
      size_t j;
      for (j = 0; j < valueSize; ++j)
      {
        if (begin[last - i + j] != value.begin[j])
          break;
      }

      if (j == valueSize)
        return last - i;
    }

    return InvalidIndex;
  }

  uint FindFirstNonWhitespaceCharIndex() const
  {
    for (uint i = 0; i < size(); ++i)
    {
      if (!isspace(begin[i]))
        return i;
    }

    return InvalidIndex;
  }

  uint FindLastNonWhitespaceCharIndex() const
  {
    size_t last = size() - 1;

    for (size_t i = 0; i <= last; ++i)
    {
      if (!isspace(begin[last - i]))
        return last - i;
    }

    return InvalidIndex;
  }

  value_type FindFirstNonWhitespaceChar() const
  {
    uint i = FindFirstNonWhitespaceCharIndex();
    if (i != InvalidIndex)
      return begin[i];
    else
      return '\0';
  }

  value_type FindLastNonWhitespaceChar() const
  {
    uint i = FindLastNonWhitespaceCharIndex();
    if (i != InvalidIndex)
      return begin[i];
    else
      return '\0';
  }

  StringRange Trim()
  {
    uint startIndex = FindFirstNonWhitespaceCharIndex();
    if(startIndex == InvalidIndex)
      return StringRange();

    uint endIndex = FindLastNonWhitespaceCharIndex();

    return sub_string(startIndex, endIndex - startIndex + 1);
  }

  bool Contains(const StringRange& value) const
  {
    uint index = FindFirstOf(value);

    return index != InvalidIndex;
  }

  bool IsAllUpper() const
  {
    for (uint i = 0; i < size(); ++i)
    {
      if (!isupper(begin[i]))
        return false;
    }

    return true;
  }

  bool IsAllWhitespace() const
  {
    for (uint i = 0; i < size(); ++i)
    {
      if (!isspace(begin[i]))
        return false;
    }

    return true;
  }

  StringRange sub_string_unsafe(size_t offset, size_t length) const
  {
    return StringRange(begin + offset, length);
  }

  StringRange sub_string(size_t offset, size_t length) const
  {
    iterator b = begin + offset;

    if (b > end)
    {
      b = end;
    }
    else if (b < begin)
    {
      b = begin;
    }

    iterator e = b + length;

    if (e > end)
    {
      e = end;
    }
    else if (e < begin)
    {
      e = begin;
    }

    if (e < b)
    {
      e = b;
    }

    return StringRange(b, e);
  }

  iterator data() const { return begin; }
  bool empty() const { return begin == end; }
  size_t size() const { return end - begin; }
  size_t length() const { return end - begin; }
  iterator begin;
  iterator end;
};

template<size_t maxSize>
class FixedString : public FixedArray<char, maxSize>
{
public:
  typedef FixedArray<char, maxSize> base_type;
  typedef FixedString<maxSize> this_type;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename base_type::size_type size_type;
  
  typedef StringRange range;
  range all()
  { 
    return StringRange(this->mData, this->mSize); 
  }

  FixedString()
    : base_type(0)
  {
    memset(this->mData, 0, maxSize);
  }

  explicit FixedString(const_pointer cstring)
  {
    assign(cstring, strlen(cstring));
  }

  explicit FixedString(range r)
  {
    assign(r.data(), r.length());
  }

  template<size_t otherSize>
  explicit FixedString(const FixedString<otherSize>& fstring)
  {
    assign(fstring.data(), fstring.size());
  }

  void operator=(const_pointer cstring)
  {
    assign(cstring, strlen(cstring));
  }

  void operator=(range r)
  {
    assign(r.data(), r.length());
  }

  void assign(const_pointer cstring, size_type size)
  {
    memset(this->mData, 0, maxSize);

    if (size > maxSize - 1)
    {
      Error("String is not large enough for range.");
      size = maxSize - 1;
    }
    
    this->mSize = size;
    //need room for null terminator
    if(this->mSize > (maxSize - 1))
      this->mSize = maxSize - 1;

    memcpy(this->mData, cstring, this->mSize);
    this->mData[this->mSize] = '\0';
  }

  template<size_t otherSize>
  friend inline bool operator==(const this_type& left,
                                const FixedString<otherSize>& right)
  {
    return strcmp(left.data(), right.data()) == 0;
  }

  template<size_t otherSize>
  friend inline bool operator<(const this_type& left, 
                               const FixedString<otherSize>& right)
  {
    return strcmp(left.data(), right.data()) < 0;
  }

  const_pointer c_str()const{return this->mData;}
};

template<size_t s>
inline bool operator==(const FixedString<s>& left, cstr right)
{
  return strcmp(left.data(), right) == 0;
}

template<size_t s>
inline bool operator!=(const FixedString<s>& left, cstr right)
{
  return strcmp(left.data(), right) != 0;
}

//String range vs other string types
template<typename stringType>
inline bool operator==(const stringType& left, const StringRange& right)
{
  return left.size() == right.size() && 
         strncmp(left.data(), right.data(), right.size()) == 0;
}

template<typename stringType>
inline bool operator==(const StringRange& left, const stringType& right)
{
  return left.size() == right.size() && 
         strncmp(left.data(), right.data(), left.size()) == 0;
}

template<typename stringType>
inline bool operator<(const stringType& left, const StringRange& right)
{
  return strncmp(left.data(), right.data(), right.size()) < 0;
}

template<typename stringType>
inline bool operator<(const StringRange& left, const stringType& right)
{
  return strncmp(left.data(), right.data(), left.size()) < 0;
}

//string range vs cstr
inline bool operator==(const StringRange& left, cstr right)
{
  return left.size() == strlen(right) && 
         strncmp(left.data(), right, left.size()) == 0;
}

inline bool operator!=(const StringRange& left, cstr right)
{
  return !(left == right);
}

inline bool operator==(cstr left, const StringRange& right)
{
  return strlen(left) == right.size() && 
         strncmp(left, right.data(), right.size()) == 0;
}

inline bool operator<(const StringRange& left, cstr right)
{
  return strncmp(left.data(), right, left.size()) < 0;
}

inline bool operator<(cstr left, const StringRange& right)
{
  return strncmp(left, right.data(), right.size()) < 0;
}

}//namespace Zero

namespace Zero
{

namespace Memory
{

struct Stats
{
  enum StatFlags
  {
    ShowActive     = 1,
    ShowDedicated  = 2,
    ShowPeak       = 4,
    ShowBytes      = 8,
    ShowTotal      = 16,
    ShowLocal      = 32,
    ShowCount      = 64,
  };

  MemCounterType Allocations;
  MemCounterType Active;
  MemCounterType BytesAllocated;
  MemCounterType BytesDedicated;
  MemCounterType PeakAllocated;

  Stats();

  template<typename Vistor>
  void Visit(Vistor& vistor, size_t flags);
  void Accumulate(const Stats& right);
};

///Base Memory graph node. All allocators are derived from this class for
///runtime memory statics collection and debugging. Class provides a graph
///structure for hierarchical grouping of memory and the ability to name allocators.
class Graph : public LinkBase
{
public:
  UseStaticMemory();

  cstr GetName(){return Name.c_str();}
  FixedString<32> Name;
  Graph* mParent;
  Stats mData;

  Graph(StringRange name, Graph* parent);

  void DeltaDedicated(MemCounterType bytes)
  {
    mData.BytesDedicated+=bytes;
  }

  void AddAllocation(MemCounterType bytes)
  {
    ++mData.Active;
    ++mData.Allocations;
    mData.BytesAllocated+=bytes;
    if(mData.BytesAllocated > mData.PeakAllocated)
      mData.PeakAllocated = mData.BytesAllocated;
  }

  void RemoveAllocation(MemCounterType bytes)
  {
    --mData.Active;
    mData.BytesAllocated-=bytes;
  }

  typedef InListBaseLink<Graph>::range RangeType;
  RangeType GetChildren(){return Children.all();}

  InListBaseLink<Graph> Children;
  void PrintHelper(size_t tabs, size_t flags, cstr name);
  void PrintHeader(size_t flags);
  void Compute(Stats& data);
  void PrintGraph(size_t flags);
  void Print(size_t tabs, size_t flags);

  virtual void CleanUp();
  virtual ~Graph();
private:
  //Can not copy memory managers.
  Graph(const Graph&);
  void operator=(const Graph&);
};

class Heap;
class Root: public Graph
{
public:
  Root(StringRange name, Graph* parent)
    :Graph(name, parent)
  {
  }

  static Root* RootGraph;
  static Heap* GloblHeap;
  static Heap* StaticHeap;

  static void Initialize();
  static void Shutdown();
  static void PrintAll();
};

Heap* GetGlobalHeap();
Heap* GetNamedHeap(cstr name);
Root* GetRoot();
Heap* GetStaticHeap();
void Shutdown();

class StandardMemory
{
public:
  static inline void MemCopy(void* dest, void* source, size_t numberOfBytes){memcpy(dest, source, numberOfBytes);}
  static inline void MemMove(void* dest, void* source, size_t numberOfBytes){memmove(dest, source, numberOfBytes);}
};

}//namespace Memory
}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Heap.hpp
/// Declaration of the Heap Allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{
namespace Memory
{

class HeapPrivate;

///Heap allocator. The heap allocator allocates memory directly from the 
///system heap using malloc and free.
class Heap : public Graph
{
public:
  Heap(StringRange name, Graph* parent);
  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);

  virtual void Print(size_t tabs, size_t flags);
};

template <typename type>
type* HeapAllocate(Heap* heap)
{
  MemPtr memory = heap->Allocate(sizeof(type));
  type* object = new(memory) type();
  return object;
}

template <typename type, typename ConstructionType>
type* HeapAllocate(Heap* heap, const ConstructionType& constructionData)
{
  MemPtr memory = heap->Allocate(sizeof(type));
  type* object = new(memory) type(constructionData);
  return object;
}

template <typename type>
void HeapDeallocate(Heap* heap, type* instance)
{
  instance->~type();
  heap->Deallocate(instance,sizeof(type));
}

}//namespace Memory

#define UseStaticHeap() \
  static void* operator new(size_t size){ return Memory::GetStaticHeap()->Allocate(size); } \
  static void operator delete(void* pMem, size_t size){return Memory::GetStaticHeap()->Deallocate(pMem, size);}

template<typename NodeType>
class TypedAllocator : public Memory::StandardMemory
{
public:
  TypedAllocator()
    :mNode(Memory::GetGlobalHeap())
  {
  }

  TypedAllocator(cstr name)
    :mNode(Memory::GetNamedHeap(name))
  {
  }

  TypedAllocator(NodeType* manager)
    :mNode(manager)
  {
  }

  MemPtr Allocate(size_t numberOfBytes){return mNode->Allocate(numberOfBytes); };
  void Deallocate(MemPtr ptr, size_t numberOfBytes){mNode->Deallocate(ptr, numberOfBytes);}
  NodeType* mNode;
};

// This allocator specifically works with 
template<typename NodeType>
class MemsetZeroTypedAllocator : public TypedAllocator<NodeType>
{
public:
  MemsetZeroTypedAllocator()
    :mNode(Memory::GetGlobalHeap())
  {
  }

  MemsetZeroTypedAllocator(cstr name)
    :mNode(Memory::GetNamedHeap(name))
  {
  }

  MemsetZeroTypedAllocator(NodeType* manager)
    :mNode(manager)
  {
  }

  MemPtr Allocate(size_t numberOfBytes)
  {
    if(mNode == nullptr)
      mNode = Memory::GetGlobalHeap();
    return mNode->Allocate(numberOfBytes);
  }

  void Deallocate(MemPtr ptr, size_t numberOfBytes)
  {
    if(mNode == nullptr)
      mNode = Memory::GetGlobalHeap();
    mNode->Deallocate(ptr, numberOfBytes);
  }

  NodeType* mNode;
};

typedef TypedAllocator<Memory::Heap> HeapAllocator;

//Override default
typedef TypedAllocator<Memory::Heap> DefaultAllocator;
typedef MemsetZeroTypedAllocator<Memory::Heap> MemsetZeroDefaultAllocator;

}//namespace Zero

#else

namespace Zero
{

void* zAllocate(size_t numberOfBytes);
void zDeallocate(void*);

class StandardMemory
{
public:
  static inline void MemCopy(void* dest, void* source, size_t numberOfBytes)
  {
    memcpy(dest, source, numberOfBytes);
  }

  static inline void MemMove(void* dest, void* source, size_t numberOfBytes)
  {
    memmove(dest, source, numberOfBytes);
  }
};

//Default allocator of Standard Memory. This allocator
//is used by default for all the containers.
class DefaultAllocator : public StandardMemory
{
public:
  enum{ cAlignment = 4 };
  void* Allocate(size_t numberOfBytes) { return zAllocate(numberOfBytes); };
  void Deallocate(void* ptr, size_t numberOfBytes) { zDeallocate(ptr); }
};

}//namespace Zero

#endif

namespace Zero
{

size_t HashString(const char* str, size_t size);

inline size_t HashUint(size_t a)
{
  a = (a ^ 61) ^ (a >> 16);
  a = a + (a << 3);
  a = a ^ (a >> 4);
  a = a * 0x27d4eb2d;
  a = a ^ (a >> 15);
  return a;
}

//From Thomas Wang, Jan 1997
inline size_t Hash64to32Shift(u64 key)
{
  key = (~key) + (key << 18); // key = (key << 18) - key - 1;
  key = key ^ (key >> 31);
  key = key * 21; // key = (key + (key << 2)) + (key << 4);
  key = key ^ (key >> 11);
  key = key + (key << 6);
  key = key ^ (key >> 22);
  return (uint) key;
}

// Policy for how values are tested for equality
// Allow the containers to be searched by values
// that are not the same as the stored type
template<typename type>
struct ComparePolicy
{
  //Default use operator ==
  template<typename otherType>
  inline bool equal(const type& left, const otherType& right) const
  {
    return right == left;
  }
};

// Policy for how values are hashed
template<typename type>
struct HashPolicy : public ComparePolicy<type>
{
  EmptyClass(HashPolicy);
  size_t operator()(const type& value) const
  {
    //Default behavior is to expect the type to have a 
    //hashing member function. If a compile error occurs here
    //define a hashing function or pass in a hash policy.
    return (size_t)value.Hash();
  }
};

// Implementation of the Pair hash function
template<typename type0, typename type1>
size_t Pair<type0, type1>::Hash() const
{
  return HashPolicy<first_type>()(first) ^ HashPolicy<second_type>()(second) * 7187;
}

///Hash Function for Integers.
template<>
struct HashPolicy<int> : public ComparePolicy<int>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const int& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

///Hash Function for unsigned integers.
template<>
struct HashPolicy<unsigned int> : public ComparePolicy<unsigned int>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const unsigned int& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

template<>
struct HashPolicy<long> : public ComparePolicy<long>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const long& value) const
  {
    return HashUint((size_t)value);
  }
};

template<>
struct HashPolicy<unsigned long> : public ComparePolicy<unsigned long>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const unsigned long& value) const
  {
    return HashUint((size_t)value);
  }
};

///Hash Function for pointers.
template<typename type>
struct HashPolicy<type*> : public ComparePolicy<type*>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const type* value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

///Hash Function for floats.
template<>
struct HashPolicy<float> : public ComparePolicy<float>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const float& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};

// Compare Policty for const char * which
// uses string comparison
template<>
struct ComparePolicy<const char*>
{
  inline bool equal(const char* left, const char* right) const
  {
    return strcmp(left, right) == 0;
  }

  template<typename stringType>
  inline bool equal(const char* left, const stringType& right) const
  {
    // use operator == to other type, usually strings
    return right == left;
  }
};

///Hash function for const char *
template<>
struct HashPolicy<const char*> : public ComparePolicy<const char*>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const char* value) const
  {
    return HashString(value, strlen(value));
  }
};

template<>
struct HashPolicy<u64> : public ComparePolicy<u64>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const u64& value) const
  {
    return Hash64to32Shift(value);
  }
};

template<>
struct HashPolicy<s64> : public ComparePolicy<s64>
{
  EmptyClass(HashPolicy);
  inline size_t operator()(const s64& value) const
  {
    return Hash64to32Shift((u64)value);
  }
};

void* const cHashOpenNode = NULL;
void* const cHashEndNode = (void*)1;

template<typename ValueType, typename Hasher, typename Allocator>
class HashedContainer : public AllocationContainer<Allocator>
{
public:
  //standard container typedefs
  typedef ValueType value_type;
  typedef size_t size_type;
  typedef ValueType& reference;
  typedef const ValueType& const_reference;
  typedef AllocationContainer<Allocator> base_type;
  typedef HashedContainer<ValueType, Hasher, Allocator> this_type;
  using base_type::mAllocator;

protected:
  //Internal node value
  struct Node
  {
    //The value stored in the node (only valid if 'next' is not set to 'cHashOpenNode');
    ValueType Value;

    //Can be set to another node in the chain, or to 'cHashOpenNode'
    //which means the node itself is open, or to 'cHashEndNode'
    //which means its at the end of the chain
    Node* next;
  };

public:

  //Default constructor
  HashedContainer()
  {
    mTableSize = 0;
    mSize = 0;
    mTable = NULL;
    mMaxLoadFactor = 0.8f;
  }

  ~HashedContainer()
  {
    deallocate();
  }

  //Range for hash map.
  struct range
  {
    typedef typename this_type::value_type value_type;

    range(Node* rbegin, Node* rend, size_t size)
      : begin(rbegin), end(rend)
    { mSize = size; }

    bool empty()
    { 
      return begin == end;
    }

    reference front()
    {
      return begin->Value;
    }

    void popFront()
    {
      ErrorIf(empty(),"Popped an empty range.");
      ++begin;
      --mSize;

      begin = SkipDead(begin, end);
      //Skip empty slots
      while(begin != end && begin->next == cHashOpenNode)
        ++begin;
    }

    size_type size()
    {
      return mSize;
    }

  private:
    Node* begin;
    Node* end;
    size_t mSize;
  };

  //Get the hash value for a given value then
  //mod it by the table size to get a valid index.
  size_type HashedIndex(const_reference value)
  {
    return mHasher(value) % mTableSize;
  }

  ///////Container Global Modify//////////////////

  //Rehash the contents of the table.
  void rehash(size_type newTableSize)
  {
    if(newTableSize < mSize)
      return;

    //Expand table to new size
    Node* oldTable = mTable;
    size_type oldTableSize = mTableSize;

    //Allocate the new table
    Node* newTable = (Node*)mAllocator.Allocate(newTableSize * sizeof(Node));

    //Set all buckets to the open node.
    for(size_type i = 0; i < newTableSize; ++i)
      newTable[i].next = (Node*)cHashOpenNode;

    //Set the internal member values
    mTable = newTable;
    mTableSize = newTableSize;
    mSize = 0;

    //Now reinsert all valid buckets values
    for(size_type i = 0; i < oldTableSize; ++i)
    {
      Node& node = oldTable[i];
      if(node.next != cHashOpenNode)
      {
        //If this errors here, it means most likely their 'equals' operator is wrong
        insertInternal(node.Value, OnCollisionError);
      }
    }

    //Free the old table if it existed
    if(oldTableSize != 0)
    {
      destructTableValues(oldTable, oldTableSize);
      mAllocator.Deallocate(oldTable, oldTableSize * sizeof(Node));
    }
  }

  //Destroy all elements.
  void clear()
  {
    destructTableValues(mTable, mTableSize);
    mSize = 0;
  }

  //Destroy all elements and frees all memory.
  void deallocate()
  {
    if(mTable != NULL)
    {
      //free all the values in the and then delete the table.
      destructTableValues(mTable, mTableSize);
      mAllocator.Deallocate(mTable, mTableSize * sizeof(Node));
    }

    mTableSize = 0;
    mSize = 0;
    mTable = NULL;
  }

  range all() const
  {
    Node* start = SkipDead(mTable, mTable + mTableSize);
    return range(start, mTable + mTableSize, mSize);
  }

  ////////////Insertion///////////////////////

  //Override
  static Node* OnCollisionOverride(Node* dest, const_reference value)
  {
    dest->Value = value;
    return dest;
  }

  //Error
  static Node* OnCollisionError(Node* dest, const_reference value)
  {
    (void)value;
    (void)dest;
    Error("Double insert, value was not inserted!");
    return NULL;
  }

  //Just return the bucket
  static Node* OnCollisionReturn(Node* dest, const_reference value)
  {
    (void)value;
    return dest;
  }

  //Insert a value.
  template <typename CollisionFunc>
  Node* insertInternal(const_reference value, CollisionFunc onCollison )
  {
    //Expand the table if insertion would break load factor
    //even if it might be a double insert
    checkForExpand(mSize + 1);

    
    //Find the node for this value this is its
    //primary bucket
    size_type curHash = HashedIndex(value);
    Node* node = mTable + curHash;

    //If the node is empty (see 'next')
    if(node->next != cHashOpenNode)
    {
      //If there is a collision check to see if it the
      //object is in its primary bucket.

      //Possible Collision or same key.
      if(mHasher.equal(node->Value, value))
      {
        return onCollison(node, value);
      }
      else
      {
        //Hash Collision
        //If this hashed value is not in its primary bucket
        //steal this bucket (robin hood hashing)
        size_type actualHash = HashedIndex(node->Value);
        if(actualHash != curHash)
        {
          //Kick the node out of the bucket

          Node* movingNodePrimary = mTable+actualHash;

          ErrorIf(movingNodePrimary->next == cHashOpenNode , 
            "Bad hash function. Hash value has changed or other issue.");

          Node* movingNodePrev = movingNodePrimary;

          //Search through the moving nodes links
          //and find the previous node. This node
          //needs it next updated.
          while(movingNodePrev->next != node)
            movingNodePrev = movingNodePrev->next;

          //Remove the object from the chain.
          movingNodePrev->next = movingNodePrev->next->next;

          //Inert the old object into its bucket chain
          AppendToBucketChain(movingNodePrev, node->Value);

          //Replace in current node
          DestructNode(node);
          FillOpenNode(node, value);

          //Increase size
          ++mSize;
          return node;

        }
        else
        {
          //This bucket is the primary key for this value
          Node* primaryNode = node;

          //Different keys can be in the same bucket chain.
          //So the entire bucket chain must be checked
          //for double insert.

          Node* searchNode = primaryNode;
          while(searchNode != cHashEndNode)
          {
            if(mHasher.equal(searchNode->Value, value))
            {
              return onCollison(searchNode, value);
            }
            searchNode = searchNode->next;
          }

          //Not in the list insert into this chain
          ++mSize;
          return AppendToBucketChain(primaryNode, value);

        }
      }

    }
    else
    {
      //bucket is free use it
      //Construct the key
      //Copy data into it
      ++mSize;
      FillOpenNode(node, value);
      return node;
    }

  }

  ////////Find//////////////////////////////

  //Find an element value that hashes and compares to a
  //value in the hash map.
  template<typename searchType, typename searchHasherType>
  Node* internal_find_as(const searchType& searchValue, 
                         searchHasherType searchHasher) const
  {
    if(mTableSize == 0)
      return (Node*)cHashOpenNode;

    //Hash the value given with the provided hasher.
    size_type searchHash = searchHasher(searchValue) % mTableSize;
    Node* node = mTable+searchHash;

    //If the node's next is set to 'cHashOpenNode', it means that
    // the node itself is open/empty
    if(node->next != cHashOpenNode)
    {
      do
      {
        //Check to see if the value of this node is equal
        //to the search value.
        if(searchHasher.equal(searchValue, node->Value))
          return node;

        //Move through all the objects in the linked list.
        node = node->next;
      }
      while(node != cHashEndNode);

    }
    return (Node*)cHashOpenNode;
  }

  size_t count(const_reference value)
  {
    Node* foundNode = internal_find_as(value, mHasher);
    if(foundNode != cHashOpenNode)
      return 1;
    else
      return 0;
  }

  ///////Erasing//////////////////////////

  //Erase a value if found.
  void erase(const_reference value)
  {
    Node* foundNode = internal_find_as(value, mHasher);
    if(foundNode != cHashOpenNode)
      eraseNode(foundNode);
  }

  void eraseNode(Node* node)
  {
    ErrorIf(node==NULL || node->next == cHashOpenNode, 
            "Attempted to erase an invalid node.");
    size_type eraseHash = HashedIndex(node->Value);
    Node* bucketPrev = mTable + eraseHash;

    if(bucketPrev == node)
    {
      if(bucketPrev->next != (Node*)cHashEndNode)
      {
        //node is the first node in a bucket chain
        //remove the front by moving the next node
        //in the chain into this bucket
        MoveNode(bucketPrev, bucketPrev->next);
      }
      else
      {
        //Node chain just destroy it
        DestructNode(bucketPrev);
      }
      --mSize;
      return;
    }

    //Search for node's parent
    while(bucketPrev->next != node)
      bucketPrev = bucketPrev->next;

    //remove the node from the list
    bucketPrev->next = node->next;
    DestructNode(node);
    --mSize;
  }

  //////////Information Functions///////////
  size_type bucket_count() const { return mTableSize; }
  size_type size() const { return mSize; }
  bool empty()const {return mSize == 0; }

  //////////Load Factor///////////////////////
  float max_load_factor()const { return mMaxLoadFactor; }
  float load_factor() const { return float(mSize) / float(mTableSize); }
  void set_max_load_factor(float newMax)
  {
    mMaxLoadFactor = newMax;
    checkForExpand(mSize);
  }

  ///Equals///////////

  bool operator==(const this_type& other)
  {
    if (other.size() != this->size())
      return false;

    range r = this->all();
    while(!r.empty())
    {
      Node* node = other.internal_find_as(r.front(), mHasher);
      if(node == (Node*)cHashOpenNode)
        return false;

      if (r.front() != node->Value)
        return false;

      r.popFront();
    }

    return true;
  }

protected:

  static Node* SkipDead(Node* start, Node* end)
  {
    while(start != end && start->next == cHashOpenNode)
      ++start;
    return start;
  }

  Node* mTable;
  size_type mTableSize;
  size_type mSize;
  float mMaxLoadFactor;
  Hasher mHasher;
  typedef Node node_type;

  void checkForExpand(size_type newsize)
  {
    if(mTableSize == 0 ||
       (float(newsize) / float(mTableSize)) > max_load_factor())
    {
      size_type newTableSize = GetNextSize(mTableSize);
      if(newTableSize == 0)
        newTableSize = 16;
      rehash(newTableSize);
    }
  }

  //assumes d is power of 2
  size_type GetNextSize(size_type d)
  {
    return d * 2;
  }

  Node* GetLastInBucketChain(Node* node)
  {
    while(node->next != cHashEndNode)
      node = node->next;
    return node;
  }

  inline Node* AppendToBucketChain(Node* root, const_reference value)
  {
    Node* lastInBucket = GetLastInBucketChain(root);
    Node* openSlot = GetNextOpenBucket(lastInBucket);

    FillOpenNode(openSlot, value);
    lastInBucket->next = openSlot;
    return openSlot;
  }

  static void destructTableValues(Node* data, size_type size)
  {
    for(size_type i = 0; i < size; ++i)
    {
      //call the destructor on all the value types
      if(data[i].next != cHashOpenNode)
        data[i].Value.~ValueType();

      data[i].next = (Node*)cHashOpenNode;
    }
  }

  void MoveNode(Node* dest, Node* source)
  {
    DestructNode(dest);

    //Move
    new(&dest->Value) value_type(source->Value);
    dest->next = source->next;

    DestructNode(source);
  }

  void FillOpenNode(Node* node, const_reference value)
  {
    new(&node->Value) value_type(value);
    node->next = (Node*)cHashEndNode;
  }

  void DestructNode(Node* node)
  {
    //Call the destructor on the value
    node->Value.~ValueType();
    //Mark this bucket as open.
    node->next = (Node*)cHashOpenNode;
  }

  Node* GetNextOpenBucket(Node* startingNode)
  {
    Node* cur = startingNode;
    Node* end = mTable + mTableSize;

    //Find a 'nearby' bucket by searching around the current
    //bucket

    while(cur < end)
    {
      if(cur->next == cHashOpenNode)
        return cur;
      ++cur;
    }

    cur = startingNode;
    while(cur >= mTable)
    {
      if(cur->next == cHashOpenNode)
        return cur;
      --cur;
    }

    Error("No free slots. Hash map is not working correctly.");

    return (Node*)cHashOpenNode;
  }

};

}//namespace Zero

namespace Zero
{
//----------------------------------------------------------------------- Utility
bool CaseSensitiveCompare(char a, char b);
bool CaseInsensitiveCompare(char a, char b);
typedef bool (*CharComparer)(char a, char b);

//----------------------------------------------------------------------- String
class String
{
public:
  ///////Standard typedefs/////////////
  typedef char              value_type;
  typedef value_type*       pointer;
  typedef const value_type* const_pointer;
  typedef value_type&       reference;
  typedef const value_type& const_reference;
  typedef size_t            size_type;
  typedef s32               count_type;
  typedef std::ptrdiff_t    difference_type;
  typedef String            this_type;
  typedef StringRange       range;

  ///////Iterators/////////////////////
  typedef const value_type* iterator;
  typedef const value_type* const_iterator;

  static const uint InvalidIndex = (uint)-1;

  struct StringNode
  {
    count_type RefCount;
    size_type Size;
    size_type HashCode;
    value_type Data[1];

    void addRef();

    void release();

    static bool isEqual(StringNode* l, StringNode* r);
  };

  ///////Constructors//////////////////
  String();

  String(StringNode* node)
  {
    assign(node);
  }

  //Caution: This is not explicit for ease of use.
  String(const_pointer cstring)
  {
    if(cstring != NULL)
    {
      assign(cstring, strlen(cstring));
    }
    else
    {
      Error("Construction of a string from a NULL pointer is not valid");
      initializeToDefault();
    }
  }

  String(StringRange str)
  {
    assign(str.begin, str.size());
  }

  String(const_pointer cstring, size_type size)
  {
    assign(cstring, size);
  }

  String(const_pointer cstart, const_pointer cend)
  {
    assign(cstart, cend - cstart);
  }

  //Copy constructor
  String(const this_type& rhs)
  {
    assign(rhs.mNode);
  }

  explicit String(char character)
  {
    char str[2] = { character, '\0' };
    assign(str, 1);
  }

  String& operator=(const String& other)
  {
    //Do not copy self
    if(this != &other)
    {
      //release this strings data
      release();
      //assign and add a reference
      assign(other.mNode);
    }

    return *this;
  }

  ~String() 
  {
    release();
  }

  ///////Data Access Functions/////////
  size_type hash() const
  {
    return mNode->HashCode;
  }

  value_type operator[](size_type index) const
  {
    // We allow the index to access the null character at the end
    ErrorIf(index > size(), "Accessed string array out of bounds.");
    return *(data() + index);
  }

  bool empty() const { return mNode->Size == 0; }
  const_pointer data() const { return mNode->Data; }
  const_pointer c_str() const { return mNode->Data; }
  size_type size() const { return mNode->Size; }
  void clear() { *this = String(); }
  char front() const { return mNode->Data[0]; }
  char back() const { return mNode->Data[mNode->Size - 1]; }

  ////////Equality and Inequality///////

  //////////Equal operators//////////////
  //Primary equal operator for strings
  friend inline bool operator == (const this_type& left, const this_type& right)
  {
    return StringNode::isEqual(left.mNode, right.mNode);
  }

  bool operator != (const String& right) const
  {
    return !((*this) == right);
  }

  ///////Less than operators///////////
  friend inline bool operator < (const this_type& left, const this_type& right)
  {
    return strcmp(left.c_str(), right.c_str()) < 0;
  }

  ///////Greater than operators///////////
  friend inline bool operator > (const this_type& left, const this_type& right)
  {
    return strcmp(right.c_str(), left.c_str()) < 0;
  }

  StringRange sub_string_unsafe(size_type offset, size_type length) const
  {
    return all().sub_string_unsafe(offset, length);
  }

  StringRange sub_string(size_type offset, size_type length) const
  {
    return all().sub_string(offset, length);
  }

  operator StringRange() const { return all(); }

  ///////Iteration/////////////////////////

  iterator begin() const { return c_str(); }
  iterator end() const { return c_str() + size(); }
  StringRange all() const { return StringRange(begin(), end()); }
  static String Format(cstr format, ...);
  static String FormatArgs(cstr format, va_list va);

  // Gets the string node that represents this string (only use in advanced cases)
  StringNode* GetNode() const { return mNode; }

  template<typename type>
  friend struct MoveOperator;
  static String ReplaceSub(StringRange source, StringRange text, 
                              size_type start, size_type end);

  uint FindFirstOf(byte value) const
  {
    return all().FindFirstOf(value);
  }

  uint FindFirstOf(const StringRange& value) const
  {
    return all().FindFirstOf(value);
  }

  uint FindLastOf(byte value) const
  {
    return all().FindLastOf(value);
  }

  uint FindLastOf(const StringRange& value) const
  {
    return all().FindLastOf(value);
  }

  uint FindFirstNonWhitespaceCharIndex() const
  {
    return all().FindFirstNonWhitespaceCharIndex();
  }

  uint FindLastNonWhitespaceCharIndex() const
  {
    return all().FindLastNonWhitespaceCharIndex();
  }

  char FindFirstNonWhitespaceChar() const
  {
    return all().FindFirstNonWhitespaceChar();
  }

  char FindLastNonWhitespaceChar() const
  {
    return all().FindLastNonWhitespaceChar();
  }

  StringRange Trim()
  {
    return all().Trim();
  }

  bool Contains(const StringRange& value) const
  {
    return all().Contains(value);
  }

  /// Returns true if all the characters in a string are upper-case
  bool IsAllUpper() const
  {
    return all().IsAllUpper();
  }

  /// Returns true if all the characters in a string are whitespace
  bool IsAllWhitespace() const
  {
    return all().IsAllWhitespace();
  }

  /// Returns true if the string starts with the given text
  bool StartsWith(StringRange startsWith, CharComparer compare = CaseSensitiveCompare) const
  {
    return StartsWith(all(), startsWith, compare);
  }

  /// Returns true if the string starts with the given text
  static bool StartsWith(StringRange source, StringRange startsWith, CharComparer compare = CaseSensitiveCompare)
  {
    // If the string we're matching is larger than our string, then we don't match
    if (startsWith.size() > source.size())
      return false;

    for (uint i = 0; i < startsWith.size(); ++i)
    {
      char compareChar = startsWith[i];
      char ourChar = source[i];
      
      if (!compare(compareChar, ourChar))
      {
        return false;
      }
    }

    return true;
  }

  static String Repeat(char c, uint numberOfTimes)
  {
    // Create a temporary memory buffer that contains the character repeated over and over
    char* buffer = (char*)alloca(numberOfTimes);
    memset(buffer, c, numberOfTimes);

    // Return a string made out of the buffer
    return String(buffer, numberOfTimes);
  }

  // Internally allocates a node
  // This should never be called by the user except in rare optimization cases
  static StringNode* allocateNode(size_type size);

private:
  void initializeToDefault();
  void addRef();
  void release();
  void assign(const_pointer data, size_type size);
  void assign(StringNode* node);
  StringNode* mNode;
};

typedef const String& StringParam;
typedef const String& StringRef;

//----------------------------------------------------------- String Token Range
class StringTokenRange
{
public:
  StringTokenRange(StringRange stringRange, char delim);
  StringRange internalRange;
  char mDelim;
  StringRange front();
  void popFront();
  bool empty();
  StringRange curRange;
};

inline bool operator==(const String& left, cstr right)
{
  return strcmp(left.data(), right) == 0;
}

inline bool operator!=(const String& left, cstr right)
{
  return strcmp(left.data(), right) != 0;
}

inline bool operator<(const String& left, cstr right)
{
  return strcmp(left.data(), right) < 0;
}

template<size_t s>
inline bool operator==(const FixedString<s>& left, const String& right)
{
  return strcmp(left.data(), right.data()) == 0;
}

template<size_t s>
inline bool operator==(const String& left, const FixedString<s>& right)
{
  return strcmp(left.data(), right.data()) == 0;
}

//--------------------------------------------------- Hash Policy (String Range)
//Hash policy for string range
template<>
struct HashPolicy<StringRange>
{
  EmptyClass(HashPolicy);
  inline size_t operator () (const StringRange& value) const
  {
    return HashString(value.begin, value.size());
  }

  inline bool equal(const StringRange& left, const StringRange& right) const
  {
    return left == right;
  }

  template<typename stringType>
  inline bool equal(const StringRange& left, const stringType& right) const
  {
    // use operator == to other type, usually strings
    return right == left;
  }
};

//--------------------------------------------------------- Hash Policy (String)
//Hash policy for String class.
template<>
struct HashPolicy<String>
{
  EmptyClass(HashPolicy);
  inline size_t operator () (const String& value) const
  {
    return value.hash();
  }

  inline bool equal(const String& left, const String& right) const
  {
    return left == right;
  }
};

//------------------------------------------------------- Move Operator (String)
template<>
struct MoveOperator<String>
{
  static inline void Move(String* dest, String* source)
  {
    dest->mNode = source->mNode;
  }
};

//------------------------------------------------------------- Global Functions
String ToLower(StringParam before);

// Wraps text input on space boundaries (does not add -)
String WordWrap(StringRange input, size_t maxLineLength);

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file StringUtility.hpp
///
/// 
/// Authors: Chris Peters
/// Copyright 2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file Array.hpp
/// Declaration of the Array container.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Zero
{

//------------------------------------------------------------------------ Array
///Generic dynamic array class / Linear Sequence. Equivalent to std::vector.
///Stores objects in contiguous blocks of dynamically allocated 
///memory allowing random access.
///Constant time insertion and removal at the end. 
///Linear time for insertion and removal at beginning or middle.
///This array is also optimized to use pod conventions (memcpy, no destructors)
///on fundamental types or types with proper type traits.(see TypeTraits). 
template<typename type, typename Allocator = DefaultAllocator, 
                        typename value_tt = StandardTraits<type> >
class Array : public AllocationContainer<Allocator>
{
public:
  //-------------------------------------------------------- Standard Typedefs
  typedef type value_type;
  typedef value_type* pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef Array<type, Allocator, value_tt> this_type;
  typedef AllocationContainer<Allocator> base_type;
  using base_type::mAllocator;

  //typedef type traits 
  typedef value_tt value_type_traits;
  typedef typename value_type_traits::is_pod_ typeIsPod;
  typedef typename value_type_traits::has_trivial_copy_ typePodCopy;
  typedef typename value_type_traits::has_trivial_destructor_  typePodDes;
  typedef typename value_type_traits::has_trivial_constructor_ typePodCon;
  typedef typename value_type_traits::is_pod_ typePodMove;

  //---------------------------------------------------------------- Iterators
  typedef value_type* iterator;
  typedef const value_type* const_iterator;

  static const size_t InvalidIndex = size_t(-1);

  struct range
  {
    typedef typename this_type::value_type value_type;
    typedef typename this_type::reference reference;
    typedef value_type contiguousRangeType;

    range() : mBegin(NULL), mEnd(NULL) {}
    range(iterator b, iterator e)
      : mBegin(b), mEnd(e)
    { }

    iterator mBegin;
    iterator mEnd;
    iterator begin() { return mBegin; }
    iterator end() { return mEnd; }
    void popFront() { ++mBegin; }
    void popBack() { --mEnd; }
    reference front() { return *mBegin; }
    reference back() { return *(mEnd - 1); }
    bool empty() const { return mBegin == mEnd; }
    size_type length() const { return mEnd - mBegin; }
    size_type size() const { return length(); }
    reference operator[](size_type index) { return mBegin[index]; }
    const_reference operator[](size_type index) const { return mBegin[index]; }
  };

  //------------------------------------------------------------- Constructors
  Array()
    : mData(NULL),
      mCapacity(0),
      mSize(0)
  { }

  Array(const this_type& other)
    : base_type(other),
      mData(NULL),
      mCapacity(other.mSize),
      mSize(other.mSize)
  {
    if(other.mSize != 0)
    {
      mData = (type*)mAllocator.Allocate(mSize*sizeof(type));
      uninitialized_copy(mData, other.mData, mSize, typePodCopy());
    }
  }

  explicit Array(size_type size)
    : mData(NULL),
      mCapacity(0),
      mSize(0)
  {
    changeCapacity(size);
    uninitialized_fill(mData, size, typePodCon());
    mSize = size;
  }

  Array(size_type size, const type& fillType)
    : mData(NULL),
      mCapacity(0),
      mSize(0)
  {
    changeCapacity(size);
    uninitialized_fill(mData, size, fillType);
    mSize = size;
  }

  void swap(this_type& other)
  {
    Swap(mData, other.mData);
    Swap(mSize, other.mSize);
    Swap(mCapacity, other.mCapacity);
  }

  void operator=(const this_type& other)
  {
    if(&other == this)
      return;

    assign(const_cast<this_type*>(&other)->all());
  }

  ~Array()
  {
    deallocate();
  }

  //---------------------------------------------------- Information Functions

  //The maximum amount of elements before the buffer
  //must be reallocated. Controlled with reserve and
  //set_capacity.
  size_type capacity() const { return mCapacity; }

  //Return whether the array contain any elements.
  bool empty() const { return mSize == 0; }

  //Returns the number of elements in the array.
  size_type size() const { return mSize; }

  //------------------------------------------------- Element Access Functions
  iterator begin() { return mData; }
  iterator end() { return mData + mSize; }
  const_iterator begin() const { return mData; }
  const_iterator end() const { return mData + mSize; }

  //Returns and range for all the elements in the container.
  range all() { return range(begin(), end()); }

  //Returns and range for all the elements in the container.
  range all() const { return const_cast<Array*>(this)->all(); }

  //Get direct pointer to data
  type* data() { return mData; }
  const type* data() const { return mData; }

  range sub_range(size_type index, size_type length)
  {
    ErrorIf(index >= mSize, "Accessed array out of bounds.");
    ErrorIf(index + length > mSize, "Accessed array out of bounds.");
    return range(mData + index, mData + index + length);
  }

  range sub_range(size_type index, size_type length) const { return const_cast<Array*>(this)->sub_range(index, length); }

  reference operator[](size_type index)
  {
    ErrorIf(index >= mSize, "Accessed array out of bounds.");
    return mData[index];
  }

  const_reference operator[](size_type index) const
  {
    ErrorIf(index >= mSize, "Accessed array out of bounds.");
    return mData[index];
  }

  reference front()
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }

  const_reference front() const
  {
    ErrorIf(mSize == 0, "Empty array, no front element.");
    return mData[0];
  }

  reference back()
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }

  const_reference back() const
  {
    ErrorIf(mSize == 0, "Empty array, no back element.");
    return mData[mSize - 1];
  }

  //--------------------------------------------------- Modification Functions
  //Adds an element to the back of the array.
  void push_back(const type& item)
  {
    const type* toBeAdded = &item;
    if(mCapacity < mSize + 1)
    {
      //Is the item from this array.
      //This prevents errors with array.push_back(array[0]);
      if(toBeAdded >= begin() && toBeAdded < end())
      {
        size_type index = toBeAdded - begin();
        expandToNewSize(mSize + 1);
        //mData is now the newly allocated array.
        //Find the value in the new array
        toBeAdded = mData + index;
      }
      else
      {
        expandToNewSize(mSize + 1);
      }
    }
    constructWith(mData + mSize, *toBeAdded);
    ++mSize;
  }

  //Increase the containers size
  type& push_back()
  {
    expandToNewSize(mSize+1);
    construct(mData+mSize, typeIsPod());
    ++mSize;
    return *(mData+(mSize-1));
  }

  //Removes the last element in the array.
  void pop_back()
  {
    ErrorIf(mSize == 0,"Empty array, can not pop back element.");
    destroy(mData + mSize - 1, typePodDes());
    --mSize;
  }

  //Resize the array to a new size.
  void resize(size_type newSize)
  {
    //Check to see if the size did not change
    if(mSize == newSize)
      return;
    else if(mSize < newSize)
    {
      //Expand memory for array
      reserve(newSize);

      //Only construct on new elements
      //Elements from current size to new size
      uninitialized_fill(mData + mSize, newSize - mSize, typePodCon());
    }
    else
    {
      //array shrinking 
      //Destroy elements from new size to old size
      destroyElements(mData + newSize, mSize - newSize, typePodDes());
    }
    mSize = newSize;
  }

  //Resize the array to a new size.
  void resize(size_type newSize, const type& defaultValue)
  {
    //Check to see if the size did not change
    if(mSize == newSize)
      return;
    else if(mSize < newSize)
    {
      //Expand memory for array
      reserve(newSize);

      //Only construct on new elements
      //Elements from current size to new size
      uninitialized_fill(mData + mSize, newSize - mSize, defaultValue);
    }
    else
    {
      //array shrinking 
      //Destroy elements from new size to old size
      destroyElements(mData + newSize, mSize - newSize, typePodDes());
    }
    mSize = newSize;
  }

  //Resize the array to zero.
  void clear()
  {
    destroyElements(mData, mSize, typePodDes());
    mSize = 0;
  }

  void reserve(size_type newCapacity)
  {
    if(mCapacity < newCapacity)
      changeCapacity(newCapacity);
  }

  void set_capacity(size_type newCapacity)
  {
    if(newCapacity != mCapacity)
      changeCapacity(newCapacity);
  }

  //Deletes all the elements and frees all memory for this container.
  void deallocate()
  {
    destroyElements(mData, mSize, typePodDes());
    if(mCapacity)
      mAllocator.Deallocate(mData, sizeof(type)*mCapacity);
    mSize = 0;
    mCapacity = 0;
  }

  //Take over a block of memory.
  void set_data(pointer memory, size_type size)
  {
    deallocate();
    mSize = size;
    mCapacity = size;
    mData = memory;
  }

  //------------------------------------------------------ Insertion Functions
  template<typename iteratorType>
  void assign(iteratorType begin, iteratorType end)
  {
    clear();
    insert(0, BuildRange(begin,end));
  }

  template<typename inputRangeType>
  void assign(inputRangeType range)
  {    
    clear();
    insert(0, range);
  }

  //Appends a range to the end of the array
  template<typename inputRangeType>
  void append(inputRangeType inputRange)
  {
    insert(mData + mSize, inputRange);
  }

  template<typename iteratorType>
  void insert(pointer where, iteratorType begin, iteratorType end)
  {
    insert(where, BuildRange(begin,end));
  }

  //Inserts elements before index
  template<typename inputRangeType>
  void insert(pointer where, inputRangeType inputRange)
  {
    if(where == NULL && mSize == 0)
    {
      //insert on empty container
      changeCapacity(inputRange.length());
      where = mData;
    }

    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");

    size_type elementsToInsert = inputRange.length();

    //Expand this container to the new size
    pointer buffer = insertExpandCapacity(where, elementsToInsert);

    for(; !inputRange.empty(); inputRange.popFront())
    {
      constructWith(buffer, inputRange.front());
      ++buffer;
    }

    mSize += elementsToInsert;
  }

  template<typename inputRangeType>
  void insertAt(size_type index, inputRangeType inputRange)
  {
    //for insertion the index can be mSize
    ErrorIf(index > mSize, "Access array out of bounds.");
    insert(mData + index, inputRange);
  }

  void insert(pointer where, const_reference value)
  {
    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");
    PointerRange<value_type> singleValue(&value, &value+1);
    insert(where, singleValue);
  }

  void insertAt(size_type index, const_reference value)
  {
    //for insertion the index can be mSize
    ErrorIf(index > mSize, "Access array out of bounds.");
    if(index == mSize)
      push_back(value);
    else
      insert(mData + index, value);
  }

  //---------------------------------------------------------- Erase Functions
  void eraseAt(size_type index)
  {
    ErrorIf(index >= mSize, "Access array out of bounds.");
    eraseElements(mData + index, 1);
  }

  pointer erase(pointer where)
  {
    ErrorIf(where < mData || where > mData + mSize, 
            "Access array out of bounds.");
    eraseElements(where, 1);
    if(!empty())
      return where;//safe memory is not reallocated
    else
      return end();
  }

  void erase(range elements)
  {
    eraseElements(elements.begin(), elements.length());
  }

  void erase_value(const type& value)
  {
    size_t index = findIndex(value);

    ReturnIf(index == InvalidIndex, , "Value not found in the array");

    erase(mData + index);
  }

  size_t findIndex(const type& value) const
  {
    for (size_t i = 0; i < mSize; ++i)
    {
      if (mData[i] == value)
        return i;
    }

    return InvalidIndex;
  }

  bool contains(const type& value) const
  {
    return findIndex(value) != InvalidIndex;
  }

  //------------------------------------------------------------------- Equals
  bool operator==(this_type& other)
  {
    return equal(this->all(), other.all());
  }

  template<typename T>
  friend struct MoveOperator;

protected:

  ///Expand the array at where by numberOf elements and return a 
  ///pointer to where the new data will be inserted.
  //When a large amount of data is inserted the array will
  //often have to reallocated. Using the standard resize function will
  //copy all the old elements over to the new array then insert have to
  //move them again. This function allocates new memory if necessary
  //and copies the memory in front of and back of where in place. 
  //It then returns the pointer for the block to insert the new elements.
  pointer insertExpandCapacity(pointer where, size_type numberOfElements)
  {
    size_type neededCapacity = numberOfElements + mSize ;
    if(neededCapacity > mCapacity)
    {
      //Need more room expand capacity
      size_type newCapacity = mCapacity + (mCapacity / 2);
      if(neededCapacity > newCapacity)
      {
        //Needed size is bigger then %50 expansion
        //just use the new size
        newCapacity = neededCapacity;
      }

      pointer newData = (pointer)mAllocator.Allocate(newCapacity*sizeof(type));
      size_type firstBlockSize = where - mData;
      size_type secondBlockSize = end() -  where;
      pointer startOfSecondBlock = newData+firstBlockSize+numberOfElements;
      pointer startOfFirstBlock = newData;

      if(mSize != 0)
      {
        //Copy over first block of data
        if(firstBlockSize != 0)
          uninitialized_move(startOfFirstBlock, mData, firstBlockSize, typePodMove());

        //Copy over second block of data
        if(secondBlockSize != 0)
        {
          uninitialized_move(startOfSecondBlock, mData+firstBlockSize, 
                             secondBlockSize, typePodMove());
        }
      }

      //Deallocate old memory
      if(mCapacity != 0)
        mAllocator.Deallocate(mData, sizeof(type)*mCapacity);

      mCapacity = newCapacity;
      mData = newData;

      return newData + firstBlockSize;

    }
    else
    {
      //There is enough room just move the elements after where outwards
      size_type elementsToMove = end() - where;

      //Watch out we have an overlapped write
      if(elementsToMove != 0)
      {
        uninitialized_moveRev(where + numberOfElements, where, elementsToMove, 
                              typePodMove());
      }
      return where;
    }
  }

  void eraseElements(pointer where, size_type numberOfElements)
  {
    size_type elementsToMove = (end() - where) - numberOfElements;

    destroyElements(where, numberOfElements, typeIsPod());

    if(elementsToMove > 0)
    {
      uninitialized_move(where, where + numberOfElements, elementsToMove, 
                         typePodMove());
    }

    mSize -= numberOfElements;
  }

  void expandToNewSize(size_type newSize)
  {
    //Do not expand if new size fits in current capacity
    if(mCapacity < newSize)
    {
      //If capacity is not zero expand by %50 of capacity
      //if it is zero set it to 2
      size_type expandedSize = mCapacity != 0 ? mCapacity + (mCapacity / 2) : 2;
      if(expandedSize < newSize)
      {
        //%50 expansion was not enough space just expand to the new size
        changeCapacity(newSize);
      }
      else
      {
        //use the expanded size
        changeCapacity(expandedSize);
      }
    }
  }

  //This function directly changes the capacity.
  //If the capacity is lowered it will destroy the old elements using
  //resize.
  void changeCapacity(size_type newCapacity)
  {
    //delete extra elements if necessary
    if(newCapacity < mSize)
      resize(newCapacity);

    if(newCapacity == 0)
      return;

    //Allocate the new buffer size
    pointer newData = (pointer)mAllocator.Allocate(newCapacity*sizeof(type));

    //copy everything in mSize above. resize call above shrinks if necessary.
    if(mSize != 0)
      uninitialized_move(newData, mData, mSize, typePodMove());

    //Deallocate old memory if any allocated
    if(mCapacity != 0)
      mAllocator.Deallocate(mData, sizeof(type)*mCapacity);

    mCapacity = newCapacity;
    mData = newData;
  }

  pointer mData;
  size_type mCapacity;
  size_type mSize;
};

//-------------------------------------------------------------------- Pod Array
/// PodArray is the same as Array expect Pod conventions are forced on.
template<typename type, typename Allocator = DefaultAllocator>
class PodArray : public Array<type, Allocator, PodOverride>
{
public:
  typedef Array<type, Allocator, PodOverride> base_type;
  typedef typename base_type::size_type size_type;

  PodArray()
    : base_type()
  {
  }

  explicit PodArray(size_type size)
    : base_type(size)
  {
  }
};

//------------------------------------------------------- Move Operator (Array)
template<typename type, typename Allocator, typename tt_traits>
struct MoveOperator<Array<type, Allocator, tt_traits> >
{
  static inline void Move(Array<type, Allocator, tt_traits>* dest, 
                          Array<type, Allocator, tt_traits>* source)
  {
    dest->mData = source->mData;
    dest->mCapacity = source->mCapacity;
    dest->mSize = source->mSize;

    new (&dest->mAllocator) Allocator(source->mAllocator);
  }
};

}//namespace Zero

namespace Zero
{

//----------------------------------------------------------------------- String
bool CaseInsensitiveStringLess(String a, String b);

// Split string into to two parts not including the delimiter
// if the delimiter is not found it will return an empty range as the second range.
Pair<StringRange,StringRange> SplitOnFirst(StringRange filename, char delimiter);

// Split string into to two parts not including the delimiter
// if the delimiter is not found it will return an empty range as the second range.
Pair<StringRange,StringRange> SplitOnLast(StringRange filename, char delimiter);

// Strip all of string before last of delimiter
StringRange StripBeforeLast(StringRange filename, char delimiter);

//Join strings together using a delimiter
String JoinStrings(const Array<String>& strings, StringParam delimiter);

char OnlyAlphaNumeric(char c);

template<typename transformFunc>
String TransformString(StringRange string, transformFunc f)
{
  uint size = string.size();
  uint bufferSize = size+1;
  char* buffer = (char*)alloca(bufferSize);
  StrCpy(buffer, bufferSize, string.data());
  for (size_t i = 0; i < size; ++i)
    buffer[i] = f(buffer[i]);
  buffer[size] = '\0';
  return buffer;
}

template<typename Predicate>
StringRange RangeUntilFirst(String string, Predicate predicate)
{
  for(uint i=0;i<string.size();++i)
  {
    if(predicate(string[i]))
      return string.sub_string(0, i);
  }
  return string.all();
}

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file StringBuilder.hpp
/// Declaration of StringBuilder.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file StringConversion.hpp
/// Conversion to and from strings.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

// Convert Integers into hexadecimal format "4A34"
uint WriteToHex(char* buffer, uint bufferSize, u64 integerValue);
uint WriteToHex(char* buffer, uint bufferSize, u32 integerValue);

// Write out 'places' number of hex digits from integerValue
uint WriteToHexSize(char* buffer, uint bufferSize, uint places, u64 integerValue);

// Read 64 bit hex string
u64 ReadHexString(StringRange range);

//Basic conversion function (input must be UTF-16/2) DestAscii must unicodeLength +1 (for null terminator)
void ConvertUnicodeToAscii(char* destAscii, uint destAsciiLength, const wchar_t* unicodeData, size_t unicodeLength);

// Convert String to value (takes value reference so function can be overloaded)
void ToValue(StringRange range, String& value);
void ToValue(StringRange range, StringRange& value);

void ToValue(StringRange range, bool& value);
void ToValue(StringRange range, float& value);
void ToValue(StringRange range, double& value);
void ToValue(StringRange range, int& value);
void ToValue(StringRange range, uint& value);
void ToValue(StringRange range, u64& value);
void ToValue(StringRange range, s64& value);

template<typename type>
inline void ToValue(StringRange token, type& value)
{
  //no ToValue cast for this type
  type::InvalidCall();
}

// Convert value to string and  write into buffer returns the number of bytes written.
uint ToBuffer(char* buffer, uint bufferSize, bool value);
uint ToBuffer(char* buffer, uint bufferSize, float value);
uint ToBuffer(char* buffer, uint bufferSize, double value);
uint ToBuffer(char* buffer, uint bufferSize, int value);
uint ToBuffer(char* buffer, uint bufferSize, uint value);
uint ToBuffer(char* buffer, uint bufferSize, u64 value);

template<typename type>
uint ToBuffer(char* buffer, uint bufferSize, const type& value)
{
  // No ToBuffer for this type
  return type::InvalidCall();
}

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file ByteBuffer.hpp
/// Definition of ByteBuffer.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

class ByteBufferBlock;

///ByteBuffer used for efficient appending. Structured as an array of blocks.
class ByteBuffer
{
public:
  typedef unsigned char byteType;

  //Block of data in the ByteBuffer
  struct Block
  {
    size_t Size;
    byteType* Data;
  };

  //Block range is used to iterate
  //through all blocks on the buffer.
  struct BlockRange
  {
    BlockRange(ByteBuffer* buffer);
    const Block& front();
    bool empty();
    void popFront();
  private:
    void loadBlock();
    size_t mBlockSize;
    size_t mLastBlockSize;
    byteType** mBlock;
    byteType** mLast;
    Block mCurrent;
  };

  ByteBuffer(size_t blockSize=512);
  ~ByteBuffer();

  //Get current position of writing
  size_t Tell();

  //Write bytes to the buffer.
  void Write(const byteType* data, size_t sizeInBytes);

  //Add Data to end of buffer.
  void Append(const byteType* data, size_t sizeInBytes);

  //Get size of buffer.
  size_t GetSize() const {return mTotalSize;}

  //Get buffer as a string
  String ToString() const;

  //Extract into a raw memory buffer
  void ExtractInto(byteType* buffer, size_t bufferSizeInBytes) const;

  //Extract into a ByteBufferReader
  void ExtractInto(ByteBufferBlock& buffer) const;

  //Deallocate memory of blocks
  void Deallocate();

  //Get range of all blocks
  BlockRange Blocks();

private:
  ByteBuffer(const ByteBuffer&) {};
  void operator=(const ByteBuffer&) {};

protected:

  Array<byteType*> mBlocks;
  size_t mBlockSize;
  size_t mTotalSize;
  size_t mCurBlockSize;
  byteType* mCurBlockBuffer;
};

///ByteBufferBlock is a simple wrapper around a single contiguous block of memory.
///has same interface as a file.
class ByteBufferBlock
{
public:
  ByteBufferBlock();
  ~ByteBufferBlock();

  //Create buffer with the given size
  ByteBufferBlock(size_t size);

  //Create a buffer from existing data. If data is owned
  //buffer will deallocate data on destruction.
  ByteBufferBlock(byte* data, size_t size, bool owned);

  //Set data to use for this byte buffer
  void SetData(byte* data, size_t size, bool owned);

  //Set data block to use for this byte buffer
  void SetBlock(DataBlock block);

  //Read data from buffer.
  size_t Read(byte* data, size_t sizeInBytes);

  //Write data to the buffer
  size_t Write(byte* data, size_t sizeInBytes);

  //Seek to position
  void Seek(int offset, uint origin);

  //Pointer to current position in buffer.
  byte* GetCurrent();

  //Size of a buffer.
  size_t Size();

  //Return current position.
  size_t Tell();
  
  //Get start of block
  byte* GetBegin();

  //Deallocate memory if owned.
  void Deallocate();

private:
  byte* mData;
  size_t mSize;
  byte* mCurrent;
  bool mOwnsData;
  friend class ByteBuffer;
};

}

namespace Zero
{

//Simple String Builder
String BuildString(StringRange a, StringRange b);
String BuildString(StringRange a, StringRange b, StringRange c);
String BuildString(StringRange a, StringRange b, StringRange c, StringRange d);
String BuildString(StringRange a, StringRange b, StringRange c, StringRange d, StringRange e);
String BuildString(StringRange** ranges, uint count);

String StringJoin(Array<String>& strings, StringParam joinToken);

///Extension of ByteBuffer for building strings. Has
///stream operators overloaded so it can act as a replacement
///for io streams.
class StringBuilder : public ByteBuffer
{
public:
  template<typename type>
  friend struct MoveOperator;

  StringBuilder(){};
  ~StringBuilder(){};
  void operator+=(StringRange a){Append(a);}
  void Append(StringRange adapter);
  void Append(char character);
  char& operator[](size_t index);

  void Repeat(size_t count, StringParam str);

private:
  StringBuilder(const StringBuilder&) {};
  void operator=(const StringBuilder&) {};
};

template<>
struct MoveOperator<StringBuilder>
{
  static inline void Move(StringBuilder* dest, StringBuilder* source)
  {
    MoveOperator< Array<ByteBuffer::byteType*> >::Move(&dest->mBlocks, &source->mBlocks);
    
    dest->mBlockSize = source->mBlockSize;
    dest->mTotalSize = source->mTotalSize;
    dest->mCurBlockSize = source->mCurBlockSize;
    dest->mCurBlockBuffer = source->mCurBlockBuffer;
  }
};

inline StringBuilder& operator<<(StringBuilder& builder, StringRange range)
{
  builder.Append(range);
  return builder;
}

inline StringBuilder& operator<<(StringBuilder& builder, cstr text)
{
  builder.Append(text);
  return builder;
}

inline StringBuilder& operator<<(StringBuilder& builder, char character)
{
  builder.Append(character);
  return builder;
}

inline StringBuilder& operator<<(StringBuilder& builder, StringRef str)
{
  builder.Append(str.all());
  return builder;
}

//Generic templated
template<typename type>
inline StringBuilder& operator<<(StringBuilder& builder, const type& value)
{
  const uint bufferSize = 128;
  char buffer[bufferSize];
  uint size = ToBuffer(buffer, bufferSize, value);
  builder.Append(StringRange(buffer, buffer+size));
  return builder;
}

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file HashMap.hpp
/// Definition of the HashMap associative container.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Zero
{

template<typename Hasher, typename KeyType, typename DataType>
struct PairHashAdapter
{
  Hasher mHasher;
  typedef Pair<KeyType, DataType> pair_type;

  size_t operator()(const KeyType& value)
  {
    return mHasher(value);
  }

  size_t operator()(const pair_type& value)
  {
    return mHasher(value.first);
  }

  bool equal(const pair_type& left, const pair_type& right)
  {
    return mHasher.equal(left.first, right.first);
  }

  template<typename otherPairType>
  bool equal(const KeyType& left, const otherPairType& rightPair)
  {
    return mHasher.equal(left, rightPair.first);
  }
};

///Hash Map is an Associative Hashed Container. 
//Stores values by hashing keys providing constant insertion, removal, and 
//searching. Iteration is not in done is sort order.
template< typename KeyType, typename DataType, 
          typename Hasher = HashPolicy<KeyType>, 
          typename Allocator = DefaultAllocator >
class HashMap :  public HashedContainer< Pair<KeyType, DataType>, 
                                         PairHashAdapter< Hasher, KeyType, 
                                                          DataType >, 
                                         Allocator >
{
public:
  typedef KeyType key_type;
  typedef DataType data_type;
  typedef HashMap<KeyType, DataType> this_type;
  typedef Pair<KeyType, DataType> value_type;
  typedef Pair<KeyType, DataType> pair;
  typedef size_t size_type;
  typedef data_type& reference;
  typedef HashedContainer< value_type, 
                           PairHashAdapter<Hasher, KeyType, DataType>, 
                           Allocator > base_type;
  typedef typename base_type::Node* iterator;
  typedef typename base_type::Node Node;
  typedef typename base_type::range range;

  HashMap()
  {
  }

  ~HashMap()
  {
  }

  struct valuerange
  {
    typedef data_type value_type;
    range r;
    valuerange(const typename base_type::range& _r)
      : r(_r){}
    bool empty() { return r.empty(); }
    void popFront() { return r.popFront(); }
    size_type size() { return r.size(); }
    reference front() { return r.front().second; }
  };
  
  // range of all the values in the map.
  valuerange values() const { return valuerange(base_type::all()); }

  data_type& operator[](const key_type& key)
  {
    Node* node = base_type::internal_find_as(key, base_type::mHasher);
    if(node != cHashOpenNode)
    {
      return node->Value.second;
    }
    else
    {
      value_type newType(key, data_type());
      node = base_type::insertInternal(newType, base_type::OnCollisionOverride);
      return node->Value.second;
    }
  }

  void insert(const value_type& datapair)
  {
    base_type::insertInternal(datapair, base_type::OnCollisionOverride);
  }

  void insert(const key_type& key, const data_type& value)
  {
    base_type::insertInternal(value_type(key, value), base_type::OnCollisionOverride);
  }

  void insert(range pair_range)
  {
    for (; !pair_range.empty(); pair_range.popFront())
    {
      base_type::insertInternal(pair_range.front(), base_type::OnCollisionOverride);
    }
  }

  bool insertOrError(const value_type& datapair)
  {
    return base_type::insertInternal(datapair, base_type::OnCollisionError) != NULL;
  }

  bool insertOrError(const key_type& key, const data_type& value)
  {
    return base_type::insertInternal(value_type(key, value), base_type::OnCollisionError) != NULL;
  }

  template <typename VType>
  bool insertOrError(const VType& value, cstr error)
  {
    (void)error;
    bool result = insertOrError(value);
    ErrorIf(result == false, "%s", error);
    return result;
  }

  template <typename KType, typename VType>
  bool insertOrError(const KType& key, const VType& value, cstr error)
  {
    return insertOrError(value_type(key, value), error);
  }

  bool insertNoOverwrite(const value_type& datapair)
  {
    return base_type::insertInternal(datapair, base_type::OnCollisionReturn) != NULL;
  }

  bool insertNoOverwrite(const key_type& key, const data_type& value)
  {
    return base_type::insertInternal(value_type(key, value), base_type::OnCollisionReturn) != NULL;
  }

  template<typename searchType, typename searchHasher>
  range find_as(const searchType& searchKey,
                searchHasher keyHasher = HashPolicy<searchType>())
  {
    Node* node = base_type::internal_find_as(searchKey, 
                                             PairHashAdapter< searchHasher,
                                                              searchType,
                                                              DataType >());
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  range find(const key_type& searchKey) const
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  bool tryGetValue(const key_type& searchKey, data_type& valueOut)
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != cHashOpenNode)
    {
      valueOut = node->Value.second;
      return true;
    }
    else
      return false;
  }

  void erase(const key_type& searchKey)
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != (Node*)cHashOpenNode)
      base_type::eraseNode(node);
  }

  size_t count(const key_type& searchKey)
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return 1;
    else
      return 0;
  }

  data_type findValue(const key_type& searchKey, const data_type& ifNotFound) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return foundNode->Value.second;
    else
      return ifNotFound;
  }

  //Returns a pointer to the value if found, or null if not found
  data_type* findPointer(const key_type& searchKey) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return &(foundNode->Value.second);
    else
      return NULL;
  }

  bool containsKey(const key_type& searchKey) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    return (foundNode != cHashOpenNode);
  }

  HashMap(const HashMap& other)
  {
    *this = other;
  }

  void operator = (const HashMap& other)
  {
    this->clear();
    range r = other.all();
    while(!r.empty())
    {
      insert(r.front());
      r.popFront();
    }
  }

private:
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file HashSet.hpp
/// Definition of the HashSet associative container.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Zero
{

template<typename Hasher, typename ValueType>
struct SetHashAdapter
{
  Hasher mHasher;
  size_t operator()(const ValueType& value)
  {
    return (size_t)mHasher(value);
  }

  bool equal(const ValueType& left, const ValueType& right)
  {
    return mHasher.equal(left, right);
  }

  template<typename othertype>
  bool equal(const ValueType& left, const othertype& right)
  {
    return mHasher.equal(left, right);
  }
};

///Hash Set is an Associative Hashed Container. 
template< typename ValueType, 
          typename Hasher = HashPolicy<ValueType>, 
          typename Allocator = DefaultAllocator >
class HashSet : public HashedContainer< ValueType, 
                                        SetHashAdapter< Hasher, ValueType >, 
                                        Allocator >
{
public:
  typedef ValueType value_type;
  typedef size_t size_type;
  typedef value_type& reference;
  typedef HashSet<ValueType, Hasher, Allocator> this_type;
  typedef HashedContainer< ValueType, 
                           SetHashAdapter< Hasher, ValueType >,
                           Allocator > base_type;
  typedef typename base_type::Node* iterator;
  typedef typename base_type::Node Node;
  typedef typename base_type::range range;

  HashSet()
  {
  }

  ///Warning: Depending on the contents of the hash sets, this may be expensive.
  HashSet(const HashSet& other)
  {
    *this = other;
  }

  ///Warning: Depending on the contents of the hash sets, this may be expensive.
  void operator = (const HashSet& other)
  {
    this->clear();
    range r = other.all();
    while(!r.empty())
    {
      base_type::insertInternal(r.front(), base_type::OnCollisionOverride);
      r.popFront();
    }
  }

  range find(const value_type& value)
  {
    //searching for the actual type of the container.
    Node* node = base_type::internal_find_as(value, base_type::mHasher);
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  template<typename searchType, typename searchHasher>
  range find_as(const searchType& searchKey, 
                searchHasher keyHasher = HashPolicy<searchType>()) const
  {
    Node* node = base_type::internal_find_as(searchKey, keyHasher);
    if(node != cHashOpenNode)
      return range(node, node + 1, 1);
    else
      return range((Node*)cHashOpenNode, (Node*)cHashOpenNode, 0);
  }

  value_type findValue(const value_type& searchKey, const value_type& ifNotFound) const
  {
    Node* node = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(node != cHashOpenNode)
      return node->Value;
    else
      return ifNotFound;
  }

  //Returns a pointer to the value if found, or null if not found
  value_type* findPointer(const value_type& searchKey) const
  {
    Node* foundNode = base_type::internal_find_as(searchKey, base_type::mHasher);
    if(foundNode != cHashOpenNode)
      return &(foundNode->Value);
    else
      return NULL;
  }

  void insert(const value_type& value)
  {
    base_type::insertInternal(value, base_type::OnCollisionOverride);
  }

  bool insertOrError(const value_type& value)
  {
    return base_type::insertInternal(value, base_type::OnCollisionError) != NULL;
  }

  bool insertOrError(const value_type& value, cstr error)
  {
    bool result = insertOrError(value);
    ErrorIf(result == false, "%s", error);
    return result;
  }

  bool insertNoOverwrite(const value_type& value)
  {
    return base_type::insertInternal(value, base_type::OnCollisionReturn) != NULL;
  }

  bool contains(const value_type& value)
  {
    return base_type::internal_find_as(value, base_type::mHasher)!=cHashOpenNode;
  }

  ~HashSet()
  {
  }
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file OwnedArray.hpp
/// Declaration of the OwnedArray container.
///
/// Authors: Trevor Sundberg
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Zero
{

//------------------------------------------------------------------------ OwnedArray

template<typename type, typename Allocator = DefaultAllocator, 
                        typename value_tt = StandardTraits<type> >
class OwnedArray : public Array<type, Allocator, value_tt>
{
public:

  //Deletes all elements within the array.
  ~OwnedArray()
  {
    for (size_t i = 0; i < this->size(); ++i)
    {
      delete (*this)[i];
    }
  }
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file BlockArray.hpp
/// Declaration of the BlockArray container.
///
/// Authors: Joshua Davis
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file Algorithm.hpp
/// Declaration of the basic algorithms for Containers.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

template<typename argument, typename result>
struct unary_function
{
  typedef argument argument_type;
  typedef result result_type;
};

template<typename argument0, typename argument1, typename result>
struct binary_function
{
  typedef argument0 first_argument_type;
  typedef argument1 second_argument_type;
  typedef result result_type;
};

#define StandardFunctor(name, operation)                    \
template<typename type>                                     \
struct name : public binary_function<type,type,bool>{       \
bool operator()(const type& left, const type& right) const{ \
return (left operation right);}};

StandardFunctor(equal_to, ==);
StandardFunctor(not_equal_to, !=);
StandardFunctor(less, <);
StandardFunctor(greater, >);
StandardFunctor(logical_and, &&);
StandardFunctor(logical_or, ||);

#undef StandardFunctor

// Linearly searches the input range and returns the range starting with either 
// the (value == searchValue) or an empty version of input range if value is not
// found.
template<typename inputRange, typename serachValueType>
inputRange find(inputRange input, const serachValueType& searchValue)
{
  while(!input.empty())
  {
    if(input.front() == searchValue)
      return input;
    input.popFront();
  }
  return input;
}

// Linearly searches the input range and returns the range starting with either 
// the Predicate(value) == true or an empty version of input range if value is not 
// found.
template<typename inputRange, typename Predicate>
inputRange find_if(inputRange input, Predicate predicate)
{
  while(!input.empty())
  {
    if(predicate(input.front()))
      return input;
    input.popFront();
  }
  return input;
}

template<typename inputRange, typename testInputRange>
inputRange find_first_of(inputRange input, testInputRange testInput)
{
  while(!input.empty())
  {
    for(testInputRange test = testInput; !test.empty(); test.popFront())
    {
      if(input.front() == test.front())
        return input;
    }
    input.popFront();
  }
  return input;
}

// Performs the unary operation on all elements in the range.
template<typename inputRange, typename unaryOperator>
void for_each(inputRange input, unaryOperator op)
{
  while(!input.empty())
  {
    op(input.front());
    input.popFront();
  }
}

// Transform all elements in input range using the unaryOperator and then place
// the result of the operation in outputRange.
template<typename inputRange, typename outputRange, typename unaryOperator>
void transform(inputRange input, outputRange output, unaryOperator op)
{
  ErrorIf(output.length() < input.length(), "Ouput range is smaller than input range.");
  while(!input.empty())
  {
    output.front() = op(input.front());
    output.popFront();
    input.popFront();
  }
}

// Copy values from one range to another
template<typename inputRange, typename outputRange>
void copy(inputRange input, outputRange output)
{
  ErrorIf(output.length() < input.length(), "Ouput range is smaller than input range.");
  while(!input.empty())
  {
    output.front() = input.front();
    output.popFront();
    input.popFront();
  }
}

// Set all values in range to source value
template<typename inputRange, typename fillType>
inline void fill(inputRange range, const fillType& sourceValue)
{
  while(!range.empty())
  {
    range.front() = sourceValue;
    range.popFront();
  }
}

// Check if two ranges are equal
template<typename inputRange0, typename inputRange1>
bool equal(inputRange0 range0, inputRange1 range1)
{
  while(!range0.empty() && !range1.empty())
  {
    if(!(range0.front() == range1.front()))
      return false;
    range0.popFront();
    range1.popFront();
  }

  if(range0.empty() && range1.empty())
    return true;
  else
    return false;
}

// Insertion sort
template<typename iterator, typename Comparer, typename type>
void insertionSort(iterator begin, iterator end, Comparer comparer, type* dummy)
{
  if(begin != end)
  {
    iterator iter = begin;
    ++iter;
    //Insert each element
    for(;iter != end; ++iter)
    {
      iterator insert = iter;
      type test = *insert;
      iterator prev = insert;
      --prev;

      while(comparer(test, *prev))
      {
        //Move previous up
        *insert = *prev;

        if(prev == begin)
        {
          --insert;
          break;
        }

        --prev;
        --insert;
      }

      //copy element into position
      *insert = test;
    }
  }
}

// partition used in quick sort
template<typename iterator, typename Comparer, typename type> 
inline Pair<iterator, iterator> partition(iterator first, iterator last, 
                                          Comparer comparer, type* dummy)
{
  size_t size = last - first;

  //Make last point to the last valid
  //element instead of the end
  --last;

  //make a pointer to the pivot
  iterator pivot = first;

  //Swap the pivot value to the front
  Zero::Swap(*pivot, *(first + size / 2));

  //Move first to the first valid element
  ++first;

  //Make sure the pivot is the median value (middle value) 
  //of the first, middle, and last elements. This prevents N^2 
  //performance on a already sorted list
  if(comparer(*last, *first))  Zero::Swap(*last, *first);
  if(comparer(*pivot, *first)) Zero::Swap(*pivot, *first);
  if(comparer(*last, *pivot))  Zero::Swap(*last, *pivot);

  //store the pivot value on the stack
  type pivotValue = *pivot;

  //keep looping while the iterators have not crossed
  while (first < last) 
  {
    //search from the left for a value greater
    //than the pivot
    do ++first; 
    while(comparer(*first, pivotValue));

    //search from the right for a value
    //less than the pivot
    do --last; 
    while(comparer(pivotValue, *last));

    //If the two value are not the middle
    if (first < last) 
    {
      Zero::Swap(*first, *last);
    }
  };

  //Move pivot back into position
  Zero::Swap(*pivot, *last);

  //return the last and first of the two new ranges.
  return Pair<iterator, iterator>(last, first);
}

const size_t cSortMaxStackSize = 40;
const size_t cSortLimit = 32;

// primary quick sort algorithm
template<typename iterator, typename Comparer, typename type>
void quickSort(iterator begin, iterator end, type* dummy, Comparer comparer)
{
  size_t stackSize = 0;

  // Instead of using recursion quick sort uses a static array
  // for performance
  Pair<iterator, iterator> rangeStack[cSortMaxStackSize];

  for(;;)
  {
    size_t rangeSize = end - begin;

    // Use quick sort for larger arrays
    if(rangeSize > cSortLimit)
    {
      Pair<iterator, iterator> division = partition(begin, end, comparer, dummy);

      // push the larger division for later
      // make the smaller division the current begin and end
      if(division.first - begin > end - division.second)
      {
        // left side larger
        rangeStack[stackSize] = make_pair(begin, division.first);
        ++stackSize;

        begin = division.second;
        // end stays the same
      }
      else
      {
        // right side larger
        rangeStack[stackSize] = make_pair(division.second, end);
        ++stackSize;

        // begin stays the same
        end = division.first;
      }

    }
    else
    {
      // Perform insertion sort on smaller range

      // if range is one element skip sorting
      if(rangeSize > 1)
      {
        insertionSort(begin, end, comparer, dummy);
      }

      // Pop the current range moving back
      if(stackSize > 0)
      {
        --stackSize;
        begin = rangeStack[stackSize].first;
        end = rangeStack[stackSize ].second;
      }
      else
      {
        // no more ranges sort is complete
        return;
      }
    }
  }
}

template<typename range,typename type>
void sortWithLess(range r, type* dummy)
{
  quickSort(r.begin(), r.end(), dummy, less<type>());
}

template<typename range>
void sort(range r)
{
  //if you see an error on this line, odds are you passed in an array instead of array.all()
  size_t temp = sizeof(typename range::contiguousRangeType);
  sortWithLess(r, &r.front());
}

template<typename range, typename Comparer>
void sort(range r, Comparer comparer)
{
  //if you see an error on this line, odds are you passed in an array instead of array.all()
  size_t temp = sizeof(typename range::contiguousRangeType);
  quickSort(r.begin(), r.end(), &r.front(), comparer);
}

template<typename iterator>
void reverse(iterator start, iterator end)
{
  --end;
  while(start<end)
  {
    Zero::Swap(*start, *end);
    ++start;
    --end;
  }
}

template<typename rangeType>
bool IsSorted(rangeType range)
{
  if(!range.empty())
  {
    rangeType r0 = range;
    rangeType r1 = range;
    r1.popFront();
    while(!r1.empty())
    {
      if(r1.front()  < r0.front())
        return false;
      r0.popFront();
      r1.popFront();
    }
  }
  return true;
}

template<typename rangeType, typename searchType, typename valueType>
valueType& BinarySearch(rangeType& range, const searchType& searchValue, valueType& valueIfNotFound)
{
  size_t begin = 0;
  size_t end = range.size();

  while(begin < end)
  {
    size_t mid = (begin+end) / 2;
    if(range[mid] < searchValue)
    {
      begin = mid + 1;
    }
    else
    {
      end = mid;
    }
  }

  if((begin < range.size()) && (range[begin] == searchValue))
  {
    return range[begin];
  }
  else
  {
    return valueIfNotFound;
  }
}

template<typename rangeType, typename Predicate>
rangeType search(rangeType searchRange, rangeType toFind, Predicate predicate)
{
  size_t findSize = toFind.size();
  while(searchRange.size() >= findSize)
  {
    rangeType r0 = searchRange;
    rangeType find = toFind;
    while(!r0.empty() && predicate(r0.front(), find.front()))
    {
      r0.popFront();
      find.popFront();

      if(find.empty())
        return searchRange;
    }

    searchRange.popFront();
  }

  //make the range empty
  searchRange.popFront(searchRange.size());

  return searchRange;
}

template<typename rangeType> 
rangeType search(rangeType searchRange, rangeType toFind)
{
  return search(searchRange, toFind, equal_to<typename rangeType::value_type>());
}

// Inserts a value into a sorted list
// return true if value was inserted false if
// value was already in the list
template<typename containertype, typename type>
bool SortedInsert(containertype& container, type& value)
{
  typename containertype::iterator cur = container.begin();
  typename containertype::iterator end = container.end();
  while(cur != end)
  {
    type& currentValue = *cur;
    if(value < currentValue)
    {
      // value is less than current value
      // insert the value at this location
      container.insert(cur, value);
      return true;
    }
    else if(value == currentValue)
    {
      // already in list
      // failed to insert
      return false;
    }
    ++cur;
  }

  //insert at end
  container.push_back(value);
  return true;
}

//Array Algorithms

template<typename desttype, typename range>
void PushAll(desttype& a, range inputRange )
{
  for(;!inputRange.empty();inputRange.popFront())
  {
    a.push_back(inputRange.front());
  }
}

template<typename type>
struct EqualTo
{
  EqualTo(type& value)
    :TestValue(value)
  {
  }

  type TestValue;

  bool operator()(type& any)
  {
    return TestValue == any;
  }
};

const size_t NotFoundIndex = (size_t)-1;

// Find the index of the first value that passes the predicate
// or NotFoundIndex when not found
template<typename ArrayType, typename Predicate>
size_t FindFirstIndex(ArrayType& array, Predicate predicate)
{
  // Loop through elements
  size_t size = array.size();
  for (size_t i = 0; i < size; ++i)
  {
    // Found value return
    if(predicate(array[i]))
      return i;
  }
  return NotFoundIndex;
}

// Remove all elements that do not pass Predicate
template<typename ArrayType, typename Predicate>
size_t RemoveAll(ArrayType& array, Predicate predicate)
{
  // Loop through all elements in the array
  // Copying over valid elements 
  size_t sourceIndex = 0;
  size_t destIndex = 0;
  size_t size = array.size();
  size_t removeCount = 0;

  for(; sourceIndex < size;)
  {
    if(predicate(array[sourceIndex]))
    {
      // If not valid just move forward source
      ++sourceIndex;
      ++removeCount;
    }
    else
    {
      // Need to keep value in array

      // Do not copy if already in place
      if(sourceIndex != destIndex)
      {
        array[destIndex] = array[sourceIndex];
      }

      // Move both forward
      ++destIndex;
      ++sourceIndex;
    }
  }

  // get rid of unused elements at the end
  array.resize(destIndex);
  return removeCount;
}

// Remove a element placing last element in its place
// to prevent extra copying
template<typename ArrayType>
void RemoveSwap(ArrayType& array, size_t index)
{
  array[index] = array.back();
  array.pop_back();
}

}//namespace Zero

namespace Zero
{

///Generic front deque array class. Store objects in buckets of a 1 << shiftSize.
///Fast when the total number of objects being inserted is not known.
///Currently hardcoded as only storing pod types.
template<typename type, uint shiftSize = 6, typename Allocator = DefaultAllocator>
class PodBlockArray : public AllocationContainer<Allocator>
{
public:
  //-------------------------------------------------------- Standard Typedefs
  typedef type value_type;
  typedef value_type* pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef PodBlockArray<type, shiftSize, Allocator> this_type;
  typedef AllocationContainer<Allocator> base_type;
  using base_type::mAllocator;

  enum
  {
    /*used to determine the size of a bucket as well as to mask off
    the lower bits and determine the number of buckets*/
    ShiftSize = shiftSize,
    BucketSize = 1 << ShiftSize,//the size of a bucket (how many objects)
    BucketMask = BucketSize - 1,//mask to determine the index within a bucket
  };

  struct iterator
  {
    iterator()
    {
      mBlockArray = NULL;
      mCurrentIndex = 0;
    }

    iterator(this_type* blockArray, size_type startIndex)
    {
      mBlockArray = blockArray;
      mCurrentIndex = startIndex;
    }

    void operator++()
    {
      ++mCurrentIndex;
    }

    void operator--()
    {
      --mCurrentIndex;
    }

    reference operator*()
    {
      return (*mBlockArray)[mCurrentIndex];
    }

    size_type operator-(const iterator& other)
    {
      return mCurrentIndex - other.mCurrentIndex;
    }

    iterator operator+(size_type offset)
    {
      return iterator(mBlockArray, mCurrentIndex + offset);
    }

    bool operator==(const iterator& other)
    {
      if(mBlockArray == other.mBlockArray && 
         mCurrentIndex == other.mCurrentIndex)
        return true;
      return false;
    }

    bool operator<(const iterator& other)
    {
      return mCurrentIndex < other.mCurrentIndex;
    }

    bool operator!=(const iterator& other)
    {
      return !(*this == other);
    }

    this_type* mBlockArray;
    size_type mCurrentIndex;
  };

  struct range
  {
    range()
    {
      mCurrentIndex = 0;
      mEndIndex = 0;
      mBlockArray = NULL;
    }

    range(this_type* blockArray)
    {
      mBlockArray = blockArray;
      mCurrentIndex = 0;
      mEndIndex = blockArray->mSize;
    }

    range(this_type* blockArray, size_type startIndex, size_type endIndex)
    {
      mBlockArray = blockArray;
      mCurrentIndex = startIndex;
      mEndIndex = endIndex;
    }

    reference front()
    {
      return (*mBlockArray)[mCurrentIndex];
    }

    void popFront()
    {
      ++mCurrentIndex;
    }

    bool empty()
    {
      return mCurrentIndex >= mEndIndex;
    }

    iterator begin()
    {
      return iterator(mBlockArray,mCurrentIndex);
    }

    iterator end()
    {
      return iterator(mBlockArray,mEndIndex);
    }

    this_type* mBlockArray;
    size_type mCurrentIndex;
    size_type mEndIndex;
  };

  PodBlockArray()
  {
    mSize = 0;
    mCapacity = 0;
    mData = NULL;
  }

  PodBlockArray(const this_type& other)
  {
    mSize = 0;
    mCapacity = 0;
    mData = NULL;
    copy(other);
  }

  PodBlockArray(size_type size)
  {
    mData = NULL;
    mSize = 0;
    mCapacity = 0;
    resize(size);
  }

  PodBlockArray(size_type size, const_reference defaultValue)
  {
    mData = NULL;
    mSize = 0;
    mCapacity = 0;
    resize(size, defaultValue);
  }

  ~PodBlockArray()
  {
    deallocate();
  }

  void operator=(const this_type& other)
  {
    copy(other);
  }

  bool empty() const
  {
    return mSize == 0;
  }

  size_t size() const
  {
    return mSize;
  }

  reference operator[](size_t index)
  {
    ErrorIf(index > mSize, "Accessed block array out of bounds.");
    return mData[index >> ShiftSize][index & BucketMask];
  }

  const_reference operator[](size_t index) const
  {
    ErrorIf(index > mSize, "Accessed block array out of bounds.");
    return mData[index >> ShiftSize][index & BucketMask];
  }

  iterator begin()
  {
    return iterator(this,0);
  }

  iterator end()
  {
    return iterator(this, mSize);
  }

  reference front()
  {
    ErrorIf(mSize == 0, "Empty block array, no front element.");
    return mData[0][0];
  }

  const_reference front() const
  {
    ErrorIf(mSize == 0, "Empty block array, no front element.");
    return mData[0][0];
  }

  reference back()
  {
    ErrorIf(mSize == 0, "Empty block array, no back element.");
    return (*this)[mSize - 1];
  }

  const_reference back() const
  {
    ErrorIf(mSize == 0, "Empty block array, no back element.");
    return (*this)[mSize - 1];
  }

  void push_back(const_reference item)
  {
    //if adding one object causes us to go over our capacity,
    //then increase our capacity by one bucket
    if(mSize >= mCapacity)
      change_capacity(mCapacity + 1);

    //insert the new item at the last index
    (*this)[mSize] = item;
    ++mSize;
  }
  
  reference push_back()
  {
    //see the above push_back
    if(mSize >= mCapacity)
      change_capacity(mCapacity + 1);

    //we aren't filling in the last item, just giving
    //back a reference for the user to fill out
    ++mSize;
    return (*this)[mSize - 1];
  }

  void pop_back()
  {
    ErrorIf(mSize == 0,"Empty block array, can not pop back element.");
    //don't change capacity at all, just decrement our size
    //(since we are pod we don't have to call a destructor on the last item)
    --mSize;
  }

  void clear()
  {
    //pod assumption, don't call destructors on the objects
    mSize = 0;
  }

  void deallocate()
  {
    size_type bucketCount = bucketCountFromSize(mCapacity);
    //deallocate all of our buckets
    for(uint i = 0; i < bucketCount; ++i)
      mAllocator.Deallocate(mData[i], sizeof(value_type) * BucketSize);
    //now deallocate the array of our buckets
    mAllocator.Deallocate(mData, sizeof(pointer) * bucketCount);
  }

  void change_capacity(size_type newCapacity)
  {
    //we never shrink at the moment, so if the capacity is the same or less do nothing
    if(newCapacity <= mCapacity)
      return;

    //round capacity up to the next bucket size
    if(newCapacity & BucketMask)
      newCapacity = (newCapacity & ~BucketMask) + (1 << ShiftSize);

    size_type newBucketSize = bucketCountFromSize(newCapacity);
    size_type oldBucketSize = bucketCountFromSize(mCapacity);
    //allocate our new array of buckets
    pointer* newData = (pointer*)mAllocator.Allocate(newBucketSize * sizeof(pointer));
    
    //if we had any buckets previously, copy over our pointers to them
    //then deallocate the old array of buckets
    if(mCapacity != 0)
    {
      uninitialized_move(newData,mData,oldBucketSize,true_type());
      mAllocator.Deallocate(mData, sizeof(pointer) * oldBucketSize);
    }

    //now allocate any new buckets we need
    for(size_t i = oldBucketSize; i < newBucketSize; ++i)
      newData[i] = (pointer)mAllocator.Allocate(sizeof(value_type) * BucketSize);

    //finally set our new state
    mData = newData;
    mCapacity = newCapacity;
  }

  range all()
  {
    return range(this);
  }

  //Returns and range for all the elements in the container.
  range all() const
  {
    return const_cast<PodBlockArray*>(this)->all();
  }

  range sub_range(size_type index, size_type length)
  {
    ErrorIf(index >= mSize, "Accessed block array out of bounds.");
    ErrorIf(index + length > mSize, "Accessed block array out of bounds.");
    return range(this, index, index + length);
  }

  bool operator==(this_type& other)
  {
    return equal(this->all(), other.all());
  }

  void resize(size_t newSize)
  {
    //resizing to the same size, do nothing
    if(mSize == newSize)
      return;

    //we only need to handle getting bigger, because getting smaller is
    //just overriding our size variable (pod assumption)

    //if our new size causes us to go beyond our capacity,
    //compute and change the capacity
    if(newSize > mCapacity)
      change_capacity(newSize);

    mSize = newSize;
  }

  void resize(size_t newSize, const_reference defaultvalue)
  {
    //resizing to the same size, do nothing
    if(mSize == newSize)
      return;

    //compute our old/new capacity and the index inside of those buckets
    size_type newBucketCount = (newSize >> ShiftSize);
    size_type oldBucketCount = (mSize >> ShiftSize);
    size_type newBucketIndex = newSize & BucketMask;
    size_type oldBucketIndex = mSize & BucketMask;

    //update the capacity
    change_capacity(newSize);
      
    //now we have to set the default value in all of the new buckets (only if we grew)
    if(newSize > mSize)
    {
      //first, set the default value in any remaining portion of the old bucket
      uninitialized_fill(mData[oldBucketCount] + oldBucketIndex, BucketSize - oldBucketIndex, defaultvalue);

      //if we aren't changing the bucket size we are done
      if(oldBucketCount != newBucketCount)
      {
        //now fill any complete buckets up
        for(uint i = oldBucketCount + 1; i < newBucketCount; ++i)
          uninitialized_fill(mData[i], BucketSize, defaultvalue);
        //finally, fill out the used portion of the last bucket
        uninitialized_fill(mData[newBucketCount],newBucketIndex,defaultvalue);
      }
    }

    mSize = newSize;
  }

  void copy(const this_type& other)
  {
    //fix our size to be the same as the other object
    resize(other.mSize);

    //if we have no size, don't do anything
    if(other.mSize == 0)
      return;

    size_type bucketSize = bucketCountFromSize(mSize);
    size_type lastBucket = bucketSize - 1;
    size_type lastBucketFillCount = mSize & BucketMask;

    //fill out all complete buckets
    for(size_type i = 0; i < lastBucket; ++i)
      uninitialized_copy(mData[i],other.mData[i],BucketSize,true_type());
    //fill out the remaining portion of the last bucket
    uninitialized_copy(mData[lastBucket],other.mData[lastBucket],lastBucketFillCount,true_type());
  }

  size_type bucketCountFromSize(size_type size)
  {
    size_type buckets = size >> ShiftSize;
    if(size & BucketMask)
      ++buckets;
    return buckets;
  }

  ///The current number of items we have
  size_type mSize;
  ///The max number of items we can store before we
  ///need to allocate more (bucketSize * numOfBuckets)
  size_type mCapacity;
  ///The start of our 2d array
  pointer* mData;
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file ForEachRange.hpp
/// Range based for each macro.
///
/// Authors: Chris Peters
/// Copyright 2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#if !ZeroHasAuto && !ZeroHasTypeOf 

//namespace to contain helpers functions
namespace fr
{

//System for getting the type with out evaluating the expression.

//Type holder
template<typename type> struct typeOf{ typedef type encodedType; };

//Convert an expression of given type to an
//expression of type typeOf<type>
template<typename type>
typeOf<type> EncodeType(const type& t)
{
  return typeOf<type>();
}

//Convertible to typeOf<type> for any type
struct AnyTypeConvert
{
  template<typename type>
  operator typeOf<type> () const
  {
    return typeOf<type>();
  }
};

//Convert an expression to the type typeOf<type> without
//evaluating the expression by using the properties of the
//ternary operator.
#define ENCODED_TYPEOF(container) \
  (true ? fr::AnyTypeConvert() : fr::EncodeType(container))

struct RangeBase
{
  operator bool() const { return false; }
};

template<typename type>
struct AnyRange : RangeBase
{
  AnyRange(const type& r) : item(r) {}
  mutable type item;
};

//Return a stack version of the Range
//life time will be extened by reference
template<typename type>
AnyRange<type> BuildRange(const type& begin)
{
  return AnyRange<type>(begin);
}

template<typename type>
type& RangeCast(RangeBase& any)
{
  return static_cast<AnyRange<type>&>(any).item;
}

//Range based functions
template<typename type>
bool IsEmpty(RangeBase& r, typeOf<type>)
{
  return RangeCast<type>(r).empty();
}

template<typename type>
void PopFront(RangeBase& r, typeOf<type>)
{
  RangeCast<type>(r).popFront();
}

template<typename type>
typename type::value_type& 
  Front(RangeBase& r, typeOf<type>)
{
  return RangeCast<type>(r).front();
}

}//namespace fr

#define forRange(value, rangeExpr)                              \
  for(fr::RangeBase& __rangeT = fr::BuildRange(rangeExpr);      \
  !fr::IsEmpty(__rangeT, ENCODED_TYPEOF(rangeExpr));            \
   fr::PopFront(__rangeT, ENCODED_TYPEOF(rangeExpr)))           \
  if(bool __forEachLoopOnce = true)                             \
  for(value = fr::Front(__rangeT, ENCODED_TYPEOF(rangeExpr));   \
  __forEachLoopOnce; __forEachLoopOnce = false)

#else

#if ZeroHasTypeOf

//Use type of expression
#define forRange(value, rangeExpr)                                                    \
  for(TypeOf(rangeExpr) __rangeT = rangeExpr;!__rangeT.empty();__rangeT.popFront())   \
  if(bool __forEachLoopOnce = true)                                                   \
  for(value = __rangeT.front() ;   __forEachLoopOnce; __forEachLoopOnce = false)

#else

//With auto this is much easier to define
#define forRange(value, rangeExpr)                                                \
  for(auto __rangeT = rangeExpr;!__rangeT.empty();__rangeT.popFront())            \
  if(bool __forEachLoopOnce = true)                                               \
  for(value = __rangeT.front() ;   __forEachLoopOnce; __forEachLoopOnce = false)

#endif

#endif

#pragma once

namespace Zero
{

/// UniquePointer takes sole ownership over a pointer and 
/// deletes it when is goes out of scope
template<typename Type>
class UniquePointer
{
public:
  UniquePointer(Type* type) { mPointer = type; }
  UniquePointer() { mPointer = nullptr; }
  ~UniquePointer() { Reset(); }
  
#ifdef SupportsMoveSemantics
  UniquePointer(UniquePointer&& other)
  {
    // Steal Pointer from rvalue
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
  
  void operator=(UniquePointer&& other)
  {
    // Self Check
    if(this != &other)
      return;
  
    Reset();
    // Steal Pointer from rvalue
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
#else
  UniquePointer(UniquePointer& other)
  {
    mPointer = other.mPointer;
    other.mPointer = nullptr;
  }
#endif

  Type* operator->() { return mPointer; }
  Type& operator*() { return *mPointer; }
  operator Type*() { return mPointer; }

  void operator=(Type* pointer)
  {
    Reset();
    mPointer = pointer;
  }

  // Reset pointer back to null
  void Reset()
  {
    if(mPointer)
    {
      delete mPointer;
      mPointer = nullptr;
    }
  }

  // Take ownership of pointer
  Type* Release()
  {
    Type* pointer = mPointer;
    mPointer = nullptr;
    return pointer;
  }

private:

#ifdef SupportsMoveSemantics
  // Can not copy UniquePointer
  UniquePointer(const UniquePointer& other);
  void operator=(const UniquePointer& other);
#endif

  Type* mPointer;
};

template<typename type>
UniquePointer<type> AutoHandle(type* event)
{
  UniquePointer<type> handle(event);
  return handle;
}

template<typename type>
UniquePointer<type> MakeUnique()
{
  return UniquePointer<type>(new type());
}

template<typename type, typename param0>
UniquePointer<type> MakeUnique(const param0& p0)
{
  return UniquePointer<type>(new type(p0));
}

template<typename type, typename param0, typename param1>
UniquePointer<type> MakeUnique(const param0& p0, const param0& p1)
{
  return UniquePointer<type>(new type(p0, p1));
}

}

///////////////////////////////////////////////////////////////////////////////
///
/// \file Atomic.hpp
/// Declaration of the atomic functions.
///
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

// Atomic functions are for fast atomic (non interruptible) multithreaded operations. 
// Used to implement lock free data structures and create multithread safe resources.

//Atomically add a number to the address
s32 AtomicAdd(volatile s32* number, s32 valueToAdd);

//Atomically increment a number
s32 AtomicIncrement(volatile s32* number);

//Atomically decrement a number
s32 AtomicDecrement(volatile s32* number);

//Attempt to swap the 32 bit number with the exchange value if its value is equal to comparison.
//Function will fail if the number was not equal to the comparison value.
bool AtomicCompareExchange(volatile s32* number, s32 exchange, s32 comparison);

//Attempt to swap the 64 bit number with the exchange value if its value is equal to comparison.
//Function will fail if the number was not equal to the comparison value.
bool AtomicCompareExchange64(volatile s64* number, s64 exchange, s64 comparison);

}

///////////////////////////////////////////////////////////////////////////////
///
/// \file Socket.hpp
/// Declaration of the Socket.
///
/// Authors: Trevor Sundberg
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes
///////////////////////////////////////////////////////////////////////////////
///
/// \file OsShared.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

typedef void *OsHandle;
typedef unsigned long OsInt;
const OsHandle cInvalidHandle = (OsHandle)0xFFFFFFFF; 
const uint cDebugNameMax = 32;

class StackHandle
{
public:
  StackHandle()
  {
    mHandle = cInvalidHandle;
  }

  ~StackHandle()
  {
    Close();
  }

  OsHandle Transfer()
  {
    OsHandle handle = mHandle;
    mHandle = cInvalidHandle;
    return handle;
  }

  void operator=(OsHandle handle)
  {
    mHandle = handle;
  }

  operator OsHandle*()
  {
    return &mHandle;
  }

  operator OsHandle()
  {
    return mHandle;
  }

  void Close();
  
private:
  OsHandle mHandle;
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file EnumDeclaration.hpp
/// Declaration of enum declaration macros.
///
/// Authors: Joshua Claeys, Joshua Davis, Auto-Generated
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

//Used to determine whether or not the enum is going to be used as a bit field
//or an index.  As a bit field, each index needs to be shifted.
#define _BitField() 1 << 
#define _Indexed() 
#define _AddNone(name) namespace name { enum {None}; }  

#define _ExpandNames1(name,mode,value1)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0};                                          \
  enum {Size = 1};                                                            \
  static cstr Names[] = {#value1, NULL};                                      \
  }                                                                           \

#define _ExpandNames2(name,mode,value1,value2)                                \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1};                         \
  enum {Size = 2};                                                            \
  static cstr Names[] = {#value1, #value2, NULL};                             \
  }                                                                           \

#define _ExpandNames3(name,mode,value1,value2,value3)                         \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2};        \
  enum {Size = 3};                                                            \
  static cstr Names[] = {#value1, #value2, #value3, NULL};                    \
  }                                                                           \

#define _ExpandNames4(name,mode,value1,value2,value3,value4)                  \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3};                                          \
  enum {Size = 4};                                                            \
  static cstr Names[] = {#value1, #value2, #value3, #value4, NULL};           \
  }                                                                           \

#define _ExpandNames5(name,mode,value1,value2,value3,value4,value5)           \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4};                         \
  enum {Size = 5};                                                            \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5, NULL};  \
  }                                                                           \

#define _ExpandNames6(name,mode,value1,value2,value3,value4,value5,value6)    \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5};        \
  enum {Size = 6};                                                            \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, NULL};                                      \
  }                                                                           \

#define _ExpandNames7(name,mode,value1,value2,value3,value4,value5,value6,    \
                      value7)                                                 \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6};                                          \
  enum {Size = 7};                                                            \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, NULL};                             \
  }                                                                           \

#define _ExpandNames8(name,mode,value1,value2,value3,value4,value5,value6,    \
                      value7,value8)                                          \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7};                         \
  enum {Size = 8};                                                            \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, NULL};                    \
  }                                                                           \

#define _ExpandNames9(name,mode,value1,value2,value3,value4,value5,value6,    \
                      value7,value8,value9)                                   \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8};        \
  enum {Size = 9};                                                            \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, NULL};           \
  }                                                                           \

#define _ExpandNames10(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10)                          \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9};                                         \
  enum {Size = 10};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10, NULL}; \
  }                                                                           \

#define _ExpandNames11(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11)                  \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10};                      \
  enum {Size = 11};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, NULL};                                     \
  }                                                                           \

#define _ExpandNames12(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12)          \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11};   \
  enum {Size = 12};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, NULL};                           \
  }                                                                           \

#define _ExpandNames13(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13)  \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12};                                        \
  enum {Size = 13};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, NULL};                 \
  }                                                                           \

#define _ExpandNames14(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13};                     \
  enum {Size = 14};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, NULL};       \
  }                                                                           \

#define _ExpandNames15(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14};  \
  enum {Size = 15};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         NULL};                                               \
  }                                                                           \

#define _ExpandNames16(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16)                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15};                                        \
  enum {Size = 16};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, NULL};                                     \
  }                                                                           \

#define _ExpandNames17(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17)                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16};                     \
  enum {Size = 17};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, NULL};                           \
  }                                                                           \

#define _ExpandNames18(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18)               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17};  \
  enum {Size = 18};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, NULL};                 \
  }                                                                           \

#define _ExpandNames19(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19)       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18};                                        \
  enum {Size = 19};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, NULL};       \
  }                                                                           \

#define _ExpandNames20(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19};                     \
  enum {Size = 20};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         NULL};                                               \
  }                                                                           \

#define _ExpandNames21(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20};  \
  enum {Size = 21};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, NULL};                                     \
  }                                                                           \

#define _ExpandNames22(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22)                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21};                                        \
  enum {Size = 22};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, NULL};                           \
  }                                                                           \

#define _ExpandNames23(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23)                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22};                     \
  enum {Size = 23};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, NULL};                 \
  }                                                                           \

#define _ExpandNames24(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24)               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23};  \
  enum {Size = 24};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, NULL};       \
  }                                                                           \

#define _ExpandNames25(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25)       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24};                                        \
  enum {Size = 25};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         NULL};                                               \
  }                                                                           \

#define _ExpandNames26(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25};                     \
  enum {Size = 26};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         #value26, NULL};                                     \
  }                                                                           \

#define _ExpandNames27(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27)                                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26};  \
  enum {Size = 27};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         #value26, #value27, NULL};                           \
  }                                                                           \

#define _ExpandNames28(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28)                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27};                                        \
  enum {Size = 28};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         #value26, #value27, #value28, NULL};                 \
  }                                                                           \

#define _ExpandNames29(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29)                       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28};                     \
  enum {Size = 29};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         #value26, #value27, #value28, #value29, NULL};       \
  }                                                                           \

#define _ExpandNames30(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29,value30)               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28, value30 = mode 29};  \
  enum {Size = 30};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         #value26, #value27, #value28, #value29, #value30,    \
                         NULL};                                               \
  }                                                                           \

#define _ExpandNames31(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29,value30,value31)       \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28, value30 = mode 29,   \
                   value31 = mode 30};                                        \
  enum {Size = 31};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         #value26, #value27, #value28, #value29, #value30,    \
                         #value31, NULL};                                     \
  }                                                                           \

#define _ExpandNames32(name,mode,value1,value2,value3,value4,value5,value6,   \
                       value7,value8,value9,value10,value11,value12,value13,  \
                       value14,value15,value16,value17,value18,value19,       \
                       value20,value21,value22,value23,value24,value25,       \
                       value26,value27,value28,value29,value30,value31,       \
                       value32)                                               \
  namespace name                                                              \
  {                                                                           \
  typedef uint Type;                                                          \
  static cstr EnumName = #name;                                               \
  enum       Enum {value1 = mode 0, value2 = mode 1, value3 = mode 2,         \
                   value4 = mode 3, value5 = mode 4, value6 = mode 5,         \
                   value7 = mode 6, value8 = mode 7, value9 = mode 8,         \
                   value10 = mode 9, value11 = mode 10, value12 = mode 11,    \
                   value13 = mode 12, value14 = mode 13, value15 = mode 14,   \
                   value16 = mode 15, value17 = mode 16, value18 = mode 17,   \
                   value19 = mode 18, value20 = mode 19, value21 = mode 20,   \
                   value22 = mode 21, value23 = mode 22, value24 = mode 23,   \
                   value25 = mode 24, value26 = mode 25, value27 = mode 26,   \
                   value28 = mode 27, value29 = mode 28, value30 = mode 29,   \
                   value31 = mode 30, value32 = mode 31};                     \
  enum {Size = 32};                                                           \
  static cstr Names[] = {#value1, #value2, #value3, #value4, #value5,         \
                         #value6, #value7, #value8, #value9, #value10,        \
                         #value11, #value12, #value13, #value14, #value15,    \
                         #value16, #value17, #value18, #value19, #value20,    \
                         #value21, #value22, #value23, #value24, #value25,    \
                         #value26, #value27, #value28, #value29, #value30,    \
                         #value31, #value32, NULL};                           \
  }                                                                           \

#define DeclareEnum1(name,v1)                                                 \
        _ExpandNames1(name,_Indexed(),v1)
#define DeclareEnum2(name,v1,v2)                                              \
        _ExpandNames2(name,_Indexed(),v1,v2)
#define DeclareEnum3(name,v1,v2,v3)                                           \
        _ExpandNames3(name,_Indexed(),v1,v2,v3)
#define DeclareEnum4(name,v1,v2,v3,v4)                                        \
        _ExpandNames4(name,_Indexed(),v1,v2,v3,v4)
#define DeclareEnum5(name,v1,v2,v3,v4,v5)                                     \
        _ExpandNames5(name,_Indexed(),v1,v2,v3,v4,v5)
#define DeclareEnum6(name,v1,v2,v3,v4,v5,v6)                                  \
        _ExpandNames6(name,_Indexed(),v1,v2,v3,v4,v5,v6)
#define DeclareEnum7(name,v1,v2,v3,v4,v5,v6,v7)                               \
        _ExpandNames7(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7)
#define DeclareEnum8(name,v1,v2,v3,v4,v5,v6,v7,v8)                            \
        _ExpandNames8(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8)
#define DeclareEnum9(name,v1,v2,v3,v4,v5,v6,v7,v8,v9)                         \
        _ExpandNames9(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9)
#define DeclareEnum10(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)                    \
        _ExpandNames10(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)
#define DeclareEnum11(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)                \
        _ExpandNames11(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)
#define DeclareEnum12(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12)            \
        _ExpandNames12(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12)
#define DeclareEnum13(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13)        \
        _ExpandNames13(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13)
#define DeclareEnum14(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14)    \
        _ExpandNames14(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14)
#define DeclareEnum15(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15)\
        _ExpandNames15(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15)
#define DeclareEnum16(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16)                                                    \
        _ExpandNames16(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16)
#define DeclareEnum17(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17)                                                \
        _ExpandNames17(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17)
#define DeclareEnum18(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18)                                            \
        _ExpandNames18(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18)
#define DeclareEnum19(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19)                                        \
        _ExpandNames19(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19)
#define DeclareEnum20(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20)                                    \
        _ExpandNames20(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20)
#define DeclareEnum21(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21)                                \
        _ExpandNames21(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21)
#define DeclareEnum22(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22)                            \
        _ExpandNames22(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22)
#define DeclareEnum23(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23)                        \
        _ExpandNames23(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23)
#define DeclareEnum24(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24)                    \
        _ExpandNames24(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24)
#define DeclareEnum25(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25)                \
        _ExpandNames25(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25)
#define DeclareEnum26(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26)            \
        _ExpandNames26(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26)
#define DeclareEnum27(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27)        \
        _ExpandNames27(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27)
#define DeclareEnum28(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28)    \
        _ExpandNames28(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28)
#define DeclareEnum29(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29)\
        _ExpandNames29(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29)
#define DeclareEnum30(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29,\
                      v30)                                                    \
        _ExpandNames30(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29,v30)
#define DeclareEnum31(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29,\
                      v30,v31)                                                \
        _ExpandNames31(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29,v30,v31)
#define DeclareEnum32(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,\
                      v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,v28,v29,\
                      v30,v31,v32)                                            \
        _ExpandNames32(name,_Indexed(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,\
                       v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,   \
                       v26,v27,v28,v29,v30,v31,v32)

#define DeclareBitField1(name,v1)                                             \
        _ExpandNames1(name,_BitField(),v1)                                    \
        _AddNone(name)
#define DeclareBitField2(name,v1,v2)                                          \
        _ExpandNames2(name,_BitField(),v1,v2)                                 \
        _AddNone(name)
#define DeclareBitField3(name,v1,v2,v3)                                       \
        _ExpandNames3(name,_BitField(),v1,v2,v3)                              \
        _AddNone(name)
#define DeclareBitField4(name,v1,v2,v3,v4)                                    \
        _ExpandNames4(name,_BitField(),v1,v2,v3,v4)                           \
        _AddNone(name)
#define DeclareBitField5(name,v1,v2,v3,v4,v5)                                 \
        _ExpandNames5(name,_BitField(),v1,v2,v3,v4,v5)                        \
        _AddNone(name)
#define DeclareBitField6(name,v1,v2,v3,v4,v5,v6)                              \
        _ExpandNames6(name,_BitField(),v1,v2,v3,v4,v5,v6)                     \
        _AddNone(name)
#define DeclareBitField7(name,v1,v2,v3,v4,v5,v6,v7)                           \
        _ExpandNames7(name,_BitField(),v1,v2,v3,v4,v5,v6,v7)                  \
        _AddNone(name)
#define DeclareBitField8(name,v1,v2,v3,v4,v5,v6,v7,v8)                        \
        _ExpandNames8(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8)               \
        _AddNone(name)
#define DeclareBitField9(name,v1,v2,v3,v4,v5,v6,v7,v8,v9)                     \
        _ExpandNames9(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9)            \
        _AddNone(name)
#define DeclareBitField10(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)                \
        _ExpandNames10(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10)       \
        _AddNone(name)
#define DeclareBitField11(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)            \
        _ExpandNames11(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11)   \
        _AddNone(name)
#define DeclareBitField12(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12)        \
        _ExpandNames12(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12)                                                   \
        _AddNone(name)
#define DeclareBitField13(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13)    \
        _ExpandNames13(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13)                                               \
        _AddNone(name)
#define DeclareBitField14(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14)\
        _ExpandNames14(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14)                                           \
        _AddNone(name)
#define DeclareBitField15(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15)                                                \
        _ExpandNames15(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15)                                       \
        _AddNone(name)
#define DeclareBitField16(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16)                                            \
        _ExpandNames16(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16)                                   \
        _AddNone(name)
#define DeclareBitField17(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17)                                        \
        _ExpandNames17(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17)                               \
        _AddNone(name)
#define DeclareBitField18(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18)                                    \
        _ExpandNames18(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18)                           \
        _AddNone(name)
#define DeclareBitField19(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19)                                \
        _ExpandNames19(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19)                       \
        _AddNone(name)
#define DeclareBitField20(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20)                            \
        _ExpandNames20(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20)                   \
        _AddNone(name)
#define DeclareBitField21(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21)                        \
        _ExpandNames21(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21)               \
        _AddNone(name)
#define DeclareBitField22(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22)                    \
        _ExpandNames22(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22)           \
        _AddNone(name)
#define DeclareBitField23(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23)                \
        _ExpandNames23(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23)       \
        _AddNone(name)
#define DeclareBitField24(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24)            \
        _ExpandNames24(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24)   \
        _AddNone(name)
#define DeclareBitField25(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25)        \
        _ExpandNames25(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25)                                                   \
        _AddNone(name)
#define DeclareBitField26(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26)    \
        _ExpandNames26(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26)                                               \
        _AddNone(name)
#define DeclareBitField27(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27)\
        _ExpandNames27(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27)                                           \
        _AddNone(name)
#define DeclareBitField28(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28)                                                \
        _ExpandNames28(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28)                                       \
        _AddNone(name)
#define DeclareBitField29(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29)                                            \
        _ExpandNames29(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29)                                   \
        _AddNone(name)
#define DeclareBitField30(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29,v30)                                        \
        _ExpandNames30(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29,v30)                               \
        _AddNone(name)
#define DeclareBitField31(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29,v30,v31)                                    \
        _ExpandNames31(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29,v30,v31)                           \
        _AddNone(name)
#define DeclareBitField32(name,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,\
                          v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,v25,v26,v27,\
                          v28,v29,v30,v31,v32)                                \
        _ExpandNames32(name,_BitField(),v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,   \
                       v12,v13,v14,v15,v16,v17,v18,v19,v20,v21,v22,v23,v24,   \
                       v25,v26,v27,v28,v29,v30,v31,v32)                       \
        _AddNone(name)

///////////////////////////////////////////////////////////////////////////////
///
/// \file ErrorCodes.hpp
/// Basic error codes.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

DeclareEnum2(StatusState, 
  Success, 
  Failure);

class Status
{
public:
  Status()
   :CurrentState(StatusState::Success), ExtendedErrorCode(0), IgnoreMessage(false)
  {}

  Status(StatusState::Enum state, StringRef message)
    :CurrentState(state), Message(message), ExtendedErrorCode(0), IgnoreMessage(false)
  {}

  bool Failed(){return CurrentState != StatusState::Success; }
  bool Succeeded(){return CurrentState == StatusState::Success; }

  void SetFailed(StringRef message, u32 extenedErrorCode = 0)
  {
    CurrentState = StatusState::Failure;
    Message = message;
    ExtendedErrorCode = extenedErrorCode;
  }

  void SetSucceeded(StringRef message = String())
  {
    CurrentState = StatusState::Success;
    Message = message;
  }

  void AppendFailed(StringRef message)
  {
    CurrentState = StatusState::Failure;
    Message = BuildString(Message, message);
  }

  // Conversion to bool
  operator bool(){return CurrentState == StatusState::Success;}
  // Current state
  StatusState::Enum CurrentState;
  // Message for display.
  String Message;
  // Some functions want to return more detail on why they failed
  // so outer code can react to failures, this is usually a declare enum
  u32 ExtendedErrorCode;
  // As an optimization, we can suggest that we don't care about the message string
  // This is only a suggestion and may not be used (but should be heeded in high performance areas)
  bool IgnoreMessage;
};

#define StatusReturnIfFailed(Status, ...) ReturnIf((Status).Failed(), __VA_ARGS__, "%s", (Status).Message.c_str())

}

///////////////////////////////////////////////////////////////////////////////
///
/// \file File.hpp
/// Declaration of the helper macros.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#define ZeroDeclarePrivateData(Type, Size) \
  byte mPrivateData[Size];                 \
  Type(const Type& right);                 \
  Type& operator = (const Type& right);

#define ZeroGetPrivateData(Type) \
  Type* self = (Type*)mPrivateData;

#define ZeroAssertPrivateDataSize(Type)                                           \
  StaticAssert(IncreaseSizeOfPrivateData_PrivateTypeTooBig,                       \
    sizeof(Type) <= sizeof(mPrivateData),                                         \
    "Increase the size of the private data because the private type is too big");

// For completely pod private data, it's easier just to clear it out (no destructor)
#define ZeroMemClearPrivateData(Type)             \
  memset(mPrivateData, 0, sizeof(mPrivateData));  \
  ZeroAssertPrivateDataSize(Type);                \
  ZeroGetPrivateData(Type);

#define ZeroConstructPrivateData(Type, ...) \
  Type* self = new (mPrivateData) Type();   \
  ZeroAssertPrivateDataSize(Type);

#define ZeroDestructPrivateData(Type, ...)  \
    ((Type*)mPrivateData)->~Type();

namespace Zero
{
  namespace SocketAddressFamily
  {
    enum Enum
    {
      Unspecified = 0,
      Unix = 1,
      InterNetworkV4 = 2,
      ImpLink = 3,
      Pup = 4,
      Chaos = 5,
      Ipx = 6,
      NS = 6,
      Osi = 7,
      Iso = 7,
      Ecma = 8,
      DataKit = 9,
      Ccitt = 10,
      Sna = 11,
      DecNet = 12,
      DataLink = 13,
      Lat = 14,
      HyperChannel = 15,
      AppleTalk = 16,
      NetBios = 17,
      VoiceView = 18,
      FireFox = 19,
      Banyan = 21,
      Atm = 22,
      InterNetworkV6 = 23,
      Cluster = 24,
      Ieee12844 = 25,
      Irda = 26,
      NetworkDesigners = 28
    };
    typedef uint Type;
  }

  DeclareEnum6(SocketType,
    Unspecified,
    Stream,
    Dgram,
    Raw,
    Rdm,
    SeqPacket);

  DeclareEnum3(SocketIo, Read, Write, Both);

  DeclareEnum3(SocketSelect, Read, Write, Error);

  namespace SocketFlags
  {
    enum Enum
    {
      None = 0,
      OutOfBand = 1,
      Peek = 2,
      DontRoute = 4,
      MaxIOVectorLength = 16,
      Truncated = 256,
      ControlDataTruncated = 512,
      Broadcast = 1024,
      Multicast = 2048,
      Partial = 32768
    };
  }

  namespace SocketProtocolType
  {
    enum Enum
    {
      Ip = 0,
      Icmp = 1,
      Igmp = 2,
      Ggp = 3,
      Ipv4 = 4,
      Tcp = 6,
      Pup = 12,
      Udp = 17,
      Idp = 22,
      Ipv6 = 41,
      Ipv6RoutingHeader = 43,
      Ipv6FragmentHeader = 44,
      IpSecEncapsulatingSecurityPayload = 50,
      IpSecAuthenticationHeader = 51,
      IcmpV6 = 58,
      Ipv6NoNextHeader = 59,
      Ipv6DestinationOptions = 60,
      Nd = 77,
      Raw = 255,
      Ipx = 1000,
      Spx = 1256,
      SpxII = 1257
    };
    typedef uint Type;
  }

  class SocketAddress
  {
  public:

    /// Constructor
    SocketAddress();

    /// Frees the address information
    ~SocketAddress();
    
    /// Initializes a remote socket address using a host name and a port (IpV4 or IpV6!)
    void InitializeInterNetwork(Status& status, StringParam host, int port);
    
    /// Initializes a local Ipv4 socket address on a given port
    void InitializeLocalInterNetwork4Any(Status& status, int port);
    
    /// Initializes a local Ipv6 socket address on a given port
    void InitializeLocalInterNetwork6Any(Status& status, int port);

    SocketAddressFamily::Enum GetAddressFamily();
    
    /// This is a similar pattern to the private data pattern,
    /// except we want to allocate different types depending on the protocol
    ZeroDeclarePrivateData(SocketAddress, 32);

    /// The size of the object stored on the in the private data
    int mSize;
  };

  /// A cross platform wrapper around sockets
  /// This wrapper only implements the base interface of sockets,
  /// and does not include threading or extra protocols on top
  class Socket
  {
  public:
    /// Creates a socket with an empty descriptor (not valid, but useful for calls to Accept)
    Socket();

    /// Destructor for the socket (closes the socket and cleans up resources)
    ~Socket();

    // Returns the maximum number of connections the os can backlog (used in the call to Listen)
    static int GetMaxConnectionBacklog();

    /// Checks if an exteneded error code returned from a receive operation is
    /// a standard close error. This includes connections being reset remotely,
    /// the socket being closed during a pending receive operation, connection aborted by software,
    /// or even a connection being dropped by lack of keep-alive activity
    /// The general idea is that these errors should not be reported via asserts because they are common
    static bool IsReceiveCloseError(int extendedErrorCode);

    /// Checks if an error code is simply just that the remote client terminated a handshake during accept
    /// Generally these errors are considered continuable (not critical)
    static bool IsAcceptRemoteError(int extendedErrorCode);

    /// Convert a buffer of bytes into network byte order or back (big endian)
    /// On machines whose endianness matches the network byte order, this does nothing
    /// The output and input can overlap (be the same pointer)
    static void NetworkByteOrderSwap(const byte* input, size_t size, byte* output);
    
    /// Helper function for converting values to network byte order or back
    template <typename T>
    static T NetworkByteOrderSwap(T value)
    {
      NetworkByteOrderSwap((const byte*)&value, sizeof(value), (byte*)&value);
      return value;
    }

    /// Returns if the socket descriptor is valid
    /// This does not imply that the socket is connected, only that we have a valid handle
    bool IsValid();

    /// Creates a new socket descriptor (closes the old one if one exists)
    void Initialize(Status& status, SocketAddressFamily::Enum addressFamily, SocketType::Enum type, SocketProtocolType::Enum protocol);

    /// Associates a socket to a given socket address (typically includes the local adapter and a port)
    /// Often times we can bind to 'any' local address which lets the OS choose
    void Bind(Status& status, const SocketAddress& address);

    /// After binding, this prepares the socket for incomming connections
    /// Only used with stream/connection oriented sockets
    void Listen(Status& status, int backlog);

    /// Outputs the socket that we accepted and the address of that socket
    /// Only used with stream/connection oriented sockets
    void Accept(Status& status, Socket* socketOut, SocketAddress* addressOut);

    /// Connects to a remote address
    /// Only used with stream/connection oriented sockets
    void Connect(Status& status, const SocketAddress& remoteAddress);

    /// Closes the socket and frees any used resources
    /// This function is safe to call on other threads (blocking calls will terminate with a 'terminated' error)
    /// Shutdown only stops sending or receiving, whilst close actually terminates the connection and frees the descriptor
    void Close(Status& status);

    /// Stops either sending or receiving on this socket (or both)
    /// Shutdown only stops sending or receiving, whilst close actually terminates the connection and frees the descriptor
    void Shutdown(Status& status, SocketIo::Enum io);
    
    /// Sends data on the socket and returns the amount of data sent (0 if any errors occur, status will contain the error)
    /// This call will block if the outgoing buffer is filled
    /// Only used with stream/connection oriented sockets
    int Send(Status& status, const byte* data, int length, SocketFlags::Enum flags);

    /// Sends data to a specific destination and returns the amount of data sent (0 if any errors occur, status will contain the error)
    /// Can be used with both connectionless and connected sockets
    int SendTo(Status& status, const byte* data, int length, SocketFlags::Enum flags, const SocketAddress& to);

    /// Receives data into a buffer and returns the amount received (0 if any errors occur, status will contain the error)
    /// Can be used with both connectionless and connected sockets
    int Receive(Status& status, byte* dataOut, int length, SocketFlags::Enum flags);

    /// Receives data into a buffer and returns the amount received (0 if any errors occur, status will contain the error)
    /// Can be used with both connectionless and connected sockets
    /// The given address can be modified by this function when using non-connection oriented protocols
    int ReceiveFrom(Status& status, byte* dataOut, int length, SocketFlags::Enum flags, SocketAddress& from);

    /// Tests the status of the socket to see if it's ready
    /// In a high efficiency situation, mechanisms other than select should be used
    bool Select(Status& status, SocketSelect::Enum selectMode, float timeoutSeconds);

    SocketAddressFamily::Enum mAddressFamily;
    SocketType::Enum mSocketType;
    SocketProtocolType::Enum mProtocolType;
    OsHandle mHandle;
  };
}

///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.hpp
/// Declaration of the Thread class.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

// Is threading enabled on this platform?
extern const bool ThreadingEnabled;

/// Thread class manages Os threads.
class Thread
{
public:
  typedef OsInt (*EntryFunction)(void*);

  //Construct a thread object does not create the thread.
  //Initialize and then resume to run the thread.
  Thread();
  ~Thread();

  //Is this a valid thread or uninitialized.
  bool IsValid();

  //Initializes the thread but does not run it.
  bool Initialize(EntryFunction entryFunction, void* instance, cstr threadName);

  //Resume the thread.
  void Resume();

  //Suspend the thread.
  void Suspend();

  //Close the thread handle. Thread should have been shut down.
  //before calling this function.
  void Close();

  //Block waiting for the thread to complete.
  //The thread should either complete in a reasonable way or
  //be signaled to be closed.
  OsInt WaitForCompletion();

  //Is the thread completed?
  bool IsCompleted();

  //Removes the thread from this object.
  OsHandle Detach();

  //Get the OsHandle to the thread.
  OsHandle GetThreadHandle();

  // Template Helper for creating Entry Functions
  // From member functions
  template<typename classType, OsInt (classType::*MemberFunction)()>
  static OsInt ObjectEntryCreator(void* objectInstance)
  {
    classType* object = (classType*)objectInstance;
    OsInt returnValue = (object->*MemberFunction)();
    return returnValue;
  }

private:
  char mThreadName[cDebugNameMax];
  ZeroDeclarePrivateData(Thread, 20);
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file ThreadSync.hpp
/// Declaration of Thread synchronization classes.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

//Standard Thread lock
class ThreadLock
{
public:
  ThreadLock();
  ~ThreadLock();
  void Lock();
  void Unlock();

  ZeroDeclarePrivateData(ThreadLock, 48);
};

//Wrapper around an unnamed event.
class OsEvent
{
public:
  OsEvent();
  ~OsEvent();
  void Initialize(bool manualReset = false, bool startSignaled = false);
  void Close();
  void Signal();
  void Reset();
  void Wait();
  OsHandle GetHandle() { return mHandle; }
private:
  OsHandle mHandle;
};

const int MaxSemaphoreCount = 0x0FFFFFFF;

//Semaphore class. Multithreaded counter / gatekeeper.
class Semaphore
{
public:
  Semaphore();
  ~Semaphore();
  void Increment();
  void Decrement();
  void Reset();
  void WaitAndDecrement();
private:
  OsHandle mHandle;
};

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Utilities.hpp
/// Declaration of the Utilities class.
/// 
/// Authors: Trevor Sundberg, Chris Peters
/// Copyright 2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

class Status;

/// System Memory Information
struct MemoryInfo
{
  uint Reserve;
  uint Commit;
  uint Free;
};

namespace Os
{

// Sleep the current thread for ms milliseconds.
void Sleep(uint ms);

// Set the Timer Frequency (How often the os checks threads for sleep, etc)
void SetTimerFrequency(uint ms);

// Get the user name for the current profile
String UserName();

// Get the computer name
String ComputerName();

// Get computer Mac Address of adapter 0
u64 GetMacAddress();

// Check if a debugger is attached
bool IsDebuggerAttached();

// Debug break (only if a debugger is attached)
void DebugBreak();

// Verb used to open file
DeclareEnum4(Verb, Default, Open, Edit, Run);

// Open the file using the appropriate Os application or
// launch an external application.
void SystemOpenFile(cstr file, uint verb=Verb::Default, cstr parameters=NULL, cstr workingDirectory=NULL);
bool SystemOpenFile(Status& status, cstr file, uint verb=Verb::Default, cstr parameters=NULL, cstr workingDirectory=NULL);

// Get the memory status of the Os.
void GetMemoryStatus(MemoryInfo& memoryInfo);

// Get an Environmental variable
String GetEnvironmentalVariable(StringRef variable);

// Translate a os error code.
String TranslateErrorCode(int errorCode);

// Get a string describing the current operating system version.
String GetVersionString();

}

// Generate a 64 bit unique Id. Uses system timer and mac
// address to generate the id.
u64 GenerateUniqueId64();

}//namespace Zero

///////////////////////////////////////////////////////////////////////////////
///
/// \file Math.hpp
/// Central location for all the math used by the Zero engine.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file Reals.hpp
/// Declaration of the real typedef and utility functions.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Math
{

typedef float real;
typedef short half;

//a pointer of the given type
typedef real* RealPointer;
//a const pointer of the given type
typedef const real* ConstRealPointer;
//a reference of the given type
typedef real& RealRef;
//a const reference of the given type
typedef const real& ConstRealRef;

const uint cX = 0;
const uint cY = 1;
const uint cZ = 2;
const uint cW = 3;

//these cannot be constants
extern const real& cInfinite;

const real cPi = real(3.1415926535897932384626433832795);
const real cTwoPi = real(2.0) * cPi;

//Golden ratio!
const real cGoldenRatio = real(1.6180339887498948482045868343656);

real Epsilon(void);
real PositiveMax(void);
real PositiveMin();
bool Equal(real lhs, real rhs);
bool Equal(real lhs, real rhs, real epsilon);
bool NotEqual(real lhs, real rhs);
bool IsZero(real val);
bool IsNegative(real number);
bool IsPositive(real number);
bool LessThan(real lhs, real rhs);
bool LessThanOrEqual(real lhs, real rhs);
bool GreaterThan(real lhs, real rhs);
bool GreaterThanOrEqual(real lhs, real rhs);
real Sqrt(real val);
bool SafeSqrt(real val, real& result);
real Rsqrt(real val);
real Sq(real sqrt);
real Pow(real base, real exp);
real Log(real val);
real Log(real val, real base);
real Log10(real val);
real Log2(real val);
real Exp(real val);
real Exp2(real val);
real Abs(real val);
int Abs(int val);
real FMod(real dividend, real divisor);
bool SafeFMod(real dividend, real divisor, real& result);
real GetSign(real val);
int Sign(real val);
int Sign(int val);
real Cos(real val);
real Sin(real val);
real Tan(real angle);
real Cosh(real val);
real Sinh(real val);
real Tanh(real angle);
real ArcCos(real angle);
real ArcSin(real angle);
real ArcTan(real angle);
real ArcTan2(real y, real x);
bool SafeArcCos(real radians, real& result);
bool SafeArcSin(real radians, real& result);
real RadToDeg(real radians);
real DegToRad(real degrees);
real Fractional(real val);
real Round(real val);
real Round(real value, int places);
real Round(real value, int places, int base);
real Truncate(real val);
real Truncate(real val, int places);
real Truncate(real val, int places, int base);
real Ceil(real val);
real Ceil(real val, int places);
real Ceil(real val, int places, int base);
real Floor(real val);
real Floor(real val, int places);
real Floor(real val, int places, int base);
real Step(real y, real x);
int CountBits(int value);
bool IsValid(real val);

template <typename T>
inline T Max(const T lhs, const T rhs)
{
  return lhs > rhs ? lhs : rhs;
}

template <typename T>
inline T Min(const T lhs, const T rhs) 
{
  return lhs > rhs ? rhs : lhs;
}

template <typename T>
inline T Clamp(const T x, const T xMin, const T xMax)
{
  return Max(xMin, Min(x, xMax));
}

template <typename T>
inline T Clamp(const T value) 
{
  return Clamp(value, T(0), T(1));
}

/// Clamps between min and max but it sets a bool saying whether or not a value was clamped.
template <typename T>
inline T DebugClamp(const T x, const T xMin, const T xMax, bool& wasClamped)
{
  wasClamped = true;
  if(x < xMin)  
    return xMin;
  if(x > xMax)
    return xMax;
  wasClamped = false;
  return x;
}

template <typename T>
inline T ClampIfClose(const T x, const T xMin, const T xMax, const T epsilon)
{
  real value = x < xMin && x > (xMin - epsilon) ? xMin : x;
  value = value > xMax && value < (xMax + epsilon) ? xMax : value;
  return value;
}

template <typename T>
inline bool TryClampIfClose(T& x, const T xMin, const T xMax, const T epsilon)
{
  if(x < xMin)
  {
    if(x > (xMin - epsilon))
      x = xMin;
    else
      return false;
  }
  if(x > xMax)
  {
    if(x < (xMax + epsilon))
      x = xMax;
    else
      return false;
  }
  return true;
}

template <typename T>
inline real InverseLerp(const T x, const T start, const T end)
{
  if(end == start)
  {
    return real(1.0);
  }

  return (x - start) / (end - start);
}

template <typename T>
inline real InverseLerpClamped(const T x, const T start, const T end)
{
  return Clamp(InverseLerp(x, start, end));
}

///Checks to see if x is within the interval of [xMin, xMax]
template <typename T>
inline bool InRange(const T x, const T xMin, const T xMax)
{
    return ((xMin <= x) && (x <= xMax));
}

///Checks to see if x is within the interval of (xMin, xMax)
template <typename T>
inline bool InBounds(const T x, const T xMin, const T xMax)
{
    return ((xMin < x) && (x < xMax));
}

template <typename T>
inline T Wrap(const T x, const T xMin, const T xMax)
{
    return (x < xMin) ? (x + (xMax - xMin)) : 
           ((x > xMax) ? (x - (xMax - xMin)) : x);
}

template <typename T>
inline void Swap(T& a, T& b)
{
  T temp(a);
  a = b;
  b = temp;
}

template <typename Data, typename T>
inline Data Lerp(const Data& start, const Data& end, T interpolationValue)
{
  return (T(1.0) - interpolationValue) * start + interpolationValue * end;
}

template <typename Data>
inline Data SmoothStep(const Data& start, const Data& end, real t)
{
  t = Clamp((t - start) / (end - start));
  
  // 3t^2 - 2t^3
  return t * t * (3 - 2 * t);
}

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector2.hpp
/// Declaration of the Vector 2 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file BoolVector2.hpp
/// Declaration of the BoolVector2 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

struct BoolVector2;
typedef BoolVector2 BoolVec2;
typedef const BoolVector2& BoolVec2Param;
typedef BoolVector2& BoolVec2Ref;
typedef BoolVector2* BoolVec2Ptr;

///2 dimensional integral vector.
struct BoolVector2
{
  BoolVector2(void) {}
  explicit BoolVector2(bool x, bool y);

  bool& operator[](uint index);
  bool operator[](uint index) const;

  //Unary Operators
  BoolVector2 operator!(void) const;

  //Binary Vector Comparisons
  bool operator==(BoolVec2Param rhs) const;
  bool operator!=(BoolVec2Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(bool x, bool y);

  union
  {
    struct  
    {
      bool x, y;
    };
    bool array[2];
  };

  static const BoolVector2 cZero;
  static const BoolVector2 cXAxis;
  static const BoolVector2 cYAxis;
};

}// namespace Math

namespace Math
{

struct Vector2;
typedef Vector2 Vec2;
typedef const Vector2& Vec2Param;
typedef Vector2& Vec2Ref;
typedef Vector2* Vec2Ptr;

//--------------------------------------------------------------------- Vector 2
///2 dimensional vector.
struct Vector2
{
  Vector2(void) {};
  explicit Vector2(real x, real y);
  explicit Vector2(real xy);
  explicit Vector2(ConstRealPointer data);

  real& operator[](uint index);
  real operator[](uint index) const;

  //Unary Operators
  Vector2 operator-(void) const;

  //Binary Assignment Operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary Operators (Reals)
  Vector2 operator*(real rhs) const;
  Vector2 operator/(real rhs) const;

  //Binary Assignment Operators (vectors)
  void operator+=(Vec2Param rhs);
  void operator-=(Vec2Param rhs);

  //Binary Operators (vectors)
  Vector2 operator+(Vec2Param rhs) const;
  Vector2 operator-(Vec2Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(Vec2Param rhs) const;
  bool operator!=(Vec2Param rhs) const;

  //Vector component-wise multiply and divide
  Vector2 operator*(Vec2Param rhs) const;
  Vector2 operator/(Vec2Param rhs) const;

  ///Component-wise assignment multiplication
  void operator*=(Vec2Param rhs);
  void operator/=(Vec2Param rhs);

  //Comparison operators
  BoolVec2 operator< (Vec2Param rhs) const;
  BoolVec2 operator<=(Vec2Param rhs) const;
  BoolVec2 operator> (Vec2Param rhs) const;
  BoolVec2 operator>=(Vec2Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(real x, real y);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  ///Calculate and return this vector reflected about the given vector.
  Vector2 Reflect(Vec2Param reflectionAxis) const;

  ///Add a vector multiplied by a scalar to this vector. A commonly done 
  ///operation and this reduces temporaries.
  void AddScaledVector(Vec2Param vector, real scalar);

  ///Compute the dot product of this vector with the given vector.
  real Dot(Vec2Param rhs) const;

  ///Get the length of this vector.
  real Length(void) const;

  ///Get the squared length of this vector.
  real LengthSq(void) const;

  ///Calculate and return a unit-length copy of this vector.
  Vector2 Normalized(void) const;

  ///Make this vector have a length of 1, returns the original length.
  real Normalize(void);

  ///Attempt to give this vector a length of 1, but checks if it's possible.
  ///Instead of crashing, will return 0 if the vector was not able to be 
  ///normalized.
  real AttemptNormalize(void);

  ///Flips this vector so it's pointing in the opposite direction.
  Vec2Ref Negate(void);

  ///Checks to see if the values of this vector's elements are usable.
  bool Valid(void) const;

  void Splat(real value);

  union
  {
    struct  
    {
      real x, y;
    };
    real array[2];
  };

  static const Vector2 cZero;
  static const Vector2 cXAxis;
  static const Vector2 cYAxis;
  static const Vector2 Axes[2];
};

Vector2 operator*(real lhs, Vec2Param rhs);

///Compute the distance between two given points.
real Distance(Vec2Param lhs, Vec2Param rhs);

///Compute the dot product of the two given vectors.
real Dot(Vec2Param lhs, Vec2Param rhs);

///Compute the 2d cross product of the two given vectors.
real Cross(Vec2Param lhs, Vec2Param rhs);

///Get the length of the given vector.
real Length(Vec2Param vec);

///Get the squared length of the given vector.
real LengthSq(Vec2Param vec);

///Calculate and return a unit-length copy of the given vector.
Vector2 Normalized(Vec2Param vec);

///Make the given vector have a length of 1, returns the original length.
real Normalize(Vec2Ptr vec);

///Attempt to give the given vector a length of 1, but checks if it's possible.
///Instead of crashing, this will return 0 if the vector was not able to be 
///normalized.
real AttemptNormalize(Vec2Ptr vec);

///Flips the given vector so it's pointing in the opposite direction.
void Negate(Vec2Ptr vec);

///Returns a vector pointing in the opposite direction of the given vector.
Vector2 Negated(Vec2Param vec);

///Returns a vector with absolute valued elements of the given vector.
Vector2 Abs(Vec2Param vec);

///Returns the component-wise minimum vector of the two vectors.
Vector2 Min(Vec2Param lhs, Vec2Param rhs);

///Returns the component-wise maximum vector of the two vectors.
Vector2 Max(Vec2Param lhs, Vec2Param rhs);

///Linearly interpolate between the two vectors, the t-value is restricted to 
///the range [0, 1].
Vector2 Lerp(Vec2Param start, Vec2Param end, real tValue);

///Clamps the values of the elements of the given vector to the range [min, max]
void Clamp(Vec2Ptr vec, real min, real max);

/// Same as clamp, however it fills out whether or not anything was clamped.
/// Useful when an assert message should be shown if anything was clamped.
Vector2 DebugClamp(Vec2Param vec, real min, real max, bool& wasClamped);

///Returns the bisector of the given vectors.
Vector2 GetBisector(Vec2Param v0, Vec2Param v1);

///Get the perpendicular vector to the given vector
Vector2 GetPerpendicular(Vec2Param vec);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector3.hpp
/// Declaration of the Vector 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file BoolVector3.hpp
/// Declaration of the BoolVector3 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

struct BoolVector3;
typedef BoolVector3 BoolVec3;
typedef const BoolVector3& BoolVec3Param;
typedef BoolVector3& BoolVec3Ref;
typedef BoolVector3* BoolVec3Ptr;

///2 dimensional integral vector.
struct BoolVector3
{
  BoolVector3(void) {}
  explicit BoolVector3(bool x, bool y, bool z);

  bool& operator[](uint index);
  bool operator[](uint index) const;

  //Unary Operators
  BoolVector3 operator!(void) const;

  //Binary Vector Comparisons
  bool operator==(BoolVec3Param rhs) const;
  bool operator!=(BoolVec3Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(bool x, bool y, bool z);

  union
  {
    struct  
    {
      bool x, y, z;
    };
    bool array[3];
  };

  static const BoolVector3 cZero;
  static const BoolVector3 cXAxis;
  static const BoolVector3 cYAxis;
  static const BoolVector3 cZAxis;
};

}// namespace Math

namespace Math
{

struct Vector3;
typedef Vector3 Vec3;
typedef const Vector3& Vec3Param;
typedef Vector3& Vec3Ref;
typedef Vector3* Vec3Ptr;

//--------------------------------------------------------------------- Vector 3
///3 dimensional vector.
struct Vector3
{
  Vector3(void) {};
  explicit Vector3(real x, real y, real z);
  //Splat all elements
  explicit Vector3(real xyz);
  explicit Vector3(Vec2Param vec2, real z = real(0.0));
  explicit Vector3(ConstRealPointer data);

  real& operator[](uint index);
  real operator[](uint index) const;

  //Unary Operators
  Vector3 operator-(void) const;

  //Binary Assignment Operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary Operators (Reals)
  Vector3 operator*(real rhs) const;
  Vector3 operator/(real rhs) const;

  //Binary Assignment Operators (vectors)
  void operator+=(Vec3Param rhs);
  void operator-=(Vec3Param rhs);

  //Binary Operators (vectors)
  Vector3 operator+(Vec3Param rhs) const;
  Vector3 operator-(Vec3Param rhs) const;  

  //Binary Vector Comparisons
  bool operator==(Vec3Param rhs) const;
  bool operator!=(Vec3Param rhs) const;

  //Vector component wise multiply and divide
  Vector3 operator*(Vec3Param rhs) const;
  Vector3 operator/(Vec3Param rhs) const;

  ///Component-wise assignment multiplication
  void operator*=(Vec3Param rhs);
  void operator/=(Vec3Param rhs);

  //Comparison operators
  BoolVec3 operator< (Vec3Param rhs) const;
  BoolVec3 operator<=(Vec3Param rhs) const;
  BoolVec3 operator> (Vec3Param rhs) const;
  BoolVec3 operator>=(Vec3Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(real x, real y, real z);

  ///Set all of the values of the vector to the passed in value.
  void Splat(real xyz);

  ///Do a component-wise scaling of this vector with the given vector.
  void ScaleByVector(Vec3Param rhs);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  ///Calculate and return this vector reflected about the given vector.
  Vector3 Reflect(Vec3Param reflectionAxis) const;

  ///Projects the vector onto the axis
  Vector3 Project(Vec3Param axis) const;

  ///Add a vector multiplied by a scalar to this vector. A commonly done 
  ///operation and this reduces temporaries.
  void AddScaledVector(Vec3Param vector, real scalar);

  ///Compute the dot product of this vector with the given vector.
  real Dot(Vec3Param rhs) const;

  ///Get the length of this vector.
  real Length(void) const;

  ///Get the squared length of this vector.
  real LengthSq(void) const;

  ///Calculate and return a unit-length copy of this vector.
  Vector3 Normalized(void) const;

  ///Make this vector have a length of 1, returns the original length.
  real Normalize(void);

  ///Ceil each component of the vector.
  void Ceil(void);

  ///Floor each component of the vector.
  void Floor(void);

  ///Truncate each component of the vector.
  void Truncate(void);

  ///If positive, it always rounds up, if negative, it always rounds down
  void RoundToExtremes();

  ///Round each component of the vector.
  void Round(void);

  ///Attempt to give this vector a length of 1, but checks if it's possible.
  ///Instead of crashing, will return 0 if the vector was not able to be 
  ///normalized.
  real AttemptNormalize(void);
  Vector3 AttemptNormalized() const;

  ///Flip this vector so it's pointing in the opposite direction.
  Vec3Ref Negate(void);

  ///Checks to see if the values of this vector's elements are usable.
  bool Valid(void) const;

  ///Compute the cross product of this vector with the given vector.
  Vector3 Cross(Vec3Param rhs) const;
  void InvertComponents(void);

  union
  {
    struct  
    {
      real x, y, z;
    };
    real array[3];
  };

  static const Vector3 cZero;
  static const Vector3 cXAxis;
  static const Vector3 cYAxis;
  static const Vector3 cZAxis;
  static const Vector3 Axes[3];
};

Vector3 operator*(real lhs, Vec3Param rhs);

bool Equal(Vec3Param lhs, Vec3Param rhs, real epsilon);

///Compute the distance between two given vectors.
real Distance(Vec3Param lhs, Vec3Param rhs);

///Compute the dot product of the two given vectors.
real Dot(Vec3Param lhs, Vec3Param rhs);

//Vector component-wise multiply
Vector3 ScaledByVector(Vec3Param lhs, Vec3Param rhs);

//Vector component-wise divide
Vector3 DividedByVector(Vec3Param lhs, Vec3Param rhs);

///Get the length of the given vector.
real Length(Vec3Param vec);

///Get the squared length of the given vector.
real LengthSq(Vec3Param vec);

///Calculate and return a unit-length copy of the given vector.
Vector3 Normalized(Vec3Param vec);

///Make the given vector have a length of 1, returns the original length.
real Normalize(Vec3Ptr vec);

///Attempt to give the given vector a length of 1, but checks if it's possible.
///Instead of crashing, this will return 0 if the vector was not able to be 
///normalized.
real AttemptNormalize(Vec3Ptr vec);

///Compute the cross product of the two given vectors.
Vector3 Cross(Vec3Param lhs, Vec3Param rhs);

///Compute the cross product of the two given vectors for 2d.
///The result is only the z axis of the cross product.
Vector3 Cross2d(Vec3Param lhs, Vec3Param rhs);

///Set all of the given vector's elements to 0.
void ZeroOut(Vec3Ptr vec);

///Flips the given vector so it's pointing in the opposite direction.
void Negate(Vec3Ptr vec);

///Returns a vector pointing in the opposite direction of the given vector.
Vector3 Negated(Vec3Param vec);

///Returns a vector with absolute valued elements of the given vector.
Vector3 Abs(Vec3Param vec);

///Returns the component-wise minimum vector of the two vectors.
Vector3 Min(Vec3Param lhs, Vec3Param rhs);

///Returns the component-wise maximum vector of the two vectors.
Vector3 Max(Vec3Param lhs, Vec3Param rhs);

///Linearly interpolate between the two vectors, the t-value is restricted to 
///the range [0, 1].
Vector3 Lerp(Vec3Param start, Vec3Param end, real tValue);

///Clamps the values of the elements of the given vector to the range [min, max]
void Clamp(Vec3Ptr vec, real min, real max);

///Calculates and returns the given vector with its values clamped to the range
///[min, max].
Vector3 Clamped(Vec3Param vec, real min, real max);

/// Same as clamp, however it fills out whether or not anything was clamped.
/// Useful when an assert message should be shown if anything was clamped.
Vector3 DebugClamp(Vec3Param vec, real min, real max, bool& wasClamped);

///Returns if all values in lhs are less than all values in rhs
bool AllLess(Vec3Param lhs, Vec3Param rhs);

///Returns if any value in lhs is less than any value in rhs
bool AnyLess(Vec3Param lhs, Vec3Param rhs);

///Returns if all values in lhs are greater than all values in rhs
bool AllGreater(Vec3Param lhs, Vec3Param rhs);

///Returns if any value in lhs is greater than any value in rhs
bool AnyGreater(Vec3Param lhs, Vec3Param rhs);

real DistanceToLineSq(Vec3Param start, Vec3Param end, Vec3Param point);

}// namespace Math

namespace Math
{

//-------------------------------------------------------------- Unary Operators
inline Vector3 Vector3::operator-(void) const
{
  return Vector3(-x, -y, -z);
}

//------------------------------------------ Binary Assignment Operators (reals)
inline void Vector3::operator*=(real rhs)
{
  x *= rhs;
  y *= rhs;
  z *= rhs;
}

inline void Vector3::operator/=(real rhs)
{
  ErrorIf(rhs == real(0.0), "Math::Vector3 - Division by zero.");
  x /= rhs;
  y /= rhs;
  z /= rhs;
}

//----------------------------------------------------- Binary Operators (reals)

inline Vector3 Vector3::operator*(real rhs) const
{
  Vector3 ret = *this;
  ret *= rhs;
  return ret;
}

inline Vector3 Vector3::operator/(real rhs) const
{
  ErrorIf(Math::IsZero(rhs), "Math::Vector3 - Division by zero.");
  Vector3 ret = *this;
  ret /= rhs;
  return ret;
}

//----------------------------------------- Binary Assignment Operator (Vectors)

inline void Vector3::operator+=(Vec3Param rhs)
{
  x += rhs.x;
  y += rhs.y;
  z += rhs.z;
}

inline void Vector3::operator-=(Vec3Param rhs)
{
  x -= rhs.x;
  y -= rhs.y;
  z -= rhs.z;
}

//--------------------------------------------------- Binary Operators (Vectors)
inline Vector3 Vector3::operator+(Vec3Param rhs) const
{
  Vector3 ret = *this;
  ret += rhs;
  return ret;
}

inline Vector3 Vector3::operator-(Vec3Param rhs) const
{
  Vector3 ret = *this;
  ret -= rhs;
  return ret;
}

inline Vector3 Vector3::operator*(Vec3Param rhs) const
{
  return Vector3(x * rhs.x, y * rhs.y, z * rhs.z);
}

inline Vector3 Vector3::operator/(Vec3Param rhs) const
{  
  ErrorIf(rhs.x == real(0.0) || rhs.y == real(0.0) || rhs.z == real(0.0),
          "Vector3 - Division by zero.");
  return Vector3(x / rhs.x, y / rhs.y, z / rhs.z);
}

inline void Vector3::operator*=(Vec3Param rhs)
{
  x *= rhs.x;
  y *= rhs.y;
  z *= rhs.z;
}

inline void Vector3::operator/=(Vec3Param rhs)
{
  x /= rhs.x;
  y /= rhs.y;
  z /= rhs.z;
}

inline real Vector3::Dot(Vec3Param rhs) const
{
  return x * rhs.x + y * rhs.y + z * rhs.z;
}

inline real Dot(Vec3Param lhs, Vec3Param rhs)
{  
  return lhs.Dot(rhs);
}

}//namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Vector4.hpp
/// Declaration of the Vector 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file BoolVector4.hpp
/// Declaration of the BoolVector4 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

struct BoolVector4;
typedef BoolVector4 BoolVec4;
typedef const BoolVector4& BoolVec4Param;
typedef BoolVector4& BoolVec4Ref;
typedef BoolVector4* BoolVec4Ptr;

///2 dimensional integral vector.
struct BoolVector4
{
  BoolVector4(void) {}
  explicit BoolVector4(bool x, bool y, bool z, bool w);

  bool& operator[](uint index);
  bool operator[](uint index) const;

  //Unary Operators
  BoolVector4 operator!(void) const;

  //Binary Vector Comparisons
  bool operator==(BoolVec4Param rhs) const;
  bool operator!=(BoolVec4Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(bool x, bool y, bool z, bool w);

  union
  {
    struct  
    {
      bool x, y, z, w;
    };
    bool array[4];
  };

  static const BoolVector4 cZero;
  static const BoolVector4 cXAxis;
  static const BoolVector4 cYAxis;
  static const BoolVector4 cZAxis;
  static const BoolVector4 cWAxis;
};

}// namespace Math

namespace Math
{

struct Vector4;
typedef Vector4 Vec4;
typedef const Vector4& Vec4Param;
typedef Vector4& Vec4Ref;
typedef Vector4* Vec4Ptr;

//--------------------------------------------------------------------- Vector 4
struct Vector4
{
  Vector4(void) {};
  explicit Vector4(real x, real y, real z, real w);
  explicit Vector4(ConstRealPointer data);
  //Splat all elements
  explicit Vector4(real xyzw);

  real& operator[](uint index);
  real operator[](uint index) const;

  //Unary Operators
  Vector4 operator-(void) const;

  //Binary Assignment Operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary Operators (Reals)
  Vector4 operator*(real rhs) const;
  Vector4 operator/(real rhs) const;

  //Binary Assignment Operators (vectors)
  void operator+=(Vec4Param rhs);
  void operator-=(Vec4Param rhs);
  void operator*=(Vec4Param rhs);
  void operator/=(Vec4Param rhs);

  //Binary Operators (vectors)
  Vector4 operator+(Vec4Param rhs) const;
  Vector4 operator-(Vec4Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(Vec4Param rhs) const;
  bool operator!=(Vec4Param rhs) const;

  //Vector component wise multiply and divide
  Vector4 operator*(Vec4Param rhs) const;
  Vector4 operator/(Vec4Param rhs) const;

  //Comparison operators
  BoolVec4 operator< (Vec4Param rhs) const;
  BoolVec4 operator<=(Vec4Param rhs) const;
  BoolVec4 operator> (Vec4Param rhs) const;
  BoolVec4 operator>=(Vec4Param rhs) const;

  void Set(real x, real y, real z, real w);

  ///Set all of the values of the vector to the passed in value.
  void Splat(real xyzw);

  ///Do a component-wise scaling of this vector with the given vector.
  void ScaleByVector(Vec4Param rhs);

  Vector4 ScaledByVector(Vec4Param rhs) const;

  void ZeroOut(void);
  void AddScaledVector(Vec4Param vector, real scalar);

  real Dot(Vec4Param rhs) const;
  real Length(void) const;
  real LengthSq(void) const;
  Vector4 Normalized(void) const;
  real Normalize(void);
  real AttemptNormalize(void);
  Vec4Ref Negate(void);
  bool Valid(void) const;

  union
  {
    struct  
    {
      real x, y, z, w;
    };
    real array[4];
  };

  static const Vector4 cZero;
  static const Vector4 cXAxis;
  static const Vector4 cYAxis;
  static const Vector4 cZAxis;
  static const Vector4 cWAxis;
  static const Vector4 Axes[4];
};

Vector4 operator*(real lhs, Vec4Param rhs);
real Dot(Vec4Param lhs, Vec4Param rhs);
real Length(Vec4Param vect);
real LengthSq(Vec4Param vect);
Vector4 Normalized(Vec4Param vect);
real Normalize(Vec4Ptr vect);
real AttemptNormalize(Vec4Ptr vect);
void Negate(Vec4Ptr vec);
Vector4 Negated(Vec4Param vec);
Vector4 Abs(Vec4Param vec);
Vector4 Min(Vec4Param lhs, Vec4Param rhs);
Vector4 Max(Vec4Param lhs, Vec4Param rhs);
Vector4 Clamped(Vec4Param vec, real min, real max);
Vector4 Lerp(Vec4Param start, Vec4Param end, real tValue);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix2.hpp
/// Declares the Matrix 2 structure.
///
/// Authors: Joshua Davis
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

struct Matrix2;
typedef Matrix2 Mat2;
typedef const Matrix2& Mat2Param;
typedef Matrix2& Mat2Ref;
typedef Matrix2* Mat2Ptr;

struct Matrix2
{
public:
  Matrix2() {};
  Matrix2(real p00, real p01,
          real p10, real p11);
  Matrix2(ConstRealPointer data_);

  Vec2Ref operator[](uint index);
  Vec2Param operator[](uint index) const;

  ConstRealPointer Begin() const;
  ConstRealPointer End() const;
  RealPointer Begin();
  RealPointer End();

  //binary assignment operators (Reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //binary operators (Reals)
  Matrix2 operator*(real rhs) const;
  Matrix2 operator/(real rhs) const;

  //binary assignment operators (matrices)
  void operator+=(Mat2Param rhs);
  void operator-=(Mat2Param rhs);

  //binary operators (matrices)
  Matrix2 operator+(Mat2Param rhs) const;
  Matrix2 operator-(Mat2Param rhs) const;
  Matrix2 operator*(Mat2Param rhs) const;

  //matrix comparisons
  bool operator==(Mat2Param rhs) const;
  bool operator!=(Mat2Param rhs) const;

  real operator()(uint r, uint c) const;
  real& operator()(uint r, uint c);

  Matrix2 Transposed() const;
  Matrix2 Inverted();
  Matrix2 Concat(Mat2Param rhs) const;
  Mat2Ref Identity();
  Mat2Ref SetIdentity();
  Mat2Ref ZeroOut();

  real Determinant() const;

  bool Valid() const;

  void Rotate(real radians);
  void Scale(real x, real y);
  void Scale(Vec2Param rhs);
  Vector2 Transform(Vec2Param vector) const;
  void TransformVector(Vec2Ref vector) const;
  Vector2 BasisVector(u32 index) const;

  Vector2 Basis(uint index) const;
  Vector2 Cross(uint index) const;

  union 
  {
    struct
    {
      real m00, m01, 
           m10, m11;
    };

    real array[4];
  };

  static const Matrix2 cIdentity;
};

Matrix2 operator*(real lhs, Mat2Param rhs);

Matrix2 Concat(Mat2Param lhs, Mat2Param rhs);
Vector2 Transform(Mat2Param mat, Vec2Param vector);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix3.hpp
/// Declaration of the Matrix 3 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
/// \file MatrixStorage.hpp
/// Declaration of the switch for how matrices are stored.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///Used to set the way matrices are laid out. If 0, then the columns of an 
///orthogonal basis matrix represent the xyz-axes of the rotation. If 1, then 
///the rows of an orthogonal basis matrix represent the xyz-axes of the 
///rotation. This only changes how the memory is laid out for matrices, the 
///matrix interfaces do not change (and neither does the code that uses them).
///The reason why this should be changed is for the memory layout with respect 
///to SIMD operations. Early versions of SSE (2 and 3) are more efficient with
///column operations (so basis vectors in the rows, I know it's backwards but go 
///with it), and xmvector and SSE 4 are more efficient with row operations (so 
///basis vectors in the columns).
#ifndef ColumnBasis
#define ColumnBasis 1
#endif

namespace Math
{

///Forward declaration
struct Quaternion;
typedef const Quaternion& QuatParam;

///Forward declaration
struct Matrix4;
typedef const Matrix4& Mat4Param;

struct Matrix3;
typedef Matrix3 Mat3;
typedef const Matrix3& Mat3Param;
typedef Matrix3& Mat3Ref;
typedef Matrix3* Mat3Ptr;

//--------------------------------------------------------------------- Matrix 3
///3 dimensional square matrix. Supports operations with other 3 dimensional
///square matrices, 2 dimensional vectors, and 3 dimensional vectors.
struct Matrix3
{
#if ColumnBasis == 1
typedef Vector3   BasisVector;
typedef Vec3Param CrossVector;
#else
typedef Vec3Param BasisVector;
typedef Vector3   CrossVector;
#endif

public:
  Matrix3(void) {};
  explicit Matrix3(real p00, real p01, real p02, 
                   real p10, real p11, real p12,
                   real p20, real p21, real p22);
  Matrix3(ConstRealPointer data_);

  //Binary assignment operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary operators (reals)
  Matrix3 operator*(real rhs) const;
  Matrix3 operator/(real rhs) const;

  //Binary assignment operators (matrices)
  void operator+=(Mat3Param rhs);
  void operator-=(Mat3Param rhs);
  
  //Binary operators (matrices)
  Matrix3 operator+(Mat3Param rhs) const;
  Matrix3 operator-(Mat3Param rhs) const;
  Matrix3 operator*(Mat3Param rhs) const;

  //Matrix comparisons
  bool operator==(Mat3Param rhs) const;
  bool operator!=(Mat3Param rhs) const;

  real operator()(uint r, uint c) const;
  real& operator()(uint r, uint c);

  Vector3& operator[](uint index);
  const Vector3& operator[](uint index) const;

  ///Returns a copy of this matrix with its elements transposed.
  Matrix3 Transposed(void) const;

  ///Transposes this matrix in place.
  Mat3Ref Transpose(void);

  ///Returns the inverse of this matrix.
  Matrix3 Inverted(void) const;

  ///Inverts this matrix in place.
  Mat3Ref Invert(void);

  ///Inverts, but clamps the determinant to the smallest positive float number.
  Matrix3 SafeInverted();

  ///Inverts in place, but clamps the determinant to the smallest positive float number.
  void SafeInvert();

  ///Multiplies this matrix with the given matrix on its right-hand side.
  Matrix3 Concat(Mat3Param rhs) const;

  ///Sets this matrix's elements to that of the identity matrix.
  Mat3Ref SetIdentity(void);

  ///Sets all of the elements in this matrix to 0.
  Mat3Ref ZeroOut(void);

  real Determinant(void) const;

  bool Valid(void) const;

  ///Converts this matrix into a pure scaling matrix.
  void Scale(real x, real y, real z);

  ///Converts this matrix into a pure scaling matrix.
  void Scale(Vec3Param rhs);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(real x, real y, real z, real radian);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(Vec3Param rhs, real radian);

  ///Converts this matrix into a pure translation matrix for 2-D vectors.
  void Translate(real x, real y);

  ///Converts this matrix into a pure translation matrix for 2-D vectors.
  void Translate(Vec2Param rhs);

  ///Builds a matrix that should be used on 2D points/vectors
  void BuildTransform(Vec2Param translate, real radians, Vec2Param scale);

  ///Builds a matrix that should be used on 3D points/vectors
  void BuildTransform(QuatParam rotate, Vec3Param scale);

  ///Forces the current matrix to be orthonormal.
  Mat3Ref Orthonormalize(void);

  ///Accesses the basis vector at the given index, with the basis vector defined
  ///as the basis vector of a pure rotation matrix.
  BasisVector Basis(uint index) const;

  ///Accesses the elements in the "x-axis" of the matrix, with the "x-axis" 
  ///defined as the x-axis of a pure rotation matrix.
  BasisVector BasisX(void) const;

  ///Accesses the elements in the "y-axis" of the matrix, with the "y-axis" 
  ///defined as the y-axis of a pure rotation matrix.
  BasisVector BasisY(void) const;

  ///Accesses the elements in the "z-axis" of the matrix, with the "z-axis" 
  ///defined as the z-axis of a pure rotation matrix.
  BasisVector BasisZ(void) const;

  ///Accesses the cross vector at the given index, with the cross vector defined
  ///as the elements in the matrix perpendicular to that of the corresponding
  ///basis vector.
  CrossVector Cross(uint index) const;
  void SetBasis(uint index, Vec3Param basisVector);
  void SetBasis(uint index, real x, real y, real z);
  void SetCross(uint index, Vec3Param crossVector);
  void SetCross(uint index, real x, real y, real z);

  union 
  {
    struct
    {
#if ColumnBasis == 1
      real m00, m01, m02,
           m10, m11, m12, 
           m20, m21, m22;
#else
      real m00, m10, m20,
           m01, m11, m21, 
           m02, m12, m22;
#endif 
    };
    real array[9];
  };

  static const Matrix3 cIdentity;
};

Matrix3 operator*(real lhs, Mat3Param rhs);
Matrix3 Concat(Mat3Param lhs, Mat3Param rhs);

///This builds a matrix that should be used on 2D points/vectors
Matrix3 BuildTransform(Vec2Param translate, real radians, Vec2Param scale);

///This builds a matrix that should be used on 3D points/vectors
Matrix3 BuildTransform(QuatParam rotate, Vec3Param scale);

Vector3 Transform(Mat3Param mat, Vec3Param vector);
void Transform(Mat3Param matrix, Vec3Ptr vector);

/// Applies transformation with the translation (p.x, p.y, 1)
Vector2 TransformPoint(Mat3Param matrix, Vec2Param vector);

/// Applies transformation without the translation (n.x, n.y, 0)
Vector2 TransformNormal(Mat3Param matrix, Vec2Param normal);

///Transforms the given vector by the matrix as if the matrix was transposed.
Vector3 TransposedTransform(Mat3Param mat, Vec3Param vector);

///Transforms the given vector by the matrix as if the matrix was transposed.
void TransposedTransform(Mat3Param matrix, Vec3Ptr vector);

real Trace(Mat3Param matrix);

real Cofactor(Mat3Param matrix, uint row, uint column);

///Takes a symmetric matrix and diagonalizes it.
void Diagonalize(Mat3Ptr matrix);
Matrix3 Diagonalized(Mat3Param matrix);

void Invert(Mat3Ptr matrix);
Matrix3 Inverted(Mat3Param matrix);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Matrix4.hpp
/// Declaration of the Matrix 4 structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{
///Forward declaration
struct Quaternion;
typedef const Quaternion& QuatParam;

///Forward declaration
struct Matrix3;
typedef const Matrix3& Mat3Param;
typedef Matrix3* Mat3Ptr;

struct Matrix4;
typedef Matrix4 Mat4;
typedef const Matrix4& Mat4Param;
typedef Matrix4& Mat4Ref;
typedef Matrix4* Mat4Ptr;

///4 dimensional square matrix. Supports operations with other 4 dimensional
///square matrices, 3 dimensional vectors, and 4 dimensional vectors.
struct Matrix4
{
#if ColumnBasis == 1
typedef Vector4   BasisVector;
typedef Vec4Param CrossVector;
#else
typedef Vec4Param BasisVector;
typedef Vector4   CrossVector;
#endif

public:
  Matrix4(void) {};
  Matrix4(real p00, real p01, real p02, real p03,
          real p10, real p11, real p12, real p13,
          real p20, real p21, real p22, real p23,
          real p30, real p31, real p32, real p33);
  Matrix4(ConstRealPointer data_);
  Matrix4(Vec4Param basisX, Vec4Param basisY,
          Vec4Param basisZ, Vec4Param basisW);

  //Binary assignment operators (reals)
  void operator*=(real rhs);
  void operator/=(real rhs);

  //Binary operators (reals)
  Matrix4 operator*(real rhs) const;
  Matrix4 operator/(real rhs) const;

  //Binary assignment operators (matrices)
  void operator+=(Mat4Param rhs);
  void operator-=(Mat4Param rhs);

  //Binary operators (matrices)
  Matrix4 operator+(Mat4Param rhs) const;
  Matrix4 operator-(Mat4Param rhs) const;
  Matrix4 operator*(Mat4Param rhs) const;

  //Matrix comparisons
  bool operator==(Mat4Param rhs) const;
  bool operator!=(Mat4Param rhs) const;

  real operator()(uint r, uint c) const;
  real& operator()(uint r, uint c);

  ///Returns a copy of this matrix with its elements transposed.
  Matrix4 Transposed(void) const;

  //Transposes this matrix in place.
  Mat4Ref Transpose(void);

  ///Returns the inverse of this matrix.
  Matrix4 Inverted(void) const;

  ///Inverts this matrix in place.
  Mat4Ref Invert(void);

  ///Multiplies this matrix with the given matrix on its right-hand side.
  Matrix4 Concat(Mat4Param rhs) const;

  ///Sets this matrix's elements to that of the identity matrix.
  Mat4Ref SetIdentity(void);

  ///Sets all of the elements in this matrix to 0.
  Mat4Ref ZeroOut(void);

  real Determinant(void) const;
  bool Valid(void) const;

  ///Converts this matrix into a pure scaling matrix.
  void Scale(real x, real y, real z);

  ///Converts this matrix into a pure scaling matrix.
  void Scale(Vec3Param axis);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(real x, real y, real z, real radians);

  ///Converts this matrix into a pure rotation matrix, given an axis-angle pair.
  void Rotate(Vec3Param axis, real radians);

  ///Converts this matrix into a pure translation matrix for 3-D vectors.
  void Translate(real x, real y, real z);

  ///Converts this matrix into a pure translation matrix for 3-D vectors.
  void Translate(Vec3Param axis);

  ///Converts this matrix into a transformation matrix, incorporating 
  ///translation, rotation, and scale. Meant for 3-D vectors.
  void BuildTransform(Vec3Param translate, QuatParam rotate, Vec3Param scale);

  ///Converts this matrix into a transformation matrix, incorporating 
  ///translation, rotation, and scale. Meant for 3-D vectors.
  void BuildTransform(Vec3Param translate, Mat3Param rotate, Vec3Param scale);

  ///Decomposes this matrix into its scale, rotation, and translational
  ///components.
  void Decompose(Vec3Ptr scale, Mat3Ptr rotate, Vec3Ptr translate) const;

  ///Attempts to decompose this matrix into a scale, rotation, and translational
  ///component while removing shear. The "original" matrix is not necessarily
  ///recovered, though the resulting matrix is orthonormal among its components.
  void Decompose(Vec3Ptr scale, Vec3Ptr shear, Mat3Ptr rotate, 
                 Vec3Ptr translate) const;

  ///Accesses the basis vector at the given index, with the basis vector defined
  ///as the basis vector of a pure rotation matrix.
  BasisVector Basis(uint index) const;

  ///Accesses the elements in the "x-axis" of the matrix, with the "x-axis" 
  ///defined as the x-axis of a pure rotation matrix.
  BasisVector BasisX(void) const;

  ///Accesses the elements in the "y-axis" of the matrix, with the "y-axis" 
  ///defined as the y-axis of a pure rotation matrix.
  BasisVector BasisY(void) const;

  ///Accesses the elements in the "z-axis" of the matrix, with the "z-axis" 
  ///defined as the z-axis of a pure rotation matrix.
  BasisVector BasisZ(void) const;

  ///Accesses the elements in the "w-axis" of the matrix, with the "w-axis" 
  ///defined as the w-axis of a pure rotation matrix.
  BasisVector BasisW(void) const;

  ///Accesses the cross vector at the given index, with the cross vector defined
  ///as the elements in the matrix perpendicular to that of the corresponding
  ///basis vector.
  CrossVector Cross(uint index) const;
  void SetBasis(uint index, Vec4Param basisVector);
  void SetBasis(uint index, Vec3Param basisVector3, real w);
  void SetBasis(uint index, real x, Vec3Param basisVector3);
  void SetBasis(uint index, real x, real y, real z, real w);
  void SetCross(uint index, Vec4Param crossVector);
  void SetCross(uint index, Vec3Param crossVector3, real w);
  void SetCross(uint index, real x, real y, real z, real w);

  ///Accesses the 3-D basis vector at the given index, ignores the last element.
  Vector3 Basis3(uint index) const;

  ///Accesses the first 3 elements in the "x-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3X(void) const;

  ///Accesses the first 3 elements in the "y-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3Y(void) const;
  
  ///Accesses the first 3 elements in the "z-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3Z(void) const;

  ///Accesses the first 3 elements in the "w-axis" of the matrix, ignoring the
  ///last element.
  Vector3 Basis3W(void) const;

  ///Accesses the 3-D cross vector at the given index, ignores the last element.
  Vector3 Cross3(uint index) const;

  Vector4& operator[](uint index){return ((Vector4*)this)[index];}
  const Vector4& operator[](uint index)const{return ((Vector4*)this)[index];}

  union 
  {
    struct
    {
#if ColumnBasis == 1
      real m00, m01, m02, m03, 
           m10, m11, m12, m13, 
           m20, m21, m22, m23, 
           m30, m31, m32, m33;
#else
      real m00, m10, m20, m30, 
           m01, m11, m21, m31, 
           m02, m12, m22, m32, 
           m03, m13, m23, m33;
#endif
    };

    real array[16];
  };

  static const Matrix4 cIdentity;
};

Matrix4 operator*(real lhs, Mat4Param rhs);
Matrix4 Concat(Mat4Param lhs, Mat4Param rhs);

Matrix4 BuildTransform(Vec3Param translate, QuatParam rotate, Vec3Param scale);
Matrix4 BuildTransform(Vec3Param translate, Mat3Param rotate, Vec3Param scale);

Vector4 Transform(Mat4Param mat, Vec4Param vector);
void Transform(Mat4Param mat, Vec4Ptr vector);

///Applies transformation with the translation (p.x, p.y, p.z, 1)
Vector3 TransformPoint(Mat4Param matrix, Vec3Param point);

///Applies transformation without the translation (n.x, n.y, n.z, 0)
Vector3 TransformNormal(Mat4Param matrix, Vec3Param normal);

///Applies transform and projects back to (w = 1)
Vector3 TransformPointProjected(Mat4Param matrix, Vec3Param point);

Vector3 TransformNormalCol(Mat4Param matrix, Vec3Param normal);
Vector3 TransformPointCol(Mat4Param matrix, Vec3Param point);
Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point);
Vector3 TransformPointProjectedCol(Mat4Param matrix, Vec3Param point, real* w);

real Trace(Mat4Param matrix);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file Quaternion.hpp
/// Declaration of the Quaternion structure.
/// 
/// Authors: Joshua Davis, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

///Forward declaration
struct Matrix3;
typedef const Matrix3& Mat3Param;
typedef Matrix3& Mat3Ref;

///Forward declaration
struct Matrix4;
typedef const Matrix4& Mat4Param;
typedef Matrix4& Mat4Ref;

struct Quaternion;
typedef const Quaternion& QuatParam;
typedef Quaternion& QuatRef;
typedef Quaternion* QuatPtr;
typedef Quaternion Quat;

//------------------------------------------------------------------- Quaternion
struct Quaternion
{
  static const Quaternion cIdentity;

  Quaternion(void) {};
  explicit Quaternion(real x, real y, real z, real w);

  void operator=(QuatParam rhs);
  void operator+=(QuatParam rhs);
  void operator-=(QuatParam rhs);
  void operator*=(QuatParam rhs);
  void operator*=(real rhs);
  void operator/=(real rhs);

  Quaternion operator-(void) const;

  Quaternion operator*(QuatParam rhs) const;
  Quaternion operator+(QuatParam rhs) const;
  Quaternion operator-(QuatParam rhs) const;
  Quaternion operator*(real rhs) const;
  Quaternion operator/(real rhs) const;

  bool operator==(QuatParam rhs) const;
  bool operator!=(QuatParam rhs) const;

  real& operator[](uint index);
  real operator[](uint index) const;

  void Set(real x, real y, real z, real w);

  void Integrate(Vec3Param vector, real scalar);

  real Normalize(void);
  Quaternion Normalized(void) const;
  real Dot(QuatParam rhs) const;
  real Length(void) const;
  real LengthSq(void) const;

  void Conjugate(void);
  Quaternion Conjugated(void) const;
  void Invert(void);
  Quaternion Inverted(void) const;
  Quaternion Exponent(void) const;
  Quaternion Logarithm(void) const;
  //Quaternion Lerp(QuatParam end, real tValue);
  //Quaternion Slerp(QuatParam end, real tValue);
  void RotateVector(Vec3Ptr vector);
  Vector3 RotatedVector(Vec3Param vector) const;
  void ZeroOut(void);

  bool Valid(void) const;

  Vector3& V3();
  Vector4& V4();
  const Vector3& V3() const;
  const Vector4& V4() const;

  real x, y, z, w;
};

Quaternion operator*(real lhs, QuatParam rhs);

void Normalize(QuatPtr quaternion);
Quaternion Normalized(QuatParam quaternion);
real Dot(QuatParam lhs, QuatParam rhs);
real Length(QuatParam quaternion);
real LengthSq(QuatParam quaternion);
Quaternion Lerp(QuatParam start, QuatParam end, real tValue);
Quaternion Slerp(QuatParam start, QuatParam end, real tValue);
Quaternion CreateDiagonalizer(Mat3Param matrix);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerAngles.hpp
///  Declaration of the EulerAngle structure, interface referenced from
///  Insomniac Games, implementation referenced from Graphics Gems IV.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
///
///  \file EulerOrder.hpp
///  Declaration of the Euler angles order as described in Graphic Gems IV,
///  EulerOrder design referenced from Insomniac Games.
///  
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

/*
  Ken Shoemake, 1993

  Order type constants, constructors, extractors
    There are 24 possible conventions, designated by:
       - EulAxI = axis used initially
       - EulPar = parity of axis permutation
       - EulRep = repetition of initial axis as last
       - EulFrm = frame from which axes are taken
    Axes I, J, K will be a permutation of X, Y, Z.
    Axis H will be either I or K, depending on EulRep.
    Frame S takes axes from initial static frame.
    If ord = (AxI = X, Par = Even, Rep = No, Frm = S), then
    {a, b, c, ord} means Rz(c)Ry(b)Rx(a), where Rz(c)v
    rotates v around Z by c radians
*/
namespace EulerOrders
{

const uint Safe[4] = { 0, 1, 2, 0 };
const uint Next[4] = { 1, 2, 0, 1 };

///The two different types of reference frames
const uint Static  = 0;
const uint Rotated = 1;

///The two different states of "is there a repeated axis?"
const uint No  = 0;
const uint Yes = 1;

///Two different states of parity
const uint Even = 0;
const uint Odd  = 1;

///CreateOrder creates an order value between 0 and 23 from 4-tuple choices.
#define CreateOrder(axis, parity, repeated, frame) (((((((axis) << 1)      + \
                                                         (parity)) << 1)   + \
                                                         (repeated)) << 1) + \
                                                         (frame))

///Bit fields to describe the different permutations of rotations, reference
///frames, repeated axes, and parity
enum Enum
{
  X = 0,
  Y,
  Z,

  //Static axes
  XYZs = CreateOrder(X, Even, No,  Static),
  XYXs = CreateOrder(X, Even, Yes, Static),
  XZYs = CreateOrder(X, Odd,  No,  Static),
  XZXs = CreateOrder(X, Odd,  Yes, Static),

  YZXs = CreateOrder(Y, Even, No,  Static),
  YZYs = CreateOrder(Y, Even, Yes, Static),
  YXZs = CreateOrder(Y, Odd,  No,  Static),
  YXYs = CreateOrder(Y, Odd,  Yes, Static),
  
  ZXYs = CreateOrder(Z, Even, No,  Static),
  ZXZs = CreateOrder(Z, Even, Yes, Static),
  ZYXs = CreateOrder(Z, Odd,  No,  Static),
  ZYZs = CreateOrder(Z, Odd,  Yes, Static),

  //Rotating axes
  ZYXr = CreateOrder(X, Even, No,  Rotated),
  XYXr = CreateOrder(X, Even, Yes, Rotated),
  YZXr = CreateOrder(X, Odd,  No,  Rotated),
  XZXr = CreateOrder(X, Odd,  Yes, Rotated),
  
  XZYr = CreateOrder(Y, Even, No,  Rotated),
  YZYr = CreateOrder(Y, Even, Yes, Rotated),
  ZXYr = CreateOrder(Y, Odd,  No,  Rotated),
  YXYr = CreateOrder(Y, Odd,  Yes, Rotated),

  YXZr = CreateOrder(Z, Even, No,  Rotated),
  ZXZr = CreateOrder(Z, Even, Yes, Rotated),
  XYZr = CreateOrder(Z, Odd,  No,  Rotated),
  ZYZr = CreateOrder(Z, Odd,  Yes, Rotated)
};

#undef CreateOrder

}// namespace EulerOrders

struct EulerOrder;
typedef EulerOrder&       EulerOrderRef;
typedef const EulerOrder& EulerOrderParam;

///Structure to hold the order of rotations when dealing with Euler angles,
///whether or not there are any repeating angles, and if the rotations are being
///described in a fixed or rotated frame of reference.
struct EulerOrder
{
  EulerOrder(EulerOrders::Enum eulerOrder);

  EulerOrder& operator = (EulerOrderParam rhs);

  bool operator == (EulerOrderParam rhs);
  bool operator != (EulerOrderParam rhs);

  ///Get the index of the first angle in the Euler angle rotation sequence.
  uint I(void) const;

  ///Get the index of the second angle in the Euler angle rotation sequence.
  uint J(void) const;

  ///Get the index of the third angle in the Euler angle rotation sequence.
  uint K(void) const;

  ///Will be I if there are repeating angles, will be K otherwise.
  uint H(void) const;

  bool RepeatingAngles(void) const;
  bool RotatingFrame(void) const;
  bool OddParity(void) const;

  ///Unpacks all useful information about order simultaneously.
  static void GetOrder(EulerOrder order, uint& i, uint& j, uint& k, uint& h, 
                       uint& parity, uint& repeated, uint& frame);

  EulerOrders::Enum Order;
};

}// namespace Math

namespace Math
{

///Forward declaration
struct Matrix3;
typedef const Matrix3& Mat3Param;
typedef Matrix3& Mat3Ref;

///Forward declaration
struct Matrix4;
typedef const Matrix4& Mat4Param;
typedef Matrix4& Mat4Ref;

///Forward declaration
struct Quaternion;
typedef const Quaternion& QuatParam;
typedef Quaternion& QuatRef;

struct EulerAngles;
typedef const EulerAngles&  EulerAnglesParam;
typedef EulerAngles&        EulerAnglesRef;
typedef EulerAngles*        EulerAnglesPtr;

//----------------------------------------------------------------- Euler Angles
///Structure to provide a consistent way to deal with rotations stored as Euler
///angles.
struct EulerAngles
{
  EulerAngles(EulerOrderParam order);
  EulerAngles(Vec3Param xyzRotation, EulerOrderParam order);
  EulerAngles(real xRotation, real yRotation, real zRotation, 
              EulerOrderParam order);
  EulerAngles(Mat3Param matrix, EulerOrderParam order);
  EulerAngles(Mat4Param matrix, EulerOrderParam order);
  EulerAngles(QuatParam quaternion, EulerOrderParam order);

  ///Index operator to access the Angles data directly.
  real operator [] (uint index) const;

  ///Index operator to access the Angles data directly.
  real& operator [] (uint index);

  real I(void) const;
  real J(void) const;
  real K(void) const;
  real H(void) const;

  void I(real i);
  void J(real j);
  void K(real k);
  void H(real h);

  void Reorder(EulerOrderParam newOrder);

  Vector3     Angles;
  EulerOrder  Order;
};

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file IntVector2.hpp
/// Declaration of the IntVector2 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

struct IntVector2;
typedef IntVector2 IntVec2;
typedef const IntVector2& IntVec2Param;
typedef IntVector2& IntVec2Ref;
typedef IntVector2* IntVec2Ptr;

///2 dimensional integral vector.
struct IntVector2
{
  IntVector2(void) {}
  explicit IntVector2(int x, int y);

  int& operator[](uint index);
  int operator[](uint index) const;

  //Unary Operators
  IntVector2 operator-(void) const;

  //Binary Assignment Operators (integers)
  void operator*=(int rhs);
  void operator/=(int rhs);

  //Binary Operators (integers)
  IntVector2 operator*(int rhs) const;
  IntVector2 operator/(int rhs) const;
  IntVector2 operator%(int rhs) const;

  //Unary operators
  IntVector2& operator++();
  IntVector2& operator--();

  //Binary Assignment Operators (vectors)
  void operator+=(IntVec2Param rhs);
  void operator-=(IntVec2Param rhs);
  void operator*=(IntVec2Param rhs);
  void operator/=(IntVec2Param rhs);

  //Binary Operators (vectors)
  IntVector2 operator+(IntVec2Param rhs) const;
  IntVector2 operator-(IntVec2Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(IntVec2Param rhs) const;
  bool operator!=(IntVec2Param rhs) const;

  //Vector component-wise multiply and divide
  IntVector2 operator*(IntVec2Param rhs) const;
  IntVector2 operator/(IntVec2Param rhs) const;
  IntVector2 operator%(IntVec2Param rhs) const;
  
  //Bitwise operators
  IntVector2  operator~() const;
  IntVector2  operator<< (IntVec2Param rhs) const;
  IntVector2  operator>> (IntVec2Param rhs) const;
  IntVector2  operator|  (IntVec2Param rhs) const;
  IntVector2  operator^  (IntVec2Param rhs) const;
  IntVector2  operator&  (IntVec2Param rhs) const;
  IntVector2& operator<<=(IntVec2Param rhs);
  IntVector2& operator>>=(IntVec2Param rhs);
  IntVector2& operator|= (IntVec2Param rhs);
  IntVector2& operator^= (IntVec2Param rhs);
  IntVector2& operator&= (IntVec2Param rhs);

  //Comparison operators
  BoolVec2 operator< (IntVec2Param rhs) const;
  BoolVec2 operator<=(IntVec2Param rhs) const;
  BoolVec2 operator> (IntVec2Param rhs) const;
  BoolVec2 operator>=(IntVec2Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(int x, int y);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  union
  {
    struct  
    {
      int x, y;
    };
    int array[2];
  };

  static const IntVector2 cZero;
  static const IntVector2 cXAxis;
  static const IntVector2 cYAxis;
};

///Binary Operators (integers)
IntVector2 operator*(int lhs, IntVec2Param rhs);

///Returns a vector with absolute valued elements of the given vector.
IntVector2 Abs(IntVec2Param vec);

///Returns the component-wise minimum vector of the two vectors.
IntVector2 Min(IntVec2Param lhs, IntVec2Param rhs);

///Returns the component-wise maximum vector of the two vectors.
IntVector2 Max(IntVec2Param lhs, IntVec2Param rhs);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file IntVector3.hpp
/// Declaration of the IntVector3 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

struct IntVector3;
typedef IntVector3 IntVec3;
typedef const IntVector3& IntVec3Param;
typedef IntVector3& IntVec3Ref;
typedef IntVector3* IntVec3Ptr;

///3 dimensional integral vector.
struct IntVector3
{
  IntVector3(void) {}
  explicit IntVector3(int x, int y, int z);

  int& operator[](uint index);
  int operator[](uint index) const;

  //Unary Operators
  IntVector3 operator-(void) const;

  //Binary Assignment Operators (integers)
  void operator*=(int rhs);
  void operator/=(int rhs);

  //Binary Operators (integers)
  IntVector3 operator*(int rhs) const;
  IntVector3 operator/(int rhs) const;
  IntVector3 operator%(int rhs) const;

  //Unary operators
  IntVector3& operator++();
  IntVector3& operator--();

  //Binary Assignment Operators (vectors)
  void operator+=(IntVec3Param rhs);
  void operator-=(IntVec3Param rhs);
  void operator*=(IntVec3Param rhs);
  void operator/=(IntVec3Param rhs);

  //Binary Operators (vectors)
  IntVector3 operator+(IntVec3Param rhs) const;
  IntVector3 operator-(IntVec3Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(IntVec3Param rhs) const;
  bool operator!=(IntVec3Param rhs) const;

  //Vector component-wise multiply and divide
  IntVector3 operator*(IntVec3Param rhs) const;
  IntVector3 operator/(IntVec3Param rhs) const;
  IntVector3 operator%(IntVec3Param rhs) const;
  
  //Bitwise operators
  IntVector3  operator~() const;
  IntVector3  operator<< (IntVec3Param rhs) const;
  IntVector3  operator>> (IntVec3Param rhs) const;
  IntVector3  operator|  (IntVec3Param rhs) const;
  IntVector3  operator^  (IntVec3Param rhs) const;
  IntVector3  operator&  (IntVec3Param rhs) const;
  IntVector3& operator<<=(IntVec3Param rhs);
  IntVector3& operator>>=(IntVec3Param rhs);
  IntVector3& operator|= (IntVec3Param rhs);
  IntVector3& operator^= (IntVec3Param rhs);
  IntVector3& operator&= (IntVec3Param rhs);

  //Comparison operators
  BoolVec3 operator< (IntVec3Param rhs) const;
  BoolVec3 operator<=(IntVec3Param rhs) const;
  BoolVec3 operator> (IntVec3Param rhs) const;
  BoolVec3 operator>=(IntVec3Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(int x, int y, int z);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  union
  {
    struct  
    {
      int x, y, z;
    };
    int array[3];
  };

  static const IntVector3 cZero;
  static const IntVector3 cXAxis;
  static const IntVector3 cYAxis;
  static const IntVector3 cZAxis;
};

///Binary Operators (integers)
IntVector3 operator*(int lhs, IntVec3Param rhs);

///Returns a vector with absolute valued elements of the given vector.
IntVector3 Abs(IntVec3Param vec);

///Returns the component-wise minimum vector of the two vectors.
IntVector3 Min(IntVec3Param lhs, IntVec3Param rhs);

///Returns the component-wise maximum vector of the two vectors.
IntVector3 Max(IntVec3Param lhs, IntVec3Param rhs);

}// namespace Math

///////////////////////////////////////////////////////////////////////////////
///
/// \file IntVector4.hpp
/// Declaration of the IntVector4 structure.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

struct IntVector4;
typedef IntVector4 IntVec4;
typedef const IntVector4& IntVec4Param;
typedef IntVector4& IntVec4Ref;
typedef IntVector4* IntVec4Ptr;

///3 dimensional integral vector.
struct IntVector4
{
  IntVector4(void) {}
  explicit IntVector4(int x, int y, int z, int w);

  int& operator[](uint index);
  int operator[](uint index) const;

  //Unary Operators
  IntVector4 operator-(void) const;

  //Binary Assignment Operators (integers)
  void operator*=(int rhs);
  void operator/=(int rhs);

  //Binary Operators (integers)
  IntVector4 operator*(int rhs) const;
  IntVector4 operator/(int rhs) const;
  IntVector4 operator%(int rhs) const;

  //Unary operators
  IntVector4& operator++();
  IntVector4& operator--();

  //Binary Assignment Operators (vectors)
  void operator+=(IntVec4Param rhs);
  void operator-=(IntVec4Param rhs);
  void operator*=(IntVec4Param rhs);
  void operator/=(IntVec4Param rhs);

  //Binary Operators (vectors)
  IntVector4 operator+(IntVec4Param rhs) const;
  IntVector4 operator-(IntVec4Param rhs) const;

  //Binary Vector Comparisons
  bool operator==(IntVec4Param rhs) const;
  bool operator!=(IntVec4Param rhs) const;

  //Vector component-wise multiply and divide
  IntVector4 operator*(IntVec4Param rhs) const;
  IntVector4 operator/(IntVec4Param rhs) const;
  IntVector4 operator%(IntVec4Param rhs) const;
  
  //Bitwise operators
  IntVector4  operator~() const;
  IntVector4  operator<< (IntVec4Param rhs) const;
  IntVector4  operator>> (IntVec4Param rhs) const;
  IntVector4  operator|  (IntVec4Param rhs) const;
  IntVector4  operator^  (IntVec4Param rhs) const;
  IntVector4  operator&  (IntVec4Param rhs) const;
  IntVector4& operator<<=(IntVec4Param rhs);
  IntVector4& operator>>=(IntVec4Param rhs);
  IntVector4& operator|= (IntVec4Param rhs);
  IntVector4& operator^= (IntVec4Param rhs);
  IntVector4& operator&= (IntVec4Param rhs);

  //Comparison operators
  BoolVec4 operator< (IntVec4Param rhs) const;
  BoolVec4 operator<=(IntVec4Param rhs) const;
  BoolVec4 operator> (IntVec4Param rhs) const;
  BoolVec4 operator>=(IntVec4Param rhs) const;

  ///Set all of the values of this vector at once.
  void Set(int x, int y, int z, int w);

  ///Set all of this vector's elements to 0.
  void ZeroOut(void);

  union
  {
    struct  
    {
      int x, y, z, w;
    };
    int array[4];
  };

  static const IntVector4 cZero;
  static const IntVector4 cXAxis;
  static const IntVector4 cYAxis;
  static const IntVector4 cZAxis;
  static const IntVector4 cWAxis;
};

///Binary Operators (integers)
IntVector4 operator*(int lhs, IntVec4Param rhs);

///Returns a vector with absolute valued elements of the given vector.
IntVector4 Abs(IntVec4Param vec);

///Returns the component-wise minimum vector of the two vectors.
IntVector4 Min(IntVec4Param lhs, IntVec4Param rhs);

///Returns the component-wise maximum vector of the two vectors.
IntVector4 Max(IntVec4Param lhs, IntVec4Param rhs);

}// namespace Math

namespace Math
{

///Creates a skew symmetric matrix from the given 3D vector. Multiplying a 
///vector by this matrix is equivalent to the cross product using the input 
///vector.
Matrix3 SkewSymmetric(Vec3Param vec3);

///Projects the normal out of the vector. Dot(normal, result) will be 0.
Vector3 ProjectOut(Vec3Param vector, Vec3Param normal);

///Projects the passed in vector on to the given axis.
Vector3 Project(Vec3Param a, Vec3Param axis);

///Reflects the passed in vector across the given axis.
Vector3 Reflect(Vec3Param a, Vec3Param axis);

///Converts a quaternion to an axis-angle pair (in radians). Axis is stored in 
///the Vector4's xyz and the angle is stored in the w.
Vector4 ToAxisAngle(QuatParam quaternion);
void ToAxisAngle(QuatParam quaternion, Vec4Ptr axisAngle);

///Converts a quaternion to an axis-angle pair (in radians).
void ToAxisAngle(QuatParam quaternion, Vec3Ptr axis, real* radians);

///Convert a 3x3 matrix to a set of Euler angles (in radians). The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(Mat3Param matrix, 
                          EulerOrders::Enum order = EulerOrders::XYZs);
void ToEulerAngles(Mat3Param matrix, EulerAnglesPtr eulerAngles);

///Convert a 4x4 matrix to a set of Euler angles in radians. The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(Mat4Param matrix,
                          EulerOrders::Enum order = EulerOrders::XYZs);
void ToEulerAngles(Mat4Param matrix, EulerAnglesPtr eulerAngles);

///Convert a quaternion to a set of Euler angles (in radians). The desired order
///of the rotations is expected to be in the given Euler angle structure.
EulerAngles ToEulerAngles(QuatParam quaternion, 
                          EulerOrders::Enum order = EulerOrders::XYZs);
void ToEulerAngles(QuatParam quaternion, EulerAnglesPtr eulerAngles);

/// Converts from Vector3 to Vector2, removing the z component of the Vector3.
Vector2 ToVector2(Vec3Param v3);

/// Converts from Vector2 to Vector3, adding the given z component.
Vector3 ToVector3(Vec2Param v, real z = real(0.0));

/// Converts from Vector3 to Vector4, adding the given w component.
inline Vec4 ToVector4(Vec3Param v, real w = real(0.0)){return Vec4(v.x, v.y, v.z, w);}

// Convert from a IntVec2 to a Vec2
inline Vec2 ToVec2(IntVec2 v){return Vec2(real(v.x), real(v.y));}

// Convert from a Vec2 to a IntVec2 standard float to int conversion
inline IntVec2 ToIntVec2(Vec2 vec2){return IntVec2(int(vec2.x), int(vec2.y));}

/// Turns the 3D transformation matrix into 2D.
Matrix3 ProjectXY(Mat4Param mat4);

///Converts an axis-angle pair to a 3x3 (in radians). Axis is stored in the
///Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
///normalized.
Matrix3 ToMatrix3(Vec4Param axisAngle);
void ToMatrix3(Vec4Param axisAngle, Mat3Ptr matrix);

///Converts an axis-angle pair to a 3x3 matrix (in radians). Axis is assumed to
///be normalized.
Matrix3 ToMatrix3(Vec3Param axis, real radians);
void ToMatrix3(Vec3Param axis, real radians, Mat3Ptr matrix);

///Convert a set of Euler angles to a 3x3 matrix (in radians).
Matrix3 ToMatrix3(EulerAnglesParam eulerAngles);
void ToMatrix3(EulerAnglesParam eulerAngles, Mat3Ptr matrix);

///Convert a 4x4 matrix to a 3x3 matrix. Simply copies the 4x4 matrix's upper 
///3x3 matrix (rotation & scale) to the 3x3 matrix.
Matrix3 ToMatrix3(Mat4Param matrix4);
void ToMatrix3(Mat4Param matrix4, Mat3Ptr matrix3);

///Converts a quaternion to a 3x3 rotation matrix (in radians).
Matrix3 ToMatrix3(QuatParam quaternion);
void ToMatrix3(QuatParam quaternion, Mat3Ptr matrix);

Matrix3 ToMatrix3(Vec3Param facing);
Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up);
Matrix3 ToMatrix3(Vec3Param facing, Vec3Param up, Vec3Param right);

///Convert a set of Euler angles to a 4x4 matrix (in radians).
Matrix4 ToMatrix4(EulerAnglesParam eulerAngles);
void ToMatrix4(EulerAnglesParam eulerAngles, Mat4Ptr matrix);

///Convert a 3x3 matrix to a 4x4 matrix. Simply copies the 3x3 matrix's values
///into the rotational part of the 4x4 matrix.
Matrix4 ToMatrix4(Mat3Param matrix3);
void ToMatrix4(Mat3Param matrix3, Mat4Ptr matrix4);

///Converts a quaternion to a 4x4 rotation matrix (in radians).
Matrix4 ToMatrix4(QuatParam quaternion);
void ToMatrix4(QuatParam quaternion, Mat4Ptr matrix);

///Converts an axis-angle pair to a quaternion (in radians). Axis is stored in
///the Vector4's xyz and the angle is stored in the w. Axis is assumed to be 
///normalized.
Quaternion ToQuaternion(Vec4Param axisAngle);
void ToQuaternion(Vec4Param axisAngle, QuatPtr quaternion);

///Converts an axis-angle pair to a quaternion (in radians). Axis is assumed to
///be normalized.
Quaternion ToQuaternion(Vec3Param axis, real radians);
void ToQuaternion(Vec3Param axis, real radians, QuatPtr quaternion);

///Convert a set of Euler angles to a quaternion (in radians).
Quaternion ToQuaternion(Vec3Param eulerVector);

///Convert a set of Euler angles to a quaternion (in radians).
Quaternion ToQuaternion(EulerAnglesParam eulerAngles);
void ToQuaternion(EulerAnglesParam eulerAngles, QuatPtr quaternion);

///Converts a 3x3 matrix to a quaternion (in radians).
Quaternion ToQuaternion(Mat3Param matrix);
void ToQuaternion(Mat3Param matrix, QuatPtr quaternion);

///Converts a 4x4 matrix to a quaternion (in radians).
Quaternion ToQuaternion(Mat4Param matrix);
void ToQuaternion(Mat4Param matrix, QuatPtr quaternion);

Quaternion ToQuaternion(Vec3Param facing, Vec3Param up);
Quaternion ToQuaternion(Vec3Param facing, Vec3Param up, Vec3Param right);
///Generates a quaternion from the x,y,z axis angles.
Quaternion ToQuaternion(real x, real y, real z);
///Generates the quaternion that rotates start to end.
Quaternion RotationQuaternionBetween(Vec3Param start, Vec3Param end);

///Generates a set of orthonormal vectors from the given vectors, modifying u 
///and v.
void GenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v);

///Doesn't blow up on zero vectors
void DebugGenerateOrthonormalBasis(Vec3Param w, Vec3Ptr u, Vec3Ptr v);

///Perform the dot product with the specified basis vector of the 3x3 matrix and
///the given vector.
real BasisNDot(Mat3Param matrix, uint basisIndex, Vec3Param vector);

///Perform the dot product with the specified basis vector of the 3x3 matrix and
///the given vector.
real BasisNDot(Mat4Param matrix, uint basisIndex, Vec4Param vector);

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the x-axis (if the matrix is pure rotation) and the given vector.
real BasisXDot(Mat3Param matrix, Vec3Param vector);

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the y-axis (if the matrix is pure rotation) and the given vector.
real BasisYDot(Mat3Param matrix, Vec3Param vector);

///Perform the dot product with the basis vector of the 3x3 matrix that 
///represents the z-axis (if the matrix is pure rotation) and the given vector.
real BasisZDot(Mat3Param matrix, Vec3Param vector);

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the x-axis (if the matrix is pure rotation) and the given vector.
real BasisXDot(Mat4Param matrix, Vec4Param vector);

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the y-axis (if the matrix is pure rotation) and the given vector.
real BasisYDot(Mat4Param matrix, Vec4Param vector);

///Perform the dot product with the basis vector of the 4x4 matrix that 
///represents the z-axis (if the matrix is pure rotation) and the given vector.
real BasisZDot(Mat4Param matrix, Vec4Param vector);

///Converts a 32-bit float into a compressed 16-bit floating point value;
///referenced from Insomniac Games math library.
half ToHalf(float value);

///Converts a 16-bit compressed floating point value back into a 32-bit float;
///referenced from Insomniac Games math library.
float ToFloat(half value);

//----------------------------------------------------------- Rotation Functions
/// Get angle between two 2D vectors in radians.
real Angle(Vec2Param a, Vec2Param b);

/// Get angle between two 3D vectors in radians.
real Angle(Vec3Param a, Vec3Param b);

/// Get angle between two quaternions in radians.
real Angle(QuatParam a, QuatParam b);

/// Computes the angle about the z-axis between the vector and the x-axis
real Angle2D(Vec3Param a);

/// Spherical linear interpolation for unit 2D vectors.
/// Interpolates along the surface of the unit sphere.
Vector2 Slerp(Vec2Param start, Vec2Param end, real t);
/// Same as slerp except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector2 SafeSlerp(Vec2Param start, Vec2Param end, real t);

/// Spherical linear interpolation for unit 3D vectors.
/// Interpolates along the surface of the unit sphere.
Vector3 Slerp(Vec3Param start, Vec3Param end, real t);
/// Same as slerp except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector3 SafeSlerp(Vec3Param start, Vec3Param end, real t);

/// Rotate a 2D vector towards another 2D vector changing at most maxAngle,
/// maxAngle is in radians.
Vector2 RotateTowards(Vec2Param a, Vec2Param b, real maxAngle);
/// Same as RotateTowards except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector2 SafeRotateTowards(Vec2Param a, Vec2Param b, real maxAngle);

/// Rotate a 3D vector towards another 3D vector changing at most maxAngle,
/// maxAngle is in radians.
Vector3 RotateTowards(Vec3Param a, Vec3Param b, real maxAngle);
/// Same as RotateTowards except this function deals correctly with
/// invalid vectors. Used for binding to scripting languages.
Vector3 SafeRotateTowards(Vec3Param a, Vec3Param b, real maxAngle);

/// Rotate a quaternion towards another quaternion changing at most maxAngle,
/// maxAngle is in radians.
Quat RotateTowards(QuatParam a, QuatParam b, real maxAngle);

/// Get the rotation angle between two vectors in radians.
real SignedAngle(Vec3Param a, Vec3Param b, Vec3Param up);

/// Rotate a vector about an axis by the given angle.
Vector3 RotateVector(Vec3Param a, Vec3Param axis, real radians);

/// Converts Euler degrees to a quaternion.
Quat EulerDegreesToQuat(Vec3Param eulerDegrees);

/// Converts a quaternion to Euler degrees.
Vector3 QuatToEulerDegrees(QuatParam rotation);

}// namespace Math

// Bring Zero primitives into the Zilch namespace
namespace Zilch
{
  // Zero types
  using Zero::AutoHandle;
  using Zero::Array;
  using Zero::BaseInList;
  using Zero::BuildString;
  using Zero::EqualTo;
  using Zero::ErrorSignaler;
  using Zero::FixedArray;
  using Zero::FixedString;
  using Zero::FindFirstIndex;
  using Zero::HashMap;
  using Zero::HashPolicy;
  using Zero::HashSet;
  using Zero::HashString;
  using Zero::InList;
  using Zero::JoinStrings;
  using Zero::Link;
  using Zero::Memory::Shutdown;
  using Zero::OsEvent;
  using Zero::OsInt;
  using Zero::OwnedArray;
  using Zero::PodArray;
  using Zero::Pair;
  using Zero::PodBlockArray;
  using Zero::Semaphore;
  using Zero::Socket;
  using Zero::SocketAddress;
  using Zero::sort;
  using Zero::StandardTraits;
  using Zero::Status;
  using Zero::String;
  using Zero::StringRange;
  using Zero::StringBuilder;
  using Zero::Thread;
  using Zero::ThreadLock;
  using Zero::ToValue;
  using Zero::UniquePointer;

  // Math types
  typedef Math::BoolVector2 Boolean2;
  typedef Math::BoolVector3 Boolean3;
  typedef Math::BoolVector4 Boolean4;
  typedef Math::IntVector2 Integer2;
  typedef Math::IntVector3 Integer3;
  typedef Math::IntVector4 Integer4;
  typedef Math::Vector2 Real2;
  typedef Math::Vector3 Real3;
  typedef Math::Vector4 Real4;
  typedef Math::Quaternion Quaternion;

  // For efficiency
  typedef const Boolean2& Boolean2Param;
  typedef const Boolean3& Boolean3Param;
  typedef const Boolean4& Boolean4Param;
  typedef const Integer2& Integer2Param;
  typedef const Integer3& Integer3Param;
  typedef const Integer4& Integer4Param;
  typedef const Real2& Real2Param;
  typedef const Real3& Real3Param;
  typedef const Real4& Real4Param;
  typedef const String& StringParam;
  typedef const Quaternion& QuaternionParam;

  // Math functions
  using Math::EulerAngles;
  using Math::ToAxisAngle;
  using Math::ToEulerAngles;
  using Math::ToQuaternion;

  // Standard types / functions
  using std::nullptr_t;
  using std::numeric_limits;
  using std::clock;
  using std::clock_t;
}

// Special macros
#define ZilchForEach(VariableName, Range) forRange(VariableName, Range)

// Zilch Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FORWARD_DECLARATIONS_HPP
#define ZILCH_FORWARD_DECLARATIONS_HPP

namespace Zilch
{
  // Forward declarations
  class Any;
  class AnyType;
  class AttributeNode;
  class BinaryOperator;
  class BinaryOperatorNode;
  class BoundSyntaxType;
  class BoundType;
  class BreakNode;
  class Call;
  class CastOperator;
  class ClassContext;
  class ClassNode;
  class ClassType;
  class CodeFormatter;
  class CodeGenerator;
  class CodeLocation;
  class CollectorContext;
  class CompilationErrors;
  class ConditionalLoopNode;
  class ConstructorNode;
  class ContinueNode;
  class CreationCallNode;
  class CreationInitializerNode;
  class DebugBreakNode;
  class Debugger;
  class DelegateSyntaxParameter;
  class DelegateSyntaxType;
  class DelegateType;
  class DeleteNode;
  class DestructorNode;
  class DoWhileNode;
  class EnumNode;
  class EnumValueNode;
  class Exception;
  class ExceptionReport;
  class ExecutableState;
  class ExpressionNode;
  class Field;
  class ForEachNode;
  class ForNode;
  class Function;
  class FunctionCallNode;
  class FunctionNode;
  class GeneratorContext;
  class GeneratorWalkerDatabase;
  class GenericFunctionNode;
  class Handle;
  class HandleManager;
  class HeapManager;
  class IdentifierNode;
  class IfNode;
  class IfRootNode;
  class IndexerCallNode;
  class IndirectionSyntaxType;
  class IndirectionType;
  class InitializerNode;
  class Library;
  class LibraryBuilder;
  class LocalVariableNode;
  class LocalVariableReferenceNode;
  class LoopNode;
  class LoopScopeNode;
  class MemberAccessNode;
  class MemberVariableNode;
  class Module;
  class Opcode;
  class Operand;
  class ParameterNode;
  class PointerManager;
  class PostExpressionNode;
  class Project;
  class Property;
  class PropertyDelegateOperatorNode;
  class RelativeJumpOpcode;
  class Resolver;
  class ReturnNode;
  class RootNode;
  class ScopeNode;
  class ScriptingEnginePrivateData;
  class SendsEvent;
  class SendsEventNode;
  class StackData;
  class StackManager;
  class StatementNode;
  class StaticLibraries;
  class StaticLibrary;
  class StringBuilderExtended;
  class StringInterpolantNode;
  class StringManager;
  class Syntaxer;
  class SyntaxNode;
  class SyntaxTree;
  class SyntaxType;
  class ThrowNode;
  class TimeoutNode;
  class Tokenizer;
  class Type;
  class TypeCastNode;
  class TypeIdNode;
  class TypeMemberAccessNode;
  class TypingContext;
  class UnaryOperator;
  class UnaryOperatorNode;
  class UnnamedOperandNode;
  class UserToken;
  class ValueNode;
  class Variable;
  class VariableNode;
  class WhileNode;
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SHARED_REFERENCE_HPP
#define ZILCH_SHARED_REFERENCE_HPP

namespace Zilch
{
  // A standard deletion policy
  template <typename Type>
  class StandardDelete
  {
  public:
    void operator()(Type* object)
    {
      // Use the standard delete operator
      delete object;
    }
  };

  // An array deletion policy
  template <typename Type>
  class ArrayDelete
  {
  public:
    void operator()(Type* object)
    {
      // Use the array delete operator
      delete[] object;
    }
  };

  class WeakPolicy
  {
  public:
    template <typename RefType>
    void AddLinkToList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::WeakType ChangedType;

      // Add ourself to the object's list of shared references
      // This will initialize our link and add it intrusively
      ref->Object->Referencers.WeakReferences.push_back((ChangedType*)ref);
    }

    template <typename RefType>
    void RemoveLinkFromList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::WeakType ChangedType;

      // Unlink ourselves from the list
      InList<ChangedType, &ChangedType::InternalLink>::Unlink((ChangedType*)ref);
    }
  };

  class NormalPolicy
  {
  public:
    template <typename RefType>
    void AddLinkToList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::SharedType ChangedRefType;
      typedef typename RefType::ReferencedType::RefLinkType::ForType ChangedType;

      ChangedRefType* changedRef = (ChangedRefType*)ref;

      // Add ourself to the object's list of shared references
      // This will initialize our link and add it intrusively
      ref->Object->Referencers.SharedReferences.push_back(changedRef);
    }

    template <typename RefType>
    void RemoveLinkFromList(RefType* ref)
    {
      // This is a hack we have to do because member pointers are stupid and don't respect the mutable flag
      // We basically use this typedef and cast our reference type to a different type then it really is
      typedef typename RefType::ReferencedType::RefLinkType::SharedType ChangedType;

      // Unlink ourselves from the list
      InList<ChangedType, &ChangedType::InternalLink>::Unlink((ChangedType*)ref);

      // If nobody else is referencing this object...
      if (ref->Object->Referencers.SharedReferences.empty())
      {
        // Get a range so we can walk over all weak references
        ZilchAutoVal(weakRefs, ref->Object->Referencers.WeakReferences.all());

        // Loop until we run out of weak references
        while (weakRefs.empty() == false)
        {
          // Get the current weak reference and iterate to the next one
          ZilchAutoRef(weakRef, weakRefs.front());
          weakRefs.popFront();

          // Set the weak reference's object to null
          weakRef.Object = nullptr;
        }

        // Clear out the weak reference list
        ref->Object->Referencers.WeakReferences.clear();

        // Invoke the deletor on the object
        ref->Deletor(ref->Object);
      }
    }
  };

  // The virtual type is used primarily for debugging
  class VirtualType
  {
  public:
    virtual ~VirtualType() = 0;
  };

  // A shared reference to a particular object
  // The shared reference requires that your class contains a
  // 'ZilchRefLink(YourClass);' member, which is intrusively
  // used as the reference count. This approach decreases memory
  // allocation and adds very little to the shared object itself
  template <typename Type, typename ModePolicy = NormalPolicy, typename DeletePolicy = StandardDelete<Type> >
  class Ref
  {
  public:

    // Type-defines
    typedef Type ReferencedType;

    // Construct the object that we are going to point to and pass it in
    explicit Ref(Type* object, void* debugOwner = nullptr, DeletePolicy deletor = DeletePolicy(), ModePolicy mode = ModePolicy())
    {
      // Store the deletor away so we can use it later
      this->Deletor = deletor;

      // Store away the mode policy
      this->Mode = mode;

      // Store the object
      this->Object = object;

      // Store the owner object
      this->Owner = (VirtualType*)debugOwner;

      // If the object was a non null object
      if (object != nullptr)
      {
        // Add ourselves to whatever list we belong to (controlled by the policy)
        mode.AddLinkToList(this);
      }
    }

    // Default constructor (assumed to be a null pointer)
    explicit Ref(void* debugOwner = nullptr)
    {
      // Null out the object and the count
      this->Object = nullptr;

      // Store the owner object
      this->Owner = (VirtualType*)debugOwner;
    }

    // We also want them to be able to use the 'nullptr' constant
    Ref(nullptr_t)
    {
      // Null out the object and the count
      this->Object = nullptr;
      this->Owner = nullptr;
    }

    // Copy constructor (for ourselves, apparently ours wont get called even with the template version below)
    Ref(const Ref& other)
    {
      // The owner was never set
      this->Owner = nullptr;

      // Copy over the information, and increment the
      // reference count since we now point at it
      CopyFrom(other);
    }
  
    // Copy constructor
    template <typename TypeOrDerived, typename OtherModePolicy>
    Ref(const Ref<TypeOrDerived, OtherModePolicy>& other)
    {
      // The owner was never set
      this->Owner = nullptr;

      // Copy over the information, and increment the
      // reference count since we now point at it
      CopyFrom(other);
    }
  
    // Destructor (decrements the reference count and potentially cleans up memory)
    ~Ref()
    {
      // Clear the object this is referencing (which also can delete the object)
      Clear();
    }

    // When hashed, we just return the function pointer hash
    size_t Hash() const
    {
      // Use pointer hashing
      return HashPolicy<Type*>()(this->Object);
    }

    // Assignment operator (for ourselves, apparently ours wont get called even with the template version below)
    Ref& operator=(const Ref& other)
    {
      return this->operator=<Type>(other);
    }

    // Assignment operator
    template <typename TypeOrDerived, typename OtherModePolicy>
    Ref& operator=(const Ref<TypeOrDerived, OtherModePolicy>& other)
    {
      // Check for assignment to the same object (or ourselves)
      if (this->Object == other.Object)
        return *this;

      // Clear the object we're referencing, since we're changing references
      Clear();

      // Copy over the information, and increment the
      // reference count since we now point at it
      CopyFrom(other);

      // Return ourself for chaining
      return *this;
    }

    // Compare to a null pointer
    bool operator==(nullptr_t) const
    {
      return this->Object == nullptr;
    }

    // Compare two shared references
    template <typename TypeOrDerived, typename OtherModePolicy>
    bool operator==(const Ref<TypeOrDerived, OtherModePolicy>& other) const
    {
      return this->Object == other.Object;
    }

    // Compare the pointers
    bool operator==(const Type* other) const
    {
      return this->Object == other;
    }

    // Compare to a null pointer
    bool operator!=(nullptr_t) const
    {
      return this->Object != nullptr;
    }

    // Compare two shared references
    template <typename TypeOrDerived, typename OtherModePolicy>
    bool operator!=(const Ref<TypeOrDerived, OtherModePolicy>& other) const
    {
      return this->Object != other.Object;
    }

    // Compare the pointers
    bool operator!=(const Type* other) const
    {
      return this->Object != other;
    }

    // Return if we have an object or not
    inline operator bool() const
    {
      return this->Object != nullptr;
    }

    // Access the object via arrow operator
    inline Type* operator->() const
    {
      return this->Object;
    }

    // Dereference the shared reference to get the object
    inline Type& operator*() const
    {
      return *this->Object;
    }

    // Get the underlying object. This should only be used for optimization
    // and in cases where you know the object's lifetime is guaranteeed
    inline Type* GetObject() const
    {
      return this->Object;
    }

    // Clear the object this pointer is referencing
    void Clear()
    {
      // If the object is not null
      if (this->Object != nullptr)
      {
        // Unlink ourselves from the list (and potentially delete the object)
        this->Mode.RemoveLinkFromList(this);

        // Null out the object and the count
        this->Object = nullptr;
      }
    }

    // Set the owner for debug purposes
    void SetOwner(void* owner)
    {
      this->Owner = (VirtualType*)owner;
    }

  public:

    // Copy over the information from another object and increment the reference to it
    inline void CopyFrom(const Ref& other)
    {
      // Straight up copy over the info we need
      this->Deletor = other.Deletor;
      this->Mode = other.Mode;
      CopyFrom<Type>(other);
    }

    // Copy over the information from another object and increment the reference to it
    template <typename TypeOrDerived, typename OtherModePolicy, typename OtherDeletePolicy>
    inline void CopyFrom(const Ref<TypeOrDerived, OtherModePolicy, OtherDeletePolicy>& other)
    {
      // Straight up copy over the info we need
      this->Object = other.Object;

      // Only copy over the owner if our owner was never set
      if (this->Owner == nullptr)
      {
        this->Owner = other.Owner;
      }

      // Do we actually need to copy the deletor from derived to base?
      // this->Deletor = other.Deletor;

      // If the object was non null (as in we didn't just copy a null ref)
      if (this->Object != nullptr)
      {
        // Add ourselves to whatever list we belong to (controlled by the policy)
        this->Mode.AddLinkToList(this);
      }
    }

  public:

    // Store the deletion policy
    DeletePolicy Deletor;

    // The mode that this reference is in
    ModePolicy Mode;

    // A pointer back to the object
    Type* Object;

    // The owner object (for debugging)
    VirtualType* Owner;

    // Store our intrusive link
    IntrusiveLink(Ref, InternalLink);
  };

  // This structure should be placed as a mutable member of your class
  template <typename Type, typename DeletePolicy = StandardDelete<Type> >
  class RefLink
  {
  public:

    // Type-defines
    typedef Type ForType;
    typedef Ref<Type, NormalPolicy, DeletePolicy>         SharedType;
    typedef Ref<Type, WeakPolicy,   DeletePolicy>         WeakType;
    typedef InList<SharedType, &SharedType::InternalLink> SharedInList;
    typedef InList<WeakType, &WeakType::InternalLink>     WeakInList;

    // Store the list of shared references to our object
    SharedInList SharedReferences;

    // Store the list of weak references to our object
    // (they will not keep us alive, but we will null them out if we die)
    WeakInList WeakReferences;
  };

// A macro that creates an intrusive reference link
// This is typically placed at the end of your class
#define ZilchRefLink(type)                  \
  public:                                   \
  typedef RefLink<const type> RefLinkType;  \
  mutable RefLinkType Referencers;

// If a particular object is going to be used as a referencer,
// we use a trick that lets the Visual Studio debugger show our
// object, but it needs to be virtual for the trick to work
#define ZilchDebuggableReferencer() \
  virtual void z() const {}
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TYPE_ALIASES_HPP
#define ZILCH_TYPE_ALIASES_HPP

namespace Zilch
{
  // The type we'll use for operands
  typedef signed int          OperandIndex;
  typedef signed int          OperandLocal;
  typedef signed int          ByteCodeOffset;
  typedef unsigned long long  GuidType;

  // Type-defines for the primitive language types
  typedef int             Integer;
  typedef long long int   DoubleInteger;
  typedef float           Real;
  typedef double          DoubleReal;
  typedef bool            Boolean;
}

// End header protection
#endif

// Standard Zilch Type-defines
namespace Zilch
{
  typedef Ref<Library>                                    LibraryRef;
  typedef Ref<const Library>                              ConstLibraryRef;

  typedef Array<Function*>                                FunctionArray;
  typedef HashMap<String, Variable*>                      VariableMap;
  typedef VariableMap::range                              VariableRange;
  typedef VariableMap::valuerange                         VariableValueRange;
  typedef HashMap<String, FunctionArray>                  FunctionMultiMap;
  typedef FunctionMultiMap::range                         FunctionMultiRange;
  typedef FunctionMultiMap::valuerange                    FunctionMultiValueRange;
  typedef HashMap<String, Field*>                         FieldMap;
  typedef FieldMap::range                                 FieldMapRange;
  typedef FieldMap::valuerange                            FieldMapValueRange;
  typedef HashMap<String, Property*>                      PropertyMap;
  typedef PropertyMap::range                              PropertyMapRange;
  typedef PropertyMap::valuerange                         PropertyMapValueRange;
  typedef Array<Property*>                                PropertyArray;
  typedef PropertyArray::range                            PropertyArrayRange;
  typedef Array<SendsEvent>                               SendsEventArray;
  typedef SendsEventArray::range                          SendsEventRange;
  typedef HashMap<GuidType, LibraryRef>                   LibraryGuidMap;
  typedef LibraryGuidMap::range                           LibraryGuidRange;
  typedef Array<LibraryRef>                               LibraryArray;
  typedef LibraryArray::range                             LibraryRange;
  typedef HashMap<GuidType, Function*>                    FunctionGuidMap;
  typedef FunctionGuidMap::range                          FunctionGuidRange;
  typedef HashMap<String, BoundType*>                     BoundTypeMap;
  typedef BoundTypeMap::pair                              BoundTypePair;
  typedef BoundTypeMap::range                             BoundTypeRange;
  typedef BoundTypeMap::valuerange                        BoundTypeValueRange;
  typedef Array<Type*>                                    TypeArray;
  typedef Array<BoundType*>                               BoundTypeArray;
  typedef HashMap<GuidType, Type*>                        TypeGuidMap;
  typedef TypeGuidMap::range                              TypeGuidRange;
  typedef Array<String>                                   StringArray;
  typedef StringArray::range                              StringArrayRange;
  typedef HashMap<GuidType, FunctionMultiMap>             FunctionExtensionMap;
  typedef FunctionExtensionMap::range                     FunctionExtensionRange;
  typedef HashMap<GuidType, PropertyMap>                  PropertyExtensionMap;
  typedef PropertyExtensionMap::range                     PropertyExtensionRange;
  typedef HashMap<BoundType*, IndirectionType*>           TypeToIndirect;
  typedef TypeToIndirect::range                           TypeToIndirectRange;

  typedef Function*                   (Type::*GetFunctionFn)            (String name) const;
  typedef const FunctionArray*        (Type::*GetOverloadedFunctionsFn) (String name) const;
  typedef Field*                      (Type::*GetFieldFn)               (String name) const;
  typedef Property*                   (Type::*GetPropertyFn)            (String name) const;

  typedef void (*PostDestructorFn)(BoundType* boundType, byte* objectData);
  typedef void (*ThreadLockFn)(bool lock);

  // The C++ function that's bound to the script function
  typedef void (*BoundFn)(Call& call, ExceptionReport& report);
  
  // Every time we created a handle manager, we expect an index back of this type
  typedef size_t HandleManagerId;

  // How a type gets copied
  namespace TypeCopyMode
  {
    enum Enum
    {
      // Value types are considered memory copyable,
      // and can therefore not contain any sort of handles
      ValueType,

      // Reference types are never copied (which means that we only ever copy
      // the handle to the reference, and not the object itself).
      ReferenceType
    };
  }
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ANY_HPP
#define ZILCH_ANY_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DELEGATE_HPP
#define ZILCH_DELEGATE_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HANDLE_HPP
#define ZILCH_HANDLE_HPP

// Enable this to add extra debugging support (for Zilch internal use, such as working on the compiler)
// Warning: This will make Zilch run significantly slower
//#define ZILCH_HANDLE_DEBUG

namespace Zilch
{
  // A unique id that lets us identify objects
  typedef unsigned Uid;

  // A special code that signifies that a Uid is not set or invalid
  const unsigned InvalidUid = 0xFFFFFFFF;

  // The user has to be able to fit their entire handle inside of the user data on the handle
  // If the user cannot fit the data inside the handle, then they must create another object
  // that acts as a reference to their object
  const size_t HandleUserDataSize = 16;

  // Any flags we put on the handle
  namespace HandleFlags
  {
    enum Enum
    {
      // No flags
      None = 0,

      // In this mode, we don't do reference counting (this is a useful optimization for handles!)
      // This flag is also set when we're deleting a handle so that it can be passed into a destructor without
      // increasing or decreasing reference counts (this is safe because the handle is already going to be deleted)
      NoReferenceCounting = 1,

      // This flag is set only if ZILCH_HANDLE_DEBUG is enabled
      // This is used to track which handles need be removed from the intrusive linked list of all handles
      // If a handle was purely initialized via memory setting to zero, we ignore it
      InitializedByConstructor = 2,
    };
    typedef byte Compact;
  }

  // A handle is an object that has the ability to point at an object
  // (both on the heap, as a member of an object on the heap, etc)
  class Handle
  {
  public:
    // Friends
    friend class VirtualMachine;
    friend class ExecutableState;

    // Constructor that creates a null handle
    Handle();

    // Destructor
    ~Handle();

    // Copy constructor for a handle
    Handle(const Handle& rhs);

    // Constructs a handle from a type and a data pointer
    // This will invoke ObjectToHandle on the handle manager
    // The 'data' passed in should be a pointer to the object (the same as that returned from Dereference)
    Handle(ExecutableState* state, BoundType* type, const byte* data);

    // Copy from assignment
    Handle& operator=(const Handle& rhs);

    // Are two handles the exact same?
    bool operator==(const Handle& rhs) const;

    // Are two handles different?
    bool operator!=(const Handle& rhs) const;

    // Hashes a handle (generally used by hashable containers)
    int Hash() const;

    // Is the handle null?
    // It is recommended for performance that you just call Dereference and
    // check if it returns a null if you need to use the dereferenced value
    bool IsNull() const;

    // Checks to see if this handle is reference counted, or if it's just a standard handle
    inline bool IsReferenceCounted();

    // Get a pointer to the data, or return null if it isn't valid
    byte* Dereference() const;

    // Attempts to delete the object pointed at by the handle
    // Returns true if the object was deleted, or if the handle was already null
    // If the object is deleted, this handle will be cleared to null
    // It is possible for the destructor to throw an exception (though not highly recommended)
    bool Delete();

  private:
    // Clear the handle to a null handle
    // Warning: This does not do reference counting or properly delete the object!
    void Clear();

    // Called only when we know it's ok to delete the object
    void DestructAndDelete();

    // Increment the reference count (only if we're counted)
    void AddReference();

    // Decrement the reference count (only if we're counted), and destruct/delete the object if necessary
    void ReleaseReference();

  public:

#ifdef ZILCH_HANDLE_DEBUG
    // In order to verify that handles are valid, we keep a global list of all handles
    // and we check to see if any of them are ever improperly destructed or get written over
    Handle* DebugNext;
    Handle* DebugPrev;
    static Handle* DebugHead;
    static Handle* DebugTail;
    static void ValidateAllHandles();
    void Validate() const;
    void DebugLink();
    void DebugUnlink();
#endif

    // The type of this handle (if the type is a valud type, then it means we were assigned via ref/indirection type)
    // Unlike most OOP designs, our handle actually contains the type (or the v-table)
    // rather than it being on the object itself. This allows us to invoke interface
    // functions on a stack object via a handle, rather than by boxing the value type
    BoundType* Type;
    //DebugPlaceholder<BoundType*> Type;

    // The manager controls the lifetime of the handle, and how we interface with it
    HandleManager* Manager;

    // An offset from the base of the handle (used in dereferencing)
    size_t Offset;

    // Flags we put on the handle
    HandleFlags::Compact Flags;

    // The user data stored on the handle (of a fixed size)
    byte Data[HandleUserDataSize];
  };
}

// End header protection
#endif

namespace Zilch
{
  // Invalid constants
  const size_t InvalidOpcodeLocation = (size_t)-1;

  // A delegate is a simple type that consists of an index for a function, as well as the this pointer object
  class Delegate
  {
  public:

    // Constructor
    Delegate();

    // Are two handles the exact same?
    bool operator==(const Delegate& rhs) const;

    // Are two handles different?
    bool operator!=(const Delegate& rhs) const;

    // Hashes a handle (generally used by hashable containers)
    int Hash() const;

  public:
    // The function we run when invoking this delegate
    Function* BoundFunction;

    // The handle for the delegate
    Handle ThisHandle;
  };
}

// End header protection
#endif

namespace Zilch
{
  // Stores any type of object (handles, delegates, or even value types)
  class Any
  {
  public:

    // Constructor that initializes the Any to null (a handle, set to NullType)
    Any();

    // Constructor that initializes to the given data and type (the data is copied in using GenericCopyConstruct)
    Any(const byte* data, Type* type);

    // Construct a default instance of a particular type (equivalent of default(T))
    Any(Type* type);

    // Copying will properly reference count handles, delegates this handle, and memcopy value types
    Any(const Any& other);

    // Destructor that decrements reference counts and properly handles stored data
    ~Any();
    
    // Copying will properly reference count handles, delegates this handle, and memcopy value types
    Any& operator=(const Any& rhs);

    // Checks if the internal handle/delegate/value is the same
    bool operator==(const Any& rhs) const;
    
    // Checks if the internal handle/delegate/value is the different
    bool operator!=(const Any& rhs) const;

    // Allocates data if the size goes past the sizeof(this->Data), or returns a pointer to this->Data
    byte* AllocateData(size_t size);

    // Get the raw type data that we point at (may be our internal Data, or may be allocated)
    const byte* GetData() const;

    // Hashes a handle (generally used by hashable containers)
    int Hash() const;

    // Converts the internal value to string (used for debugging)
    String ToString() const;

    // Destruct any data stored by the any
    // This also clears the entire any out to zero
    void Clear();

    // Much like the copy constructor or assignment of an any, except it avoids
    // creating an extra 'any' in cases where we just have the memory and the type
    void AssignFrom(const byte* data, Type* type);

    // Replaces our stored definition with a default constructed version of the given type (equivalent of default(T))
    // Typically makes handles null, delegates null, and value types cleared to 0
    void DefaultConstruct(Type* type);

    // Generically copies the value of this any to another location
    // This will NOT copy the 'Any' but rather the stored type
    // Make sure the size and type of destination matches!
    void CopyStoredValueTo(byte* to) const;

  public:

    // We want to store the largest type (the delegate, handle, etc)
    // The delegate stores the handle, so we know delegate is the biggest
    // If the size of the type is bigger then can fit here, then we allocate a pointer instead
    byte Data[sizeof(Delegate)];

    // The type that we're storing inside the data
    Type* StoredType;
  };

  // Type defines for ease of use
  typedef const Any& AnyParam;

  // Given a type we know natively, return a value pointed at by a data pointer
  // If the data is not given, this will default construct the type
  // This is specialized by the Any type to return an Any that encapsulates the value
  template <typename T>
  T CopyToAnyOrActualType(byte* data, Type* dataType)
  {
    // If no data was provided, then return the default value for T
    if (data == nullptr)
      return T();

    // Otherwise just cast data into the T type
    return *(T*)data;
  }
  
  // Specialziation for the Any type, which will copy the value into an Any
  template <>
  Any CopyToAnyOrActualType<Any>(byte* data, Type* dataType);

  // Given a type we know natively, just directly copy it to a location
  // This is specialized by the Any type to only copy its inner value
  template <typename T>
  void CopyFromAnyOrActualType(const T& value, byte* to)
  {
    // Just directly construct the value
    new (to) T(value);
  }

  // Specialziation for the Any type, which will copy the value out of an Any
  template <>
  void CopyFromAnyOrActualType<Any>(const Any& any, byte* to);
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_BINDING_HPP
#define ZILCH_BINDING_HPP

// Includes

namespace Zilch
{
  // Type-defines
  typedef void (*StaticInitializeFn)(StaticLibrary& library);
  typedef void (*SetupTypeFn)(LibraryBuilder& library, BoundType* type);

  //Move to here to fix GCC compiler issue
  template <typename T>
  class StaticDereference
  {
  public:
    typedef T Type;
  };

  template <typename T>
  class StaticDereference<T*>
  {
  public:
    typedef T Type;
  };

  namespace BuildState
  {
    enum Enum
    {
      NotBuilt,
      Building,
      Built
    };
  }

  // Tells us whether a type is a primitive (built in type)
  template <typename T>
  class IsPrimitive
  {
  public:
    static const bool Value = false;
    typedef void FalseType;
  };

  // Mark all the basic types that we know of as primtiive
  template <> class IsPrimitive<          bool     > { public: static const bool Value = true; };
  template <> class IsPrimitive<          float    > { public: static const bool Value = true; };
  template <> class IsPrimitive<          double   > { public: static const bool Value = true; };
  template <> class IsPrimitive<          char     > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    char     > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  char     > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    short    > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  short    > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    int      > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  int      > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    long     > { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  long     > { public: static const bool Value = true; };
  template <> class IsPrimitive<signed    long long> { public: static const bool Value = true; };
  template <> class IsPrimitive<unsigned  long long> { public: static const bool Value = true; };

  // This is the interface we expect to see when creating any static
  // library / using the binding system. The only other function that
  // is expected is a static 'GetLibrary()' function which returns a
  // reference to your own type
  class StaticLibrary
  {
  public:
    // Friends
    friend class StaticLibraries;

    // Check if this library was built, is in the process of being built, or hasn't started building yet
    BuildState::Enum GetBuildState();

    // Get the library that we represent
    LibraryRef GetLibrary();

    // Get a reference to the library builder
    LibraryBuilder* GetBuilder();
    
    // Add to the initializers (return an int so we can use it globally)
    int AddInitializer(StaticInitializeFn fn);

    // Create the type (the parent can be NULL if the type is a base)
    BoundType* MakeType
    (
      StringParam         name,
      size_t              size,
      TypeCopyMode::Enum  copyMode,
      BoundType*          parent,
      size_t              nativeVirtualCount
    );

  protected:

    // Constructor
    StaticLibrary(String name);

    // Declare a virtual destructor
    virtual ~StaticLibrary();

    // Setup any custom binding for the library
    virtual void PreSetupBinding(LibraryBuilder& builder);

    // Setup any custom binding for the library
    virtual void PostSetupBinding(LibraryBuilder& builder);

  private:

    // Builds the library (this may only be called once!)
    void BuildLibrary();

  protected:

    // Any dependencies these libraries have upon other libraries
    // For example, many libraries depend upon the 'Core' library to be built before
    // themselves, so that primitive types such as 'Integer' and 'Real' exist
    Array<StaticLibrary*> Dependencies;

  private:

    // The name of the library
    String Name;

    // Tells us whether or not we built this library
    BuildState::Enum Build;

    // The initializers we need to run through when this library is built
    // These initializers typically setup / bind members to the types
    Array<StaticInitializeFn> Initializers;

    // The library builder we use to create the static library
    LibraryBuilder* Builder;

    // The built library (only built after all the static classes get added to it)
    LibraryRef Library;

    // If the static library has had its dependency order computed relative to other libraries
    // This is used so that we can skip adding libraries that have already been added in order
    bool IsDependencyOrderComputed;

    // If the library is currently being walked for dependency checking, and attempt to
    // walk this node again, it means we've detected a cycle
    bool IsBeingWalked;
  };

  // Create a static library that we can use in C++ binding
  // Use this in a header (preferrably in a namespace)
  // After specifying the name, you can pass in a variable number of
  // ZilchDependency(Namespace::OtherLibrary) to mark dependencies
  // upon other static libraries
  // All libraries declared with this macro implicitly add a dependency on Core
  #define ZilchStaticLibrary(Name, ...)       \
    class Name : public Zilch::StaticLibrary  \
    {                                         \
    public:                                   \
      Name() :                                \
        Zilch::StaticLibrary(#Name)           \
      {                                       \
        ZilchDependency(Zilch::Core)          \
        __VA_ARGS__                           \
      }                                       \
      static Name& GetInstance()              \
      {                                       \
        static Name instance;                 \
        return instance;                      \
      }                                       \
    }

  // Used in declaring dependencies upon other static libraries
  #define ZilchDependency(Library)  \
    this->Dependencies.push_back(&Library::GetInstance());

  // Holds the collection of static libraries in order of dependence
  class StaticLibraries
  {
  public:
    
    // This class is a singleton, this gets the instance
    static StaticLibraries& GetInstance();

    // Adds a static library to be built when we initialize Zilch
    void AddStaticLibrary(StaticLibrary& library);
    
    // Builds all the libraries (this should only be called once)
    void BuildAll();

    // Check if we already built the libraries
    BuildState::Enum GetBuildState();

  private:

    // Constructor
    StaticLibraries();

    // Compute the dependencies and the proper order to initialize libraries
    void VisitDependencies(StaticLibrary* library, Array<StaticLibrary*>& dependencyOrder);

  private:

    // Tells us whether or not we built the libraries already
    BuildState::Enum Build;
    
    // A list of all the builders we've already encountered
    HashSet<StaticLibrary*> DuplicateLibraryFinder;

    // The list of static libraries, in order of dependence
    Array<StaticLibrary*> LibrariesTobeBuilt;
  };

  // A simple macro that we specle everywhere to ensure that the user initializes Zilch
  #define ZilchErrorIfNotStarted(Name)                                                                \
    ErrorIf(StaticLibraries::GetInstance().GetBuildState() != BuildState::Built,                      \
      "In order to use the Zilch " #Name " you must invoke Zilch::ZilchStartup() and let it finish")

  /*************************** VIRTUAL DERIVED TYPE ******************************/

  // Derive from object
  class IZilchObject
  {
  public:
    // Declare a virtual destructor
    virtual ~IZilchObject() {}

    // Get the most derived type from an instance of the class (probably a base pointer)
    virtual BoundType* ZilchGetDerivedType() const = 0;
  };

  // This type is used in the case where we have no base type (base type gets defined as this)
  class NoType : public IZilchObject
  {
  public:

    static const TypeCopyMode::Enum ZilchCopyMode = TypeCopyMode::ReferenceType;

    static BoundType* ZilchGetStaticType()
    {
      return nullptr;
    }
    virtual BoundType* ZilchGetDerivedType() const
    {
      return nullptr;
    }
    static void ZilchInitializeStaticType(StaticLibrary& library)
    {
    }
    static void ZilchDebugDerivedHasNotBeenDeclared()
    {
    }
    static void ZilchDebugBaseHasNotBeenDeclared()
    {
    }
  };

  
  /********************************** BINDING ************************************/

  // Helper macros for accessing these types
  #define ZilchStaticType(Type) Zilch::TypeBinding::StaticTypeId<Type>
  #define ZilchTypeId(Type) (ZilchStaticType(Type)::Get())
  #define ZilchBindingType(Type) typename ZilchStaticType(Type)::BindingType

  // All things relevant to binding types
  class TypeBinding
  {
  public:

    // Check if a type is derived from a given base
    static bool IsA(BoundType* type, BoundType* base);

    // Check if a type is derived from a given base
    static bool IndirectionIsA(IndirectionType* type, IndirectionType* base);

    // Check if a type is derived from a given base
    static bool GenericIsA(Type* type, Type* base);

    // Dynamically cast a base type into a derived type
    template <typename Derived, typename Base>
    static Derived* DynamicCastEx(Base* baseClassPointer)
    {
      // Do some error checking (these calls will give somewhat intuitive errors if they don't exist)
      #if _DEBUG
      Base::ZilchDebugBaseHasNotBeenDeclared();
      Derived::ZilchDebugDerivedHasNotBeenDeclared();
      #endif

      // If the passed in pointer was null, then return null
      if (baseClassPointer == nullptr)
      {
        // We can't possibly cast it or know what it even is...
        return nullptr;
      }

      // If the cast is safe...
      if (IsA(baseClassPointer->ZilchGetDerivedType(), ZilchTypeId(Derived)))
      {
        // Get the base class pointer
        return static_cast<Derived*>(baseClassPointer);
      }

      // Otherwise the cast failed, return a null pointer
      return nullptr;
    }

    // Dynamically cast a base type into a derived type
    template <typename Derived, typename Base>
    static Derived DynamicCast(Base baseClassPointer)
    {
      return DynamicCastEx<typename StaticDereference<Derived>::Type, typename StaticDereference<Base>::Type>(baseClassPointer);
    }

    // Using SFINAE we can detect if we have the 'ZilchGetDerivedType' method on a type T
    template <typename T>
    class CanGetDerivedType
    {
    private:
      typedef char Yes[1];
      typedef char No[2];

      template <typename U, U>
      class GenericTemplate;

      template <typename C>
      static Yes& Test(GenericTemplate<BoundType* (C::*)() const, &C::ZilchGetDerivedType>*);

      template <typename>
      static No& Test(...);

    public:
        static bool const Result = sizeof(Test<T>(0)) == sizeof(Yes);
    };

    // The macro ZilchVirtualTypeId will create this template using the above SFINAE template (checking for ZilchGetDerivedType)
    // If the method does not exist on type T, then this one will get called (just resulting in the static typeid)
    template <typename T, bool HasZilchGetDerivedType>
    class DiscoverDerivedType
    {
    public:
      static BoundType* Get(T* object)
      {
        return ZilchTypeId(T);
      }
    };

    // If the type T has ZilchGetDerivedType when invoking the macro ZilchVirtualTypeId, this one will get chosen, and will actually invoke ZilchGetDerivedType
    template <typename T>
    class DiscoverDerivedType<T, true>
    {
    public:
      static BoundType* Get(T* object)
      {
        return object->ZilchGetDerivedType();
      }
    };

    // Get the type of the pointer (using virtual behavior if possible)
    #define ZilchVirtualTypeId(Pointer) Zilch::TypeBinding::DiscoverDerivedType<ZilchStrip(ZilchTypeOf(Pointer)), Zilch::TypeBinding::CanGetDerivedType<ZilchStrip(ZilchTypeOf(Pointer))>::Result>::Get(Pointer)

    template <typename T>
    class StripQualifiers
    {
    public:
      typedef T Type;
    };

    template <typename T>
    class StripQualifiers<T*>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    template <typename T>
    class StripQualifiers<T&>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    template <typename T>
    class StripQualifiers<const T>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    template <typename T>
    class StripQualifiers<volatile T>
    {
    public:
      // Use template recursion to strip all qualifiers
      typedef typename StripQualifiers<T>::Type Type;
    };

    // Strip all const, pointer, reference, and volatile qualifiers from a type to get its core
    #define ZilchStrip(T) typename Zilch::TypeBinding::StripQualifiers<T>::Type

    // Handles:
    //  int
    //  const int
    //  int&
    //  const int&
    template <typename T>
    static T* InternalToPointer(const T& value)
    {
      return (T*)&value;
    }

    // Handles:
    //  int*
    //  const int*
    //  int*&
    //  const int*&
    //  int* const
    //  const int* const
    //  int* const&
    //  const int* const&
    template <typename T>
    static T* InternalToPointer(const T* value)
    {
      return (T*)value;
    }

    // Handles:
    //  const int**
    //  const int**&
    template <typename T>
    static T* InternalToPointer(const T** value)
    {
      return (T*)*value;
    }

    // Handles:
    //  int**
    //  int**&
    template <typename T>
    static T* InternalToPointer(T* const* value)
    {
      return (T*)*value;
    }

    // Takes any expression and turns it into a pointer of the core type
    // Examples: const int** -> int*, or const int& -> int*
    // To just get the type as a pointer rather than the expression, use ZilchStrip(T)*
    #define ZilchToPointer(Expression) (Zilch::TypeBinding::InternalToPointer<ZilchStrip(ZilchTypeOf(Expression))>(Expression))

    // Strips all forms of const from a type
    template <typename T>
    class StripConst
    {
    public:
      typedef T Type;
    };

    template <typename T>
    class StripConst<const T> : public StripConst<T>
    {
    };

    template <typename T>
    class StripConst<const T&> : public StripConst<typename StripConst<T>::Type&>
    {
    };

    // Value to value
    template <typename From, typename To> class ReferenceCast              { public: static To  Cast(From   from) { return  from; } };
    // Value to pointer (illegal)
    template <typename From, typename To> class ReferenceCast<From  , To*> { public: static To* Cast(From   from) { return "IllegalConversionFromValueToPointer"; } };
    // Value to reference (illegal)
    template <typename From, typename To> class ReferenceCast<From  , To&> { public: static To& Cast(From   from) { return "IllegalConversionFromValueToReference"; } };
    // Pointer to pointer
    template <typename From, typename To> class ReferenceCast<From* , To*> { public: static To* Cast(From*  from) { return  from; } };
    // Pointer to reference
    template <typename From, typename To> class ReferenceCast<From* , To&> { public: static To& Cast(From*  from) { return *from; } };
    // Pointer to value (only works because we specialized pointer and reference above)
    template <typename From, typename To> class ReferenceCast<From* , To > { public: static To  Cast(From*  from) { return *from; } };
    // Reference to reference
    template <typename From, typename To> class ReferenceCast<From& , To&> { public: static To& Cast(From&  from) { return  from; } };
    // Reference to pointer
    template <typename From, typename To> class ReferenceCast<From& , To*> { public: static To* Cast(From&  from) { return &from; } };
    // Reference to value
    template <typename From, typename To> class ReferenceCast<From& , To > { public: static To  Cast(From&  from) { return  from; } };
    // Reference to a pointer to pointer
    template <typename From, typename To> class ReferenceCast<From*&, To*> { public: static To* Cast(From*& from) { return  from; } };
    // Reference to a pointer to reference
    template <typename From, typename To> class ReferenceCast<From*&, To&> { public: static To& Cast(From*& from) { return *from; } };

    template <typename T>
    class FromDataPointer
    {
    public:
      static T Cast(byte* data)
      {
        return *(T*)data;
      }
    };

    template <typename T>
    class FromDataPointer<T*>
    {
    public:
      static T* Cast(byte* data)
      {
        return (T*)data;
      }
    };

    template <typename T>
    class FromDataPointer<T&>
    {
    public:
      static T& Cast(byte* data)
      {
        return *(T*)data;
      }
    };

    template <typename T>
    class ToDataPointer
    {
    public:
      static byte* Cast(const T& value)
      {
        return (byte*)&value;
      }
    };

    template <typename T>
    class ToDataPointer<T*>
    {
    public:
      static byte* Cast(T* value)
      {
        return (byte*)value;
      }
    };

    template <typename T>
    class ToDataPointer<T&>
    {
    public:
      static byte* Cast(T& value)
      {
        return (byte*)&value;
      }
    };

    // Lets us choose one type or the other based the condition (eg TypeChooser<int, float, false>::Type will be float)
    template <typename IfTrueType, typename IfFalseType, bool condition>
    class TypeChooser
    {
    public:
    };

    template <typename IfTrueType, typename IfFalseType>
    class TypeChooser<IfTrueType, IfFalseType, true>
    {
    public:
      typedef IfTrueType Type;
    };

    template <typename IfTrueType, typename IfFalseType>
    class TypeChooser<IfTrueType, IfFalseType, false>
    {
    public:
      typedef IfFalseType Type;
    };

    // A template for grabbing a TypeInfo given a template type
    // (This template can be specialized using macros)
    // Tthis is to allow Rtti for pre-defined types such as int, via specialization
    template <typename T>
    class StaticTypeId
    {
    public:
      // Lets us know at compile time whether this is a value/complex type
      static const TypeCopyMode::Enum CopyMode = T::ZilchCopyMode;

      // The T type (and because partial specializations of 'StaticTypeId', this will always be a stripped type)
      typedef T UnqualifiedType;

      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef T QualifiedType;

      // The type we use in any generated binding. This is generally the QualifiedType, however if the type is a redirect, it will be unqualified
      typedef T BindingType;

      // This is the type that we represent when written to the stack
      // (as a value type) or dereferenced from a handle (as a reference type)
      typedef T RepresentedType;

      // Because our representation is the exact same (whether in C++ or on the stack/in a handle)
      // then our resulting type when read is just a reference (not the case in all specializations!)
      typedef T& ReadType;
      
      // Since our representation is the exact same (as mentioned above) this will be a direct read
      static const bool DirectRead = true;
      
      // Read our object representation from either stack data or handle data
      static ReadType Read(byte* from)
      {
        // Reading and writing by default should just be pulling the object out directly
        return *(T*)from;
      }

      // Write our object representation to either stack data or handle data
      static void Write(const T& value, byte* to)
      {
        // Copy construct our object direclty into the memory location
        new (to) T(value);
      }

      static BoundType* Get()
      {
        // If no specialization was made, then we expect that the class we're trying
        // to get a type-info from has a 'GetStaticType' function
        return T::ZilchGetStaticType();
      }

      static void InitializeStaticType(Zilch::StaticLibrary& library)
      {
        // This can be specialized to invoke other initialize functions
        T::ZilchInitializeStaticType(library);
      }
    };

    // A partial specialization for reference types
    template <typename T>
    class StaticTypeId<T&> : public StaticTypeId<T>
    {
    public:
      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef T& QualifiedType;

      // Based on whether this object supports direct reading or not, we choose to use the qualified or unqualified type in binding
      typedef typename TypeChooser<QualifiedType, typename StaticTypeId<T>::UnqualifiedType, StaticTypeId<T>::DirectRead>::Type BindingType;
    };

    // A partial specialization for reference types
    template <typename T>
    class StaticTypeId<const T> : public StaticTypeId<T>
    {
    public:
      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef const T QualifiedType;

      // Based on whether this object supports direct reading or not, we choose to use the qualified or unqualified type in binding
      typedef typename TypeChooser<QualifiedType, typename StaticTypeId<T>::UnqualifiedType, StaticTypeId<T>::DirectRead>::Type BindingType;
    };

    // A partial specialization for pointer types
    template <typename T>
    class StaticTypeId<T*> : public StaticTypeId<T>
    {
    public:
      // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
      typedef T* QualifiedType;

      // Based on whether this object supports direct reading or not, we choose to use the qualified or unqualified type in binding
      typedef typename TypeChooser<QualifiedType, typename StaticTypeId<T>::UnqualifiedType, StaticTypeId<T>::DirectRead>::Type BindingType;

      // Error checking
      ZilchStaticAssert(
        StaticTypeId<T>::CopyMode != TypeCopyMode::ValueType,
        "Pointers to value types are not supported",
        PointerToValueTypeNotSupported
      );
    };

    // Used to count virtual table functions or get a virtual method index
    class VirtualTableCounter
    {
    public:

      // Constructor
      VirtualTableCounter();

      // A helper to tell us whether or not a method being tested is virtual 
      static bool StaticDebugIsVirtual;

      // An extra helper to tell us whether or not a method being tested is virtual
      bool InstanceDebugIsVirtual;

      // Checks if the function we were testing was virtual or not
      void AssertIfNotVirtual();

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

virtual size_t Get0()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 0;
}

virtual size_t Get1()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 1;
}

virtual size_t Get2()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 2;
}

virtual size_t Get3()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 3;
}

virtual size_t Get4()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 4;
}

virtual size_t Get5()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 5;
}

virtual size_t Get6()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 6;
}

virtual size_t Get7()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 7;
}

virtual size_t Get8()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 8;
}

virtual size_t Get9()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 9;
}

virtual size_t Get10()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 10;
}

virtual size_t Get11()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 11;
}

virtual size_t Get12()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 12;
}

virtual size_t Get13()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 13;
}

virtual size_t Get14()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 14;
}

virtual size_t Get15()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 15;
}

virtual size_t Get16()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 16;
}

virtual size_t Get17()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 17;
}

virtual size_t Get18()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 18;
}

virtual size_t Get19()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 19;
}

virtual size_t Get20()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 20;
}

virtual size_t Get21()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 21;
}

virtual size_t Get22()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 22;
}

virtual size_t Get23()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 23;
}

virtual size_t Get24()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 24;
}

virtual size_t Get25()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 25;
}

virtual size_t Get26()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 26;
}

virtual size_t Get27()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 27;
}

virtual size_t Get28()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 28;
}

virtual size_t Get29()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 29;
}

virtual size_t Get30()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 30;
}

virtual size_t Get31()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 31;
}

virtual size_t Get32()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 32;
}

virtual size_t Get33()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 33;
}

virtual size_t Get34()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 34;
}

virtual size_t Get35()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 35;
}

virtual size_t Get36()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 36;
}

virtual size_t Get37()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 37;
}

virtual size_t Get38()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 38;
}

virtual size_t Get39()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 39;
}

virtual size_t Get40()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 40;
}

virtual size_t Get41()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 41;
}

virtual size_t Get42()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 42;
}

virtual size_t Get43()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 43;
}

virtual size_t Get44()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 44;
}

virtual size_t Get45()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 45;
}

virtual size_t Get46()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 46;
}

virtual size_t Get47()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 47;
}

virtual size_t Get48()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 48;
}

virtual size_t Get49()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 49;
}

virtual size_t Get50()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 50;
}

virtual size_t Get51()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 51;
}

virtual size_t Get52()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 52;
}

virtual size_t Get53()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 53;
}

virtual size_t Get54()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 54;
}

virtual size_t Get55()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 55;
}

virtual size_t Get56()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 56;
}

virtual size_t Get57()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 57;
}

virtual size_t Get58()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 58;
}

virtual size_t Get59()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 59;
}

virtual size_t Get60()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 60;
}

virtual size_t Get61()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 61;
}

virtual size_t Get62()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 62;
}

virtual size_t Get63()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 63;
}

virtual size_t Get64()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 64;
}

virtual size_t Get65()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 65;
}

virtual size_t Get66()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 66;
}

virtual size_t Get67()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 67;
}

virtual size_t Get68()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 68;
}

virtual size_t Get69()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 69;
}

virtual size_t Get70()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 70;
}

virtual size_t Get71()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 71;
}

virtual size_t Get72()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 72;
}

virtual size_t Get73()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 73;
}

virtual size_t Get74()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 74;
}

virtual size_t Get75()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 75;
}

virtual size_t Get76()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 76;
}

virtual size_t Get77()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 77;
}

virtual size_t Get78()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 78;
}

virtual size_t Get79()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 79;
}

virtual size_t Get80()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 80;
}

virtual size_t Get81()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 81;
}

virtual size_t Get82()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 82;
}

virtual size_t Get83()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 83;
}

virtual size_t Get84()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 84;
}

virtual size_t Get85()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 85;
}

virtual size_t Get86()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 86;
}

virtual size_t Get87()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 87;
}

virtual size_t Get88()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 88;
}

virtual size_t Get89()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 89;
}

virtual size_t Get90()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 90;
}

virtual size_t Get91()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 91;
}

virtual size_t Get92()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 92;
}

virtual size_t Get93()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 93;
}

virtual size_t Get94()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 94;
}

virtual size_t Get95()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 95;
}

virtual size_t Get96()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 96;
}

virtual size_t Get97()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 97;
}

virtual size_t Get98()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 98;
}

virtual size_t Get99()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 99;
}

virtual size_t Get100()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 100;
}

virtual size_t Get101()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 101;
}

virtual size_t Get102()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 102;
}

virtual size_t Get103()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 103;
}

virtual size_t Get104()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 104;
}

virtual size_t Get105()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 105;
}

virtual size_t Get106()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 106;
}

virtual size_t Get107()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 107;
}

virtual size_t Get108()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 108;
}

virtual size_t Get109()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 109;
}

virtual size_t Get110()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 110;
}

virtual size_t Get111()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 111;
}

virtual size_t Get112()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 112;
}

virtual size_t Get113()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 113;
}

virtual size_t Get114()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 114;
}

virtual size_t Get115()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 115;
}

virtual size_t Get116()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 116;
}

virtual size_t Get117()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 117;
}

virtual size_t Get118()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 118;
}

virtual size_t Get119()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 119;
}

virtual size_t Get120()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 120;
}

virtual size_t Get121()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 121;
}

virtual size_t Get122()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 122;
}

virtual size_t Get123()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 123;
}

virtual size_t Get124()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 124;
}

virtual size_t Get125()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 125;
}

virtual size_t Get126()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 126;
}

virtual size_t Get127()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 127;
}

virtual size_t Get128()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 128;
}

virtual size_t Get129()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 129;
}

virtual size_t Get130()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 130;
}

virtual size_t Get131()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 131;
}

virtual size_t Get132()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 132;
}

virtual size_t Get133()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 133;
}

virtual size_t Get134()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 134;
}

virtual size_t Get135()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 135;
}

virtual size_t Get136()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 136;
}

virtual size_t Get137()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 137;
}

virtual size_t Get138()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 138;
}

virtual size_t Get139()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 139;
}

virtual size_t Get140()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 140;
}

virtual size_t Get141()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 141;
}

virtual size_t Get142()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 142;
}

virtual size_t Get143()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 143;
}

virtual size_t Get144()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 144;
}

virtual size_t Get145()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 145;
}

virtual size_t Get146()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 146;
}

virtual size_t Get147()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 147;
}

virtual size_t Get148()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 148;
}

virtual size_t Get149()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 149;
}

virtual size_t Get150()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 150;
}

virtual size_t Get151()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 151;
}

virtual size_t Get152()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 152;
}

virtual size_t Get153()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 153;
}

virtual size_t Get154()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 154;
}

virtual size_t Get155()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 155;
}

virtual size_t Get156()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 156;
}

virtual size_t Get157()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 157;
}

virtual size_t Get158()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 158;
}

virtual size_t Get159()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 159;
}

virtual size_t Get160()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 160;
}

virtual size_t Get161()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 161;
}

virtual size_t Get162()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 162;
}

virtual size_t Get163()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 163;
}

virtual size_t Get164()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 164;
}

virtual size_t Get165()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 165;
}

virtual size_t Get166()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 166;
}

virtual size_t Get167()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 167;
}

virtual size_t Get168()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 168;
}

virtual size_t Get169()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 169;
}

virtual size_t Get170()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 170;
}

virtual size_t Get171()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 171;
}

virtual size_t Get172()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 172;
}

virtual size_t Get173()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 173;
}

virtual size_t Get174()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 174;
}

virtual size_t Get175()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 175;
}

virtual size_t Get176()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 176;
}

virtual size_t Get177()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 177;
}

virtual size_t Get178()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 178;
}

virtual size_t Get179()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 179;
}

virtual size_t Get180()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 180;
}

virtual size_t Get181()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 181;
}

virtual size_t Get182()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 182;
}

virtual size_t Get183()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 183;
}

virtual size_t Get184()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 184;
}

virtual size_t Get185()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 185;
}

virtual size_t Get186()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 186;
}

virtual size_t Get187()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 187;
}

virtual size_t Get188()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 188;
}

virtual size_t Get189()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 189;
}

virtual size_t Get190()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 190;
}

virtual size_t Get191()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 191;
}

virtual size_t Get192()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 192;
}

virtual size_t Get193()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 193;
}

virtual size_t Get194()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 194;
}

virtual size_t Get195()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 195;
}

virtual size_t Get196()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 196;
}

virtual size_t Get197()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 197;
}

virtual size_t Get198()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 198;
}

virtual size_t Get199()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 199;
}

virtual size_t Get200()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 200;
}

virtual size_t Get201()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 201;
}

virtual size_t Get202()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 202;
}

virtual size_t Get203()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 203;
}

virtual size_t Get204()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 204;
}

virtual size_t Get205()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 205;
}

virtual size_t Get206()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 206;
}

virtual size_t Get207()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 207;
}

virtual size_t Get208()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 208;
}

virtual size_t Get209()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 209;
}

virtual size_t Get210()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 210;
}

virtual size_t Get211()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 211;
}

virtual size_t Get212()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 212;
}

virtual size_t Get213()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 213;
}

virtual size_t Get214()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 214;
}

virtual size_t Get215()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 215;
}

virtual size_t Get216()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 216;
}

virtual size_t Get217()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 217;
}

virtual size_t Get218()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 218;
}

virtual size_t Get219()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 219;
}

virtual size_t Get220()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 220;
}

virtual size_t Get221()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 221;
}

virtual size_t Get222()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 222;
}

virtual size_t Get223()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 223;
}

virtual size_t Get224()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 224;
}

virtual size_t Get225()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 225;
}

virtual size_t Get226()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 226;
}

virtual size_t Get227()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 227;
}

virtual size_t Get228()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 228;
}

virtual size_t Get229()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 229;
}

virtual size_t Get230()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 230;
}

virtual size_t Get231()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 231;
}

virtual size_t Get232()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 232;
}

virtual size_t Get233()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 233;
}

virtual size_t Get234()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 234;
}

virtual size_t Get235()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 235;
}

virtual size_t Get236()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 236;
}

virtual size_t Get237()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 237;
}

virtual size_t Get238()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 238;
}

virtual size_t Get239()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 239;
}

virtual size_t Get240()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 240;
}

virtual size_t Get241()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 241;
}

virtual size_t Get242()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 242;
}

virtual size_t Get243()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 243;
}

virtual size_t Get244()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 244;
}

virtual size_t Get245()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 245;
}

virtual size_t Get246()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 246;
}

virtual size_t Get247()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 247;
}

virtual size_t Get248()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 248;
}

virtual size_t Get249()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 249;
}

virtual size_t Get250()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 250;
}

virtual size_t Get251()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 251;
}

virtual size_t Get252()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 252;
}

virtual size_t Get253()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 253;
}

virtual size_t Get254()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 254;
}

virtual size_t Get255()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 255;
}

virtual size_t Get256()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 256;
}

virtual size_t Get257()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 257;
}

virtual size_t Get258()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 258;
}

virtual size_t Get259()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 259;
}

virtual size_t Get260()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 260;
}

virtual size_t Get261()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 261;
}

virtual size_t Get262()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 262;
}

virtual size_t Get263()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 263;
}

virtual size_t Get264()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 264;
}

virtual size_t Get265()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 265;
}

virtual size_t Get266()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 266;
}

virtual size_t Get267()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 267;
}

virtual size_t Get268()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 268;
}

virtual size_t Get269()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 269;
}

virtual size_t Get270()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 270;
}

virtual size_t Get271()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 271;
}

virtual size_t Get272()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 272;
}

virtual size_t Get273()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 273;
}

virtual size_t Get274()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 274;
}

virtual size_t Get275()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 275;
}

virtual size_t Get276()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 276;
}

virtual size_t Get277()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 277;
}

virtual size_t Get278()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 278;
}

virtual size_t Get279()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 279;
}

virtual size_t Get280()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 280;
}

virtual size_t Get281()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 281;
}

virtual size_t Get282()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 282;
}

virtual size_t Get283()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 283;
}

virtual size_t Get284()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 284;
}

virtual size_t Get285()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 285;
}

virtual size_t Get286()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 286;
}

virtual size_t Get287()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 287;
}

virtual size_t Get288()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 288;
}

virtual size_t Get289()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 289;
}

virtual size_t Get290()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 290;
}

virtual size_t Get291()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 291;
}

virtual size_t Get292()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 292;
}

virtual size_t Get293()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 293;
}

virtual size_t Get294()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 294;
}

virtual size_t Get295()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 295;
}

virtual size_t Get296()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 296;
}

virtual size_t Get297()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 297;
}

virtual size_t Get298()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 298;
}

virtual size_t Get299()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 299;
}

virtual size_t Get300()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 300;
}

virtual size_t Get301()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 301;
}

virtual size_t Get302()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 302;
}

virtual size_t Get303()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 303;
}

virtual size_t Get304()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 304;
}

virtual size_t Get305()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 305;
}

virtual size_t Get306()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 306;
}

virtual size_t Get307()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 307;
}

virtual size_t Get308()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 308;
}

virtual size_t Get309()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 309;
}

virtual size_t Get310()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 310;
}

virtual size_t Get311()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 311;
}

virtual size_t Get312()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 312;
}

virtual size_t Get313()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 313;
}

virtual size_t Get314()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 314;
}

virtual size_t Get315()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 315;
}

virtual size_t Get316()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 316;
}

virtual size_t Get317()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 317;
}

virtual size_t Get318()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 318;
}

virtual size_t Get319()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 319;
}

virtual size_t Get320()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 320;
}

virtual size_t Get321()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 321;
}

virtual size_t Get322()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 322;
}

virtual size_t Get323()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 323;
}

virtual size_t Get324()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 324;
}

virtual size_t Get325()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 325;
}

virtual size_t Get326()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 326;
}

virtual size_t Get327()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 327;
}

virtual size_t Get328()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 328;
}

virtual size_t Get329()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 329;
}

virtual size_t Get330()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 330;
}

virtual size_t Get331()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 331;
}

virtual size_t Get332()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 332;
}

virtual size_t Get333()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 333;
}

virtual size_t Get334()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 334;
}

virtual size_t Get335()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 335;
}

virtual size_t Get336()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 336;
}

virtual size_t Get337()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 337;
}

virtual size_t Get338()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 338;
}

virtual size_t Get339()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 339;
}

virtual size_t Get340()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 340;
}

virtual size_t Get341()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 341;
}

virtual size_t Get342()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 342;
}

virtual size_t Get343()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 343;
}

virtual size_t Get344()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 344;
}

virtual size_t Get345()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 345;
}

virtual size_t Get346()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 346;
}

virtual size_t Get347()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 347;
}

virtual size_t Get348()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 348;
}

virtual size_t Get349()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 349;
}

virtual size_t Get350()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 350;
}

virtual size_t Get351()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 351;
}

virtual size_t Get352()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 352;
}

virtual size_t Get353()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 353;
}

virtual size_t Get354()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 354;
}

virtual size_t Get355()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 355;
}

virtual size_t Get356()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 356;
}

virtual size_t Get357()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 357;
}

virtual size_t Get358()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 358;
}

virtual size_t Get359()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 359;
}

virtual size_t Get360()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 360;
}

virtual size_t Get361()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 361;
}

virtual size_t Get362()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 362;
}

virtual size_t Get363()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 363;
}

virtual size_t Get364()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 364;
}

virtual size_t Get365()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 365;
}

virtual size_t Get366()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 366;
}

virtual size_t Get367()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 367;
}

virtual size_t Get368()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 368;
}

virtual size_t Get369()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 369;
}

virtual size_t Get370()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 370;
}

virtual size_t Get371()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 371;
}

virtual size_t Get372()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 372;
}

virtual size_t Get373()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 373;
}

virtual size_t Get374()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 374;
}

virtual size_t Get375()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 375;
}

virtual size_t Get376()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 376;
}

virtual size_t Get377()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 377;
}

virtual size_t Get378()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 378;
}

virtual size_t Get379()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 379;
}

virtual size_t Get380()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 380;
}

virtual size_t Get381()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 381;
}

virtual size_t Get382()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 382;
}

virtual size_t Get383()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 383;
}

virtual size_t Get384()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 384;
}

virtual size_t Get385()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 385;
}

virtual size_t Get386()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 386;
}

virtual size_t Get387()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 387;
}

virtual size_t Get388()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 388;
}

virtual size_t Get389()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 389;
}

virtual size_t Get390()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 390;
}

virtual size_t Get391()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 391;
}

virtual size_t Get392()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 392;
}

virtual size_t Get393()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 393;
}

virtual size_t Get394()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 394;
}

virtual size_t Get395()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 395;
}

virtual size_t Get396()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 396;
}

virtual size_t Get397()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 397;
}

virtual size_t Get398()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 398;
}

virtual size_t Get399()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 399;
}

virtual size_t Get400()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 400;
}

virtual size_t Get401()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 401;
}

virtual size_t Get402()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 402;
}

virtual size_t Get403()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 403;
}

virtual size_t Get404()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 404;
}

virtual size_t Get405()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 405;
}

virtual size_t Get406()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 406;
}

virtual size_t Get407()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 407;
}

virtual size_t Get408()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 408;
}

virtual size_t Get409()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 409;
}

virtual size_t Get410()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 410;
}

virtual size_t Get411()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 411;
}

virtual size_t Get412()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 412;
}

virtual size_t Get413()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 413;
}

virtual size_t Get414()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 414;
}

virtual size_t Get415()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 415;
}

virtual size_t Get416()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 416;
}

virtual size_t Get417()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 417;
}

virtual size_t Get418()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 418;
}

virtual size_t Get419()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 419;
}

virtual size_t Get420()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 420;
}

virtual size_t Get421()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 421;
}

virtual size_t Get422()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 422;
}

virtual size_t Get423()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 423;
}

virtual size_t Get424()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 424;
}

virtual size_t Get425()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 425;
}

virtual size_t Get426()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 426;
}

virtual size_t Get427()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 427;
}

virtual size_t Get428()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 428;
}

virtual size_t Get429()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 429;
}

virtual size_t Get430()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 430;
}

virtual size_t Get431()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 431;
}

virtual size_t Get432()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 432;
}

virtual size_t Get433()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 433;
}

virtual size_t Get434()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 434;
}

virtual size_t Get435()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 435;
}

virtual size_t Get436()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 436;
}

virtual size_t Get437()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 437;
}

virtual size_t Get438()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 438;
}

virtual size_t Get439()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 439;
}

virtual size_t Get440()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 440;
}

virtual size_t Get441()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 441;
}

virtual size_t Get442()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 442;
}

virtual size_t Get443()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 443;
}

virtual size_t Get444()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 444;
}

virtual size_t Get445()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 445;
}

virtual size_t Get446()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 446;
}

virtual size_t Get447()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 447;
}

virtual size_t Get448()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 448;
}

virtual size_t Get449()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 449;
}

virtual size_t Get450()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 450;
}

virtual size_t Get451()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 451;
}

virtual size_t Get452()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 452;
}

virtual size_t Get453()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 453;
}

virtual size_t Get454()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 454;
}

virtual size_t Get455()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 455;
}

virtual size_t Get456()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 456;
}

virtual size_t Get457()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 457;
}

virtual size_t Get458()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 458;
}

virtual size_t Get459()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 459;
}

virtual size_t Get460()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 460;
}

virtual size_t Get461()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 461;
}

virtual size_t Get462()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 462;
}

virtual size_t Get463()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 463;
}

virtual size_t Get464()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 464;
}

virtual size_t Get465()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 465;
}

virtual size_t Get466()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 466;
}

virtual size_t Get467()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 467;
}

virtual size_t Get468()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 468;
}

virtual size_t Get469()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 469;
}

virtual size_t Get470()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 470;
}

virtual size_t Get471()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 471;
}

virtual size_t Get472()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 472;
}

virtual size_t Get473()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 473;
}

virtual size_t Get474()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 474;
}

virtual size_t Get475()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 475;
}

virtual size_t Get476()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 476;
}

virtual size_t Get477()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 477;
}

virtual size_t Get478()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 478;
}

virtual size_t Get479()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 479;
}

virtual size_t Get480()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 480;
}

virtual size_t Get481()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 481;
}

virtual size_t Get482()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 482;
}

virtual size_t Get483()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 483;
}

virtual size_t Get484()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 484;
}

virtual size_t Get485()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 485;
}

virtual size_t Get486()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 486;
}

virtual size_t Get487()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 487;
}

virtual size_t Get488()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 488;
}

virtual size_t Get489()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 489;
}

virtual size_t Get490()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 490;
}

virtual size_t Get491()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 491;
}

virtual size_t Get492()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 492;
}

virtual size_t Get493()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 493;
}

virtual size_t Get494()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 494;
}

virtual size_t Get495()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 495;
}

virtual size_t Get496()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 496;
}

virtual size_t Get497()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 497;
}

virtual size_t Get498()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 498;
}

virtual size_t Get499()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 499;
}

virtual size_t Get500()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 500;
}

virtual size_t Get501()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 501;
}

virtual size_t Get502()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 502;
}

virtual size_t Get503()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 503;
}

virtual size_t Get504()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 504;
}

virtual size_t Get505()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 505;
}

virtual size_t Get506()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 506;
}

virtual size_t Get507()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 507;
}

virtual size_t Get508()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 508;
}

virtual size_t Get509()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 509;
}

virtual size_t Get510()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 510;
}

virtual size_t Get511()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 511;
}

virtual size_t Get512()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 512;
}

virtual size_t Get513()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 513;
}

virtual size_t Get514()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 514;
}

virtual size_t Get515()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 515;
}

virtual size_t Get516()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 516;
}

virtual size_t Get517()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 517;
}

virtual size_t Get518()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 518;
}

virtual size_t Get519()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 519;
}

virtual size_t Get520()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 520;
}

virtual size_t Get521()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 521;
}

virtual size_t Get522()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 522;
}

virtual size_t Get523()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 523;
}

virtual size_t Get524()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 524;
}

virtual size_t Get525()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 525;
}

virtual size_t Get526()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 526;
}

virtual size_t Get527()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 527;
}

virtual size_t Get528()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 528;
}

virtual size_t Get529()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 529;
}

virtual size_t Get530()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 530;
}

virtual size_t Get531()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 531;
}

virtual size_t Get532()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 532;
}

virtual size_t Get533()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 533;
}

virtual size_t Get534()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 534;
}

virtual size_t Get535()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 535;
}

virtual size_t Get536()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 536;
}

virtual size_t Get537()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 537;
}

virtual size_t Get538()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 538;
}

virtual size_t Get539()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 539;
}

virtual size_t Get540()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 540;
}

virtual size_t Get541()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 541;
}

virtual size_t Get542()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 542;
}

virtual size_t Get543()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 543;
}

virtual size_t Get544()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 544;
}

virtual size_t Get545()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 545;
}

virtual size_t Get546()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 546;
}

virtual size_t Get547()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 547;
}

virtual size_t Get548()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 548;
}

virtual size_t Get549()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 549;
}

virtual size_t Get550()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 550;
}

virtual size_t Get551()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 551;
}

virtual size_t Get552()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 552;
}

virtual size_t Get553()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 553;
}

virtual size_t Get554()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 554;
}

virtual size_t Get555()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 555;
}

virtual size_t Get556()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 556;
}

virtual size_t Get557()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 557;
}

virtual size_t Get558()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 558;
}

virtual size_t Get559()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 559;
}

virtual size_t Get560()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 560;
}

virtual size_t Get561()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 561;
}

virtual size_t Get562()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 562;
}

virtual size_t Get563()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 563;
}

virtual size_t Get564()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 564;
}

virtual size_t Get565()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 565;
}

virtual size_t Get566()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 566;
}

virtual size_t Get567()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 567;
}

virtual size_t Get568()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 568;
}

virtual size_t Get569()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 569;
}

virtual size_t Get570()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 570;
}

virtual size_t Get571()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 571;
}

virtual size_t Get572()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 572;
}

virtual size_t Get573()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 573;
}

virtual size_t Get574()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 574;
}

virtual size_t Get575()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 575;
}

virtual size_t Get576()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 576;
}

virtual size_t Get577()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 577;
}

virtual size_t Get578()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 578;
}

virtual size_t Get579()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 579;
}

virtual size_t Get580()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 580;
}

virtual size_t Get581()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 581;
}

virtual size_t Get582()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 582;
}

virtual size_t Get583()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 583;
}

virtual size_t Get584()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 584;
}

virtual size_t Get585()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 585;
}

virtual size_t Get586()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 586;
}

virtual size_t Get587()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 587;
}

virtual size_t Get588()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 588;
}

virtual size_t Get589()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 589;
}

virtual size_t Get590()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 590;
}

virtual size_t Get591()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 591;
}

virtual size_t Get592()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 592;
}

virtual size_t Get593()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 593;
}

virtual size_t Get594()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 594;
}

virtual size_t Get595()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 595;
}

virtual size_t Get596()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 596;
}

virtual size_t Get597()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 597;
}

virtual size_t Get598()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 598;
}

virtual size_t Get599()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 599;
}

virtual size_t Get600()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 600;
}

virtual size_t Get601()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 601;
}

virtual size_t Get602()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 602;
}

virtual size_t Get603()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 603;
}

virtual size_t Get604()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 604;
}

virtual size_t Get605()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 605;
}

virtual size_t Get606()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 606;
}

virtual size_t Get607()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 607;
}

virtual size_t Get608()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 608;
}

virtual size_t Get609()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 609;
}

virtual size_t Get610()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 610;
}

virtual size_t Get611()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 611;
}

virtual size_t Get612()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 612;
}

virtual size_t Get613()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 613;
}

virtual size_t Get614()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 614;
}

virtual size_t Get615()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 615;
}

virtual size_t Get616()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 616;
}

virtual size_t Get617()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 617;
}

virtual size_t Get618()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 618;
}

virtual size_t Get619()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 619;
}

virtual size_t Get620()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 620;
}

virtual size_t Get621()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 621;
}

virtual size_t Get622()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 622;
}

virtual size_t Get623()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 623;
}

virtual size_t Get624()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 624;
}

virtual size_t Get625()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 625;
}

virtual size_t Get626()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 626;
}

virtual size_t Get627()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 627;
}

virtual size_t Get628()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 628;
}

virtual size_t Get629()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 629;
}

virtual size_t Get630()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 630;
}

virtual size_t Get631()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 631;
}

virtual size_t Get632()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 632;
}

virtual size_t Get633()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 633;
}

virtual size_t Get634()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 634;
}

virtual size_t Get635()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 635;
}

virtual size_t Get636()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 636;
}

virtual size_t Get637()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 637;
}

virtual size_t Get638()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 638;
}

virtual size_t Get639()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 639;
}

virtual size_t Get640()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 640;
}

virtual size_t Get641()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 641;
}

virtual size_t Get642()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 642;
}

virtual size_t Get643()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 643;
}

virtual size_t Get644()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 644;
}

virtual size_t Get645()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 645;
}

virtual size_t Get646()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 646;
}

virtual size_t Get647()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 647;
}

virtual size_t Get648()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 648;
}

virtual size_t Get649()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 649;
}

virtual size_t Get650()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 650;
}

virtual size_t Get651()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 651;
}

virtual size_t Get652()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 652;
}

virtual size_t Get653()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 653;
}

virtual size_t Get654()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 654;
}

virtual size_t Get655()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 655;
}

virtual size_t Get656()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 656;
}

virtual size_t Get657()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 657;
}

virtual size_t Get658()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 658;
}

virtual size_t Get659()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 659;
}

virtual size_t Get660()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 660;
}

virtual size_t Get661()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 661;
}

virtual size_t Get662()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 662;
}

virtual size_t Get663()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 663;
}

virtual size_t Get664()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 664;
}

virtual size_t Get665()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 665;
}

virtual size_t Get666()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 666;
}

virtual size_t Get667()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 667;
}

virtual size_t Get668()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 668;
}

virtual size_t Get669()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 669;
}

virtual size_t Get670()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 670;
}

virtual size_t Get671()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 671;
}

virtual size_t Get672()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 672;
}

virtual size_t Get673()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 673;
}

virtual size_t Get674()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 674;
}

virtual size_t Get675()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 675;
}

virtual size_t Get676()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 676;
}

virtual size_t Get677()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 677;
}

virtual size_t Get678()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 678;
}

virtual size_t Get679()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 679;
}

virtual size_t Get680()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 680;
}

virtual size_t Get681()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 681;
}

virtual size_t Get682()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 682;
}

virtual size_t Get683()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 683;
}

virtual size_t Get684()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 684;
}

virtual size_t Get685()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 685;
}

virtual size_t Get686()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 686;
}

virtual size_t Get687()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 687;
}

virtual size_t Get688()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 688;
}

virtual size_t Get689()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 689;
}

virtual size_t Get690()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 690;
}

virtual size_t Get691()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 691;
}

virtual size_t Get692()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 692;
}

virtual size_t Get693()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 693;
}

virtual size_t Get694()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 694;
}

virtual size_t Get695()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 695;
}

virtual size_t Get696()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 696;
}

virtual size_t Get697()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 697;
}

virtual size_t Get698()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 698;
}

virtual size_t Get699()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 699;
}

virtual size_t Get700()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 700;
}

virtual size_t Get701()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 701;
}

virtual size_t Get702()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 702;
}

virtual size_t Get703()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 703;
}

virtual size_t Get704()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 704;
}

virtual size_t Get705()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 705;
}

virtual size_t Get706()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 706;
}

virtual size_t Get707()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 707;
}

virtual size_t Get708()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 708;
}

virtual size_t Get709()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 709;
}

virtual size_t Get710()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 710;
}

virtual size_t Get711()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 711;
}

virtual size_t Get712()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 712;
}

virtual size_t Get713()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 713;
}

virtual size_t Get714()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 714;
}

virtual size_t Get715()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 715;
}

virtual size_t Get716()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 716;
}

virtual size_t Get717()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 717;
}

virtual size_t Get718()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 718;
}

virtual size_t Get719()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 719;
}

virtual size_t Get720()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 720;
}

virtual size_t Get721()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 721;
}

virtual size_t Get722()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 722;
}

virtual size_t Get723()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 723;
}

virtual size_t Get724()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 724;
}

virtual size_t Get725()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 725;
}

virtual size_t Get726()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 726;
}

virtual size_t Get727()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 727;
}

virtual size_t Get728()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 728;
}

virtual size_t Get729()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 729;
}

virtual size_t Get730()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 730;
}

virtual size_t Get731()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 731;
}

virtual size_t Get732()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 732;
}

virtual size_t Get733()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 733;
}

virtual size_t Get734()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 734;
}

virtual size_t Get735()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 735;
}

virtual size_t Get736()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 736;
}

virtual size_t Get737()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 737;
}

virtual size_t Get738()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 738;
}

virtual size_t Get739()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 739;
}

virtual size_t Get740()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 740;
}

virtual size_t Get741()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 741;
}

virtual size_t Get742()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 742;
}

virtual size_t Get743()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 743;
}

virtual size_t Get744()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 744;
}

virtual size_t Get745()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 745;
}

virtual size_t Get746()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 746;
}

virtual size_t Get747()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 747;
}

virtual size_t Get748()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 748;
}

virtual size_t Get749()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 749;
}

virtual size_t Get750()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 750;
}

virtual size_t Get751()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 751;
}

virtual size_t Get752()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 752;
}

virtual size_t Get753()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 753;
}

virtual size_t Get754()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 754;
}

virtual size_t Get755()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 755;
}

virtual size_t Get756()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 756;
}

virtual size_t Get757()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 757;
}

virtual size_t Get758()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 758;
}

virtual size_t Get759()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 759;
}

virtual size_t Get760()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 760;
}

virtual size_t Get761()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 761;
}

virtual size_t Get762()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 762;
}

virtual size_t Get763()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 763;
}

virtual size_t Get764()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 764;
}

virtual size_t Get765()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 765;
}

virtual size_t Get766()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 766;
}

virtual size_t Get767()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 767;
}

virtual size_t Get768()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 768;
}

virtual size_t Get769()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 769;
}

virtual size_t Get770()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 770;
}

virtual size_t Get771()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 771;
}

virtual size_t Get772()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 772;
}

virtual size_t Get773()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 773;
}

virtual size_t Get774()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 774;
}

virtual size_t Get775()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 775;
}

virtual size_t Get776()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 776;
}

virtual size_t Get777()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 777;
}

virtual size_t Get778()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 778;
}

virtual size_t Get779()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 779;
}

virtual size_t Get780()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 780;
}

virtual size_t Get781()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 781;
}

virtual size_t Get782()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 782;
}

virtual size_t Get783()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 783;
}

virtual size_t Get784()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 784;
}

virtual size_t Get785()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 785;
}

virtual size_t Get786()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 786;
}

virtual size_t Get787()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 787;
}

virtual size_t Get788()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 788;
}

virtual size_t Get789()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 789;
}

virtual size_t Get790()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 790;
}

virtual size_t Get791()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 791;
}

virtual size_t Get792()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 792;
}

virtual size_t Get793()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 793;
}

virtual size_t Get794()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 794;
}

virtual size_t Get795()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 795;
}

virtual size_t Get796()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 796;
}

virtual size_t Get797()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 797;
}

virtual size_t Get798()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 798;
}

virtual size_t Get799()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 799;
}

virtual size_t Get800()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 800;
}

virtual size_t Get801()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 801;
}

virtual size_t Get802()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 802;
}

virtual size_t Get803()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 803;
}

virtual size_t Get804()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 804;
}

virtual size_t Get805()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 805;
}

virtual size_t Get806()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 806;
}

virtual size_t Get807()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 807;
}

virtual size_t Get808()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 808;
}

virtual size_t Get809()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 809;
}

virtual size_t Get810()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 810;
}

virtual size_t Get811()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 811;
}

virtual size_t Get812()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 812;
}

virtual size_t Get813()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 813;
}

virtual size_t Get814()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 814;
}

virtual size_t Get815()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 815;
}

virtual size_t Get816()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 816;
}

virtual size_t Get817()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 817;
}

virtual size_t Get818()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 818;
}

virtual size_t Get819()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 819;
}

virtual size_t Get820()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 820;
}

virtual size_t Get821()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 821;
}

virtual size_t Get822()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 822;
}

virtual size_t Get823()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 823;
}

virtual size_t Get824()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 824;
}

virtual size_t Get825()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 825;
}

virtual size_t Get826()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 826;
}

virtual size_t Get827()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 827;
}

virtual size_t Get828()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 828;
}

virtual size_t Get829()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 829;
}

virtual size_t Get830()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 830;
}

virtual size_t Get831()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 831;
}

virtual size_t Get832()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 832;
}

virtual size_t Get833()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 833;
}

virtual size_t Get834()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 834;
}

virtual size_t Get835()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 835;
}

virtual size_t Get836()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 836;
}

virtual size_t Get837()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 837;
}

virtual size_t Get838()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 838;
}

virtual size_t Get839()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 839;
}

virtual size_t Get840()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 840;
}

virtual size_t Get841()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 841;
}

virtual size_t Get842()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 842;
}

virtual size_t Get843()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 843;
}

virtual size_t Get844()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 844;
}

virtual size_t Get845()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 845;
}

virtual size_t Get846()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 846;
}

virtual size_t Get847()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 847;
}

virtual size_t Get848()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 848;
}

virtual size_t Get849()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 849;
}

virtual size_t Get850()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 850;
}

virtual size_t Get851()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 851;
}

virtual size_t Get852()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 852;
}

virtual size_t Get853()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 853;
}

virtual size_t Get854()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 854;
}

virtual size_t Get855()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 855;
}

virtual size_t Get856()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 856;
}

virtual size_t Get857()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 857;
}

virtual size_t Get858()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 858;
}

virtual size_t Get859()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 859;
}

virtual size_t Get860()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 860;
}

virtual size_t Get861()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 861;
}

virtual size_t Get862()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 862;
}

virtual size_t Get863()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 863;
}

virtual size_t Get864()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 864;
}

virtual size_t Get865()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 865;
}

virtual size_t Get866()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 866;
}

virtual size_t Get867()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 867;
}

virtual size_t Get868()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 868;
}

virtual size_t Get869()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 869;
}

virtual size_t Get870()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 870;
}

virtual size_t Get871()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 871;
}

virtual size_t Get872()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 872;
}

virtual size_t Get873()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 873;
}

virtual size_t Get874()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 874;
}

virtual size_t Get875()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 875;
}

virtual size_t Get876()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 876;
}

virtual size_t Get877()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 877;
}

virtual size_t Get878()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 878;
}

virtual size_t Get879()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 879;
}

virtual size_t Get880()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 880;
}

virtual size_t Get881()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 881;
}

virtual size_t Get882()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 882;
}

virtual size_t Get883()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 883;
}

virtual size_t Get884()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 884;
}

virtual size_t Get885()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 885;
}

virtual size_t Get886()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 886;
}

virtual size_t Get887()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 887;
}

virtual size_t Get888()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 888;
}

virtual size_t Get889()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 889;
}

virtual size_t Get890()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 890;
}

virtual size_t Get891()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 891;
}

virtual size_t Get892()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 892;
}

virtual size_t Get893()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 893;
}

virtual size_t Get894()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 894;
}

virtual size_t Get895()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 895;
}

virtual size_t Get896()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 896;
}

virtual size_t Get897()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 897;
}

virtual size_t Get898()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 898;
}

virtual size_t Get899()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 899;
}

virtual size_t Get900()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 900;
}

virtual size_t Get901()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 901;
}

virtual size_t Get902()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 902;
}

virtual size_t Get903()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 903;
}

virtual size_t Get904()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 904;
}

virtual size_t Get905()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 905;
}

virtual size_t Get906()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 906;
}

virtual size_t Get907()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 907;
}

virtual size_t Get908()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 908;
}

virtual size_t Get909()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 909;
}

virtual size_t Get910()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 910;
}

virtual size_t Get911()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 911;
}

virtual size_t Get912()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 912;
}

virtual size_t Get913()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 913;
}

virtual size_t Get914()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 914;
}

virtual size_t Get915()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 915;
}

virtual size_t Get916()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 916;
}

virtual size_t Get917()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 917;
}

virtual size_t Get918()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 918;
}

virtual size_t Get919()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 919;
}

virtual size_t Get920()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 920;
}

virtual size_t Get921()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 921;
}

virtual size_t Get922()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 922;
}

virtual size_t Get923()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 923;
}

virtual size_t Get924()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 924;
}

virtual size_t Get925()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 925;
}

virtual size_t Get926()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 926;
}

virtual size_t Get927()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 927;
}

virtual size_t Get928()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 928;
}

virtual size_t Get929()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 929;
}

virtual size_t Get930()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 930;
}

virtual size_t Get931()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 931;
}

virtual size_t Get932()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 932;
}

virtual size_t Get933()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 933;
}

virtual size_t Get934()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 934;
}

virtual size_t Get935()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 935;
}

virtual size_t Get936()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 936;
}

virtual size_t Get937()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 937;
}

virtual size_t Get938()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 938;
}

virtual size_t Get939()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 939;
}

virtual size_t Get940()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 940;
}

virtual size_t Get941()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 941;
}

virtual size_t Get942()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 942;
}

virtual size_t Get943()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 943;
}

virtual size_t Get944()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 944;
}

virtual size_t Get945()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 945;
}

virtual size_t Get946()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 946;
}

virtual size_t Get947()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 947;
}

virtual size_t Get948()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 948;
}

virtual size_t Get949()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 949;
}

virtual size_t Get950()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 950;
}

virtual size_t Get951()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 951;
}

virtual size_t Get952()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 952;
}

virtual size_t Get953()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 953;
}

virtual size_t Get954()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 954;
}

virtual size_t Get955()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 955;
}

virtual size_t Get956()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 956;
}

virtual size_t Get957()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 957;
}

virtual size_t Get958()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 958;
}

virtual size_t Get959()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 959;
}

virtual size_t Get960()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 960;
}

virtual size_t Get961()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 961;
}

virtual size_t Get962()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 962;
}

virtual size_t Get963()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 963;
}

virtual size_t Get964()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 964;
}

virtual size_t Get965()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 965;
}

virtual size_t Get966()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 966;
}

virtual size_t Get967()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 967;
}

virtual size_t Get968()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 968;
}

virtual size_t Get969()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 969;
}

virtual size_t Get970()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 970;
}

virtual size_t Get971()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 971;
}

virtual size_t Get972()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 972;
}

virtual size_t Get973()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 973;
}

virtual size_t Get974()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 974;
}

virtual size_t Get975()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 975;
}

virtual size_t Get976()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 976;
}

virtual size_t Get977()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 977;
}

virtual size_t Get978()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 978;
}

virtual size_t Get979()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 979;
}

virtual size_t Get980()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 980;
}

virtual size_t Get981()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 981;
}

virtual size_t Get982()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 982;
}

virtual size_t Get983()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 983;
}

virtual size_t Get984()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 984;
}

virtual size_t Get985()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 985;
}

virtual size_t Get986()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 986;
}

virtual size_t Get987()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 987;
}

virtual size_t Get988()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 988;
}

virtual size_t Get989()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 989;
}

virtual size_t Get990()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 990;
}

virtual size_t Get991()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 991;
}

virtual size_t Get992()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 992;
}

virtual size_t Get993()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 993;
}

virtual size_t Get994()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 994;
}

virtual size_t Get995()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 995;
}

virtual size_t Get996()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 996;
}

virtual size_t Get997()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 997;
}

virtual size_t Get998()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 998;
}

virtual size_t Get999()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 999;
}

virtual size_t Get1000()
{
  StaticDebugIsVirtual = true;
  this->InstanceDebugIsVirtual = true;
  return 1000;
}

    };

    // The signature / size that this compiler uses for function pointers in a virtual-table
    typedef void (TypeBinding::*VirtualTableFn)();

    // Get the number of entries in a class' virtual-table
    template <typename T>
    static size_t GetVirtualTableCount(typename IsPrimitive<T>::FalseType)
    {
      // We use a trick where we derive from the given type and add a single virtual function,
      // which when invoked on a 'counter' class will return us the index of the last function (eg the count)
      class Derived : public T
      {
      public:

        // The last function in the virtual-table, which when reinterpreted and called gives us the count
        virtual size_t GetVirtualTableCount()
        {
          // We can really return anything here, it should never be called
          Error("This should never be called!");
          return (size_t)-1;
        }
      };

      // This class has a virtual-table where every function returns its own index
      VirtualTableCounter counter;

      // Reinterpret the counter class as the derived class, and invoke
      // the last function (which will actually return the count)
      size_t count = reinterpret_cast<Derived*>(&counter)->GetVirtualTableCount();
      
      // Ensure the function we invoked a virtual function (this should always be the case)
      counter.AssertIfNotVirtual();

      // Return the count we got from the virtual table
      return count;
    }

    template <typename T>
    static size_t GetVirtualTableCount()
    {
      return 0;
    }

    // Checks if a class has a virtual-table by counting it's virtual functions
    template <typename T>
    static bool HasVirtualTable()
    {
      return GetVirtualTableCount<T>() != 0;
    }

    // Gets the index of a given virtual method pointer
    // The method SHOULD be virtual, otherwise corruption can occur!
    template <typename Method>
    static size_t GetVirtualMethodIndex(Method methodPtr)
    {
      // Make another method that looks like our counter class methods
      typedef size_t (VirtualTableCounter::*IndexFn)();

      // Reinterpret cast the given method into our counter method
      // Because the method SHOULD be virtual, calling this on the counter will return its index
      // NOTE: If the function given is actually not virtual, this will call the function on a BAD instance!
      // If this occurs, memory may be corrupted (we can't really counter this very well currently...)
      IndexFn indexMethodPtr = reinterpret_cast<IndexFn>(methodPtr);

      // This class has a virtual-table where every function returns its own index
      VirtualTableCounter counter;

      // Invoke the virtual method on our counter class (it better be virtual!)
      size_t index = (counter.*indexMethodPtr)();

      // Ensure the function we invoked a virtual function (if it hasn't already been corrupted by this point)
      counter.AssertIfNotVirtual();

      // Return the index of the virtual function
      return index;
    }

    // A guid generator for functions (primarily virtual)
    static GuidType& GetFunctionCounter()
    {
      static GuidType counter = 0;
      return counter;
    }

    // Gives a unique id to a function (primarily used for virtual function thunks)
    template <typename Function, Function function>
    static GuidType GetFunctionUniqueId()
    {
      static GuidType guid = GetFunctionCounter()++;
      return guid;
    };
  };
  
  /************************************ VOID *************************************/
  template <>
  class TypeBinding::StaticTypeId<void>
  {
  public:
    static BoundType* Get();
  };

  /************************************ NULL POINTER *************************************/
  template <>
  class TypeBinding::StaticTypeId<nullptr_t>
  {
  public:
    static BoundType* Get();
  };

  /************************************ ANY *************************************/
  template <>
  class TypeBinding::StaticTypeId<Any>
  {
  public:

    // The T type (and because partial specializations of 'StaticTypeId', this will always be a stripped type)
    typedef Any UnqualifiedType;

    // This type gets shadowed by the other partial specializations (and will be the actual type when accessed from the ZilchStaticType macro)
    typedef Any QualifiedType;

    // The type we use in any generated binding. This is generally the QualifiedType, however if the type is a redirect, it will be unqualified
    typedef Any BindingType;

    // This is the type that we represent when written to the stack
    // (as a value type) or dereferenced from a handle (as a reference type)
    typedef Any RepresentedType;

    // Because our representation is the exact same (whether in C++ or on the stack/in a handle)
    // then our resulting type when read is just a reference (not the case in all specializations!)
    typedef Any& ReadType;
      
    // Since our representation is the exact same (as mentioned above) this will be a direct read
    static const bool DirectRead = true;
      
    static AnyType* Get();
  };
  
  /*********************************** TRAITS ************************************/
  
  template <typename SelfType, typename BaseType>
  class CheckTypesAreRelated
  {
  public:
    static void Test()
    {
      // Check that the derived type is bigger than the
      // base type (should be since we have Debug_SizeTest)
      ZilchStaticAssert
      (
        sizeof(SelfType) > sizeof(BaseType),
        "It appears either the derived class or parent class is incorrect",
        TypeNotRelatedDerivedOrBase
      );

      // Attempt a static cast to ensure the types given were related
      // We need to use an invalid pointer (but not null) to avoid this getting compiled out
      BaseType* type1 = (BaseType*)0x00000001;
      SelfType* type2 = (SelfType*)0x00000001;
      type2 = static_cast<SelfType*>(type1);
      type1 = static_cast<BaseType*>(type2);
    }
  };
  
  template <typename SelfType>
  class CheckTypesAreRelated<SelfType, NoType>
  {
  public:
    static void Test()
    {
    }
  };

  /*********************************** CHECKS ************************************/

// If we're in debug mode, add extra checks...
#if _DEBUG
  // Checks used in the declaration of a C++ type exposed to Zilch
  #define ZilchDeclareChecks(SelfType, BaseType)                                                                          \
    /* Enforce that derived classes will always be bigger (only in debug) */                                              \
    int Debug_SizeTest;                                                                                                   \
    /* Do a series of debug checks to ensure the user is using the macros correctly */                                    \
    void Debug_Checks()                                                                                                   \
    {                                                                                                                     \
      /* Check that the sizes of the type we declared as 'our type' is the same as the size of the this reference */      \
      ZilchStaticAssert(sizeof(SelfType) == sizeof(*this),                                                                \
        "The type passed into the macro wasn't the same as the class it was declared in",                                 \
        TypeNotTheSameAsDeclared);                                                                                        \
      /* Check that the two types are related via static casting */                                                       \
      Zilch::CheckTypesAreRelated<SelfType, BaseType>::Test();                                                            \
    }                                                                                                                     \
    static void ZilchDebugDerivedHasNotBeenDeclared() {}                                                                  \
    static void ZilchDebugBaseHasNotBeenDeclared() {}
#else
  #define ZilchDeclareChecks(SelfType, BaseType)
  #define ZilchDefineChecks(SelfType, BaseType)
#endif

  
  /********************************** EXTERNAL ***********************************/
  // Declare an external type
  #define ZilchDeclareExternalHelper(SelfType, BaseType, TypeCopy)                      \
    /* A specialization so we know that type info exists for this type */               \
    template <>                                                                         \
    class ZilchStaticType(SelfType)                                                     \
    {                                                                                   \
    public:                                                                             \
      static const TypeCopyMode::Enum CopyMode = TypeCopy;                              \
      typedef SelfType UnqualifiedType;                                                 \
      typedef SelfType QualifiedType;                                                   \
      typedef SelfType BindingType;                                                     \
      typedef SelfType RepresentedType;                                                 \
      typedef SelfType& ReadType;                                                       \
      static const bool DirectRead = true;                                              \
      static Zilch::BoundType* Get();                                                   \
      /* Binding macros need the current class being bound */                           \
      typedef BaseType  Base;                                                           \
      typedef BaseType* BasePtr;                                                        \
      typedef SelfType  Self;                                                           \
      typedef SelfType* SelfPtr;                                                        \
      /* Creates the static type (our reflected type) */                                \
      static void InitializeStaticType(Zilch::StaticLibrary& library);                  \
      /* External types still need a way to setup thier bindings */                     \
      static void SetupType(Zilch::LibraryBuilder& builder, Zilch::BoundType* type);    \
      /* Read and write values from stack data and dereferenced handle data */          \
      static ReadType Read(byte* from);                                                 \
      static void Write(const SelfType& value, byte* to);                               \
    };

  // Declare an external base type (belongs inside the type definition)
  #define ZilchDeclareExternalBaseType(SelfType, TypeCopy)                              \
    ZilchDeclareExternalHelper(SelfType, NoType, TypeCopy)

  // Declare an external derived type (belongs inside the type definition)
  #define ZilchDeclareExternalDerivedType(SelfType, BaseType, TypeCopy)                 \
    ZilchDeclareExternalHelper(SelfType, BaseType, TypeCopy)

  // (Helper) Define an external type with a given name
  #define ZilchDefineExternalTypeAs(SelfType, Library, Name)                            \
    /* We store the Zilch type, but ideally this would be not accessible */             \
    Zilch::BoundType* __##SelfType##Type = nullptr;                                     \
    /* Implementation of the 'get type' specialization */                               \
    Zilch::BoundType* ZilchStaticType(SelfType)::Get()                                  \
    {                                                                                   \
      Zilch::StaticLibraries& statics = StaticLibraries::GetInstance();                 \
      if (__##SelfType##Type == nullptr)                                                \
      {                                                                                 \
        if (statics.GetBuildState() == BuildState::Building)                            \
        {                                                                               \
          InitializeStaticType(Library::GetInstance());                                 \
        }                                                                               \
        else                                                                            \
        {                                                                               \
          Error("The type '" #SelfType "' has not yet been initialized. "               \
            "To build all static libraries call Zilch::ZilchStartup() in main.");       \
        }                                                                               \
      }                                                                                 \
      return __##SelfType##Type;                                                        \
    }                                                                                   \
    /* Read our object representation from either stack data or handle data */          \
    ZilchStaticType(SelfType)::ReadType ZilchStaticType(SelfType)::Read(byte* from)     \
    {                                                                                   \
      return *(SelfType*)from;                                                          \
    }                                                                                   \
    /* Write our object representation to either stack data or handle data */           \
    void ZilchStaticType(SelfType)::Write(const SelfType& value, byte* to)              \
    {                                                                                   \
      new (to) SelfType(value);                                                         \
    }                                                                                   \
    /* This function gets called when the static library we belong to is built */       \
    void ZilchStaticType(SelfType)::InitializeStaticType(Zilch::StaticLibrary& library) \
    {                                                                                   \
      /* Check if we've already been initialized */                                     \
      if (__##SelfType##Type != nullptr)                                                \
        return;                                                                         \
      typedef ZilchStaticType(SelfType) InitType;                                       \
      /* First initialize our base type... */                                           \
      ZilchStaticType(Base)::InitializeStaticType(library);                             \
      /* Actually create and bind our type */                                           \
      __##SelfType##Type = library.MakeType                                             \
      (                                                                                 \
        Name,                                                                           \
        sizeof(SelfType),                                                               \
        InitType::CopyMode,                                                             \
        ZilchTypeId(InitType::Base),                                                    \
        Zilch::TypeBinding::GetVirtualTableCount<SelfType>()                            \
      );                                                                                \
      InitType::SetupType(*library.GetBuilder(), __##SelfType##Type);                   \
    }                                                                                   \
    /* Add to the global initializers, so we can ensure initialization of types */      \
    int SelfType##Init = Library::GetInstance().AddInitializer(                         \
      ZilchStaticType(SelfType)::InitializeStaticType);                                 \
    /* Implementation of the binding (the user provides the body) */                    \
    void ZilchStaticType(SelfType)::                                                    \
      SetupType(Zilch::LibraryBuilder& builder, Zilch::BoundType* type)
  
  // (Helper) Define an external type
  #define ZilchDefineExternalType(SelfType, Library)                                    \
    ZilchDefineExternalTypeAs(SelfType, Library, #SelfType)

  // (Helper) Define a type
  #define ZilchDefineSimpleExternalTypeAs(SelfType, Library, Name)                      \
    ZilchDefineExternalTypeAs(SelfType, Library, Name)                                  \
    {                                                                                   \
    }

  // (Helper) Define a type
  #define ZilchDefineSimpleExternalType(SelfType, Library)                              \
    ZilchDefineSimpleExternalTypeAs(SelfType, Library, #SelfType)

  /**************************** EXTERNAL REDIRECTION *****************************/
  // Declare an external type
  #define ZilchDeclareRedirectType(SelfType, RedirectType)                              \
    /* A specialization so we know that type info exists for this type */               \
    template <>                                                                         \
    class ZilchStaticType(SelfType)                                                     \
    {                                                                                   \
    public:                                                                             \
      static const TypeCopyMode::Enum CopyMode = StaticTypeId<RedirectType>::CopyMode;  \
      typedef SelfType UnqualifiedType;                                                 \
      typedef SelfType QualifiedType;                                                   \
      typedef SelfType BindingType;                                                     \
      typedef RedirectType RepresentedType;                                             \
      typedef SelfType ReadType;                                                        \
      static const bool DirectRead = false;                                             \
      static Zilch::BoundType* Get();                                                   \
      /* Read and write values from stack data and dereferenced handle data */          \
      static ReadType Read(byte* from);                                                 \
      static void Write(const SelfType& value, byte* to);                               \
    };

  // (Helper) Define an external type with a given name
  #define ZilchDefineRedirectType(SelfType, ConvertFromRedirect, ConvertToRedirect)     \
    /* Implementation of the 'get type' specialization */                               \
    Zilch::BoundType* ZilchStaticType(SelfType)::Get()                                  \
    {                                                                                   \
      return ZilchTypeId(RepresentedType);                                              \
    }                                                                                   \
    /* Read our object representation from either stack data or handle data */          \
    ZilchStaticType(SelfType)::ReadType ZilchStaticType(SelfType)::Read(byte* from)     \
    {                                                                                   \
      return ConvertToRedirect(*(RepresentedType*)from);                                \
    }                                                                                   \
    /* Write our object representation to either stack data or handle data */           \
    void ZilchStaticType(SelfType)::Write(const SelfType& value, byte* to)              \
    {                                                                                   \
      new (to) RepresentedType(ConvertFromRedirect(value));                             \
    }

  // Can be used by redirection macros to support changing of a type to another type
  template <typename From, typename To>
  To StaticCast(const From& from)
  {
    return static_cast<To>(from);
  }

  // Define an external type with a given name that can be statically casted to our redirected type
  #define ZilchDefineSimpleRedirectType(SelfType)                                       \
    ZilchDefineRedirectType(SelfType,                                                   \
    (StaticCast<SelfType, ZilchStaticType(SelfType)::RepresentedType>),                 \
    (StaticCast<ZilchStaticType(SelfType)::RepresentedType, SelfType>))

  /********************************** INTERNAL ***********************************/
  // Declare a type (belongs inside the type definition)
  #define ZilchDeclareHelper(SelfType, BaseType, TypeCopy)                              \
    ZilchDeclareChecks(SelfType, BaseType)                                              \
    public:                                                                             \
    /* Get the most derived type from an instance of the class */                       \
    /* Inheriting from 'IZilchObject' will make these virtual */                        \
    /*virtual*/ Zilch::BoundType* ZilchGetDerivedType() const;                          \
    /* Get the static type id from the object */                                        \
    static Zilch::BoundType* ZilchGetStaticType();                                      \
    static const Zilch::TypeCopyMode::Enum ZilchCopyMode = TypeCopy;                    \
    /* Binding macros need the current class being bound */                             \
    typedef BaseType  ZilchBase;                                                        \
    typedef BaseType* ZilchBasePtr;                                                     \
    typedef SelfType  ZilchSelf;                                                        \
    typedef SelfType* ZilchSelfPtr;                                                     \
    /* Creates the static type (our reflected type) */                                  \
    static void ZilchInitializeStaticType(Zilch::StaticLibrary& library);               \
    /* Setup any bindings that may be necessary for this type */                        \
    static void ZilchSetupType(Zilch::LibraryBuilder& builder, Zilch::BoundType* type);

  // Declare a base type (belongs inside the type definition)
  #define ZilchDeclareBaseType(SelfType, CopyType)                                      \
    ZilchDeclareHelper(SelfType, Zilch::NoType, CopyType)

  // Declare a derived type (belongs inside the type definition)
  #define ZilchDeclareDerivedType(SelfType, BaseType)                                   \
    ZilchDeclareHelper(SelfType, BaseType, BaseType::ZilchCopyMode)

  // (Helper) Define a type
  #define ZilchDefineTypeAs(SelfType, Library, Name)                                    \
    /* We store the Zilch type, but ideally this would be not accessible */             \
    Zilch::BoundType* __##SelfType##Type = nullptr;                                     \
    /* Implementation of the get derived type function */                               \
    Zilch::BoundType* SelfType::ZilchGetDerivedType() const                             \
    {                                                                                   \
      return SelfType::ZilchGetStaticType();                                            \
    }                                                                                   \
    /* Get the static type id from the object */                                        \
    Zilch::BoundType* SelfType::ZilchGetStaticType()                                    \
    {                                                                                   \
      Zilch::StaticLibraries& statics = Zilch::StaticLibraries::GetInstance();          \
      if (__##SelfType##Type == nullptr)                                                \
      {                                                                                 \
        if (statics.GetBuildState() == Zilch::BuildState::Building)                     \
        {                                                                               \
          ZilchInitializeStaticType(Library::GetInstance());                            \
        }                                                                               \
        else                                                                            \
        {                                                                               \
          Error("The type '" #SelfType "' has not yet been initialized. "               \
            "To build all static libraries call Zilch::ZilchStartup() in main.");       \
        }                                                                               \
      }                                                                                 \
      return __##SelfType##Type;                                                        \
    }                                                                                   \
    /* This function gets called when the static library we belong to is built */       \
    void SelfType::ZilchInitializeStaticType(Zilch::StaticLibrary& library)             \
    {                                                                                   \
      /* Check if we've already been initialized */                                     \
      if (__##SelfType##Type != nullptr)                                                \
        return;                                                                         \
      /* First initialize our base type... */                                           \
      ZilchStaticType(ZilchBase)::InitializeStaticType(library);                        \
      /* Actually create and bind our type */                                           \
      __##SelfType##Type = library.MakeType                                             \
      (                                                                                 \
        Name,                                                                           \
        sizeof(SelfType),                                                               \
        ZilchCopyMode,                                                                  \
        ZilchTypeId(ZilchBase),                                                         \
        Zilch::TypeBinding::GetVirtualTableCount<SelfType>()                            \
      );                                                                                \
      ZilchSetupType(*library.GetBuilder(), __##SelfType##Type);                        \
    }                                                                                   \
    /* Add to the global initializers, so we can ensure initialization of types */      \
    int SelfType##Init = Library::GetInstance()                                         \
      .AddInitializer(SelfType::ZilchInitializeStaticType);                             \
    /* Implementation of the binding (the user provides the body) */                    \
    void SelfType::ZilchSetupType                                                       \
      (Zilch::LibraryBuilder& builder, Zilch::BoundType* type)
  
  // (Helper) Define an external type
  #define ZilchDefineType(SelfType, Library)                                            \
    ZilchDefineTypeAs(SelfType, Library, #SelfType)

  // (Helper) Define a type
  #define ZilchDefineSimpleTypeAs(SelfType, Library, Name)                              \
    ZilchDefineTypeAs(SelfType, Library, Name)                                          \
    {                                                                                   \
    }

  // (Helper) Define a type
  #define ZilchDefineSimpleType(SelfType, Library)                                      \
    ZilchDefineSimpleTypeAs(SelfType, Library, #SelfType)

  /********************************** PRIMITIVE **********************************/
  // Declaration of all primitive types (these MUST be seen by anything
  // using type-binding, and therefore they are declared within this file)
  ZilchDeclareExternalBaseType(Boolean,       TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Boolean2,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Boolean3,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Boolean4,      TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(Integer,       TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Integer2,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Integer3,      TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Integer4,      TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(Real,          TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Real2,         TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Real3,         TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(Real4,         TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(Quaternion,    TypeCopyMode::ValueType);

  ZilchDeclareExternalBaseType(String,        TypeCopyMode::ReferenceType);
  
  ZilchDeclareExternalBaseType(DoubleReal,    TypeCopyMode::ValueType);
  ZilchDeclareExternalBaseType(DoubleInteger, TypeCopyMode::ValueType);

  // All the redirection types
  ZilchDeclareRedirectType(char,                Integer);
  ZilchDeclareRedirectType(signed   char,       Integer);
  ZilchDeclareRedirectType(unsigned char,       Integer);
  ZilchDeclareRedirectType(signed   short,      Integer);
  ZilchDeclareRedirectType(unsigned short,      Integer);
  
  ZilchDeclareRedirectType(unsigned int,        Integer);
  ZilchDeclareRedirectType(signed   long,       Integer);
  ZilchDeclareRedirectType(unsigned long,       Integer);

  ZilchDeclareRedirectType(unsigned long long,  DoubleInteger);
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CORE_HPP
#define ZILCH_CORE_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TYPE_HPP
#define ZILCH_TYPE_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CODE_LOCATION_HPP
#define ZILCH_CODE_LOCATION_HPP

namespace Zilch
{
  // We can print Zilch messages in many different formats
  // This is used for printing errors, exceptions, and general code location information
  namespace MessageFormat
  {
    enum Enum
    {
      // This is the standard format we use to print Zilch error messages
      // We try to be very descriptive about where our errors occur
      // Style: 'In <origin> at line <line>, character <character> (within function <function>)'
      //        '  <message>'
      Zilch,
      
      // Style: '  File "<origin>", line <line>, in <function>'
      //        '    <message>'
      Python,
      
      // Msvc errors are useful when editing Zilch inside of Visual Studio,
      // because you can double click the error and go directly to the file
      // Style: '<origin>(<line>): <message>'
      MsvcCpp
    };
  }

  // A code location provides us with a context of where something occurred
  class CodeLocation
  {
  public:
    // Default constructor
    CodeLocation();

    // Checks if this location was ever set to a valid value
    bool IsValid();

    // Get a formatted message that includes this location (may include newlines depending on the format)
    String GetFormattedStringWithMessage(MessageFormat::Enum format, StringParam message) const;

    // Get this location formatted in different styles (does not include newlines)
    String GetFormattedString(MessageFormat::Enum format) const;

    // Creates a code location that is strictly at the start of this location
    CodeLocation GetStartOnlyLocation();

    // Creates a code location that is strictly at the end of this location
    CodeLocation GetEndOnlyLocation();

    // This hash matches the hash used in the CodeEntry, and can generally be used to map back to files
    size_t GetHash();

    // Every file and code string compiled gets a unique id
    String Code;

    // The line range that the node originated from
    // Lines start at a value of 1 (a value of 0 is invalid)
    size_t StartLine;
    size_t EndLine;

    // The character range that the node originated from (relative to the start of the line)
    // Characters start at a value of 1 (a value of 0 is invalid)
    size_t StartCharacter;
    size_t EndCharacter;

    // A location that we generally use when displaying errors or other visualizations
    // For example, in a binary operator the location Start/End encompasses both the Left/Right operands
    // however the primary location is the operator itself
    size_t PrimaryLine;
    size_t PrimaryCharacter;

    // The file/script this node originated from
    String Origin;

    // This is an optional library that we're from (typically filled out in the syntaxer phase)
    String Library;

    // This is an optional class that we're from (typically filled out in the syntaxer phase)
    String Class;

    // This is an optional function that we're from (typically filled out in the syntaxer phase)
    String Function;

    // Tells us if the location is within C++, which
    // means that it cannot be debugged or visualized
    bool IsNative;

    // When the user provides a code block to the project to be compiled
    // they have the option of providing user-data. This user-data is the
    // same data that they passed in
    mutable const void* CodeUserData;
  };

  // Every time we add code to the project we do it through this
  // This is also stored on the library that gets generated out of the project
  class CodeEntry
  {
  public:
    // Constructor
    CodeEntry();

    String Code;
    String Origin;
    void* CodeUserData;

    // Gets a hash that we can use to uniquely identify this code
    // This includes the code and its origin
    // If a file changes names, this will no longer map up to that same file
    size_t GetHash();
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DESTRUCTABLE_BUFFER_HPP
#define ZILCH_DESTRUCTABLE_BUFFER_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_UNTYPED_BLOCK_ARRAY_HPP
#define ZILCH_UNTYPED_BLOCK_ARRAY_HPP

namespace Zilch
{
  // A block array (except it is untyped, and therefore works mostly with copyable structs)
  template <size_t BlockSize>
  class UntypedBlockArray
  {
  public:

    // Constructor
    UntypedBlockArray()
    {
      this->CompactedSize = 0;
    }

    // Destructor
    ~UntypedBlockArray()
    {
      // Clear out the block array
      Clear();
    }

    // Efficiently compact all the data into one output buffer
    // This will wipe out any empty space between the blocks
    void RelativeCompact(byte* output)
    {
      // Loop through all the blocks
      for (size_t i = 0; i < this->Blocks.size(); ++i)
      {
        // Get the current block
        Block& block = this->Blocks[i];

        // Copy all the block's data to the output
        memcpy(output, block.Data, block.LengthWritten);

        // Move the pointer forward so we can copy the next block
        output += block.LengthWritten;
      }
    }

    // Gets an element in a block given an exact location
    byte* GetAbsoluteElement(size_t index)
    {
      // Determine the block index and offset into that block
      size_t blockIndex = index / BlockSize;
      size_t blockOffset = index % BlockSize;

      // Get the current block
      Block& block = this->Blocks[blockIndex];

      // Return a pointer to that location
      return block.Data + blockOffset;
    }

    // Get an element by index (note that this is not a constant time operation)
    byte* GetRelativeElement(size_t index)
    {
      // Note: This could potentially be optimized using a few key facts
      // We know that we will probably mostly fill up each block, so block sizes
      // very close to the LengthWritten for any given full block
      // Each block could then store all the previous size up to that point
      // We could use the index to guess a block (index / BlockSize) and we know
      // that the element is either in that block or in a previous one close by

      // More than likely, it's not a problem since our block array
      // will be so big that worst case scenario, we're probably 
      // indexing into the second or third block (near constant time)

      // Loop through all the blocks
      for (size_t i = 0; i < this->Blocks.size(); ++i)
      {
        // Get the current block
        Block& block = this->Blocks[i];

        // If the index is within this block
        if (index < block.LengthWritten)
        {
          // Return the element
          return block.Data + index;
        }
        else
        {
          // Move the index back by the amount written to this block
          index -= block.LengthWritten;
        }
      }

      // We didn't find it?
      Error("Unable to find a given element by index");
      return nullptr;
    }
    
    // Get the total size
    size_t RelativeSize()
    {
      return this->CompactedSize;
    }
    
    // Get the total size
    // Note: Do NOT use this as an absolute index, as it's possible that the next element
    // that's added to the block array will get pushed into another block (wrong index...)
    size_t AbsoluteSize()
    {
      if (this->Blocks.empty())
      {
        return 0;
      }
      else
      {
        return (this->Blocks.size() - 1) * BlockSize + this->Blocks.back().LengthWritten;
      }
    }

    // Clear all the of blocks out
    void Clear()
    {
      // Reset the size since we now store nothing
      this->CompactedSize = 0;

      // Loop through all the blocks
      for (size_t i = 0; i < this->Blocks.size(); ++i)
      {
        // Delete the block memory
        delete[] this->Blocks[i].Data;
      }

      // Clear the blocks out too
      this->Blocks.clear();
    }

    // Request a chunk of memory of a given size, and return a pointer to the beginning of it
    byte* RequestElementOfSize(size_t size, size_t* absoluteIndexOut = nullptr)
    {
      // Error checking and handling
      ReturnIf(size > BlockSize, nullptr, "The element that was being allocated was larger than the block size");
      
      // We know that we'll add that size below (we have to!)
      this->CompactedSize += size;

      // If we have no blocks...
      if (this->Blocks.empty())
      {
        // Create our first block since we have none
        this->CreateBlock();
      }

      // Call the recursive version
      return this->RequestElementOfSizeRecursive(size, absoluteIndexOut);
    }

  private:

    // A block of opcodes
    class Block
    {
    public:
      // A pointer to the data that each block stores
      byte* Data;
      
      // The length that we've written into the data block
      // Note that the size of the memory pointed at by 'Data' is the BlockSize, however,
      // we may not have written all the way up to the end due to different opcode sizes
      size_t LengthWritten;
    };

    // Recursive version of requesting an element (we only recurse once)
    byte* RequestElementOfSizeRecursive(size_t size, size_t* absoluteIndexOut = nullptr)
    {
      // Get the last block (the only one we should be writing to)
      Block& last = this->Blocks.back();

      // Check if the last block has enough space for this element
      if (BlockSize - last.LengthWritten > size)
      {
        // Get a pointer to the element data
        byte* element = last.Data + last.LengthWritten;

        // If the user wants an absolute index back...
        if (absoluteIndexOut != nullptr)
        {
          // Return the index where we wrote the data
          *absoluteIndexOut = (this->Blocks.size() - 1) * BlockSize + last.LengthWritten;
        }

        // We've now 'written' more to the last block
        last.LengthWritten += size;

        // Return the element
        return element;
      }
      else
      {
        // Otherwise, we need to create a fresh new block
        this->CreateBlock();

        // Invoke the function again
        return this->RequestElementOfSizeRecursive(size, absoluteIndexOut);
      }
    }

    // Create another block at the end of the block array
    void CreateBlock()
    {
      // Create a new block
      Block& block = this->Blocks.push_back();

      // Create the block of data
      block.Data = new byte[BlockSize];

      // We haven't written anything yet
      block.LengthWritten = 0;
    }

  private:

    // Store an array of all the blocks that we use
    PodArray<Block> Blocks;

    // Store the total size overall
    size_t CompactedSize;
  };
}

// End header protection
#endif

namespace Zilch
{
  // Aligns a number to a machine byte boundary (either the same or a larger value)
  size_t AlignToBusWidth(size_t value);

  // A function that will invoke the destructor on an object (does not call delete or free!)
  typedef void (*DestructFn) (void* object);

  // A function for wrapping a destructor of any object in the above signature
  template <typename T>
  void DestructorWrapper(void* object)
  {
    // Cast the object pointer we got into our own object type
    T* objectTyped = (T*)object;

    // Invoke the destructor on the object
    // Note: We do not call free or delete on the object memory, it isn't ours!
    objectTyped->~T();
  }

  // Get the destructor for a type, or null for pod types...
  template <typename T>
  DestructFn GetDestructor()
  {
    // If the type is considered to be pod, ignore the destructor
    if (StandardTraits<T>::is_pod_::value)
    {
      return nullptr;
    }
    else
    {
      // Otherwise we wrap the destructor into our own signature
      return DestructorWrapper<T>;
    }
  }

  // Used to write arbitrary data to a buffer where some of the data could be destructed
  class DestructableBuffer
  {
  public:

    // The block size we use for allocations
    static const size_t BlockSize = 512;
    
    // Destructor
    ~DestructableBuffer();

    // Get the absolute size of the data
    // Note: Do NOT use this as an index in 'Read' or 'GetElement'
    size_t GetSize();

    // Clears the entire buffer, invoking all the destructors as needed
    void Clear();

    // Allocates writable memory that the user can work with
    // If the destructor passed in is null, then no destructor will be pushed
    byte* Allocate(size_t size, DestructFn destructor = nullptr, size_t* positionOut = nullptr);

    // Writes memory directly to the buffer
    // If the destructor passed in is null, then no destructor will be pushed
    byte* WriteMemory(void* source, size_t size, DestructFn destructor = nullptr);

    // Writes an object directly to the buffer
    // If the object is POD, no destructor will be pushed
    template <typename T>
    T& WriteObject(const T& value, size_t* positionOut = nullptr)
    {
      // Allocate the memory for the object and push a wrapper around it's destructor
      byte* newData = this->Allocate(sizeof(T), GetDestructor<T>(), positionOut);

      // Copy the object we got into the allocated data and return it
      return *new (newData) T(value);
    }

    // Creates an object with a default constructor directly
    // to the buffer and pushes the destructor
    template <typename T>
    T& CreateObject(size_t* positionOut = nullptr)
    {
      // Allocate the memory for the object and push a wrapper around it's destructor
      byte* newData = this->Allocate(sizeof(T), GetDestructor<T>(), positionOut);

      // Default construct the type into the allocated data and return it
      return *new (newData) T();
    }

    // Reads an amount of data starting from the given position
    // and can optionally return the next position to read from
    byte* Read(size_t position, size_t length, size_t* nextPositionOut = nullptr);

    // Reads an object from the data and moves the position forward by its size
    template <typename T>
    T& ReadObject(size_t position, size_t* nextPositionOut = nullptr)
    {
      // Read the data using the size of the given class
      return *(T*)this->Read(position, sizeof(T), nextPositionOut);
    }

    // Get the element at the given position
    byte* GetElement(size_t position);

  private:

    // Represents any bit of destructable data in our buffer
    class Destructable
    {
    public:
      // The position in the buffer where the object lives
      size_t AbsolutePosition;

      // The destructor (typically wrapped) to call on the object's memory
      // This destrcutor should never call free or delete, just the class destructor
      DestructFn Destructor;
    };

    // All the bits of data in the buffer that must be destructed
    PodArray<Destructable> Destructors;

    // The internal data
    UntypedBlockArray<BlockSize> Data;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_MEMBERS_HPP
#define ZILCH_MEMBERS_HPP

// Includes

namespace Zilch
{
  // The types of attribute parameters we support
  namespace AttributeType
  {
    enum Enum
    {
      Null,
      String,
      Number,
      Boolean
    };
  }

  // An attribute parameter can be any of the literal types we support
  class AttributeParameter
  {
  public:
    // Default constructor
    AttributeParameter();

    // An optional name given to the parameter (if the user used name parameter calling)
    String Name;

    // The type of the attribute parameter (literals only, default Null)
    AttributeType::Enum Type;

    // The original value, unparsed (for strings this includes quotes and escape sequences)
    String Token;

    // When Type is String, this will be the fully unescaped version of the string (default empty)
    String StringValue;
    
    // When Type is Number, this will be the parsed number value (default 0.0)
    // Note: Even integers will be stored as a number, and can just be cast out
    double NumberValue;
    
    // When Type is Boolean, this will be set to true or false (default false)
    bool BooleanValue;
  };

  // An attribute provides extra data about classes, functions, fields,
  // properties, etc that the language normally does not provide
  // An example would be marking a property as have a range of values from 1 to 100 eg [Range(1, 100)]
  class Attribute
  {
  public:
    // The name of the attribute
    String Name;

    // All the parameters we parsed from the attributes in the order they were given
    Array<AttributeParameter> Parameters;
  };

  // Provides a description
  class DocumentedObject : public IZilchObject
  {
  public:
    // Constructor
    DocumentedObject();

    // Gets a readable key that unqiuely identifies the object
    virtual String GetDocumentationKey() = 0;

    // Checks to see if an attribute exists
    bool HasAttribute(StringParam name);

    // A basic description for the type (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;

    // All the attributes attached to this type
    Array<Attribute> Attributes;

    // All documented objects can be hidden (for things parsed in language, use the [Hidden] attribute)
    bool IsHidden;
  };

  // All primitives that appear on types (properties, fields, functions, etc) are members
  class Member : public DocumentedObject
  {
  public:

    // Default constructor
    Member();

    // The owning type that this member belongs to
    BoundType* Owner;
  };

  // A class property basically consists of two functions that let us get and set a variable
  class Property : public Member
  {
  public:
    ZilchDeclareBaseType(Property, TypeCopyMode::ReferenceType);

    // Constructor
    Property();

    // Virtualize the destructor
    virtual ~Property();

    // DocumentedObject interface
    String GetDocumentationKey() override;

    // The name of the property
    String Name;

    // Whether or not the property is considered static
    bool IsStatic;

    // Mark if this property is hidden when null (useful for showing things like optional components)
    // This only applies to nullable types like handles and delegates
    bool IsHiddenWhenNull;

    // The type and offset into the class it belongs to
    Function* Get;
    Function* Set;

    // The type that we represent
    Type* PropertyType;

    // The code location at which the member was defined
    CodeLocation Location;
  };

  // A class field basically consists of the type, as well as the offset into the memory block
  class Field : public Property
  {
  public:
    ZilchDeclareDerivedType(Field, Property);

    // Constructor
    Field();

    // The offset into the class it belongs to
    size_t Offset;
  };

  // Store information about a variable inside a function
  class Variable
  {
  public:
    // Constructor
    Variable();

    // The relative position on the stack that this variable exists
    OperandLocal Local;

    // The type of the variable
    Type* ResultType;

    // Store the name of the variable
    String Name;
  };

  // Information about events sent by a class or struct
  class SendsEvent
  {
  public:
    // Constructor
    SendsEvent();

    // The name of the event that is being sent
    String Name;

    // The type of event being sent
    Type* ResultType;
  };
}

// End header protection
#endif

namespace Zilch
{
  // A structure that is responsible for resolving members and functions of a class
  class Resolver
  {
  public:
    // Get the instance resolver
    static Resolver Instance(Type* type);

    // Get the static resolver
    static Resolver Static(Type* type);

    // The virtual member functions that we'll call on the compiled type
    GetOverloadedFunctionsFn  GetOverloadedFunctions;
    GetFieldFn                GetField;
    GetPropertyFn             GetProperty;
    Type*                     TypeInstance;
    bool                      IsStatic;
  };

  // In the case where we're attempting to find members
  namespace FindMemberOptions
  {
    enum Enum
    {
      // No options
      None = 0,

      // A member that is not part of an instance,
      // but rather part of the type itself
      Static = 1,

      // Specifies that we will search only this type,
      // and not the hierarchy (base types) for the function
      DoNotIncludeBaseClasses = 2,
    };
    typedef unsigned Flags;
  }

  namespace CastOperation
  {
    enum Enum
    {
      // The casting operation was not valid
      Invalid,

      // A cast that has nothing to do (the underlying values are equivalent in raw form)
      // Includes casting from a derived class to a base class (ex: Cat to Animal)
      // Also include casting from NullType to any reference/handle type (null to Animal)
      Raw,
      
      // Casting from a built in primitive (ex: Integer to Real)
      // This really implies that there is an entire instruction made to deal with this cast
      Primitive,
      
      // Casting a base class to a dervied class, which must be checked (ex: Animal to Cat)
      DynamicDown,

      // Casting to the 'any' type, a special type that can contain or be anything (ex: Integer to any)
      ToAny,

      // Casting from the 'any' type which must be chcecked (ex: any to Integer)
      FromAny,

      // A special cast from null to a delegate type (null is a handle type)
      NullToDelegate,
    };
  }

  // A type is the base representation of all types
  class Type : public DocumentedObject
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareBaseType(Type, TypeCopyMode::ReferenceType);

    // Constructor
    Type();

    // DocumentedObject interface
    String GetDocumentationKey() override;

    // Hash the type
    virtual GuidType Hash() const = 0;

    // Gets a human readable name for the type
    // This name is only used for debugging and printing
    virtual String ToString() const = 0;

    // Checks whether a type has a complicated copy operator (handles, delegates, etc)
    // The opposite of this being that the data is POD (plain old data / value types)
    virtual bool IsCopyComplex() const = 0;

    // Get the size of the type (or if it's a reference type, the size of a handle)
    virtual size_t GetCopyableSize() const;

    // Get the size of the type if we were to allocate it in a memory block
    virtual size_t GetAllocatedSize() const = 0;

    // Constructs a default instance of this type
    // For as many types as possible, this will construct something akin to null
    // If the type does not support a null (such as value types) it will clear the memory to zeros
    // This is mainy used for templating, and the concept of 'default(T)'
    virtual void GenericDefaultConstruct(byte* toConstruct) const = 0;

    // Copies a value at one place to another
    // If the given type is a reference / delegate type, a handle copy will be performed
    // All value types will be directly memory copied
    virtual void GenericCopyConstruct(byte* to, const byte* from) const = 0;

    // Performs a handle release in the case that the type is a reference / delegate
    // Otherwise in the case of value types, this does nothing
    virtual void GenericDestruct(byte* value) const = 0;

    // Get the memory of the underlying object (only used for debugging)
    // For a reference/handle type, we will Dereference the handle (so this could be null)
    // Otherwise for value types, it will just directly return the passed in memory
    // For delegate types, this will also directly return the memory
    // For the AnyType, this will recursively call GenericGetMemory on the value stored inside the Any (if none, it will return itself)
    virtual byte* GenericGetMemory(const byte* value) const;

    // Get the most derived type of whatever we're looking at
    // In all case that the values that the value is null of (whatever that means) it will return this types itself
    // For bound value types this will just return the type directly (value types are always the correct type)
    // For all handle types (bound reference, indirect, AnyHandleType) this will return the type stored in the handle
    // For all delegate types (delegate type, AnyDelegateType) this will return the type of the function stored in the delegate
    // For the AnyType, this will recursively call GenericGetVirtualType on the value stored within the Any (if none, it will return itself)
    virtual Type* GenericGetVirtualType(const byte* value) const = 0;

    // Hashes an object of this type
    virtual Integer GenericHash(const byte* value) const = 0;

    // Converts the object or value into a human readable string
    virtual String GenericToString(const byte* value) const = 0;

    // Tests equality of two objects of the exact same type
    virtual Boolean GenericEquals(const byte* lhs, const byte* rhs) const = 0;
    
    // Finds a function by name given the type signature
    virtual Function* FindFunction(StringParam name, const Array<Type*>& parameters, Type* returnType, FindMemberOptions::Flags options) const;

    // The pre-constructor is a function that gets invoked before the standard constructor
    // and is used typically for member initialization. If set to null, the pre-constructor
    // will not be run when an instance of this type is created
    virtual Function* GetPreConstructor() const;

    // There will only ever be one single destructor (which takes no parameters and returns nothing)
    // Return null if the destructor does not exist
    virtual Function* GetDestructor() const;

    // Get an array of overloaded instance functions under the same name. Returning null
    // or an empty array will signal that the function does not exist. Moreover, returning
    // a single function in the array will also work as if it were not overloaded
    virtual const FunctionArray* GetOverloadedInstanceFunctions(String name) const;

    // Get an array of overloaded static functions under the same name. Returning null
    // or an empty array will signal that the function does not exist. Moreover, returning
    // a single function in the array will also work as if it were not overloaded
    virtual const FunctionArray* GetOverloadedStaticFunctions(String name) const;

    // Get an array of overloaded constructors. Returning null
    // or an empty array will signal that no constructors exist. Moreover, returning
    // a single constructor in the array will also work as if it were not overloaded
    virtual const FunctionArray* GetOverloadedConstructors() const;

    // Get an array of overloaded constructors (either on your type, or inherited). Returning
    // null or an empty array will signal that no constructors exist. Moreover, returning
    // a single constructor in the array will also work as if it were not overloaded
    virtual const FunctionArray* GetOverloadedInheritedConstructors() const;

    // Get an instance member by name
    virtual Field* GetInstanceField(String name) const;

    // Get a static member by name
    virtual Field* GetStaticField(String name) const;

    // Get an instance property by name
    virtual Property* GetInstanceProperty(String name) const;

    // Get a static property by name
    virtual Property* GetStaticProperty(String name) const;
    
    // Get a list of attributes (empty if there are no attributes)
    virtual SendsEventRange GetSendsEvents() const;

    // Attempt to get a default constructor (or return null if one cannot be found)
    static Function* GetDefaultConstructor(const FunctionArray* constructors);

    // Check if a given type is a handle type
    static bool IsHandleType(Type* type);

    // Check if a given type is a value type
    static bool IsValueType(Type* type);

    // Check if a given type is a delegate type
    static bool IsDelegateType(Type* type);

    // Check if a given type is an enum type
    static bool IsEnumType(Type* type);

    // Check if a given type is an flags type
    static bool IsFlagsType(Type* type);

    // Check if a given type is an enum or flags type
    static bool IsEnumOrFlagsType(Type* type);

    // Check if a given type is a any type
    static bool IsAnyType(Type* type);

    // Generically get the base class type (if we have one) or return null
    static Type* GetBaseType(Type* type);

    // Returns the type referenced by a handle type, or nullptr if the type was not a handle
    // Note that this function works for both indirect types as well as class bound types
    static BoundType* GetReferenceType(Type* handleType);

    // Check if two types are of the same type
    static bool IsSame(Type* a, Type* b);

    // Store the parent library from which the type originated
    // This information is generally used for linking purposes
    Library* SourceLibrary;

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructableBuffer ComplexUserData;

    // Not copyable
    ZilchNoCopy(Type);
  };

  // A qualified type represents a true-type with qualifications
  class IndirectionType : public Type
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IndirectionType, Type);

    // Constructor
    IndirectionType();

    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetAllocatedSize() const override;
    GuidType Hash() const override;
    String ToString() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    byte* GenericGetMemory(const byte* value) const override;
    Type* GenericGetVirtualType(const byte* value) const override;

    // Store the referenced type (the parent type that this qualified type represents)
    BoundType* ReferencedType;
  };

  // The 'any type' is a special type that can contain any primitive (delegates, handles, values, etc)
  // Note: There should only ever be one instantiation of this type (core.AnyType)
  class AnyType : public Type
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(AnyType, Type);

    // Constructor
    AnyType();

    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetAllocatedSize() const override;
    GuidType Hash() const override;
    String ToString() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    byte* GenericGetMemory(const byte* value) const override;
    Type* GenericGetVirtualType(const byte* value) const override;
  };

  // An enum that gives us information about the state of the current type's size
  namespace SizeState
  {
    enum Enum
    {
      Determined,
      BeingDetermined,
      Undetermined
    };
  }

  // A function used for converting a value or object to a string
  typedef String (*ToStringFn)(const BoundType* type, const byte* data);

  namespace SpecialType
  {
    enum Enum
    {
      Standard,
      Enumeration,
      Flags
    };
  }

  namespace AddMemberResult
  {
    enum Enum
    {
      AlreadyExists,
      Added
    };
  }

  // A type that provides us with a simple way of grabbing members and functions from maps
  class BoundType : public Type
  {
  public:

    // Declare the class for RTTI
    ZilchDeclareDerivedType(BoundType, Type);

    // Constructor
    BoundType(const String& name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount);

    // Destructor
    ~BoundType();

    // Get whether this is a reference or value type
    TypeCopyMode::Enum GetCopyMode() const;

    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetCopyableSize() const override;
    size_t GetAllocatedSize() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    byte* GenericGetMemory(const byte* value) const override;
    Type* GenericGetVirtualType(const byte* value) const override;
    Function* FindFunction(StringParam name, const Array<Type*>& parameters, Type* returnType, FindMemberOptions::Flags options) const;
    Function* FindFunction(StringParam name, DelegateType* type, FindMemberOptions::Flags options) const;
    const FunctionArray* GetOverloadedInstanceFunctions(String name) const override;
    const FunctionArray* GetOverloadedStaticFunctions(String name) const override;
    Field* GetInstanceField(String name) const override;
    Field* GetStaticField(String name) const override;
    Property* GetInstanceProperty(String name) const override;
    Property* GetStaticProperty(String name) const override;
    Function* GetPreConstructor() const override;
    const FunctionArray* GetOverloadedConstructors() const override;
    const FunctionArray* GetOverloadedInheritedConstructors() const override;
    Function* GetDestructor() const override;
    SendsEventRange GetSendsEvents() const override;
    GuidType Hash() const override;
    String ToString() const override;

    // Saves documentation in Zilch Documentation format
    String SaveDocumentation();

    // Loads documentation from the Zilch Documentation format
    void LoadDocumentation(String doc);

    // Add a function (created through the library) to the bound type
    AddMemberResult::Enum AddRawFunction(Function* function);

    // Add a property to the bound type
    AddMemberResult::Enum AddRawProperty(Property* property);

    // Add a field to the bound type
    AddMemberResult::Enum AddRawField(Field* field);

    // Get either the static or instance field map (maps strings to the fields)
    FieldMap& GetFieldMap(bool isStatic);

    // Get either the static or instance property map (maps strings to the fields)
    PropertyMap& GetPropertyMap(bool isStatic);

    // Get either the static or instance function map (maps strings to the fields)
    FunctionMultiMap& GetFunctionMap(bool isStatic);

    // By default, when our object is converted into
    // a string it simply prints out the type name
    static String DefaultTypeToString(const BoundType* type, const byte* data);

  public:

    // Tells us whether this is considered to be a value type or not
    // Value types have the property that they are memory copyable
    // and can therefore not store any references of any kind (only POD data)
    TypeCopyMode::Enum CopyMode;

    // Whether or not we can use new/local to create this type
    bool CreatableInScript;

    // Store the pre-constructor
    Function* PreConstructor;

    // Store the constructors
    FunctionArray Constructors;

    // The singular destructor (can be null if no destructor exists)
    Function* Destructor;

    // Responsible for the destruction of members
    PostDestructorFn PostDestructor;

    // Store all the instance functions defined within this class
    FunctionMultiMap InstanceFunctions;

    // Store all the static functions defined within this class
    FunctionMultiMap StaticFunctions;

    // Store all the instance class fields
    // Even though fields are properties, they do not exist in the property map
    FieldMap InstanceFields;

    // Store all the static class fields
    // Even though fields are properties, they do not exist in the property map
    FieldMap StaticFields;

    // Store all the instance class properties
    PropertyMap InstanceProperties;

    // Store all the static class properties
    PropertyMap StaticProperties;

    // Which events get sent by this type
    SendsEventArray SendsEvents;

    // All the properties in the order they are declared (includes both static and instance!)
    // This also includes all fields and properties (unlike the PropertyMap)
    PropertyArray AllProperties;

    // All the functions in the order they are declared (includes both static and instance!)
    FunctionArray AllFunctions;
    
    // Store the size of the object
    size_t Size;

    // Store the name of the type
    String Name;

    // In the case that this type is being generically allocated or a handle
    // is being pushed via binding/pointer, we need to know which handle manager
    // we are associated with
    HandleManagerId HandleManager;

    // The number of native virtual functions that the type has (0 if the type is non-native)
    // This is basically the exact number of entries in the C++ virtual table
    size_t RawNativeVirtualCount;

    // How many virtual functions we've actually bound
    // This is used to determine whether or not we need to build a v-table for this type upon creation
    size_t BoundNativeVirtualCount;

    // A function that converts a value into a string
    ToStringFn ToStringFunction;

    // Store all the instance functions defined within this class
    mutable FunctionMultiMap InstanceFunctionsCache;

    // Store all the static functions defined within this class
    mutable FunctionMultiMap StaticFunctionsCache;

    // Store all the instance class properties
    mutable PropertyMap InstancePropertiesCache;

    // Store all the static class properties
    mutable PropertyMap StaticPropertiesCache;

    // A bound type could be an enum, flags, or just a regular old type
    // This is important because it affects what operators can be applied to the object
    SpecialType::Enum SpecialType;

    // Any interface types that we implement
    Array<BoundType*> InterfaceTypes;

    // The base type (or null if there is no base)
    BoundType* BaseType;

    // The location in code that this class was defined
    CodeLocation Location;

    // Store the status of the current type's size information
    SizeState::Enum SizeState;

    // The handles that need to be cleaned up
    Array<size_t> Handles;

    // The delegates that need to be cleaned up
    Array<size_t> Delegates;
  };

  // Structure for delegate parameters
  class DelegateParameter
  {
  public:
    // Constructor
    DelegateParameter();

    // Implicit conversion from a type
    DelegateParameter(Type* type);

    // The name of the parameter
    String Name;

    // The type of the parameter
    Type* ParameterType;

    // The offset on the stack where this parameter exists
    // Note that the first parameter always comes after the
    // return value, and every parameter comes after that
    OperandIndex StackOffset;
  };

  // Type-defines
  typedef Array<DelegateParameter> ParameterArray;

  // The delegate type essentially stores the signature of a function (regardless of the class it belongs to)
  class DelegateType : public Type
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DelegateType, Type);

    // Constructor
    DelegateType();
    
    // Implement the type interface
    bool IsCopyComplex() const override;
    size_t GetAllocatedSize() const override;
    GuidType Hash() const override;
    String ToString() const override;
    void GenericDefaultConstruct(byte* toConstruct) const override;
    void GenericCopyConstruct(byte* to, const byte* from) const override;
    void GenericDestruct(byte* value) const override;
    int GenericHash(const byte* value) const override;
    String GenericToString(const byte* value) const override;
    bool GenericEquals(const byte* lhs, const byte* rhs) const override;
    Type* GenericGetVirtualType(const byte* value) const override;

    // Builds the just the parameter part of the string (used in overload resolving)
    void BuildParameterString(StringBuilder& builder) const;

    // Builds the entire signature string, without the name
    void BuildSignatureString(StringBuilder& builder) const;

    // Gets the entire signature string, without the name
    String GetSignatureString() const;

    // The list of parameter types this function will take
    ParameterArray Parameters;

    // The single return type of the delegate (should never be null, but rather core.VoidType)
    Type* Return;

    // The return value's stack offset
    // This should always be zero (just added for clarity)
    OperandIndex ReturnStackOffset;

    // If we're calling a delegate that uses a 'this' handle, then this
    // parameter represents the stack offset to where the handle exists
    // In our calling convention, the 'this' handle always resides after
    // the return value and all parameters
    OperandIndex ThisHandleStackOffset;

    // The total stack size, excluding the optional this handle size at the end
    // Note that this should always be the same value as 'ThisHandleStackOffset'
    // (it is provided for clarification)
    size_t TotalStackSizeExcludingThisHandle;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_LIBRARY_HPP
#define ZILCH_LIBRARY_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FUNCTION_HPP
#define ZILCH_FUNCTION_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_THREE_ADDRESS_OPCODE_HPP
#define ZILCH_THREE_ADDRESS_OPCODE_HPP

// Includes

namespace Zilch
{
  // Forward declaration
  class SyntaxTree;

  // The actual instructions that we can execute
  namespace Instruction
  {
    enum Enum
    {
      #define ZilchEnumValue(value) value,
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Note: These macros mirror those inside of Shared and VirtualMachine (for generation of instructions)

// Copy
#define ZilchCopyInstructions(Type)               \
  ZilchEnumValue(Copy##Type)

// Equality and inequality
#define ZilchEqualityInstructions(Type)           \
  ZilchEnumValue(TestInequality##Type)            \
  ZilchEnumValue(TestEquality##Type)

// Less and greater comparison
#define ZilchComparisonInstructions(Type)         \
  ZilchEnumValue(TestLessThan##Type)              \
  ZilchEnumValue(TestLessThanOrEqualTo##Type)     \
  ZilchEnumValue(TestGreaterThan##Type)           \
  ZilchEnumValue(TestGreaterThanOrEqualTo##Type)

// Generic numeric operators, copy, equality
#define ZilchNumericInstructions(Type)            \
  ZilchCopyInstructions(Type)                     \
  ZilchEqualityInstructions(Type)                 \
  /* No instruction for unary plus */             \
  ZilchEnumValue(Negate##Type)                    \
  ZilchEnumValue(Increment##Type)                 \
  ZilchEnumValue(Decrement##Type)                 \
  ZilchEnumValue(Add##Type)                       \
  ZilchEnumValue(Subtract##Type)                  \
  ZilchEnumValue(Multiply##Type)                  \
  ZilchEnumValue(Divide##Type)                    \
  ZilchEnumValue(Modulo##Type)                    \
  ZilchEnumValue(Pow##Type)                       \
  ZilchEnumValue(AssignmentAdd##Type)             \
  ZilchEnumValue(AssignmentSubtract##Type)        \
  ZilchEnumValue(AssignmentMultiply##Type)        \
  ZilchEnumValue(AssignmentDivide##Type)          \
  ZilchEnumValue(AssignmentModulo##Type)          \
  ZilchEnumValue(AssignmentPow##Type)

// Generic numeric operators, copy, equality, comparison
#define ZilchScalarInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)

// Vector operations, generic numeric operators, copy, equality
#define ZilchVectorInstructions(Type)             \
  ZilchNumericInstructions(Type)                  \
  ZilchComparisonInstructions(Type)               \
  ZilchEnumValue(ScalarMultiply##Type)            \
  ZilchEnumValue(ScalarDivide##Type)              \
  ZilchEnumValue(ScalarModulo##Type)              \
  ZilchEnumValue(ScalarPow##Type)                 \
  ZilchEnumValue(AssignmentScalarMultiply##Type)  \
  ZilchEnumValue(AssignmentScalarDivide##Type)    \
  ZilchEnumValue(AssignmentScalarModulo##Type)    \
  ZilchEnumValue(AssignmentScalarPow##Type)

// Special integral operators, generic numeric operators, copy, equality, and comparison
#define ZilchIntegralInstructions(Type)           \
  ZilchEnumValue(BitwiseNot##Type)                \
  ZilchEnumValue(BitshiftLeft##Type)              \
  ZilchEnumValue(BitshiftRight##Type)             \
  ZilchEnumValue(BitwiseOr##Type)                 \
  ZilchEnumValue(BitwiseXor##Type)                \
  ZilchEnumValue(BitwiseAnd##Type)                \
  ZilchEnumValue(AssignmentBitshiftLeft##Type)    \
  ZilchEnumValue(AssignmentBitshiftRight##Type)   \
  ZilchEnumValue(AssignmentBitwiseOr##Type)       \
  ZilchEnumValue(AssignmentBitwiseXor##Type)      \
  ZilchEnumValue(AssignmentBitwiseAnd##Type)

// Core instructions
ZilchEnumValue(InvalidInstruction)

ZilchEnumValue(InternalDebugBreakpoint)
ZilchEnumValue(ThrowException)
ZilchEnumValue(PropertyDelegate)

ZilchEnumValue(BeginTimeout)
ZilchEnumValue(EndTimeout)

ZilchEnumValue(BeginScope)
ZilchEnumValue(EndScope)

ZilchEnumValue(ToHandle)

ZilchEnumValue(BeginStringBuilder)
ZilchEnumValue(EndStringBuilder)
ZilchEnumValue(AddToStringBuilder)

ZilchEnumValue(CreateInstanceDelegate)
ZilchEnumValue(CreateStaticDelegate)

ZilchEnumValue(IfFalseRelativeGoTo)
ZilchEnumValue(IfTrueRelativeGoTo)
ZilchEnumValue(RelativeGoTo)

ZilchEnumValue(Return)
ZilchEnumValue(PrepForFunctionCall)
ZilchEnumValue(FunctionCall)

ZilchEnumValue(NewObject)
ZilchEnumValue(LocalObject)
ZilchEnumValue(DeleteObject)

// Primitive type instructions
ZilchIntegralInstructions(Integer)
ZilchScalarInstructions(Integer)
ZilchVectorInstructions(Integer2)
ZilchVectorInstructions(Integer3)
ZilchVectorInstructions(Integer4)
ZilchIntegralInstructions(Integer2)
ZilchIntegralInstructions(Integer3)
ZilchIntegralInstructions(Integer4)
ZilchScalarInstructions(Real)
ZilchVectorInstructions(Real2)
ZilchVectorInstructions(Real3)
ZilchVectorInstructions(Real4)
ZilchScalarInstructions(DoubleReal)
ZilchIntegralInstructions(DoubleInteger)
ZilchScalarInstructions(DoubleInteger)

ZilchEqualityInstructions(Boolean)
ZilchEqualityInstructions(Handle)
ZilchEqualityInstructions(Delegate)
ZilchEqualityInstructions(Any)
ZilchEqualityInstructions(Value)

ZilchCopyInstructions(Boolean)
ZilchCopyInstructions(Any)
ZilchCopyInstructions(Handle)
ZilchCopyInstructions(Delegate)
ZilchCopyInstructions(Value)

ZilchEnumValue(LogicalNotBoolean)

ZilchEnumValue(ConvertIntegerToReal)
ZilchEnumValue(ConvertIntegerToBoolean)
ZilchEnumValue(ConvertRealToInteger)
ZilchEnumValue(ConvertRealToBoolean)
ZilchEnumValue(ConvertBooleanToInteger)
ZilchEnumValue(ConvertBooleanToReal)

ZilchEnumValue(ConvertInteger2ToReal2)
ZilchEnumValue(ConvertInteger2ToBoolean2)
ZilchEnumValue(ConvertReal2ToInteger2)
ZilchEnumValue(ConvertReal2ToBoolean2)
ZilchEnumValue(ConvertBoolean2ToInteger2)
ZilchEnumValue(ConvertBoolean2ToReal2)

ZilchEnumValue(ConvertInteger3ToReal3)
ZilchEnumValue(ConvertInteger3ToBoolean3)
ZilchEnumValue(ConvertReal3ToInteger3)
ZilchEnumValue(ConvertReal3ToBoolean3)
ZilchEnumValue(ConvertBoolean3ToInteger3)
ZilchEnumValue(ConvertBoolean3ToReal3)

ZilchEnumValue(ConvertInteger4ToReal4)
ZilchEnumValue(ConvertInteger4ToBoolean4)
ZilchEnumValue(ConvertReal4ToInteger4)
ZilchEnumValue(ConvertReal4ToBoolean4)
ZilchEnumValue(ConvertBoolean4ToInteger4)
ZilchEnumValue(ConvertBoolean4ToReal4)

ZilchEnumValue(ConvertDowncast)
ZilchEnumValue(ConvertToAny)
ZilchEnumValue(ConvertFromAny)
ZilchEnumValue(AnyDynamicMemberGet)
ZilchEnumValue(AnyDynamicMemberSet)

      #undef ZilchEnumValue
      Count
    };

    // The names of the instructions (for reflection and debugging)
    extern const char* Names[];
  }

  namespace DebugOrigin
  {
    enum Enum
    {
      LocalVariable,
      Scope,
      Timeout,
      If,
      While,
      For,
      DoWhile,
      Loop,
      Break,
      Continue,
      PropertyDelegate,
      DebugBreak,
      BinaryOperation,
      UnaryOperation,
      DataMemberAccess,
      TypeCast,
      ReturnValue,
      FunctionCall,
      FunctionContext,
      DeleteObject,
      ThrowException,
      NewObject,
      LocalObject,
      FunctionMemberAccess,
      PropertyGetMemberAccess,
      PropertySetMemberAccess,
      FunctionCallConstructor,
      StringInterpolant
    };
  }

  // This is the form that the intermediate three-address opcode will take
  // An opcode is basically a single instruction with its operand (like an assembly command)
  class Opcode
  {
  public:
    // Constructor (gets rid of the annoying warning about POD constructors)
    Opcode() {}

    // The instruction to be generated
    Instruction::Enum Instruction;

#ifdef _DEBUG
    // Make the class virtual in debug mode so that we can view a list of opcodes easily
    // Having a vtable in visual studio also gives us a reflected view of the derived class
    virtual ~Opcode() { }
    
    // The origin of the instruction for debugging purposes (who created it)
    DebugOrigin::Enum DebugOrigin;
#endif
  };

  // The type of an operand
  // This generally tells us how we read/write to a particular expression
  // For example, if we're going to a property, we must call set, whereas
  // a local variable we can just write to directly on the stack
  namespace OperandType
  {
    enum Enum
    {
      NotSet,     // If the access type was not set, we know we have a bug
      Constant,   // The value is read only and cannot be assigned to
      Local,      // The value is a local variable and can be assigned to
      Field,      // The value is a member variable (field) and can be assigned to
      Property    // The value is a property and uses get/set (not really used)
    };
  }

  // An operand is used inside of an opcode,
  // for when it needs to refer to any bit of memory
  class Operand
  {
  public:
    // Default constructor
    Operand();

    // Construct from an index on the current stack
    explicit Operand(OperandIndex local);

    // Construct from a primary index, secondary index, and an access type
    Operand(OperandIndex handleConstantLocal, size_t field, OperandType::Enum type);

    // Members for the operand
    OperandType::Enum Type;
    OperandIndex HandleConstantLocal;
    size_t Field;
  };

  // Opcode for the creation of a handle from a local
  class TimeoutOpcode : public Opcode
  {
  public:
    // Even though it might be more efficient to store this in ticks
    // Technically if want this format to be savable and platform independent, it's better
    // to save it in seconds
    size_t LengthSeconds;
  };

  // Opcode for the creation of a handle from a local
  class ToHandleOpcode : public Opcode
  {
  public:
    Operand ToHandle;
    OperandLocal SaveLocal;
    BoundType* Type;
  };

  // Opcode for the creation of generic delegates (never used directly)
  class CreateDelegateOpcode : public Opcode
  {
  public:
    Function* BoundFunction;
    OperandLocal SaveLocal;
  };

  // Opcode for the creation of static delegates
  // Note that this opcode always saves to a local
  // (anyone that wants to store the value just copies it from a local)
  class CreateStaticDelegateOpcode : public CreateDelegateOpcode
  {
  public:
  };

  // Opcode for the creation of instance delegates
  // Note that this opcode always saves to a local
  // (anyone that wants to store the value just copies it from a local)
  class CreateInstanceDelegateOpcode : public CreateDelegateOpcode
  {
  public:
    Operand ThisHandle;
    bool CanBeVirtual;
  };

  // Opcode for the if-instruction
  class IfOpcode : public Opcode
  {
  public:
    Operand Condition;
    ByteCodeOffset JumpOffset;
  };

  // Opcode for the relative jump instruction
  class RelativeJumpOpcode : public Opcode
  {
  public:
    ByteCodeOffset JumpOffset;
  };

  // Opcode for the prep for function call instruction
  class PrepForFunctionCallOpcode : public Opcode
  {
  public:
    Operand Delegate;
    ByteCodeOffset JumpOffsetIfStatic;
  };

  // Creates a fresh string builder that we use for efficient concatenation of strings
  class BeginStringBuilderOpcode : public Opcode
  {
  public:
  };

  // Finishes off a string builder and outputs the string to a given stack local
  class EndStringBuilderOpcode : public Opcode
  {
  public:
    OperandLocal SaveStringHandleLocal;
  };

  // Creates a fresh string builder that we use for efficient concatenation of strings
  class AddToStringBuilderOpcode : public Opcode
  {
  public:
    const Type* TypeToConvert;
    Operand Value;
  };

  // Opcode for generic creation of an object
  // Note that this opcode always creates a handle at the given local position
  class CreateTypeOpcode : public Opcode
  {
  public:
    BoundType* CreatedType;
    OperandLocal SaveHandleLocal;
  };

  // Opcode for local creation of an object
  class CreateLocalTypeOpcode : public CreateTypeOpcode
  {
  public:
    OperandLocal StackLocal;
  };

  // Opcode for the creation of a property delegate (a reference object)
  class CreatePropertyDelegateOpcode : public CreateTypeOpcode
  {
  public:
    OperandLocal ThisHandleLocal;
    Function* Get;
    Function* Set;
  };

  // Opcode for the delete object instruction
  class DeleteObjectOpcode : public Opcode
  {
  public:
    Operand Object;
  };

  // Opcode for the throw exception instruction
  class ThrowExceptionOpcode : public Opcode
  {
  public:
    Operand Exception;
  };

  // Binary operation between two operands (this instruction has no side effects
  // and is only used with value types, and therefore the output is always local)
  class BinaryRValueOpcode : public Opcode
  {
  public:
    Operand Left;
    Operand Right;
    OperandLocal Output;
    size_t Size;
  };

  // A side effect operator (such as assignment)
  class BinaryLValueOpcode : public Opcode
  {
  public:
    Operand Output;
    Operand Right;
  };

  // Unary operation for a single operand (this instruction has no side effects
  // and is only used with value types, and therefore the output is always local)
  class UnaryRValueOpcode : public Opcode
  {
  public:
    Operand SingleOperand;
    OperandLocal Output;
  };

  // A side effect operator (such as increment)
  class UnaryLValueOpcode : public Opcode
  {
  public:
    Operand SingleOperand;
  };

  // Convert one value to another (this instruction has no side effects and
  // is only used with value types, and therefore the output is always local)
  class ConversionOpcode : public Opcode
  {
  public:
    Operand ToConvert;
    OperandLocal Output;
  };

  // Convert a type into the 'Any' type (which means copying it's value into the variant)
  class AnyConversionOpcode : public ConversionOpcode
  {
  public:
    // For ConvertToAny:
    // The type we're going to be putting into the Any
    // Note that we may actually do extra introspection to find a more derived type
    // As an example, if we attempt to store an Animal into the Any, the type stored on
    // this opcode would be the Animal, even if the underlying value was really a Cat
    // however, when we actually do the operation, we'll know if it's a handle type
    // and then we'll pull the derived type Cat out and store that on the Any

    // For ConvertFromAny:
    // We compare the type stored within the Any to this type to ensure that
    // we only pull out the correct type, otherwise we throw an exception
    Type* RelatedType;
  };

  // When we cast between a base type and derived handles
  class DowncastConversionOpcode : public ConversionOpcode
  {
  public:
    // We check to make sure the type stored in the handle is a type that is either
    // more derived or the same as this related type
    Type* ToType;
  };

  // Describes how to get a value out of a value stored by the 'any' type
  class AnyDynamicGet : public Opcode
  {
  public:
    // An index into the constant table where the member's name lives (as a string)
    OperandIndex StringConstant;
  };

  namespace CopyMode
  {
    enum Enum
    {
      Assignment,
      Initialize,
      ToParameter,
      FromReturn,
      ToReturn,
    };
  }

  // Copy a value from one place to another
  class CopyOpcode : public Opcode
  {
  public:
    Operand Source;
    Operand Destination;
    size_t Size;
    CopyMode::Enum Mode;
  };

  namespace DebugPrimitive
  {
    enum Enum
    {
      Integer,
      Boolean,
      Real,
      Real2,
      Real3,
      Real4,
      Handle,
      Delegate,
      Memory
    };
  }

  class DebugOperand
  {
  public:
    DebugOperand();
    DebugOperand(size_t offset, DebugPrimitive::Enum primitive, bool isLocal, StringParam name);
    size_t OperandOffset;
    DebugPrimitive::Enum Primitive;
    bool IsLocalOnly;
    String Name;
  };

  class DebugInstruction
  {
  public:
    DebugInstruction();

    Array<DebugOperand> ReadOperands;
    Array<DebugOperand> WriteOperands;
    Array<size_t> Sizes;
    Array<size_t> OpcodeOffsets;
    Array<size_t> FunctionPointers;
    Array<size_t> TypePointers;
    Array<size_t> Options;
    bool IsCopy;
  };

  // Generate debug info per instruction
  void GenerateDebugInstructionInfo(Array<DebugInstruction>& debugOut);
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_STRING_CONSTANTS_HPP
#define ZILCH_STRING_CONSTANTS_HPP

namespace Zilch
{
  // Constants
  const String ThisKeyword          ("this");
  const String ValueKeyword         ("value");
  const String PreConstructorName   ("[PreConstructor]");
  const String ConstructorName      ("[Constructor]");
  const String DestructorName       ("[Destructor]");
  const String ExpressionProgram    ("[ExpressionProgram]");
  const String ExpressionMain       ("[ExpressionMain]");
  const String PropertyDelegateName ("Property");
  const String StaticAttribute      ("Static");
  const String OverrideAttribute    ("Override");
  const String VirtualAttribute     ("Virtual");
  const String HiddenAttribute      ("Hidden");
  const String CodeString           ("CodeString");
  const String ContainerAdd         ("Add");
  const String UnknownOrigin        ("<Unknown>");

  // Helper functions
  String BuildGetterName(String name);
  String BuildSetterName(String name);

  // Perform string escape replacements
  String ReplaceStringEscapes(StringRange input);
  // Strip outlining quotes (directly used for string literals)
  StringRange StripStringQuotes(StringRange input);
  // Perform string escape replacements and outlining quotes (directly used for string literals)
  String ReplaceStringEscapesAndStripQuotes(StringRange input);

  // Change an identifier between lower and upper camel cases (just modifies the first letter)
  String ToLowerCamelCase(StringRange input);
  String ToUpperCamelCase(StringRange input);
}

// End header protection
#endif

namespace Zilch
{
  // Information we hand to the 
  class NativeVirtualInfo
  {
  public:
    // A special index that means that a function is non-virtual
    static const size_t NonVirtual = (size_t)-1;
    static const GuidType InvalidGuid = (GuidType)-1;

    // Constructor
    NativeVirtualInfo();

    // Validates that the given data is valid (returns false if it's invalid)
    bool Validate();

    // Is this method defined natively as a virtual function? (was it bound as a virtual function?)
    // If so, then this represents the index into the virtual table for the C++ type
    // If this function is not natively virtual, it will be set to 'NonVirtual'
    size_t Index;

    // In the case that this function is considered to be virtual
    // this will be set to the thunk function that actually invokes Zilch
    // from a native virtual call (or null if it's non-virtual)
    TypeBinding::VirtualTableFn Thunk;

    // In order to map a native function thunk back to it's Zilch function, we need
    // every bound virtual function to have it's own guid that we use in a map
    GuidType Guid;
  };

  // A base function
  class Function : public Member
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareBaseType(Function, TypeCopyMode::ReferenceType);

    // Constructor
    Function();

    // Make the function virtual for debugging purposes
    virtual ~Function();

    // DocumentedObject interface
    String GetDocumentationKey() override;

    // Hash the function
    GuidType Hash() const;

    // Get the function in string form
    String ToString() const;

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructableBuffer ComplexUserData;
    
    // Gets the code location from a given program counter location
    // If the program counter is for a native function (or non active), this will return null
    CodeLocation* GetCodeLocationFromProgramCounter(size_t programCounter);

    // Allocate an argumentless opcode
    Opcode& AllocateArgumentFreeOpcode(Instruction::Enum instruction, DebugOrigin::Enum debugOrigin, const CodeLocation& debugLocation);

    // Allocate an opcode of type T
    template <typename T>
    T& AllocateOpcode(Instruction::Enum instruction, DebugOrigin::Enum debugOrigin, const CodeLocation& debugLocation)
    {
      // Get the compacted index
      size_t compactedIndex = this->OpcodeBuilder.RelativeSize();

      // Get an element of memory with the size of the opcode
      byte* element = this->OpcodeBuilder.RequestElementOfSize(sizeof(T));

      // Get a reference to the opcode
      T& opcode = *new (element) T();

      // Make sure this opcode location is valid...
      ErrorIf(debugLocation.Origin == UnknownOrigin,
        "A code location given for an opcode was from an unknown location (opcode always gets generated from real code!)");

      // For debugging, we need to know from an opcode index where it originated from
      this->OpcodeLocationToCodeLocation.insert(compactedIndex, debugLocation);

      // We use the compacted indices for debugging
      this->OpcodeCompactedIndices.push_back(compactedIndex);

#ifdef _DEBUG
      // Add the debug info to the list
      this->OpcodeDebug.push_back(&opcode);
      opcode.DebugOrigin = debugOrigin;
#endif

      // Set the instruction
      opcode.Instruction = instruction;

      // Return the opcode to be filled in
      return opcode;
    }

    // Allocates a register and returns its index
    OperandIndex AllocateRegister(size_t size);

    // Allocates a constant and returns its index
    template <typename T>
    T& AllocateConstant(size_t constantSize, OperandIndex& indexOut)
    {
      // Allocate the spot in the constants
      size_t largeIndex;
      T& constant = this->Constants.CreateObject<T>(&largeIndex);
      
      // Get the index where we allocated the constant
      indexOut = (OperandIndex)largeIndex;

      // Return the constant to the user
      return constant;
    }

    // Get the current index into the opcode
    size_t GetCurrentOpcodeIndex();

    // Now that opcode has been compacted, set the
    // debug opcode to point at the compacted opcode
    void SetupCompactedOpcodeDebug();

  public:

    // Store the name of the function
    String Name;

    // The bound function is the function that gets called when this function is invoked
    BoundFn BoundFunction;

    // The variables associated with this function
    Array<Variable*> Variables;

    // Store the type of the function
    DelegateType* Type;

    // In order to invoke this function, a given amount of stack space is required
    // For example, all the parameters need space on the stack, and the return also needs space
    // Moreover, any local variables in a compiled function also need space on the stack
    // For a user bound function, the required space only includes the parameters and returns,
    // because any locals they will store will be on the actual C++ stack, not on ours
    size_t RequiredStackSpace;

    // A pointer the 'this' variable (or null if it is static)
    // Note that the current calling convention is that the this pointer is the
    // last parameter passed on the stack, which means this should point to the end of
    // the required stack space
    Variable* This;

    // Store the parent library from which the function originated
    // This information is generally used for linking purposes. When we call a
    // function we need the library it came from so we can re-link it back up
    Library* SourceLibrary;

    // Any information related to this function being native and virtual
    NativeVirtualInfo NativeVirtual;

    // If this function is a property getter or setter
    bool IsPropertyGetOrSet;

    // If this function is virtual or not (whether it can be overridden)
    // All overriding functions are also marked as virtual
    bool IsVirtual;

    // All the constants used in this function (only used for compiled functions)
    DestructableBuffer Constants;

    // A temporary buffer for storing opcode
    UntypedBlockArray<1024> OpcodeBuilder;

    // The opcode for this function compacted into a linear array
    Array<byte> CompactedOpcode;

    // Store a list of pointers to opcodes for debugging purposes
    Array<size_t> OpcodeCompactedIndices;

    // Maps from an opcode offset to a code location (so we can determine where we are in debugging)
    HashMap<size_t, CodeLocation> OpcodeLocationToCodeLocation;

#ifdef _DEBUG
    PodArray<Opcode*> OpcodeDebug;
#endif
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CALLBACKS_HPP
#define ZILCH_CALLBACKS_HPP

namespace Zilch
{
  // Type-defines
  typedef void (*TypeParsedCallback)(LibraryBuilder& builder, BoundType* type, const void* codeUserData, const void* userData);

  // An type parsed delegate is a structure that stores the callback and user-data
  class TypeParsedDelegate
  {
  public:
    // Constructor
    TypeParsedDelegate();

    // The associated callback / method
    TypeParsedCallback Callback;

    // The 'this' pointer to the object
    const void* UserData;
  };

  // Type-defines
  typedef BoundType* (*InstantiateTemplateCallback)
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  );

  // An type parsed delegate is a structure that stores the callback and user-data
  class InstantiateTemplateDelegate
  {
  public:
    // Constructor
    InstantiateTemplateDelegate();

    // The associated callback / method
    InstantiateTemplateCallback Callback;

    // The 'this' pointer to the object
    const void* UserData;
  };

  // Type-defines
  typedef void (*OpcodeStepCallback)(ExecutableState* state, size_t programCounter, CodeLocation* location, const void* userData);

  // A callback that occurs everytime we step over an opcode
  class OpcodeStepDelegate
  {
  public:
    // Constructor
    OpcodeStepDelegate();

    // The associated callback / method
    OpcodeStepCallback Callback;

    // The 'this' pointer to the object
    const void* UserData;
  };

  // Type-defines
  typedef void (*FunctionStepCallback)(ExecutableState* state, Function* function, size_t stackOffset, CodeLocation* location, const void* userData);

  // A callback that occurs everytime we step over an opcode
  class FunctionStepDelegate
  {
  public:
    // Constructor
    FunctionStepDelegate();

    // The associated callback / method
    FunctionStepCallback Callback;

    // The 'this' pointer to the object
    void* UserData;
  };

  // Type-defines
  typedef void (*ExceptionCallback)(ExecutableState* state, Exception* exception, const void* userData);

  // A callback that occurs everytime we step over an opcode
  class ExceptionDelegate
  {
  public:
    // Constructor
    ExceptionDelegate();

    // The associated callback / method
    ExceptionCallback Callback;

    // The 'this' pointer to the object
    const void* UserData;
  };

  namespace FatalError
  {
    enum Enum
    {
      OutOfMemory,
      StackReserveOverflow
    };
  }

  // Type-defines
  typedef void (*FatalErrorCallback)(FatalError::Enum error, const void* userData);

  // A callback that occurs everytime we step over an opcode
  class FatalErrorDelegate
  {
  public:
    // Constructor
    FatalErrorDelegate();

    // The associated callback / method
    FatalErrorCallback Callback;

    // The 'this' pointer to the object
    const void* UserData;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DOCUMENTATION_HPP
#define ZILCH_DOCUMENTATION_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_STANDARD_LIBRARIES_HPP
#define ZILCH_STANDARD_LIBRARIES_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_EVENTS_HPP
#define ZILCH_EVENTS_HPP

// Includes

namespace Zilch
{
  // Declares an event to be sent by an EventHandler
  // The typical pattern in C++ is to declare these within the Events namespace
  #define ZilchDeclareEvent(EventName, EventType) const String EventName = #EventName;

  // All events that are sent must be derived from this type
  class EventData : public IZilchObject
  {
  public:
    ZilchDeclareBaseType(EventData, TypeCopyMode::ReferenceType);

    // Mark the destructor as virtual so we can properly clean up resources
    virtual ~EventData();

    // The name that we sent the event under
    String EventName;
  };

  // The virtual base class that represents a callback
  // This class is specialized for C++ static and member and Zilch delegates (can be made for other languages too)
  class EventDelegate
  {
  public:

    // The size of the event delegate must be less than or equal to this size
    static const size_t MaxEventDelegateSize = 80;

    // Default constructor
    EventDelegate();

    // Mark the destructor as virtual so we can properly clean up resources
    virtual ~EventDelegate();

    // Invokes the delegate (with whatever representation we use under the hood)
    virtual void Invoke(EventData* event) = 0;

    // To support safe iteration through events (and modification of event handlers while sending)
    // All event delegates need to be copyable
    // This is achieved by knowing the size of the derived event delegate, and implementing an in place clone
    // Use the macro 'ZilchDefineEventDelegateHelpers' to automatically implement these virtual methods

    // Copy the event delegate in place
    virtual void CopyInto(byte* destination) = 0;

    // Get a unique id or pointer that lets us identify the owner of the delegate (who the delegate is bound to)
    virtual void* GetThisPointerOrUniqueId() = 0;

    // The type of event we accept
    // Note: We'll also accept more derived versions of this type
    BoundType* Type;

    // Every delegate is connected to the list of dispatched events per message type (MessageDelegateList)
    Link<EventDelegate> OutgoingLink;

    // Delegates are also connected to the message handler that will receive them (MessageHandler)
    Link<EventDelegate> IncomingLink;
  };

  // When we create new event delegates, we put this at the top to automatically implement 'GetSize' and 'CopyInto'
  // Our implementation of 'CopyInto' just invokes the copy constructor via placement new
  #define ZilchDefineEventDelegateHelpers(SelfType)                                     \
    void CopyInto(byte* destination) override                                           \
    {                                                                                   \
      ZilchStaticAssert(sizeof(SelfType) <= MaxEventDelegateSize,                       \
        "The size of the event delegate must not exceed MaxEventDelegateSize",          \
        EventDelegateExceedsMaxEventDelegateSize);                                      \
      SelfType* copy = new (destination) SelfType(*this);                               \
      copy->OutgoingLink.Next = nullptr;                                                \
      copy->IncomingLink.Next = nullptr;                                                \
    }

  // We use dual intrusively linked lists with the delegate to ensure that
  // events get destroyed when either the sender or reciever dies
  typedef InList<EventDelegate, &EventDelegate::OutgoingLink> OutgoingList;
  typedef InList<EventDelegate, &EventDelegate::IncomingLink> IncomingList;

  // Stores all outbound connections for a particular event name
  // As an optimiziation, this list can be pulled out and stored next to an EventHandler (but will be destroyed along with the handler)
  class EventDelegateList
  {
  public:

    // The destructor deletes all outgoing connections
    ~EventDelegateList();

    // Send an event to all outgoing delegates
    void Send(EventData* event);
    
    //******** Internal ********//

    // Store the name of the events associated with this list
    String EventName;

    // The intrusive list of all outgoing connections
    // A connection can be marked as invalid, in which it will be erased
    OutgoingList Outgoing;
  };

  // Stores all outgoing connections
  class EventHandler
  {
  public:

    // When we get destructed we mark all outgoing and incoming events as destroyed
    ~EventHandler();

    // Connects a sender and receiver event handler for a particular event, given an event connection
    static void Connect(EventHandler* sender, StringParam eventName, EventDelegate* delegate, EventHandler* receiver);

    // Disconnect an event that we previously connected to
    // Disconnecting can also be done by storing the event delegate and deleting it
    // Returns the number of connections that were disconnected
    // Note: There can be more than one disconnected, but only if someone connected to the same event twice on the same object
    static size_t Disconnect(EventHandler* sender, EventHandler* receiver, StringParam eventName, void* thisPointerOrUniqueId);

    // Get or create a delegate list for the particular event name
    // As an optimiziation, this list can be pulled out and stored next to an EventHandler (but will be destroyed along with the handler)
    EventDelegateList* GetOrCreateOutgoingDelegateList(StringParam eventName);

    // Invokes the event handler for anyone listening to this event name on our object
    void Send(StringParam eventName, EventData* event);

    //******** Internal ********//

    // Whenever we send an event, we look if anyone will respond by looking in this map
    // The delegate list stores an intrusive list of all event delegates that need to recieve the event
    HashMap<String, EventDelegateList*> OutgoingPerEventName;

    // We keep track of all delegates that would send events to us
    // If we get destroyed, we'll mark all these delegates as destroyed
    IncomingList Incoming;

    // A global event handler (used for registering static functions and such)
    static EventHandler Global;
  };

  // When we want to connect up member functions, we use this template
  template <typename ClassType, typename EventType>
  class MemberFunctionEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(MemberFunctionEventDelegate);

    // This is the signature of method that we accept
    typedef void (ClassType::*FunctionType)(EventType* event);

    // We store the member function pointer and the 'this' pointer for the class
    FunctionType FunctionPointer;
    ClassType* ThisPointer;

    // Constuct a member function delegate from a class instance and member function pointer
    MemberFunctionEventDelegate(FunctionType function, ClassType* instance) :
      FunctionPointer(function),
      ThisPointer(instance)
    {
      this->Type = ZilchTypeId(EventType);
    }

    // Invoking the delegate just invokes the member function pointer (casts the event type too)
    void Invoke(EventData* event) override
    {
      // Technically the event type cast is unsafe, however we validate that it is safe using our reflection
      (this->ThisPointer->*this->FunctionPointer)((EventType*)event);
    }

    // We can just directly return the this pointer for the member function connection
    void* GetThisPointerOrUniqueId() override
    {
      return this->ThisPointer;
    }
  };

  // A special template helper that can infer template arguments to make member function connecting easier
  template <typename ClassType, typename EventType>
  void EventConnect(EventHandler* sender, StringParam eventName, void (ClassType::*function)(EventType*), ClassType* receiver)
  {
    // Create a member function delegate
    typedef MemberFunctionEventDelegate<ClassType, EventType> EventDelegateType;
    EventDelegateType* eventDelegate = new EventDelegateType(function, receiver);
    
    // Connect the event handler up to this newly created member delegate
    EventHandler::Connect(sender, eventName, eventDelegate, receiver);
  }

  // When we want to connect up static functions, we use this template
  template <typename EventType>
  class StaticFunctionEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(StaticFunctionEventDelegate);

    // This is the signature of function that we accept
    typedef void (*FunctionType)(EventType* event);

    // We store the static function pointer to call
    FunctionType FunctionPointer;

    // Constuct a member function delegate from a class instance and member function pointer
    StaticFunctionEventDelegate(FunctionType function) :
      FunctionPointer(function)
    {
      this->Type = ZilchTypeId(EventType);
    }

    // Invoking the delegate just invokes the static function pointer (casts the event type too)
    void Invoke(EventData* event) override
    {
      // Technically the event type cast is unsafe, however we validate that it is safe using our reflection
      this->FunctionPointer((EventType*)event);
    }
    
    // Since we have no real 'this' pointer, we're just going to return the function's address
    void* GetThisPointerOrUniqueId() override
    {
      return this->FunctionPointer;
    }
  };

  // A special template helper that can infer template arguments to make static function connecting easier
  template <typename EventType>
  void EventConnect(EventHandler* sender, StringParam eventName, void (*function)(EventType*))
  {
    // Create a member function delegate
    typedef StaticFunctionEventDelegate<EventType> EventDelegateType;
    EventDelegateType* eventDelegate = new EventDelegateType(function);
    
    // Connect the event handler up to this newly created static function delegate
    // We use the global event handler here (there is no receiver...)
    EventHandler::Connect(sender, eventName, eventDelegate, &EventHandler::Global);
  }

  // When we want to connect up static functions with userdata, we use this template
  template <typename EventType>
  class StaticFunctionUserDataEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(StaticFunctionUserDataEventDelegate);

    // This is the signature of function that we accept
    typedef void (*FunctionType)(EventType* event, void* userData);

    // We store the static function pointer to call and the user-data
    FunctionType FunctionPointer;
    void* UserData;

    // Constuct a member function delegate from a class instance and member function pointer
    StaticFunctionUserDataEventDelegate(FunctionType function, void* userData) :
      FunctionPointer(function),
      UserData(userData)
    {
      this->Type = ZilchTypeId(EventType);
    }

    // Invoking the delegate just invokes the static function pointer (casts the event type too)
    void Invoke(EventData* event) override
    {
      // Technically the event type cast is unsafe, however we validate that it is safe using our reflection
      this->FunctionPointer((EventType*)event, this->UserData);
    }
    
    // Return whatever the user gave us as user-data
    void* GetThisPointerOrUniqueId() override
    {
      return this->UserData;
    }
  };

  // A special template helper that can infer template arguments to make static function connecting easier (with user-data)
  template <typename EventType>
  void EventConnect(EventHandler* sender, StringParam eventName, void (*function)(EventType*), void* userData)
  {
    // Create a member function delegate
    typedef StaticFunctionUserDataEventDelegate<EventType> EventDelegateType;
    EventDelegateType* eventDelegate = new EventDelegateType(function, userData);
    
    // Connect the event handler up to this newly created static function delegate
    // We use the global event handler here (there is no receiver...)
    EventHandler::Connect(sender, eventName, eventDelegate, &EventHandler::Global);
  }

  // A simple event delegate that just forwards events to another EventHandler
  class ForwardingEventDelegate : public EventDelegate
  {
  public:
    ZilchDefineEventDelegateHelpers(ForwardingEventDelegate);

    // The event handler we forward received events to
    // Note: This is safe to store as a pointer because we only allow forwarding to
    // whoever this event delegate is connected to (OutgoingLink)
    // If that object gets deleted, this delegate will automatically be deleted
    EventHandler* ForwardTo;

    // Constuct a member function delegate from a class instance and member function pointer
    ForwardingEventDelegate(EventHandler* forwardTo);

    // EventDelegate interface
    void Invoke(EventData* event);
    void* GetThisPointerOrUniqueId();
  };

  // Automatically forwards all events of a type of event name to another receiver
  void EventForward(EventHandler* sender, StringParam eventName, EventHandler* receiver);
}

// End header protection
#endif

namespace Zilch
{
  namespace Events
  {
    // Sent when anyone prints to the console
    ZilchDeclareEvent(ConsoleWrite, ConsoleEvent);

    // Sent when anyone attempts to read from the console
    ZilchDeclareEvent(ConsoleRead, ConsoleEvent);
  }

  // When the user prints data using the console, or attempts to read
  // this will be the event type that we send out (for callbacks)
  class ConsoleEvent : public EventData
  {
  public:
    // The state invoking the console event
    ExecutableState* State;

    // The text of the console's WriteLine (to be printed)
    // If this is a read event, it is up to the user to set this text
    String Text;
  };

  // The default write text callback that prints to stdio
  void DefaultWriteText(ConsoleEvent* event);

  // The default read text callback that reads text from stdin
  void DefaultReadText(ConsoleEvent* event);

  // The type that we use to bind a console to the language
  class Console
  {
  public:
    ZilchDeclareBaseType(Console, TypeCopyMode::ReferenceType);

    // Write to the console (not bound to Zilch)
    static void Write(AnyParam value0);
    static void Write(AnyParam value0, AnyParam value1);
    static void Write(AnyParam value0, AnyParam value1, AnyParam value2);
    static void Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3);
    static void Write(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4);
    static void Write(StringParam value);
    static void Write(StringRange value);
    static void Write(cstr value);
    static void Write(char value);
    static void Write(Boolean value);
    static void Write(Boolean2Param value);
    static void Write(Boolean3Param value);
    static void Write(Boolean4Param value);
    static void Write(Integer value);
    static void Write(Integer2Param value);
    static void Write(Integer3Param value);
    static void Write(Integer4Param value);
    static void Write(Real value);
    static void Write(Real2Param value);
    static void Write(Real3Param value);
    static void Write(Real4Param value);
    static void Write(DoubleInteger value);
    static void Write(DoubleReal value);
    static void Write(QuaternionParam value);
    static void WriteLine();
    static void WriteLine(AnyParam value0);
    static void WriteLine(AnyParam value0, AnyParam value1);
    static void WriteLine(AnyParam value0, AnyParam value1, AnyParam value2);
    static void WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3);
    static void WriteLine(AnyParam value0, AnyParam value1, AnyParam value2, AnyParam value3, AnyParam value4);
    static void WriteLine(StringParam value);
    static void WriteLine(StringRange value);
    static void WriteLine(cstr value);
    static void WriteLine(char value);
    static void WriteLine(Boolean value);
    static void WriteLine(Boolean2Param value);
    static void WriteLine(Boolean3Param value);
    static void WriteLine(Boolean4Param value);
    static void WriteLine(Integer value);
    static void WriteLine(Integer2Param value);
    static void WriteLine(Integer3Param value);
    static void WriteLine(Integer4Param value);
    static void WriteLine(Real value);
    static void WriteLine(Real2Param value);
    static void WriteLine(Real3Param value);
    static void WriteLine(Real4Param value);
    static void WriteLine(DoubleInteger value);
    static void WriteLine(DoubleReal value);
    static void WriteLine(QuaternionParam value);

    // Write out an object (1 level deep - only properties)
    static void DumpValue(AnyParam value);

    // Write out an object to a certain number of levels deep (used for debugging)
    static void DumpValue(AnyParam value, Integer howDeep);

    // Read from the console
    static String ReadString();
    static Integer ReadInteger();
    static Boolean ReadBoolean();
    static Real ReadReal();

  private:

    // Write out data (sends the write event)
    static void WriteData(StringParam text);

    // Read text from the console (sends the read event)
    // If no users handle this then it will return an empty string
    static String ReadData();

    // Helper for writing out objects
    static void DumpValue(StringBuilderExtended& builder, Type* type, const byte* value, Integer howDeep, Integer currentDepth);

  public:

    // Responsible for the console sending and receiveing events (how we hook up callbacks!)
    static EventHandler Events;
  };

  // String builder is a convenient way to concatenate strings
  class StringBuilderExtended : public StringBuilder
  {
  public:
    ZilchDeclareBaseType(StringBuilderExtended, TypeCopyMode::ReferenceType);

    // Write to the string builder
    void Write(AnyParam value);
    void Write(StringParam value);
    void Write(StringRange value);
    void Write(char value);
    void Write(cstr value);
    void Write(Boolean value);
    void Write(Boolean2Param value);
    void Write(Boolean3Param value);
    void Write(Boolean4Param value);
    void Write(Integer value);
    void Write(Integer2Param value);
    void Write(Integer3Param value);
    void Write(Integer4Param value);
    void Write(Real value);
    void Write(Real2Param value);
    void Write(Real3Param value);
    void Write(Real4Param value);
    void Write(DoubleInteger value);
    void Write(DoubleReal value);
    void Write(QuaternionParam value);
    void WriteLine();
    void WriteLine(AnyParam value);
    void WriteLine(StringParam value);
    void WriteLine(StringRange value);
    void WriteLine(cstr value);
    void WriteLine(char value);
    void WriteLine(Boolean value);
    void WriteLine(Boolean2Param value);
    void WriteLine(Boolean3Param value);
    void WriteLine(Boolean4Param value);
    void WriteLine(Integer value);
    void WriteLine(Integer2Param value);
    void WriteLine(Integer3Param value);
    void WriteLine(Integer4Param value);
    void WriteLine(Real value);
    void WriteLine(Real2Param value);
    void WriteLine(Real3Param value);
    void WriteLine(Real4Param value);
    void WriteLine(DoubleInteger value);
    void WriteLine(DoubleReal value);
    void WriteLine(QuaternionParam value);

    // Convert the internally stored buffers into a string
    String ToString() const;
  };
}

// End header protection
#endif

namespace Zilch
{
  // Represents a parameter in a function
  class DocumentationParameter
  {
  public:

    // The name of the parameter (or an empty string if it's nothing)
    String Name;

    // The type of the parameter
    String Type;
  };

  // Documentation that describes an individual function
  class DocumentationFunction
  {
  public:

    // Destructor
    ~DocumentationFunction();

    // The name of the function
    String Name;

    // The parameter names and types
    Array<DocumentationParameter*> Parameters;

    // The return type (or empty if it's void / returns nothing)
    String ReturnType;

    // The entire signature (no name, but includes parameters and return type)
    String Signature;

    // A basic description for the function (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;

    // The exceptions that this function can throw
    StringArray ExceptionsThrown;
  };

  // Documentation that describes an individual property
  class DocumentationProperty
  {
  public:

    // Constructor
    DocumentationProperty();

    // Destructor
    ~DocumentationProperty();

    // The name of the property
    String Name;

    // The type of the property
    String Type;

    // A basic description for the property (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;

    // Tells us if this property can be set
    bool IsSettable;

    // Tells us if this property can be retrieved
    bool IsGettable;

    // Tells us if this property is a data member
    // Generally data members should be displayed along with properties
    bool IsField;
  };

  // Documentation that describes an individual type
  class DocumentationType
  {
  public:

    // Destructor
    ~DocumentationType();

    // Constructor
    DocumentationType();

    // The name of the type
    String Name;

    // The name of the base type, or empty if there is none
    String BaseName;

    // Is this a value type or a reference type?
    bool IsValueType;

    // A basic description for the type (typically parsed from comments)
    String Description;
    
    // Any samples or remarks about the usage of a particular object or member
    StringArray Remarks;
    
    // The constructors that belong to this type
    Array<DocumentationFunction*> Constructors;
    
    // The instance methods that belong to this type (sorted by name, owned)
    Array<DocumentationFunction*> InstanceMethods;
    
    // The static methods that belong to this type (sorted by name, owned)
    Array<DocumentationFunction*> StaticMethods;
    
    // The instance methods that belong to this type (sorted by name, includes data members, owned)
    Array<DocumentationProperty*> InstanceProperties;
    
    // The static methods that belong to this type (sorted by name, includes data members, owned)
    Array<DocumentationProperty*> StaticProperties;
  };

  // Represents an entire library built by our documentation engine
  class DocumentationLibrary
  {
  public:

    // Destructor
    ~DocumentationLibrary();
    
    // The name of the library
    String Name;

    // All the types defined within the library
    HashMap<String, DocumentationType*> TypesByName;

    // The same array of types, sorted by name
    Array<DocumentationType*> TypesSorted;
  };

  // Represents an entire library built by our documentation engine
  class DocumentationModule
  {
  public:

    // Destructor
    ~DocumentationModule();

    // All the libraries we're dependent upon
    Array<DocumentationLibrary*> Libraries;
  };

  class RstTable
  {
  public:
    // Constructor
    RstTable();

    // Resize the table to have the number of columns and rows
    void Resize(size_t columns, size_t rows);

    // Set a cell by column and row
    void SetCell(StringParam value, size_t column, size_t row);

    // Get a cell by column and row
    String GetCell(size_t column, size_t row);

    // All the cells in the table (indexed as a 2d array)
    Array<String> Cells;

    // The number of columns and rows of this table
    // Cells must be Rows * Columns in size
    size_t Columns;
    size_t Rows;

    // How many of the first rows are header rows (does not add to the total number)
    // Must be less than or equal to Rows
    size_t HeaderRows;
  };

  namespace RstHeadingType
  {
    enum Enum
    {
      Part,
      Chapter,
      Section,
      SubSection,
      SubSubSection,
      Paragraph
    };
  }

  class RstBuilder : public StringBuilderExtended
  {
  public:
    // We don't want to hide the base class members, but rather add overloads
    using StringBuilderExtended::WriteLine;

    // Write out a table with columns and rows
    void WriteLine(RstTable& table);

    // Write out a heading (typically bold and larger)
    void WriteLineHeading(StringRange heading, RstHeadingType::Enum type);
  };

  namespace JsonValueType
  {
    enum Enum
    {
      Invalid,
      String,
      Integer,
      Real,
      Object,
      Array,
      True,
      False,
      Null
    };
  }

  class JsonValue;

  // A member is basically just a key-value pair, where
  // the key is always a string and the value is generic
  class JsonMember
  {
  public:
    // Constructor
    JsonMember();

    // Destructor (cleans up value)
    ~JsonMember();

    // Effectively the name of the member
    String Key;

    // The value of our member
    JsonValue* Value;
  };

  namespace JsonErrorMode
  {
    enum Enum
    {
      DefaultValue,
      ReportError
    };
  }

  // A 'value' in Json can be a string, number, object, array, true/false, or null
  class JsonValue
  {
  public:

    // Constructor
    JsonValue();

    // Converts the value and it's children into Json
    String ToString();

    // Get a member (reports errors if this is not an object, or if the member doesn't exist)
    JsonValue* GetMember(StringParam name, JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Index a value of an array (reports errors if this is not an array, or if the index is out of bounds)
    JsonValue* IndexValue(size_t index, JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Helper functions for pulling native types out of a json value
    bool      AsBool    (bool         defaultValue = false,     JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    String    AsString  (StringParam  defaultValue = String(),  JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    double    AsDouble  (double       defaultValue = 0.0,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    float     AsFloat   (float        defaultValue = 0.0f,      JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    long long AsLongLong(long long    defaultValue = 0LL,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    int       AsInteger (int          defaultValue = 0,         JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Helper functions for pulling out members of a json object
    // Only valid when the 'Type' is set to 'Object'
    bool      MemberAsBool    (StringParam name, bool         defaultValue = false,     JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    String    MemberAsString  (StringParam name, StringParam  defaultValue = String(),  JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    double    MemberAsDouble  (StringParam name, double       defaultValue = 0.0,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    float     MemberAsFloat   (StringParam name, float        defaultValue = 0.0f,      JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    long long MemberAsLongLong(StringParam name, long long    defaultValue = 0LL,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    int       MemberAsInteger (StringParam name, int          defaultValue = 0,         JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Helper functions for indexing values of a json array
    // Only valid when the 'Type' is set to 'Array'
    bool      IndexAsBool     (size_t index, bool         defaultValue = false,     JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    String    IndexAsString   (size_t index, StringParam  defaultValue = String(),  JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    double    IndexAsDouble   (size_t index, double       defaultValue = 0.0,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    float     IndexAsFloat    (size_t index, float        defaultValue = 0.0f,      JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    long long IndexAsLongLong (size_t index, long long    defaultValue = 0LL,       JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);
    int       IndexAsInteger  (size_t index, int          defaultValue = 0,         JsonErrorMode::Enum errorMode = JsonErrorMode::ReportError);

    // Specifies what type of value this is
    JsonValueType::Enum Type;

    // Only valid when the 'Type' is set to 'String'
    String StringValue;

    // Only valid when the 'Type' is set to 'Real'
    double RealValue;

    // Only valid when the 'Type' is set to 'Integer'
    long long IntegralValue;

    // Only valid when the 'Type' is set to 'Object'
    OwnedArray<JsonMember*> OrderedMembers;

    // A map of names to the values
    // Only valid when the 'Type' is set to 'Object'
    HashMap<String, JsonValue*> Members;

    // Only valid when the 'Type' is set to 'Array'
    OwnedArray<JsonValue*> ArrayElements;
  };

  class JsonReader
  {
  public:

    // Reads a json text file into a tree format
    static JsonValue* ReadIntoTreeFromString(CompilationErrors& errors, StringParam json, StringParam origin, void* userData);
    
    // Reads json text into a tree format
    static JsonValue* ReadIntoTreeFromFile(CompilationErrors& errors, StringParam fileName, void* userData);
  };

  namespace JsonType
  {
    enum Enum
    {
      ArraySingleLine,
      ArrayMultiLine,
      Object
    };
  }

  class JsonBuilder
  {
  public:

    // Constructor
    JsonBuilder();

    // Get the resulting Json (only legal if it's completely closed)
    String ToString() const;

    // Writes the json tree out
    void WriteTree(JsonValue* value);

    // Start a key/member inside of an object (illegal to do at the root or inside an array)
    void Key(StringRange name);

    // Write a value to Json (only legal as a member or in an array)
    void Value(int value);
    void Value(unsigned int value);
    void Value(long value);
    void Value(unsigned long value);
    void Value(long long value);
    void Value(unsigned long long value);
    void Value(double value);
    void Value(StringRange value);
    void Value(cstr value);
    void Value(bool value);
    void Null();

    // The string provided is written exactly to the Json object as a value
    // Only legal as a member or in an array
    void RawValue(StringParam value);

    // Start either a Json object or array
    // When inside an object, it's only legal to call this after creating a 'Member'
    // When inside an array, it is always legal to call this
    void Begin(JsonType::Enum type);

    // End a Json object or array
    void End();

  private:

    // Checks if we can write a value (includes object or array)
    void VerifyCanWriteValue();

    // Returns an empty string or a string containing a
    // comma if it's needed to add a value/member for the current object or array
    void AttemptComma();

    void AttemptNewline();

  public:

    // In compact mode, we only output necessary spaces
    bool IsCompactMode;

  private:

    // Lets us know what's the last operation of the Json stack was
    Array<JsonType::Enum> Stack;

    // Lets us know if we started a member
    // This is only used when a Json object was the last thing on the stack
    bool IsMember;

    // Whether or not we wrote to the current object/array
    bool IsWrittenTo;

    // Allow us to efficiently build the json file
    StringBuilderExtended Builder;
  };
}

// End header protection
#endif

namespace Zilch
{
  // All the information we need to instantiate a new template
  class InstantiateTemplateInfo
  {
  public:
    // Get the fully qualified name of the template
    String GetFullName(const Array<Type*>& templateArguments);

    // The callback we use to instantiate the template (user provided)
    InstantiateTemplateDelegate Delegate;

    // The names of the template arguments
    StringArray TemplateArgumentNames;

    // The actual base name of the template
    String BaseName;
  };

  // A library stores all the types and 
  class Library
  {
  public:

    // Friends
    friend class LibraryBuilder;
    
    // Destructor
    ~Library();

    // The name of the library, used for debug purposes
    String Name;

    // The source code this library was built from (generally the result of a Project)
    // If this library is native / build via generation, this array will be empty
    // If a type is compiled from script, it should point back at the script it resulted from
    // Code locations also reference the index into this array
    Array<CodeEntry> Entries;

    // Store all the types compiled in this library
    BoundTypeMap BoundTypes;

    // Any types that we own that are non named types (delegate, qualifieds, etc)
    Array<Type*> OwnedTypes;

    // Store the array of bound functions
    FunctionArray OwnedFunctions;

    // Store any variable created by the functions
    Array<Variable*> OwnedVariables;

    // Store any properties created by the types (includes members)
    Array<Property*> OwnedProperties;

    // This map controls how we extend types with functions without using inheritance
    // We map a type guid to the functions we extend it with
    FunctionExtensionMap StaticExtensionFunctions;
    FunctionExtensionMap InstanceExtensionFunctions;

    // This map controls how we extend types with properties without using inheritance
    // We map a type guid to the properties we extend it with
    PropertyExtensionMap StaticExtensionProperties;
    PropertyExtensionMap InstanceExtensionProperties;

    // All the string literals we contain (effectively the string pool)
    StringArray StringLiterals;

    // Callbacks that we try and call to handle template
    HashMap<String, InstantiateTemplateInfo> TemplateHandlers;

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructableBuffer ComplexUserData;

  private:

    // Constructor
    Library();

    // Not copyable
    ZilchNoCopy(Library);

    // An intrusive reference count for memory handling
    ZilchRefLink(Library);
  };

  // Any options we use while building a function
  namespace FunctionOptions
  {
    enum Enum
    {
      // No options
      None = 0,

      // A member that is not part of an instance,
      // but rather part of the type itself
      Static = 1,

      // A function that is virtual can be overridden by
      // another function in a more derived class
      Virtual = 2
    };
    typedef unsigned Flags;
  }

  // Any options we use while building a member
  namespace MemberOptions
  {
    enum Enum
    {
      // No options
      None = 0,

      // A member that is not part of an instance,
      // but rather part of the type itself
      Static = 1,
    };
    typedef unsigned Flags;
  }

  // A hashing policy for the delegate type set
  class DelegateTypePolicy
  {
  public:
    // Hashing operator
    GuidType operator() (DelegateType* type);

    // Comparison operator
    bool equal(DelegateType* a, DelegateType* b);
  };

  // Make a hash set using the above policy
  typedef HashSet<DelegateType*, DelegateTypePolicy>  DelegateTypeSet;
  typedef DelegateTypeSet::range                      DelegateTypeRange;

  // Specifies how we want to check / verify token names in the library builder
  namespace TokenCheck
  {
    enum Enum
    {
      None = 0,
      IsUpper = 1,
      Asserts = 2
    };

    typedef unsigned Flags;
  }

  // An error code for how we instantiate templates
  namespace TemplateResult
  {
    enum Enum
    {
      // We succeeded at instantiating the template
      Success,

      // A template instantiator by the same name could not be found
      FailedNameNotFound,

      // The template instantiator provided by the user failed to instantiate a template
      FailedInstantiatorDidNotReturnType,

      // We failed to instantiate the template because we provided the wrong number of arguments
      FailedInvalidArgumentCount
    };
  }

  // What we return from instantiating a template
  class InstantiatedTemplate
  {
  public:
    // Constructor
    InstantiatedTemplate();

    // The type of the template (or null if it failed)
    BoundType* Type;

    // The number of arguments expected for this template
    size_t ExpectedArguments;

    // The result (or an error code for why we couldn't instantiate the template)
    TemplateResult::Enum Result;
  };

  // Helper functions for generating parameter arrays (used in library building)
  ParameterArray OneParameter(Type* type);
  ParameterArray OneParameter(Type* type, StringParam name);
  ParameterArray TwoParameters(Type* type);
  ParameterArray TwoParameters(Type* type1, Type* type2);
  ParameterArray TwoParameters(Type* type, StringParam name1, StringParam name2);
  ParameterArray TwoParameters(Type* type1, StringParam name1, Type* type2, StringParam name2);
  ParameterArray ThreeParameters(Type* type);
  ParameterArray ThreeParameters(Type* type1, Type* type2, Type* type3);
  ParameterArray ThreeParameters(Type* type, StringParam name1, StringParam name2, StringParam name3);
  ParameterArray ThreeParameters(Type* type1, StringParam name1, Type* type2, StringParam name2, Type* type3, StringParam name3);

  class LibraryBuilder
  {
  public:
    // Friends
    friend class Core;
    friend class CodeGenerator;
    friend class Syntaxer;
    friend class Module;

    // Constructor that takes the name of the library we want to build
    LibraryBuilder(String name);

    // Get the name fo the library we are building
    String GetName();

    // Set the original source code entries that this library is being built from
    void SetEntries(const Array<CodeEntry>& entries);

    // Add a function to the library and bound type (pass nullptr for thisType if the function is static)
    Function* AddBoundFunction
    (
      BoundType* owner,
      String name,
      BoundFn function,
      const ParameterArray& parameters,
      Type* returnType,
      FunctionOptions::Flags options,
      NativeVirtualInfo nativeVirtual = NativeVirtualInfo()
    );

    // Add a function to the library as an extension of another type (pass nullptr for thisType if the function is static)
    Function* AddExtensionFunction
    (
      BoundType* forType,
      String name,
      BoundFn function,
      const ParameterArray& parameters,
      Type* returnType,
      FunctionOptions::Flags options
    );
    
    // Add a pre-constructor to the library and bound type
    Function* AddBoundPreConstructor(BoundType* owner, BoundFn function);
    
    // Add a constructor to the library and bound type
    Function* AddBoundConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters);
    
    // Add a default constructor to the library and bound type
    Function* AddBoundDefaultConstructor(BoundType* owner, BoundFn function);
    
    // Add a destructor to the library and bound type
    Function* AddBoundDestructor(BoundType* owner, BoundFn function);

    // Add a member to the library and bound type
    Field* AddBoundField(BoundType* owner, String name, Type* type, size_t offset, MemberOptions::Flags options);

    // Add a property to the library and bound type
    Property* AddBoundProperty(BoundType* owner, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options);

    // Add a property to the library as an extension of another type
    Property* AddExtensionProperty(BoundType* forType, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options);

    // Attempts to instantiate a template (or returns a failure error code)
    InstantiatedTemplate InstantiateTemplate(StringParam baseName, const Array<Type*>& arguments, const LibraryArray& fromLibraries);

    // Add a function to the library (pass nullptr for thisType if the function is static)
    Function* CreateRawFunction
    (
      BoundType* owner,
      String name,
      BoundFn function,
      const ParameterArray& parameters,
      Type* returnType,
      FunctionOptions::Flags options,
      NativeVirtualInfo nativeVirtual = NativeVirtualInfo()
    );
    
    // Add a pre-constructor to the library
    Function* CreateRawPreConstructor(BoundType* owner, BoundFn function);
    
    // Add a constructor to the library
    Function* CreateRawConstructor(BoundType* owner, BoundFn function, const ParameterArray& parameters);
    
    // Add a default constructor to the library
    Function* CreateRawDefaultConstructor(BoundType* owner, BoundFn function);

    // Add a destructor to the library
    Function* CreateRawDestructor(BoundType* owner, BoundFn function);

    // Add a property to the library
    Property* CreateRawProperty(BoundType* owner, String name, Type* type, BoundFn set, BoundFn get, MemberOptions::Flags options);

    // Add a field to the library
    Field* CreateRawField(BoundType* owner, String name, Type* type, size_t offset, MemberOptions::Flags options);

    // Add a variable to the library
    Variable* CreateRawVariable(Function* function, String name);

    // Add a string constant to the library (typically only done by the compiler)
    const String& AddStringLiteral(cstr text);
    
    // Add a string constant to the library (typically only done by the compiler)
    const String& AddStringLiteral(const String& text);
    
    // Add a string constant to the library (typically only done by the compiler)
    const String& AddStringLiteral(StringRange text);

    
    // Get the type that reprsents one more level of indirection to the given type
    Type* ToHandleType(BoundType* type);

    // Get the type that reprsents one more level of indirection to the given type
    IndirectionType* ReferenceOf(BoundType* type);

    // Dereference the given type and get the resulting type from that
    BoundType* Dereference(IndirectionType* type);

    // Given a created delegate type, add or merge it into the delegate set (and return the proper type that we should be using...)
    DelegateType* GetDelegateType(const ParameterArray& parameters, Type* returnType);

    // Adds a callback to the library that will be called any time a user attempts to instantiate a template type with this name
    void AddTemplateInstantiator(StringParam baseName, InstantiateTemplateCallback callback, StringArray& templateArgumentNames, void* userData);

    // Adds a bound type to the library builder
    BoundType* AddBoundType(String name, TypeCopyMode::Enum copyMode, size_t size, size_t nativeVirtualCount = 0);

    // Adds a bound type to the library
    void AddRawBoundType(BoundType* type);

    // Find a named type by name, or return null
    BoundType* FindBoundType(String name);

    // Create a library from the builder
    LibraryRef CreateLibrary();

    // Checks to see if an upper-identifier is valid
    static bool CheckUpperIdentifier(String identifier);

    // Checks to see if a lower-identifier is valid
    static bool CheckLowerIdentifier(String identifier);

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructableBuffer ComplexUserData;

  private:

    // A constant we can pass in as a get/set that signifies to not actually generate the get/set Function object
    static const BoundFn DoNotGenerate;

    // A constant that will generate a get/set Function object (can later be replaced)
    static const BoundFn NoOperation;

    // Checks to see if a identifier is valid
    static bool CheckIdentifier(StringParam identifier, TokenCheck::Flags flags);

    // Generates the property getter/setter for fields
    // Must be called AFTER all sizes have been computed
    // Can be called multiple times (only checks fields with no get/set)
    void GenerateGetSetFields();

  private:

    // The library builder always creates a single library
    LibraryRef BuiltLibrary;

    // Store all the types compiled in this library
    BoundTypeMap BoundTypes;

    // A map that allows us to cut down on the number of qualified types we allocate
    TypeToIndirect IndirectTypes;

    // Store a set of all the delegate types (note that delegate types are shared, eg the same definition results in the same type)
    DelegateTypeSet DelegateTypes;

    // Not copyable
    ZilchNoCopy(LibraryBuilder);
  };

  // A module contains many libraries
  class Module : public LibraryArray
  {
  public:

    // Constructor
    Module();

    // Finds a type in any of the libraries by name
    BoundType* FindType(StringParam name);

    // Link libraries together to create a single executable application
    ExecutableState* Link() const;

    // Builds a documentation object that contains all the libraries, types, functions, etc
    DocumentationModule* BuildDocumentation();
    
    // Create an html/javascript file that defines our documentation
    String BuildDocumentationHtml();
    
    // Output documentation for the library into rst format
    void BuildDocumentationRst(StringParam directory);

  private:

    // Build documentation for a given type
    void BuildTypeDocumentation(BoundType* type, DocumentationType* docType);

    // Build documentation for a set of functions
    void BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionMultiMap& functions);
    void BuildFunctionDocumentation(Array<DocumentationFunction*>& addTo, const FunctionArray& functions);

    // Build documentation for properties and members
    void BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const FieldMap& fields);
    void BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const PropertyMap& properties);
    void BuildPropertyDocumentation(Array<DocumentationProperty*>& addTo, const Property* property);

    // Builds a Json array of documented constructors
    void BuildJsonConstructors(JsonBuilder& json, const Array<DocumentationFunction*>& constructors, StringParam name);

    // Builds a Json array of documented functions
    void BuildJsonMethods(JsonBuilder& json, const Array<DocumentationFunction*>& functions, StringParam name);

    // Builds a Json array of documented properties
    void BuildJsonProperties(JsonBuilder& json, const Array<DocumentationProperty*>& properties, StringParam name);
  };

  //class ExtensionPropertyMapRange
  //{
  //public:

  //  // Constructor
  //  ExtensionPropertyMapRange(LibraryArray& libraries, bool isStatic, Type* type);

  //  // Range interface
  //  void popFront();
  //  PropertyMap* front();
  //  bool empty();

  //private:

  //  
  //  void UpdateCurrentMap();
  //  
  //private:

  //  // The current map we've found
  //  PropertyMap* CurrentMap;

  //  // A re-entrant index into the library array
  //  size_t LibraryIndex;

  //  // We iterate up the base types to find extension properties
  //  // We terminate when we hit the last base type from the last library
  //  Type* BaseIterator;

  //  // The libraries that we look through to find extension properties
  //  LibraryArray& Libraries;

  //  // Whether we're looking for a static property or not
  //  bool IsStatic;

  //  // The type that the properties are defined to work on
  //  Type* ExtensionType;
  //};

  // The functor should return a bool (true means stop, false means keep going) and takes (PropertyMap*)
  
  template <typename Functor>
  void ForEachExtensionPropertyMap(bool isStatic, LibraryArray& libraries, Type* type, Functor functor)
  {
    // Loop through all the libraries
    for (size_t i = 0; i < libraries.size(); ++i)
    {
      // We need to look up the entire heirarchy (the property could be on any base classes)
      Type* baseIterator = type;
      while (baseIterator != nullptr)
      {
        // Grab the current library
        LibraryRef& library = libraries[i];

        // Get the guid of the type (this should be legal here since we've collected all members)
        GuidType guid = baseIterator->Hash();

        // Get the array of properties (may be empty)
        PropertyMap* properties = nullptr;
        
        // If we're resolving a static member
        if (isStatic)
        {
          properties = library->StaticExtensionProperties.findPointer(guid);
        }
        else
        {
          properties = library->InstanceExtensionProperties.findPointer(guid);
        }
        
        // If we got a valid array of properties...
        if (properties != nullptr)
        {
          if (functor(properties))
            return;
        }
          
        // Iterate to the next type
        baseIterator = Type::GetBaseType(baseIterator);
      }
    }
  }
}

// End header protection
#endif

namespace Zilch
{
  // The core of zilch contains all types that the compiler uses internally
  // The core also acts as a global database of all immutable and sharable types
  class Core : public StaticLibrary
  {
  public:
    // Friends
    friend class CodeGenerator;
    friend class Syntaxer;
    friend class CoreLibraries;
    friend class Type;

    // Grab the singleton instance of the type database
    static Core& GetInstance();

    // Store pointers to the basic data-types
    BoundType* BooleanType;
    BoundType* Boolean2Type;
    BoundType* Boolean3Type;
    BoundType* Boolean4Type;
    BoundType* IntegerType;
    BoundType* Integer2Type;
    BoundType* Integer3Type;
    BoundType* Integer4Type;
    BoundType* RealType;
    BoundType* Real2Type;
    BoundType* Real3Type;
    BoundType* Real4Type;
    BoundType* QuaternionType;
    BoundType* DoubleIntegerType;
    BoundType* DoubleRealType;
    BoundType* StringType;
    BoundType* EventsType;
    BoundType* ExceptionType;
    BoundType* MathType;

    // Void is a special type that can actually be declared, but is typically used for specifying no return type
    BoundType* VoidType;

    // The null type is the type that the constant 'null' has before implicit conversion
    BoundType* NullType;

    // This is used when types cannot be resolved (it should never show up in code generation)
    // Using this type helps to prevent crashes, which is useful for more tolerant cases like code-completion
    BoundType* ErrorType;

    // The overloaded methods type is akin to the ErrorType and is only used when we encounter method overloads
    // Typically this type is replaced by another type, however in the event that overloads are not resolved
    // this will be the final resulting type (an entirely useless type that should probably be an error to store)
    BoundType* OverloadedMethodsType;

    // A special array of vector types
    // Useful for when we're using an index
    static const size_t MaxComponents = 4;
    BoundType* RealTypes    [MaxComponents];
    BoundType* IntegerTypes [MaxComponents];
    BoundType* BooleanTypes [MaxComponents];
    Array<BoundType*> AllRealTypes;
    Array<BoundType*> AllIntegerTypes;
    Array<BoundType*> AllBooleanTypes;

    // Special array of what matrix types to make (real, int, etc...)
    static const size_t MinMatrixComponents = 2;
    static const size_t MaxMatrixComponents = 4;
    static const size_t MaxMatrixElementTypes = 3;
    BoundType* MatrixElementTypes[MaxMatrixElementTypes];
    // To perform certain generic matrix operations generically,
    // MultiplyAdd functions (a += b * c) are needed
    typedef void (*MatrixMultiplyAddFunction)(byte* outData, byte* inputA, byte* inputB);
    MatrixMultiplyAddFunction TypeMultiplyAddFunctions[MaxMatrixElementTypes];

    // A very special type that allows us to take a delegate of any type
    // This can currently not be declared in language, but can be used from C++
    DelegateType* AnyDelegateType;

    // A type that can be set to anything (delegates, value types, reference types, etc)
    AnyType* AnythingType;

  protected:

    // Setup the binding for the core library
    void PreSetupBinding(LibraryBuilder& builder) override;

  private:

    // Instantiates a hash-map template when requested
    static BoundType* InstantiateHashMap
    (
      LibraryBuilder& builder,
      StringParam baseName,
      StringParam fullyQualifiedName,
      const Array<Type*>& templateTypes,
      const void* userData
    );

    // Instantiates a pair template when requested
    static BoundType* InstantiateKeyValue
    (
      LibraryBuilder& builder,
      StringParam baseName,
      StringParam fullyQualifiedName,
      const Array<Type*>& templateTypes,
      const void* userData
    );

    // Instantiates a property delegate template when requested
    static BoundType* InstantiatePropertyDelegate
    (
      LibraryBuilder& builder,
      StringParam baseName,
      StringParam fullyQualifiedName,
      const Array<Type*>& templateTypes,
      const void* userData
    );

    // Privatized constructor (it's a singleton)
    Core();

    // Destructor
    ~Core();

    // Not copyable
    ZilchNoCopy(Core);
  };

  // A single entry in a stack trace
  class StackEntry
  {
  public:
    // Constructor
    StackEntry();

    // A file / line location of where we are in the stack
    CodeLocation Location;

    // The function we're currently on
    Function* ExecutingFunction;
  };

  // Contains all the locations that we're at in an execution of Zilch
  class StackTrace
  {
  public:
    // Get the most recent non-native call (for debugging and visualization)
    // or return null if the entire stack is native or empty
    // Typically when an exception occurs (or any place a stack trace happens) you will
    // want to use this to point the user at the location where the error occurred in their code
    StackEntry* GetMostRecentNonNativeStackEntry();

    // Get the relevant location that the exception occurred (where should show the user)
    // This will invoke the above 'GetMostRecentNonNativeStackEntry' function, and if it
    // returns null it will return an empty location
    CodeLocation GetMostRecentNonNativeLocation();

    // Get the standard formatting for stack traces (used by exception printing too)
    String GetFormattedMessage(MessageFormat::Enum format);
    
    // The code locations of the entire stack and what functions were called
    // We have to use a special allocator here that supports being memset to zero
    // (because exceptions are just memset to 0, no constructor called)
    Array<StackEntry, Zero::MemsetZeroDefaultAllocator> Stack;
  };

  // The base class of any exception that gets thrown
  class Exception
  {
  public:
    ZilchDeclareBaseType(Exception, TypeCopyMode::ReferenceType);

    // Default constructor
    Exception();

    // Construct an exception with a message
    Exception(StringParam message);

    // Get the standard formatting for error messages
    String GetFormattedMessage(MessageFormat::Enum format);

    // The error that occurred as a human readable string, including technical details
    String Message;

    // The code locations of the entire stack and what functions were called
    StackTrace Trace;
  };

  // A property delegate contains both the get and set delegates
  // Technically we store the handle twice, which could be compacted because
  // we know that the 'this' handle will always be the same among both
  class PropertyDelegateTemplate
  {
  public:
    // The property getter and setters
    Delegate Get;
    Delegate Set;
  };

  // Bind the StringBuilder class
  ZilchDeclareExternalBaseType(StringBuilder, TypeCopyMode::ReferenceType);

  // Functions for converting our primitives to strings
  String BooleanToString(Boolean value);
  String Boolean2ToString(Boolean2Param value);
  String Boolean3ToString(Boolean3Param value);
  String Boolean4ToString(Boolean4Param value);
  String IntegerToString(Integer value);
  String Integer2ToString(Integer2Param value);
  String Integer3ToString(Integer3Param value);
  String Integer4ToString(Integer4Param value);
  String RealToString(Real value);
  String Real2ToString(Real2Param value);
  String Real3ToString(Real3Param value);
  String Real4ToString(Real4Param value);
  String QuaternionToString(QuaternionParam value);
  String DoubleIntegerToString(DoubleInteger value);
  String DoubleRealToString(DoubleReal value);
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ARRAY_HPP
#define ZILCH_ARRAY_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_GRAMMAR_CONSTANTS_HPP
#define ZILCH_GRAMMAR_CONSTANTS_HPP

namespace Zilch
{
  // All the symbol constants in the language
  namespace Grammar
  {
    enum Enum
    {
      Invalid = -1,
      End = 0,
      Error = 1,
      Whitespace = 2,
      UpperIdentifier = 3,
      LowerIdentifier = 4,
      IntegerLiteral = 5,
      DoubleIntegerLiteral = 6,
      RealLiteral = 7,
      DoubleRealLiteral = 8,
      CharacterLiteral = 9,
      StringLiteral = 10,
      BeginStringInterpolate = 11,
      EndStringInterpolate = 12,
      EndBeginStringInterpolate = 13,
      Abstract = 14,
      Alias = 15,
      Alignof = 16,
      Assert = 17,
      Auto = 18,
      Case = 19,
      Catch = 20,
      Checked = 21,
      Const = 22,
      Default = 23,
      Dynamic = 24,
      Explicit = 25,
      Export = 26,
      Extern = 27,
      Finally = 28,
      Fixed = 29,
      Friend = 30,
      Global = 31,
      Goto = 32,
      Immutable = 33,
      Implicit = 34,
      Import = 35,
      In = 36,
      Include = 37,
      Inline = 38,
      Interface = 39,
      Internal = 40,
      Is = 41,
      Local = 42,
      Lock = 43,
      Module = 44,
      Mutable = 45,
      Namespace = 46,
      Operator = 47,
      Out = 48,
      Override = 49,
      Package = 50,
      Params = 51,
      Partial = 52,
      Positional = 53,
      Private = 54,
      Protected = 55,
      Public = 56,
      Readonly = 57,
      Register = 58,
      Require = 59,
      Scope = 60,
      Sealed = 61,
      Signed = 62,
      Sizeof = 63,
      Stackalloc = 64,
      Static = 65,
      Switch = 66,
      Timeout = 67,
      Try = 68,
      Typedef = 69,
      Typename = 70,
      Unchecked = 71,
      Unsafe = 72,
      Unsigned = 73,
      Using = 74,
      Virtual = 75,
      Volatile = 76,
      Where = 77,
      Yield = 78,
      Any = 79,
      And = 80,
      As = 81,
      Base = 82,
      Break = 83,
      Class = 84,
      Constructor = 85,
      Continue = 86,
      Debug = 87,
      Delegate = 88,
      Delete = 89,
      Destructor = 90,
      Do = 91,
      Else = 92,
      Enumeration = 93,
      False = 94,
      Flags = 95,
      For = 96,
      ForEach = 97,
      Function = 98,
      Get = 99,
      If = 100,
      Loop = 101,
      New = 102,
      Not = 103,
      Null = 104,
      Or = 105,
      Ref = 106,
      Return = 107,
      Sends = 108,
      Set = 109,
      Struct = 110,
      Throw = 111,
      True = 112,
      Typeid = 113,
      Typeof = 114,
      Variable = 115,
      While = 116,
      Access = 117,
      DynamicAccess = 118,
      NonVirtualAccess = 119,
      TypeSpecifier = 120,
      NameSpecifier = 120,
      Inheritance = 120,
      InitializerList = 120,
      ArgumentSeparator = 121,
      RefersTo = 122,
      Assignment = 123,
      AssignmentSubtract = 124,
      AssignmentAdd = 125,
      AssignmentDivide = 126,
      AssignmentMultiply = 127,
      AssignmentModulo = 128,
      AssignmentExponent = 129,
      AssignmentLeftShift = 130,
      AssignmentRightShift = 131,
      AssignmentBitwiseXor = 132,
      AssignmentBitwiseOr = 133,
      AssignmentBitwiseAnd = 134,
      Equality = 135,
      Inequality = 136,
      LessThan = 137,
      LessThanOrEqualTo = 138,
      GreaterThan = 139,
      GreaterThanOrEqualTo = 140,
      Negative = 141,
      Subtract = 141,
      Positive = 142,
      Add = 142,
      Divide = 143,
      Multiply = 144,
      Modulo = 145,
      Exponent = 146,
      Decrement = 147,
      Increment = 148,
      BitshiftLeft = 149,
      BitshiftRight = 150,
      BitwiseXor = 151,
      BitwiseOr = 152,
      BitwiseAnd = 153,
      BitwiseNot = 154,
      PropertyDelegate = 155,
      LogicalOr = 156,
      LogicalAnd = 157,
      LogicalNot = 158,
      StatementSeparator = 159,
      BeginIndex = 160,
      BeginTemplate = 160,
      BeginInitializer = 160,
      EndIndex = 161,
      EndTemplate = 161,
      EndInitializer = 161,
      BeginFunctionCall = 162,
      BeginFunctionParameters = 162,
      BeginGroup = 162,
      EndFunctionCall = 163,
      EndFunctionParameters = 163,
      EndGroup = 163,
      BeginScope = 164,
      EndScope = 165,
      CommentLine = 166,
      CommentStart = 167,
      CommentEnd = 168,
      SymbolCount
    };

    // Gets the name of a given grammar constant
    const String& GetName(Grammar::Enum value);

    // Gets the keyword or symbol associated with a grammar constant, or returns the string 'Invalid'
    const String& GetKeywordOrSymbol(Grammar::Enum value);

    // Get a list of keywords used by Zilch (typically provided for syntax highlighting)
    // If you need a list of words separated by spaces, you can use Zilch::JoinStrings
    const Array<String>& GetUsedKeywords();

    // Special keywords that only exist in certain contexts, (eg this, value...)
    // If you need a list of words separated by spaces, you can use Zilch::JoinStrings
    const Array<String>& GetSpecialKeywords();

    // Get a list of keywords reserved by Zilch (these may not be used, but do nothing)
    const Array<String>& GetReservedKeywords();
  }
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TEMPLATE_BINDING_HPP
#define ZILCH_TEMPALTE_BINDING_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_EXECUTABLE_STATE_HPP
#define ZILCH_EXECUTABLE_STATE_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HANDLE_MANAGER_HPP
#define ZILCH_HANDLE_MANAGER_HPP

// Includes

namespace Zilch
{
  // A function we use to create the handle managers by index
  typedef HandleManager* (*CreateHandleManagerFn)(ExecutableState* state);

  // Generates handle manager creator functions
  template <typename T>
  HandleManager* HandleManagerCreator(ExecutableState* state)
  {
    return new T(state);
  }

  // This holds any shared handle manager memory
  class HandleManagers
  {
  public:
    // Get the singleton instance
    static HandleManagers& GetInstance();

    // Constructor
    HandleManagers();

    // Destructor
    ~HandleManagers();

    // Add a shared handle manager
    void AddSharedManager(HandleManagerId index, HandleManager* manager);

    // Add a unique creator function
    void AddUniqueCreator(HandleManagerId index, CreateHandleManagerFn creator);

    // Get a shared handle manager
    HandleManager* GetSharedManager(HandleManagerId index);

    // Get a unique creator function
    CreateHandleManagerFn GetUniqueCreator(HandleManagerId index);

    // Get the next available id in the handle manager
    HandleManagerId GetNextId();

    // Lock it so we cannot add anymore handle managers
    void Lock();

  private:
    // All the shared handle managers, by index
    HashMap<size_t, HandleManager*> Shared;

    // For unqiue handle managers, this maps the index to a function that will create them
    HashMap<size_t, CreateHandleManagerFn> Unique;

    // Counter for assigning handle manager indices
    HandleManagerId UniqueCounter;

    // We consider this locked once we call ZilchStartup
    bool Locked;
  };

  template <typename T>
  class HandleManagerGuid
  {
  public:
    // The index into the executable state that this manager gets
    // This index is also used to uniquely identify the manager
    static const HandleManagerId Id;
  };

  // Auto-increment the handle manager index as we register more managers
  template <typename T>
  const HandleManagerId HandleManagerGuid<T>::Id = HandleManagers::GetInstance().GetNextId();

  // Get the id of a handle manager
  #define ZilchManagerId(Type) Zilch::HandleManagerGuid<Type>::Id

  // Creates and registers a shared handle manager
  // Any extra arguments will be given to the constructor of your type
  // Shared handle managers MUST be implemented in a thread safe fashion
  #define ZilchRegisterSharedHandleManager(Type)  \
    Zilch::HandleManagers::GetInstance().AddSharedManager(ZilchManagerId(Type), new Type(nullptr))

  // Registers a unqiue (per ExecutableState) handle manager
  // The types registered are expected to have a default constructor
  #define ZilchRegisterUniqueHandleManager(Type)  \
    Zilch::HandleManagers::GetInstance().AddUniqueCreator(ZilchManagerId(Type), Zilch::HandleManagerCreator<Type>)
  
  // The result we get back from releasing a reference to a handle object
  namespace ReleaseResult
  {
    enum Enum
    {
      // Zilch will invoke the destructors and call delete on the object
      DeleteObject,

      // The object is still being referenced and must be kept alive
      KeepAlive,

      // Tells Zilch not to worry about the lifetime of the object
      // This should be used when the object reference was already deleted
      Ignore
    };
  }

  // An interface that users must implement for their own handle types
  // Common handle types are slot map handles (index into a table with unique id)
  // Other types include refrence counted objects, or even garbage collected objects
  // Note that objects allocated within the language are managed by the language
  class HandleManager
  {
  public:

    // Constructor
    // The state will be null in the case that this is a shared handle manager
    HandleManager(ExecutableState* state);

    // Virtualize the destructor
    virtual ~HandleManager();

    // Get the name of the handle manager, only for debugging and exceptions
    virtual String GetName() = 0;

    // Allocate the type and initialize a handle to that allocated object
    // The custom flags can be used to pass in any information to the allocation scheme
    // For example, the HeapHandleManager uses the flags to specify whether the type should be reference counted or not
    // Note that the only portion of the handle the needs to be initialized is the Data field,
    // and that the handle will have been memory cleared to all 0 (the Type and Manager will be set externally)
    virtual void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) = 0;

    // Initializes a handle given a pointer to an object (generally used for Write / WriteRef in C++)
    // The 'object' is the same pointer that we would get back from Dereferencing the handle
    // Note that the only portion of the handle the needs to be initialized is the Data field,
    // and that the handle will have been memory cleared to all 0 (the Type and Manager will be set externally)
    virtual void ObjectToHandle(const byte* object, Handle& handleToInitialize) = 0;

    // Dereference the user-data stored on the handle and
    // turn it into an instance pointer to the user's object
    // Return a null pointer if the object handle is null
    virtual byte* HandleToObject(const Handle& handle) = 0;

    // Retrieve the hash value of a given handle (generally just the pointer value or some unqiue value)
    // This is generally used to compare handles when added to hashable containers
    // All null handles should return 0
    virtual int Hash(const Handle& handle);
    
    // Add a reference to the object
    // The default behavior is to do nothing (assumes the object is a global and never dies)
    virtual void AddReference(const Handle& handle);

    // Releases the reference to the object and must return the current reference count
    // This function MUST NOT actually destroy the object
    // Instead, it should return either 'KeepAlive' to do nothing, or 'DeleteObject' to tell
    // Zilch to run the destructor chain (it will also call your 'Delete' function afterward)
    virtual ReleaseResult::Enum ReleaseReference(const Handle& handle);

    // Destroys the object and frees its memory
    // Deleting the object should always try and ensure that all references to it become null
    // This will only ever be called if CanDelete return true
    virtual void Delete(const Handle& handle);

    // Returns true if the object is deletable, false otherwise
    // Note that returning false will cause a 'non-deleteable object' exception in the language
    // The default behavior is to return false (assumes the object can never be explicitly deleted)
    virtual bool CanDelete(const Handle& handle);

    // Compare two handles with each other; return true if they are equal, false otherwise
    // The default behavior is to compare the dereferenced pointers
    // Since this check is only done after the handles have already been deferenced,
    // we also pass in the dereferenced byte pointers we received
    virtual bool IsEqual
    (
      const Handle& handleLhs,
      const Handle& handleRhs,
      const byte* objectLhs,
      const byte* objectRhs
    );

  public:

    // The executable state (only used in the case that we're not shared)
    ExecutableState* const State;

    // Handle managers are non-copyable
    ZilchNoCopy(HandleManager);
  };
  
  // Flags passed into the heap Allocate function
  namespace HeapFlags
  {
    enum Enum
    {
      // Allocates a regular reference counted object (default)
      ReferenceCounted = 0,

      // Allocates a non-reference counted object, however supports safe handle behavior
      NonReferenceCounted
    };
  }
  
  // The object slot is basically just a pointer to the object with a free list
  class ObjectSlot
  {
  public:
    byte*           Data;
    Uid             UniqueId;
    unsigned        ReferenceCount;
    HeapFlags::Enum Flags;
    ObjectSlot*     NextFreeSlot;
  };

  // The structure of our heap handle's inner data
  class HeapHandleData
  {
  public:
    Uid           UniqueId;
    ObjectSlot*   Slot;
  };

  // This manages heap objects allocated in the language (including references to heap members via offset)
  class HeapManager : public HandleManager
  {
  public:

    // Destructor
    virtual ~HeapManager();

    // HandleManager interface
    HeapManager(ExecutableState* state);
    String GetName() override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
    void Delete(const Handle& handle) override;
    bool CanDelete(const Handle& handle) override;
    void AddReference(const Handle& handle) override;
    ReleaseResult::Enum ReleaseReference(const Handle& handle) override;

  private:

    // All the slots act as places to hold objects
    Array<ObjectSlot> Objects;

    // The next free object slot available to us
    ObjectSlot* NextFreeSlot;

    // Store statistics for how many objects we have allocated
    size_t ObjectCount;

    // A unique ID counter (so we can assign objects unique IDs...)
    Uid UidCount;
  };

  // The structure of our stack handle's inner data
  class StackHandleData
  {
  public:
    //UID       UniqueId;
    //unsigned  ScopeCount;
    byte*     StackLocation;
  };

  // This manages stack objects initialized in the language (including references to stack members via offset)
  class StackManager : public HandleManager
  {
  public:
    // HandleManager interface
    StackManager(ExecutableState* state);
    String GetName() override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
  };

  // This manages insertion of pointers into the language, which are assumed to be global
  class PointerManager : public HandleManager
  {
  public:
    // HandleManager interface
    PointerManager(ExecutableState* state);
    String GetName() override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
  };

  // This manages string nodes for the string class, which is always a reference type
  class StringManager : public HandleManager
  {
  public:
    // HandleManager interface
    StringManager(ExecutableState* state);
    String GetName() override;
    int Hash(const Handle& handle) override;
    void Allocate(BoundType* type, Handle& handleToInitialize, size_t customFlags) override;
    byte* HandleToObject(const Handle& handle) override;
    void ObjectToHandle(const byte* object, Handle& handleToInitialize) override;
    void AddReference(const Handle& handle) override;
    ReleaseResult::Enum ReleaseReference(const Handle& handle) override;
    bool IsEqual
    (
      const Handle& handleLhs,
      const Handle& handleRhs,
      const byte* objectLhs,
      const byte* objectRhs
    ) override;
  };
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TIMER_HPP
#define ZILCH_TIMER_HPP

// Includes

namespace Zilch
{
  // The timer maintains a precision of at around 1ms and attempts to deal with wrap around
  class Timer
  {
  public:
    // Constructor
    Timer();

    // The ticks that make up a second
    static const long long TicksPerSecond;

    // Updates the timer and returns its time
    long long GetAndUpdateTicks();

    // Resets the ticks that have been counted
    void Reset();

  private:

    // We keep our own tick count which is actually in the same
    // measurement as clock_t, but deals with wrap around
    long long TotalTicks;

    // Store the last sample we did to the clock
    long long LastClock;
  };
}

// End header protection
#endif

namespace Zilch
{
  // Two constants we use to note the state of our debug program counter pointer
  const size_t ProgramCounterNotActive = (size_t)-1;
  const size_t ProgramCounterNative = (size_t)-2;

  // The data that exists per scope (per stack frame)
  // Every function has an implicit scope
  class PerScopeData
  {
  public:
    // Invoke the destructors of anything we need to cleanup
    // and clear out the arrays for recycling
    void PerformCleanup();

    // Handles on the stack that need to be cleaned up
    // This includes 'this' handles inside delegates, any handles that get copied to the stack,
    // and or any handles that are created (such as via local/new, or stack/member handles)
    Array<Any*> AnysToBeCleaned;
    Array<Handle*> HandlesToBeCleaned;
    Array<Delegate*> DelegatesToBeCleaned;
  };

  // Debug flags that we use for making and receiving calls
  namespace CallDebug
  {
    enum Enum
    {
      None                      = 0,
      SetParameter0             = 1 << 0,
      SetParameter1             = 1 << 1,
      SetParameter2             = 1 << 2,
      SetParameter3             = 1 << 3,
      SetParameter4             = 1 << 4,
      SetParameter5             = 1 << 5,
      SetParameter6             = 1 << 6,
      SetParameter7             = 1 << 7,
      SetParameter8             = 1 << 8,
      SetParameter9             = 1 << 9,
      SetParameter10            = 1 << 10,
      SetParameter11            = 1 << 11,
      SetParameter12            = 1 << 12,
      SetParameter13            = 1 << 13,
      SetParameter14            = 1 << 14,
      SetParameter15            = 1 << 15,
      SetParameter16            = 1 << 16,
      SetParameter17            = 1 << 17,
      SetParameter18            = 1 << 18,
      SetParameter19            = 1 << 19,
      SetParameter20            = 1 << 20,
      SetParameter21            = 1 << 21,
      SetReturn                 = 1 << 22,
      SetThis                   = 1 << 23,
      Invoked                   = 1 << 24,
      NoReturnChecking          = 1 << 25,
      NoReturnDestruction       = 1 << 26,
      NoParameterChecking       = 1 << 27,
      NoParameterDestruction    = 1 << 28,
      NoThisChecking            = 1 << 29,
      NoThisDestruction         = 1 << 30
    };
  }

  // The state of a stack frame
  namespace StackErrorState
  {
    enum Enum
    {
      Normal,
      Overflowed,
      MaxRecursionReached
    };
  }

  // The data that exists per stack frame
  class PerFrameData
  {
  public:
    // Constructor
    PerFrameData(ExecutableState* state);

    // Adds an 'any type' that needs cleanup
    void QueueAnyCleanup(Any* any);

    // Adds a handle that needs cleanup
    void QueueHandleCleanup(Handle* handle);

    // Adds a delegate that needs cleanup
    void QueueDelegateCleanup(Delegate* delegate);

    // If the stack overflowed or we reached the max recursion depth,
    // this will throw an exception and return true
    // Otherwise this will return false if no exception was thrown
    bool AttemptThrowStackExceptions(ExceptionReport& report);

    // Checks if a variable is initialized within the current frame
    // Note: This is only intended to be used by a debugger, and may be incorrect for value types
    bool IsVariableInitialized(Variable* variable);

    // For the current stack frame, this is where all the data lies
    byte* Frame;
    byte* NextFrame;

    // We need a pointer back to the state to do certain operations
    ExecutableState* State;

    // The active program counter for this call stack
    // By default, this is set to 'ProgramCounterNotActive' which indicates it should not be used
    // For C++ bound functions, this is 'ProgramCounterNative' which means it is active but more information is needed
    size_t ProgramCounter;

    // The current function that is being executed
    Function* CurrentFunction;

    // Any per scope data (this data is generally 'things to be destructed')
    // This is also used to destruct things when exceptions are thrown
    Array<PerScopeData*> Scopes;

    // Used for debugging (we can't invoke a function until all parameters are written)
    CallDebug::Enum Debug;

    // Where we report exceptions to
    // This is only set when actually entering the call, not when the frame is created
    ExceptionReport* Report;

    // When we're inside the VM, this is the location that we jump to if an exception occurs
    // This is only set when actually inside the VM's 'ExecuteNext' function
    jmp_buf ExceptionJump;

    // The number of timeouts we have associated with this stack frame
    // When this frame gets destroyed/unrolled, we need to pop these timeouts
    size_t Timeouts;

    // The frame itself could have been created past the recursion depth or in an overflowed state
    StackErrorState::Enum ErrorState;
  };

  namespace CheckPrimitive
  {
    enum Enum
    {
      Handle,
      Value,
      Delegate,
      Any
    };
  }

  namespace Direction
  {
    enum Enum
    {
      Get,
      Set
    };
  }

  // Describes where an operand is pointing to =
  // (a location on the stack, or an object, etc)
  class OperandLocation
  {
  public:
    // Constructor
    OperandLocation();

    // The type will either be set to Member, Constant, or Local
    OperandType::Enum Type;

    // If the operand is a Member, then this is a pointer to the base of
    // the object where the member exists. If the operand is a Constant,
    // this points at the base of the constant buffer for the current function.
    // If the operand is a Local, then this is a pointer to the stack.
    const char* Memory;

    // The size of the memory. In the case of the Member, this is the size
    // of the object. In the case of the Constant, this is the size of the
    // constant buffer. In the case of the Local, this is the size of the stack
    size_t MemorySize;

    // The offset into the memory where the Member, Constant, or Local exists
    size_t Offset;
  };

  // Tells us when a function or timeout scope started, and how
  // long it has until it exceeds its time and throws an exception
  class Timeout
  {
  public:
    // Constructor
    Timeout();

    // The length of the timeout in ticks (once the accumulation reaches this we throw an exception)
    // We also use this to print a meaningful exception message
    long long LengthTicks;

    // Stores the amount of ticks accumulated under this timeout (based on the Timer class)
    // Every timeout is exclusive, which means while a timeout is active it's parents DO NOT accumulate time
    long long AccumulatedTicks;

#if _DEBUG
    // Only used to verify that the correct frame that pushed us is the only one to pop us
    PerFrameData* Frame;
#endif
  };

  // With any function call, an exception can occur that we need to catch
  class ExceptionReport
  {
  public:
    // Friends
    friend class ExecutableState;

    // Tests if any exceptions were thrown
    bool HasThrownExceptions();

    // Gets all the exceptions concatenated in a list
    String GetConcatenatedMessages();
    
    // The exceptions that are being thrown (as we unravel the stack)
    Array<Handle> Exceptions;

  private:
    // An array of exception pointers, only for debugging purposes
    Array<Exception*> ExceptionsForDebugOnly;
  };

  // A callback that prints to stderr whenever an exception occurs
  void DefaultExceptionCallback(ExecutableState* state, Exception* exception, void* userData);

  // Stores the generated functions, and anything else needed for a VM to execute
  class ExecutableState
  {
  public:
    // Friends
    friend class VirtualMachine;
    friend class Module;
    friend class Handle;
    friend class CodeGenerator;
    friend class HeapManager;
    friend class StackManager;
    friend class Call;
    friend class PerFrameData;
    friend class Debugger;

    // Because users often need to access the state in their own bound functions, we provide a thread local
    // that is the last running state (set before each call to Zilch, and reset to the previous after the call)
    static ZilchThreadLocal ExecutableState* CallingState;

    // Constructor
    ExecutableState();

    // Destructor
    ~ExecutableState();

    // Set the timeout for this state in seconds (equivalent of a timeout statement in language)
    // Any code that runs for longer than this amount of time will throw an exception saying
    // that it timed out. This is mainly used to prevent user code from infinite looping/recursing
    // This can only be set while we're not inside a call-stack
    // A value of 0 seconds will clear the timeout
    void SetTimeout(size_t seconds);

    // Checks if we are currently inside a call stack
    bool IsInCallStack();

    // Allocates an object on the stack at the given stack
    // position and returns a stack handle to the object
    // Note that the handle will become null when we leave the scope
    // that the object was allocated in (return from a function, etc)
    Handle AllocateStackObject(byte* stackLocation, BoundType* type, ExceptionReport& report);

    // Allocates an object on the heap at the given stack
    // position and returns a heap handle to the object
    // Note that the memory will be managed by the language itself
    Handle AllocateHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags);

    // Allocates an object on the heap at the given stack
    // position and returns a heap handle to the object
    // Note that the memory will be managed by the language itself
    Handle AllocateDefaultConstructedHeapObject(BoundType* type, ExceptionReport& report, HeapFlags::Enum flags);

    // Get a pointer to the current stack for the current function
    // If the function has a return value, then it is the first value on the stack
    // After the return value comes the parameters, in tightly packed order
    // If the function is an instance method, then the last value is the 'this' handle,
    // whose type is actually 'Handle'; handles can be dereferenced to get a
    // direct pointer to the object
    // Only ever read up to the size of your return, parameters, and this handle
    byte* GetCurrentStackFrame();

    // Throws a standard null reference exception
    void ThrowNullReferenceException(ExceptionReport& report);

    // Throws a standard null reference exception with a custom message
    void ThrowNullReferenceException(ExceptionReport& report, StringParam customMessage);

    // Throws a standard exception with the given message
    void ThrowException(ExceptionReport& report, StringParam message);

    // Throws an exception allocated by the user
    void ThrowException(ExceptionReport& report, Handle& exception);

    // Ensures that a scope does not exceed a time limit (throws an exception if it does)
    // This should be periodically called in native C++ code for proper timeout protection
    // Returns true if we threw a timeout exception, false otherwise
    bool ThrowExceptionOnTimeout(ExceptionReport& report);

    // Build a stack trace into the stack array
    void GetStackTrace(StackTrace& trace);

    // Gets a handle manager by type
    template <typename T>
    T* GetHandleManager() const
    {
      return (T*)this->GetHandleManager(ZilchManagerId(T));
    }

    // Gets a handle manager by id
    HandleManager* GetHandleManager(HandleManagerId id) const;

    // Update the virtual table of a native C++ object, or do nothing if it's not virtual or native
    void UpdateCppVirtualTable(byte* objectWithBaseVTable, BoundType* cppBaseType, BoundType* derivedType);

    // A callback that occurs before we hit an opcode (nullptr will clear the callback)
    void SetOpcodePreStepCallback(OpcodeStepCallback callback, void* userData);

    // A callback that occurs after we hit an opcode (nullptr will clear the callback)
    void SetOpcodePostStepCallback(OpcodeStepCallback callback, void* userData);

    // A callback that occurs when we step into a function (nullptr will clear the callback)
    void SetEnterFunctionCallback(FunctionStepCallback callback, void* userData);

    // A callback that occurs when we step out of a function (nullptr will clear the callback)
    void SetExitFunctionCallback(FunctionStepCallback callback, void* userData);

    // A callback that occurs upon a fatal error (out of memory, reserve stack overflow, etc)
    // The program will be immediately aborted after this callback is run
    void SetFatalErrorCallback(FatalErrorCallback callback, void* userData);

    // A callback that occurs when any exception is thrown (nullptr will clear the callback)
    void SetExceptionCallback(ExceptionCallback callback, void* userData);

    // Get the raw stack array
    const byte* GetRawStack();

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructableBuffer ComplexUserData;

  private:

    // Gets a pointer to the next stack frame
    // If we're currently in a function, this represents the
    // position ahead of our current function. If we're not
    // in any functions, it should be the front of the stack
    // Always call this BEFORE you push any frame data
    byte* GetNextStackFrame();

    // Push a new stack frame and returns the location on the stack
    ZilchForceInline PerFrameData* PushFrame(Function* function);

    // A slightly more optmial version of pushing a stack frame (used internally in execution)
    ZilchForceInline PerFrameData* PushFrame(byte* frame, Function* function);

    // Pops a stack frame and return a pointer to where the return value should be
    ZilchForceInline PerFrameData* PopFrame();

    // Initialize a handle to point at a location on the stack
    void InitializeStackHandle(Handle& handle, byte* location, BoundType* type);

    // Invokes the pre-constructor (which initializes memory) on a handle
    void InvokePreConstructorOrRelease(Handle& handle, ExceptionReport& report);

    // Allocates or recycles a scope
    PerScopeData* AllocateScope();

    // A timeout is a low level construct that allows us to ensure code does not run beyond a certain time
    // Timeouts do not work while calling native code (except upon native code's return)
    // This will push a timeout based on a given number of seconds
    // Returns true if we threw a timeout exception, false otherwise
    bool PushTimeout(PerFrameData* frame, size_t seconds);

    // Exits a timeout scope and validates that the timeout was not reached
    // Returns true if we threw a timeout exception, false otherwise
    bool PopTimeout(PerFrameData* frame);

  public:

    // Externally set breakpoints will overwrite the instruction, so we remap the opcode's index
    // to its original instruction here (if a breakpoint gets uneset, we use this to write back the original instruction)
    HashMap<size_t, Instruction::Enum> ExternalBreakpoints;

    // An array of functions in the order they were linked
    // This array is used in function rebasing (and has other purposes)
    //FunctionArray Functions;

    // We need a way to map virtual function ids into our function
    HashMap<GuidType, Function*> ThunksToFunctions;

    // The size of the stack
    const size_t StackSize;

    // Reserved space after the stack, this is only used when we reach a stack overflow
    const size_t OverflowStackSize;

    // The maximum number of recursive calls we allow in this state
    size_t MaxRecursionDepth;

    // Used for debugging (the name will show up in the debugger, and so on)
    String Name;

    // We want to hold references to the libraries that we were compiled with
    Module Dependencies;

  private:

    // Pointers to our global handle managers
    HeapManager* HeapObjects;
    StackManager* StackObjects;
    PointerManager* PointerObjects;

    // Debugging callbacks
    OpcodeStepDelegate OpcodePreStepCallback;
    OpcodeStepDelegate OpcodePostStepCallback;
    FunctionStepDelegate EnterFunctionCallback;
    FunctionStepDelegate ExitFunctionCallback;

    // Any sort of fatal errors, eg no memory, stack overflow inside another overflow, etc
    // Once a call to this is made, if the handler returns then the program will be immediately aborted
    FatalErrorDelegate FatalCallback;

    // Callback that occurs when an exception is thrown
    ExceptionDelegate ExceptionThrownCallback;

    // All the virtual tables (of varying sizes) for each native type that has virtual methods bound
    HashMap<BoundType*, byte*> NativeVirtualTables;

    // The handle managers we use to derefence and setup handles
    mutable HashMap<HandleManagerId, HandleManager*> UniqueManagers;

    // Map code entry ids to the code entry itself (the entry will be alive as long as the library is alive)
    // This maintains a list of all code entries used by this state
    HashMap<size_t, CodeEntry*> CodeHashToCodeEntry;

    // Data that we need each time we jump into a new stack frame
    Array<PerFrameData*> StackFrames;
    
    // Every time we allocate a stack frame, we don't actually delete it, but rather put it into this free list of stack frames
    // These are destroyed along with the executable state
    OwnedArray<PerFrameData*> RecycledFrames;

    // Recycled for memory efficiency (see RecycledFrames)
    OwnedArray<PerScopeData*> RecycledScopes;

    // This stack of string builders that we use for efficient concatenation of strings
    Array<StringBuilder> StringBuilders;

    // In the case where we have no globally set timeout, and we have no timeout statements,
    // this array will be empty. Otherwise if a timeout exists it will be checked by the
    // virtual machine
    // Note: Timeouts are closely related to stack frames, as they can only be pushed
    // or popped by the same stack frame
    Array<Timeout> Timeouts;

    // The timer we use to measure timeouts
    // Ideally this timer would have a high fidelity to prevent timing inaccuracies
    Timer TimeoutTimer;

    // The amount of time we require when executing a timeout
    // A value of 0 means that we don't perform any timeouts
    // This value is only used when we enter the first function on the call stack
    size_t TimeoutSeconds;

    // The stack data used by the executable state
    // This is the base of the stack, NOT the current stack
    // Note that the stack is of a fixed size, and should never be reallocted
    byte* const Stack;

    // Once we hit a stack overflow we no longer have stack space to invoke anything
    // such as destructors, or constructing the exception itself! To fix this issue,
    // we use an extra reserve of space at the end of the stack, however it is only
    // valid to access that stack space when this flag is set
    // If a destructor then stack overflows while another stack overflow occurred,
    // we hit a fatal error
    bool HitStackOverflow;

    // Not copyable
    ZilchNoCopy(ExecutableState);
  };
  
  // Grab the next value from the stack frame
  // This will push the stack frame pointer forward
  // You can get the current stack frame by calling 'GetCurrentStackFrame'
  // See 'GetCurrentStackFrame' for the calling conventions
  template <typename T>
  T InternalReadValue(byte* stackFrame)
  {
    // Return the read in value and advance the stack forward by the value's size
    typedef typename TypeBinding::StaticTypeId<T>::ReadType ReadType;
    ReadType readValue = TypeBinding::StaticTypeId<T>::Read(stackFrame);
    return TypeBinding::ReferenceCast<ReadType, T>::Cast(readValue);
  }

  // Pushes a value onto the stack frame
  // This will push the stack frame pointer forward
  // You can get the current stack frame by calling 'GetCurrentStackFrame'
  // See 'GetCurrentStackFrame' for the calling conventions
  template <typename T>
  void InternalWriteValue(const T& value, byte* stackFrame)
  {
    // Write the value directly to the stack frame
    typedef typename TypeBinding::StaticTypeId<T>::UnqualifiedType& ToType;
    typedef typename TypeBinding::StripConst<T>::Type& FromType;
    ZilchStaticType(T)::Write(TypeBinding::ReferenceCast<FromType, ToType>::Cast((FromType)value), stackFrame);
  }

  // Grab the next reference type from the stack frame
  // This will push the stack frame pointer forward
  // You can get the current stack frame by calling 'GetCurrentStackFrame'
  // See 'GetCurrentStackFrame' for the calling conventions
  template <typename T>
  T InternalReadRef(byte* stackFrame)
  {
    // Read the handle that will point at the string from the stack
    Handle& handle = *(Handle*)stackFrame;

    // Read the data from the handle by dereferencing it
    byte* data = handle.Dereference();

    // Read the value from the handle data
    return InternalReadValue<T>(data);
  }

  template <typename T>
  void InternalWriteRef(const T& value, byte* stackFrame, const ExecutableState* state)
  {
    // Get the type we're trying to write
    BoundType* type = ZilchTypeId(T);

    // Grab the handle manager via the state
    HandleManager* manager = state->GetHandleManager(type->HandleManager);

    // Create a handle that goes with the given manager index
    Handle* handle = new (stackFrame) Handle();
    handle->Manager = manager;

    // If this is a redirected type...
    if (ZilchStaticType(T)::DirectRead)
    {
      // Get a raw pointer to the value (removes all const, reference, and other qualifiers)
      ZilchStrip(T)* pointerToValue = ZilchToPointer(value);
      handle->Type = ZilchVirtualTypeId(pointerToValue);

      // Setup the newly created handle
      manager->ObjectToHandle((const byte*)pointerToValue, *handle);
    }
    else
    {
      // Write the value to a temporary buffer
      size_t size = sizeof(typename ZilchStaticType(T)::RepresentedType);
      byte* data = (byte*)alloca(size);

      // This was a redirect, so just take the type of the redirect and put it on the handle
      handle->Type = type;

      // Convert the value to the redirected type within our temporary buffer
      InternalWriteValue<T>(value, data);

      // Setup the newly created handle
      manager->ObjectToHandle(data, *handle);

      // Invoke the destructor on the temporary memory
      typedef typename ZilchStaticType(T)::RepresentedType RepresentedType;
      ((RepresentedType*)data)->~RepresentedType();
    }
  }

  class Call
  {
  public:
    friend class ExecutableState;
    friend class VirtualMachine;

    // Constructor for calling a function
    Call(Function* function, ExecutableState* state);

    // Constructor for calling a delegate (automatically sets the this handle)
    Call(const Delegate& delegate, ExecutableState* state);

    // Destructor (constructor is private so only the ExecutableState can create it)
    ~Call();

    // All getters and setters below perform checks on the size and type (if possible)
    // These are special constants that represent the 'this' handle and return value
    static const size_t Return  = (size_t)-1;
    static const size_t This    = (size_t)-2;

    // Set either a parameter or return for the call (value types only, this not allowed)
    void SetValue(size_t index, const byte* input, size_t size);

    // Set either a parameter, return, or this handle for the call
    void SetHandle(size_t index, const Handle& value);

    // Set either a parameter or return for the call (this not allowed)
    void SetDelegate(size_t index, const Delegate& value);
    
    // Set either a parameter or return for the call (value types only, this not allowed)
    template <typename T>
    void SetValue(size_t index, const T& value)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(typename ZilchStaticType(T)::RepresentedType), ZilchTypeId(T), CheckPrimitive::Value, Direction::Set);

      // Finally, copy the input into the stack position
      InternalWriteValue<T>(value, stack);
    }
    
    // Set either a parameter, return, or this handle for the call (reference types only)
    template <typename T>
    void SetHandle(size_t index, const T& value)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(Handle), ZilchTypeId(T), CheckPrimitive::Handle, Direction::Set);

      // Finally, copy the input into the stack position
      InternalWriteRef<T>(value, stack, this->Data->State);
    }

    // Set either a parameter, return, or this handle for the call
    // This method auto determines whether it's reference or value type
    template <typename T>
    void Set(size_t index, const T& value)
    {
      // If the type is a reference type...
      if (ZilchStaticType(T)::CopyMode == TypeCopyMode::ReferenceType)
      {
        this->SetHandle<T>(index, value);
      }
      // Otherwise it must be a value type...
      else
      {
        this->SetValue<T>(index, value);
      }
    }

    // Get either a parameter or return from the call (value types only, this not allowed)
    void GetValue(size_t index, byte* output, size_t size);
    
    // Get either a parameter, return, or this handle from the call
    Handle& GetHandle(size_t index);
    
    // Get either a parameter or return from the call (this not allowed)
    Delegate& GetDelegate(size_t index);

    // Get either a parameter or return from the call (value types only, this not allowed)
    template <typename T>
    T GetValue(size_t index)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(typename ZilchStaticType(T)::RepresentedType), ZilchTypeId(T), CheckPrimitive::Value, Direction::Get);
      
      // Read the value from the stack and return it (or convert it)
      return InternalReadValue<T>(stack);
    }
    
    // Get either a parameter, return, or this handle from the call (reference types only)
    template <typename T>
    T GetHandle(size_t index)
    {
      // Get the stack location and perform checks
      byte* stack = this->GetChecked(index, sizeof(Handle), ZilchTypeId(T), CheckPrimitive::Handle, Direction::Get);
      
      // Read the value from the stack and return it (or convert it)
      return InternalReadRef<T>(stack);
    }

    // Get either a parameter, return, or this handle from the call
    // This method auto determines whether it's reference or value type
    template <typename T>
    T Get(size_t index)
    {
      // If the type is a reference type...
      if (ZilchStaticType(T)::CopyMode == TypeCopyMode::ReferenceType)
      {
        return this->GetHandle<T>(index);
      }
      // Otherwise it must be a value type...
      else
      {
        return this->GetValue<T>(index);
      }
    }
    
    // Invoke the function / call
    // All parameters must be set before invoking (and the 'this' if it's an instance method)
    void Invoke(ExceptionReport& report);

    // Get a reference to the executable state
    ExecutableState* GetState();

    // Get a raw pointer to the stack
    byte* GetStackUnchecked();
    
    // Get a raw pointer to the stack where the 'this' handle is placed
    byte* GetThisUnchecked();

    // Get a raw pointer to the stack where the parameters are placed
    byte* GetParametersUnchecked();

    // Get a raw pointer to the stack where a particular parameter is placed
    byte* GetParameterUnchecked(size_t parameterIndex);

    // Get a raw pointer to the stack where the return is placed
    byte* GetReturnUnchecked();
    
    // Get the function involved in the call
    Function* GetFunction();

    // Makes it so we ignore debug checking for parameters
    // Only set this flag if you plan on raw manipulating the stack
    // If raw manipulation is done, make sure you also clean up the stack manually
    void DisableParameterChecks();

    // Makes it so we ignore debug checking for the 'this' handle
    // Only set this flag if you plan on raw manipulating the stack
    // If raw manipulation is done, make sure you also clean up the stack manually
    void DisableThisChecks();
    
    // Makes it so we ignore debug checking for the return value
    // Only set this flag if you plan on raw manipulating the stack
    // If raw manipulation is done, make sure you also clean up the stack manually
    void DisableReturnChecks();

    // Disables the automatic destruction of parameters at the end of the call
    // Only disable this feature if you plan on manually cleaning up the stack
    void DisableParameterDestruction();
    
    // Disables the automatic destruction of the 'this' handle at the end of the call
    // Only disable this feature if you plan on manually cleaning up the stack
    void DisableThisDestruction();
    
    // Disables the automatic destruction of the return value at the end of the call
    // Only disable this feature if you plan on manually cleaning up the stack
    void DisableReturnDestruction();

    // Tells the debugging features that the parameter, return, or this handle was set
    // Only use this if you set the return via direct stack memory
    void MarkAsSet(size_t index);

    // Tells the debugging features that the return value was set
    // Only use this if you set the return via direct stack memory
    void MarkReturnAsSet();

    // Tells the debugging features that the 'this' handle was set
    // Only use this if you set the return via direct stack memory
    void MarkThisAsSet();

    // Tells the debugging features that the 'this' handle was set
    // Only use this if you set the return via direct stack memory
    void MarkParameterAsSet(size_t parameterIndex);

    // Get a generic stack location and do error checking
    byte* GetChecked(size_t index, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

  private:
    
    // Run a set of checks on the given type / size
    void PerformStandardChecks(size_t size, Type* userType, Type* actualType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Get a stack location to the 'this' handle and do error checking
    byte* GetThisChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Get a stack location to the return and do error checking
    byte* GetReturnChecked(size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Get a stack location to the given parameter and do error checking
    byte* GetParameterChecked(size_t parameterIndex, size_t size, Type* userType, CheckPrimitive::Enum primitive, Direction::Enum io);

    // Constructor for the virtual machine call
    Call(PerFrameData* data);

    // Make sure we can't copy this around
    ZilchNoCopy(Call);

  private:

    // Every call corresponds with per frame data
    PerFrameData* Data;
  };

  // Set the Any type (handled specially so we can bind 'Any')
  template <>
  void Call::Set<Any>(size_t index, const Any& value);
    
  // Get the Any type (handle pointer, reference, and const types)
  template <>       Any* Call::Get<      Any*>(size_t index);
  template <>       Any  Call::Get<      Any >(size_t index);
  template <>       Any& Call::Get<      Any&>(size_t index);
  template <> const Any* Call::Get<const Any*>(size_t index);
  template <> const Any& Call::Get<const Any&>(size_t index);

  // Set the Handle type (handled specially so we can bind 'Handle')
  template <>
  void Call::Set<Handle>(size_t index, const Handle& value);
    
  // Get the Handle type (handle pointer, reference, and const types)
  template <>       Handle* Call::Get<      Handle*>(size_t index);
  template <>       Handle  Call::Get<      Handle >(size_t index);
  template <>       Handle& Call::Get<      Handle&>(size_t index);
  template <> const Handle* Call::Get<const Handle*>(size_t index);
  template <> const Handle& Call::Get<const Handle&>(size_t index);

  // Set the Delegate type (handled specially so we can bind 'Delegate')
  template <>
  void Call::Set<Delegate>(size_t index, const Delegate& value);
    
  // Get the Delegate type (handle pointer, reference, and const types)
  template <>       Delegate* Call::Get<      Delegate*>(size_t index);
  template <>       Delegate  Call::Get<      Delegate >(size_t index);
  template <>       Delegate& Call::Get<      Delegate&>(size_t index);
  template <> const Delegate* Call::Get<const Delegate*>(size_t index);
  template <> const Delegate& Call::Get<const Delegate&>(size_t index);

}

// End header protection
#endif

namespace Zilch
{
  namespace PropertyBinding
  {
    enum Enum
    {
      Get,
      Set,
      GetSet
    };
  }

  // All things relevant to binding methods
  class TemplateBinding
  {
  public:

    // Given a space delimited string of names (eg, "destination source size") this will fill in the parameter array with
    // those names. The number of parameters must match the number of parsed names. All names should be lower-camel case
    // For generic use, if the names list is empty, this will immediately return with no errors
    static void ParseParameterArrays(ParameterArray& parameters, StringParam spaceDelimitedNames);

    // Include all the binding code
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

//BeginBound
template <typename FunctionType, FunctionType function>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  function();
}
//EndBound
template <typename FunctionType, FunctionType function>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (*)() )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  function(arg0);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (*)(Arg0) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  function(arg0, arg1);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  function(arg0, arg1, arg2);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  function(arg0, arg1, arg2, arg3);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundStatic(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  function(arg0, arg1, arg2, arg3, arg4);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundStatic<FunctionType, function, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  Return result = function();
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (*)() )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  Return result = function(arg0);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (*)(Arg0) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  Return result = function(arg0, arg1);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  Return result = function(arg0, arg1, arg2);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  Return result = function(arg0, arg1, arg2, arg3);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundStaticReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  Return result = function(arg0, arg1, arg2, arg3, arg4);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromStatic(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundStaticReturn<FunctionType, function, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Static
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)();
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)() )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1, arg2);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1, arg2, arg3);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundInstance(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  (self->*function)(arg0, arg1, arg2, arg3, arg4);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)();
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)() )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1, arg2);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1, arg2, arg3);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}
//BeginBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundInstanceReturn(Call& call, ExceptionReport& report)
{
  ZilchBindingType(Arg0) arg0 = call.Get<ZilchBindingType(Arg0)>(0);
  ZilchBindingType(Arg1) arg1 = call.Get<ZilchBindingType(Arg1)>(1);
  ZilchBindingType(Arg2) arg2 = call.Get<ZilchBindingType(Arg2)>(2);
  ZilchBindingType(Arg3) arg3 = call.Get<ZilchBindingType(Arg3)>(3);
  ZilchBindingType(Arg4) arg4 = call.Get<ZilchBindingType(Arg4)>(4);
  Class* self = (Class*)call.GetHandle(Call::This).Dereference();
  Return result = (self->*function)(arg0, arg1, arg2, arg3, arg4);
  call.Set<Return>(Call::Return, result);
}
//EndBound
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) )
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)() const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) const)
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)() const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromInstance(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4) const)
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::None
  );
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

template <typename FunctionType, FunctionType function, typename Class>
void VirtualThunk()
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)())
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void>));
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
void VirtualThunk(Arg0 arg0)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
void VirtualThunk(Arg0 arg0, Arg1 arg1)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
void VirtualThunk(Arg0 arg0, Arg1 arg1, Arg2 arg2)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1, Arg2>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
void VirtualThunk(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1, Arg2, Arg3>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
void VirtualThunk(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  call.Set<Arg4>(4, arg4);
  ExceptionReport report;
  call.Invoke(report);
  return ;
}
template <typename FunctionType, FunctionType function, typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, void (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4))
{
  BoundFn boundFunction = BoundInstance<FunctionType, function, Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ZilchAutoVal(thunk, (&VirtualThunk<FunctionType, function, Class, void, Arg0, Arg1, Arg2, Arg3, Arg4>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(void),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return>
Return VirtualThunkReturn()
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)())
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return>));
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
Return VirtualThunkReturn(Arg0 arg0)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1, Arg2 arg2)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Return VirtualThunkReturn(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
{
  byte* virtualTable = *(byte**)this;
  byte* typePointer = virtualTable - sizeof(BoundType*) - sizeof(ExecutableState*);
  byte* executableStatePointer = virtualTable - sizeof(ExecutableState*);
  BoundType* type = *(BoundType**)typePointer;
  ExecutableState* state = *(ExecutableState**)(executableStatePointer);
  GuidType virtualId = type->Hash() ^ TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionToCall = state->ThunksToFunctions.findValue(virtualId, nullptr);
  ErrorIf(functionToCall == nullptr,
    "There was no function found by the guid, what happened?");
  HandleManagers& managers = HandleManagers::GetInstance();
  HandleManager* pointerManager = managers.GetSharedManager(ZilchManagerId(PointerManager));
  Handle thisHandle;
  thisHandle.Manager = pointerManager;
  thisHandle.Type = type;
  pointerManager->ObjectToHandle((byte*)this, thisHandle);
  Call call(functionToCall, state);
  call.SetHandle(Call::This, thisHandle);
  call.Set<Arg0>(0, arg0);
  call.Set<Arg1>(1, arg1);
  call.Set<Arg2>(2, arg2);
  call.Set<Arg3>(3, arg3);
  call.Set<Arg4>(4, arg4);
  ExceptionReport report;
  call.Invoke(report);
  return call.Get<Return>(Call::Return);
}
template <typename FunctionType, FunctionType function, typename Class, typename Return, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam name, StringParam spaceDelimitedNames, Return (Class::*)(Arg0, Arg1, Arg2, Arg3, Arg4))
{
  BoundFn boundFunction = BoundInstanceReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ZilchAutoVal(thunk, (&VirtualThunkReturn<FunctionType, function, Class, Return, Arg0, Arg1, Arg2, Arg3, Arg4>));
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  NativeVirtualInfo nativeVirtual;
  nativeVirtual.Index = TypeBinding::GetVirtualMethodIndex(function);
  nativeVirtual.Thunk = (TypeBinding::VirtualTableFn)thunk;
  nativeVirtual.Guid = TypeBinding::GetFunctionUniqueId<FunctionType, function>();
  Function* functionRef = builder.AddBoundFunction
  (
    classBoundType,
    name,
    boundFunction,
    parameters,
    ZilchTypeId(Return),
    FunctionOptions::Virtual,
    nativeVirtual
  );
  ++classBoundType->BoundNativeVirtualCount;
  ErrorIf(classBoundType->BoundNativeVirtualCount > classBoundType->RawNativeVirtualCount,
    "The number of bound virtual functions must never exceed the actual v-table count");
  return functionRef;
}

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

template <typename Class>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class();
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class();
}
template <typename Class>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class>;
  ParameterArray parameters;
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0);
}
template <typename Class, typename Arg0>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1);
}
template <typename Class, typename Arg0, typename Arg1>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1, Arg2>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1, Arg2, Arg3>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundConstructorVirtual(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Arg4 arg4 = call.Get<Arg4>(4);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3, arg4);
  call.GetState()->UpdateCppVirtualTable(data, ZilchTypeId(Class), handle.Type);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromConstructorVirtual(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructorVirtual<Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static void BoundConstructor(Call& call, ExceptionReport& report)
{
  Arg0 arg0 = call.Get<Arg0>(0);
  Arg1 arg1 = call.Get<Arg1>(1);
  Arg2 arg2 = call.Get<Arg2>(2);
  Arg3 arg3 = call.Get<Arg3>(3);
  Arg4 arg4 = call.Get<Arg4>(4);
  Handle& handle = call.GetHandle(Call::This);
  byte* data = handle.Dereference();
  new (data) Class(arg0, arg1, arg2, arg3, arg4);
}
template <typename Class, typename Arg0, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
static Function* FromConstructor(LibraryBuilder& builder, BoundType* classBoundType, StringParam spaceDelimitedNames)
{
  BoundFn boundFunction = BoundConstructor<Class, Arg0, Arg1, Arg2, Arg3, Arg4>;
  ParameterArray parameters;
  DelegateParameter& p0 = parameters.push_back();
  p0.ParameterType = ZilchTypeId(Arg0);
  DelegateParameter& p1 = parameters.push_back();
  p1.ParameterType = ZilchTypeId(Arg1);
  DelegateParameter& p2 = parameters.push_back();
  p2.ParameterType = ZilchTypeId(Arg2);
  DelegateParameter& p3 = parameters.push_back();
  p3.ParameterType = ZilchTypeId(Arg3);
  DelegateParameter& p4 = parameters.push_back();
  p4.ParameterType = ZilchTypeId(Arg4);
  ParseParameterArrays(parameters, spaceDelimitedNames);
  return builder.AddBoundConstructor
  (
    classBoundType,
    boundFunction,
    parameters
  );
}

    // Wraps a destructor call with the Zilch signature
    template <typename Class>
    static void BoundDestructor(Call& call, ExceptionReport& report)
    {
      //// Get our self object
      //Class* self = call.Get<Class*>(Call::This);

      // We need to investigate why the above call doesn't work
      // Unfortunately this comment is written whilst looking back, and I don't understand
      // why I had commented the above out. My guess would be that for struct types (value types)
      // the 'this type' is actually the ref instead of the type itself... something like that
      // Most likely the handle is storing the BoundType*, eg Quaternion, instead of the IndirectionType*
      // Why doesn't this appear elswhere, say the field get functions?
      Handle& selfHandle = call.GetHandle(Call::This);
      Class* self = (Class*)selfHandle.Dereference();

      // Explicitly call the destructor of the class
      self->~Class();
    }

    // Generates a Zilch function to call a class destructor
    template <typename Class>
    static Function* FromDestructor(LibraryBuilder& builder, BoundType* classBoundType)
    {
      return builder.AddBoundDestructor(classBoundType, BoundDestructor<Class>);
    }

    template <typename Field, typename Class, Field Class::* field>
    static void BoundInstanceGet(Call& call, ExceptionReport& report)
    {
      // Get our self object
      Class* self = call.Get<Class*>(Call::This);

      // Get the value of the member
      Field& value = self->*field;

      // Get the member's value by returning it
      call.Set(Call::Return, value);
    }

    template <typename Field, typename Class, Field Class::* field>
    static void BoundInstanceSet(Call& call, ExceptionReport& report)
    {
      // Get our self object
      Class* self = call.Get<Class*>(Call::This);

      // Read in the value that we're trying to set
      Field value = call.Get<Field>(0);

      // Set the value of the member
      self->*field = value;
    }

    // Generates a Zilch property for a bound instance member that includes a get/set function
    template <typename FieldPtr, FieldPtr field, typename Class, typename Field>
    static Property* FromInstanceField(LibraryBuilder& builder, BoundType* owner, StringParam name, Field Class::* dummy, PropertyBinding::Enum mode)
    {
      ErrorIf(dummy != field, "The dummy should always match our template member");
      BoundFn set = BoundInstanceSet<Field, Class, field>;
      BoundFn get = BoundInstanceGet<Field, Class, field>;
      
      if (mode == PropertyBinding::Get)
      {
        set = nullptr;
      }
      if (mode == PropertyBinding::Set)
      {
        get = nullptr;
      }

      return builder.AddBoundProperty(owner, name, ZilchTypeId(Field), set, get, MemberOptions::None);
    }

    template <typename Field, Field* field>
    static void BoundStaticGet(Call& call, ExceptionReport& report)
    {
      // Get the value of the member
      Field& value = *field;

      // Get the member's value by returning it
      call.Set(Call::Return, value);
    }

    template <typename Field, Field* field>
    static void BoundStaticSet(Call& call, ExceptionReport& report)
    {
      // Read in the value that we're trying to set
      Field value = call.Get<Field>(0);

      // Set the value of the member
      *field = value;
    }

    // Generates a Zilch property for a bound instance member that includes a get/set function
    template <typename FieldPtr, FieldPtr field, typename Field>
    static Property* FromStaticField(LibraryBuilder& builder, BoundType* owner, StringParam name, Field* dummy, PropertyBinding::Enum mode)
    {
      ErrorIf(dummy != field, "The dummy should always match our template member");
      BoundFn set = BoundStaticSet<Field, field>;
      BoundFn get = BoundStaticGet<Field, field>;
      
      if (mode == PropertyBinding::Get)
      {
        set = nullptr;
      }
      if (mode == PropertyBinding::Set)
      {
        get = nullptr;
      }

      return builder.AddBoundProperty(owner, name, ZilchTypeId(Field), set, get, MemberOptions::Static);
    }
  };

  // A define we use when there is no namespace that
  // a binding is in to make it clear that it's global
  #define ZilchGlobal

  // Workhorse macro for binding methods
  #define ZilchBindMethodHelper(ZilchBuilder, ZilchType, Kind, MethodPtr, Name, NamedParameters, Signature)                   Zilch::TemplateBinding::From##Kind<Signature, MethodPtr>(ZilchBuilder, ZilchType, Name, NamedParameters, static_cast<Signature>(MethodPtr))

  // Property binding
  #define ZilchBindInternalInstanceGetSet(Method) \

  // Method binding (including aliases)
  #define ZilchBindInternalStaticMethod(Method) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, #Method, Zilch::String(), ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindStaticMethod(Method) \
    ZilchBindInternalStaticMethod(Method)
  #define ZilchBindInternalStaticMethodAs(Method, Name) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, Name, Zilch::String(), ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindStaticMethodAs(Method, Name) \
    ZilchBindInternalStaticMethodAs(Method, Name)
  #define ZilchBindInternalStaticNamedParameterMethod(Method, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, #Method, NamedParameters, ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindStaticNamedParameterMethod(Method, NamedParameters) \
    ZilchBindInternalStaticMethod(Method, NamedParameters)
  #define ZilchBindInternalStaticNamedParameterMethodAs(Method, Name, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, Name, NamedParameters, ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindStaticNamedParameterMethodAs(Method, Name, NamedParameters) \
    ZilchBindInternalStaticMethodAs(Method, Name, NamedParameters)
  #define ZilchBindInternalStaticMethodOverload(Method, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, #Method, Zilch::String(), ReturnType (*) (__VA_ARGS__))
  #define ZilchBindStaticMethodOverload(Method, ReturnType, ...) \
    ZilchBindInternalStaticMethodOverload(Method, ReturnType, __VA_ARGS__)
  #define ZilchBindInternalStaticMethodOverloadAs(Method, Name, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, Name, Zilch::String(), ReturnType (*) (__VA_ARGS__))
  #define ZilchBindStaticMethodOverloadAs(Method, Name, ReturnType, ...) \
    ZilchBindInternalStaticMethodOverloadAs(Method, Name, ReturnType, __VA_ARGS__)
  #define ZilchBindInternalStaticNamedParameterMethodOverload(Method, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, #Method, NamedParameters, ReturnType (*) (__VA_ARGS__))
  #define ZilchBindStaticNamedParameterMethodOverload(Method, NamedParameters, ReturnType, ...) \
    ZilchBindInternalStaticMethodOverload(Method, NamedParameters, ReturnType, __VA_ARGS__)
  #define ZilchBindInternalStaticNamedParameterMethodOverloadAs(Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &ZilchSelf::Method, Name, NamedParameters, ReturnType (*) (__VA_ARGS__))
  #define ZilchBindStaticNamedParameterMethodOverloadAs(Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindInternalStaticMethodOverloadAs(Method, Name, NamedParameters, ReturnType, __VA_ARGS__)
  #define ZilchBindInternalInstanceMethod(Method) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, #Method, Zilch::String(), ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindMethod(Method) \
    ZilchBindInternalInstanceMethod(Method)
  #define ZilchBindInternalInstanceMethodAs(Method, Name) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, Name, Zilch::String(), ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindMethodAs(Method, Name) \
    ZilchBindInternalInstanceMethodAs(Method, Name)
  #define ZilchBindInternalInstanceNamedParameterMethod(Method, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, #Method, NamedParameters, ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindNamedParameterMethod(Method, NamedParameters) \
    ZilchBindInternalInstanceMethod(Method, NamedParameters)
  #define ZilchBindInternalInstanceNamedParameterMethodAs(Method, Name, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, Name, NamedParameters, ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindNamedParameterMethodAs(Method, Name, NamedParameters) \
    ZilchBindInternalInstanceMethodAs(Method, Name, NamedParameters)
  #define ZilchBindInternalInstanceMethodOverload(Method, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, #Method, Zilch::String(), ReturnType (ZilchSelf::*) (__VA_ARGS__))
  #define ZilchBindMethodOverload(Method, ReturnType, ...) \
    ZilchBindInternalInstanceMethodOverload(Method, ReturnType, __VA_ARGS__)
  #define ZilchBindInternalInstanceMethodOverloadAs(Method, Name, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, Name, Zilch::String(), ReturnType (ZilchSelf::*) (__VA_ARGS__))
  #define ZilchBindMethodOverloadAs(Method, Name, ReturnType, ...) \
    ZilchBindInternalInstanceMethodOverloadAs(Method, Name, ReturnType, __VA_ARGS__)
  #define ZilchBindInternalInstanceNamedParameterMethodOverload(Method, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, #Method, NamedParameters, ReturnType (ZilchSelf::*) (__VA_ARGS__))
  #define ZilchBindNamedParameterMethodOverload(Method, NamedParameters, ReturnType, ...) \
    ZilchBindInternalInstanceMethodOverload(Method, NamedParameters, ReturnType, __VA_ARGS__)
  #define ZilchBindInternalInstanceNamedParameterMethodOverloadAs(Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &ZilchSelf::Method, Name, NamedParameters, ReturnType (ZilchSelf::*) (__VA_ARGS__))
  #define ZilchBindNamedParameterMethodOverloadAs(Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindInternalInstanceMethodOverloadAs(Method, Name, NamedParameters, ReturnType, __VA_ARGS__)
  #define ZilchBindExternalStaticMethod(NamespaceAndClass, Method) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, #Method, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalStaticMethodAs(NamespaceAndClass, Method, Name) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, Name, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalStaticNamedParameterMethod(NamespaceAndClass, Method, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, #Method, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalStaticNamedParameterMethodAs(NamespaceAndClass, Method, Name, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, Name, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalStaticMethodOverload(NamespaceAndClass, Method, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, #Method, Zilch::String(), ReturnType (*) (__VA_ARGS__))
  #define ZilchBindExternalStaticMethodOverloadAs(NamespaceAndClass, Method, Name, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, Name, Zilch::String(), ReturnType (*) (__VA_ARGS__))
  #define ZilchBindExternalStaticNamedParameterMethodOverload(NamespaceAndClass, Method, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, #Method, NamedParameters, ReturnType (*) (__VA_ARGS__))
  #define ZilchBindExternalStaticNamedParameterMethodOverloadAs(NamespaceAndClass, Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Static, &NamespaceAndClass::Method, Name, NamedParameters, ReturnType (*) (__VA_ARGS__))
  #define ZilchBindExternalInstanceMethod(NamespaceAndClass, Method) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, #Method, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalMethod(NamespaceAndClass, Method) \
    ZilchBindExternalInstanceMethod(NamespaceAndClass, Method)
  #define ZilchBindExternalInstanceMethodAs(NamespaceAndClass, Method, Name) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, Name, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalMethodAs(NamespaceAndClass, Method, Name) \
    ZilchBindExternalInstanceMethodAs(NamespaceAndClass, Method, Name)
  #define ZilchBindExternalInstanceNamedParameterMethod(NamespaceAndClass, Method, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, #Method, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalNamedParameterMethod(NamespaceAndClass, Method, NamedParameters) \
    ZilchBindExternalInstanceMethod(NamespaceAndClass, Method, NamedParameters)
  #define ZilchBindExternalInstanceNamedParameterMethodAs(NamespaceAndClass, Method, Name, NamedParameters) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, Name, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindExternalNamedParameterMethodAs(NamespaceAndClass, Method, Name, NamedParameters) \
    ZilchBindExternalInstanceMethodAs(NamespaceAndClass, Method, Name, NamedParameters)
  #define ZilchBindExternalInstanceMethodOverload(NamespaceAndClass, Method, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, #Method, Zilch::String(), ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindExternalMethodOverload(NamespaceAndClass, Method, ReturnType, ...) \
    ZilchBindExternalInstanceMethodOverload(NamespaceAndClass, Method, ReturnType, __VA_ARGS__)
  #define ZilchBindExternalInstanceMethodOverloadAs(NamespaceAndClass, Method, Name, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, Name, Zilch::String(), ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindExternalMethodOverloadAs(NamespaceAndClass, Method, Name, ReturnType, ...) \
    ZilchBindExternalInstanceMethodOverloadAs(NamespaceAndClass, Method, Name, ReturnType, __VA_ARGS__)
  #define ZilchBindExternalInstanceNamedParameterMethodOverload(NamespaceAndClass, Method, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, #Method, NamedParameters, ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindExternalNamedParameterMethodOverload(NamespaceAndClass, Method, NamedParameters, ReturnType, ...) \
    ZilchBindExternalInstanceMethodOverload(NamespaceAndClass, Method, NamedParameters, ReturnType, __VA_ARGS__)
  #define ZilchBindExternalInstanceNamedParameterMethodOverloadAs(NamespaceAndClass, Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(builder, type, Instance, &NamespaceAndClass::Method, Name, NamedParameters, ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindExternalNamedParameterMethodOverloadAs(NamespaceAndClass, Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindExternalInstanceMethodOverloadAs(NamespaceAndClass, Method, Name, NamedParameters, ReturnType, __VA_ARGS__)
  #define ZilchBindCustomStaticMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, #Method, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomStaticMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, Name, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomStaticNamedParameterMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, #Method, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomStaticNamedParameterMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, Name, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomStaticMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, #Method, Zilch::String(), ReturnType (*) (__VA_ARGS__))
  #define ZilchBindCustomStaticMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, Name, Zilch::String(), ReturnType (*) (__VA_ARGS__))
  #define ZilchBindCustomStaticNamedParameterMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, #Method, NamedParameters, ReturnType (*) (__VA_ARGS__))
  #define ZilchBindCustomStaticNamedParameterMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Method, Name, NamedParameters, ReturnType (*) (__VA_ARGS__))
  #define ZilchBindCustomInstanceMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, #Method, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method) \
    ZilchBindCustomInstanceMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method)
  #define ZilchBindCustomInstanceMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, Name, Zilch::String(), ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name) \
    ZilchBindCustomInstanceMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name)
  #define ZilchBindCustomInstanceNamedParameterMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, #Method, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomNamedParameterMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters) \
    ZilchBindCustomInstanceMethod(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters)
  #define ZilchBindCustomInstanceNamedParameterMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, Name, NamedParameters, ZilchTypeOf(&NamespaceAndClass::Method))
  #define ZilchBindCustomNamedParameterMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters) \
    ZilchBindCustomInstanceMethodAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters)
  #define ZilchBindCustomInstanceMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, #Method, Zilch::String(), ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindCustomMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, ReturnType, ...) \
    ZilchBindCustomInstanceMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, ReturnType, __VA_ARGS__)
  #define ZilchBindCustomInstanceMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, Name, Zilch::String(), ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindCustomMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, ReturnType, ...) \
    ZilchBindCustomInstanceMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, ReturnType, __VA_ARGS__)
  #define ZilchBindCustomInstanceNamedParameterMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, #Method, NamedParameters, ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindCustomNamedParameterMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters, ReturnType, ...) \
    ZilchBindCustomInstanceMethodOverload(ZilchBuilder, ZilchType, NamespaceAndClass, Method, NamedParameters, ReturnType, __VA_ARGS__)
  #define ZilchBindCustomInstanceNamedParameterMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindMethodHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Method, Name, NamedParameters, ReturnType (NamespaceAndClass::*) (__VA_ARGS__))
  #define ZilchBindCustomNamedParameterMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters, ReturnType, ...) \
    ZilchBindCustomInstanceMethodOverloadAs(ZilchBuilder, ZilchType, NamespaceAndClass, Method, Name, NamedParameters, ReturnType, __VA_ARGS__)

  // Workhorse macro for binding virtual methods
  #define ZilchBindVirtualMethodHelper(ZilchBuilder, ZilchType, MethodPtr, Name, Signature)                                   Zilch::TemplateBinding::FromVirtual<Signature, MethodPtr>(ZilchBuilder, ZilchType, Name, static_cast<Signature>(MethodPtr))

  // Virtual method binding (including aliases)
  #define ZilchBindInternalVirtualMethod(Method)                                                                              ZilchBindVirtualMethodHelper(builder, type, &ZilchSelf::Method, #Method, ZilchTypeOf(&ZilchSelf::Method))
  #define ZilchBindVirtualMethod(Method)                                                                                      ZilchBindInternalVirtualMethod(Method)
  
  // Constructor and destructor binding (including aliases)
  #define ZilchBindInternalConstructor(...)                                                                                   Zilch::TemplateBinding::FromConstructor<ZilchSelf, ##__VA_ARGS__>(builder, type, Zilch::String())
  #define ZilchBindInternalConstructorVirtual(...)                                                                            Zilch::TemplateBinding::FromConstructorVirtual<ZilchSelf, ##__VA_ARGS__>(builder, type, Zilch::String())
  #define ZilchBindInternalDestructor()                                                                                       Zilch::TemplateBinding::FromDestructor<ZilchSelf>(builder, type)
  #define ZilchBindConstructor(...)                                                                                           ZilchBindInternalConstructor(__VA_ARGS__)
  #define ZilchBindVirtualConstructor(...)                                                                                    ZilchBindInternalConstructorVirtual(__VA_ARGS__)
  #define ZilchBindDestructor()                                                                                               ZilchBindInternalDestructor()
  #define ZilchBindExternalConstructor(Class, ...)                                                                            Zilch::TemplateBinding::FromConstructor<Class, ##__VA_ARGS__>(builder, type, Zilch::String())
  #define ZilchBindExternalConstructorVirtual(Class, ...)                                                                     Zilch::TemplateBinding::FromConstructorVirtual<Class, ##__VA_ARGS__>(builder, type, Zilch::String())
  #define ZilchBindExternalDestructor(Class)                                                                                  Zilch::TemplateBinding::FromDestructor<Class>(builder, type)
  #define ZilchBindCustomConstructor(ZilchBuilder, ZilchType, Class, ...)                                                     Zilch::TemplateBinding::FromConstructor<Class, ##__VA_ARGS__>(ZilchBuilder, ZilchType, Zilch::String())
  #define ZilchBindCustomConstructorVirtual(ZilchBuilder, ZilchType, Class, ...)                                              Zilch::TemplateBinding::FromConstructorVirtual<Class, ##__VA_ARGS__>(ZilchBuilder, ZilchType, Zilch::String())
  #define ZilchBindCustomDestructor(ZilchBuilder, ZilchType, Class)                                                           Zilch::TemplateBinding::FromDestructor<Class>(ZilchBuilder, ZilchType)

  // Workhorse macro for binding fields (data members)
  #define ZilchBindFieldHelper(ZilchBuilder, ZilchType, Kind, FieldPtr, Name, IoMode)                                         Zilch::TemplateBinding::From##Kind##Field<ZilchTypeOf(FieldPtr), FieldPtr>(ZilchBuilder, ZilchType, Name, FieldPtr, Zilch::PropertyBinding::IoMode);

  // Data member binding (including aliases)
  #define ZilchBindInternalStaticFieldGet(Field)                                                                              ZilchBindFieldHelper(builder, type, Static, &ZilchSelf::Field, #Field, Get)
  #define ZilchBindStaticFieldGet(Field)                                                                                      ZilchBindInternalStaticFieldGet(Field)
  #define ZilchBindInternalStaticFieldSet(Field)                                                                              ZilchBindFieldHelper(builder, type, Static, &ZilchSelf::Field, #Field, Set)
  #define ZilchBindStaticFieldSet(Field)                                                                                      ZilchBindInternalStaticFieldSet(Field)
  #define ZilchBindInternalStaticFieldGetSet(Field)                                                                           ZilchBindFieldHelper(builder, type, Static, &ZilchSelf::Field, #Field, GetSet)
  #define ZilchBindStaticFieldGetSet(Field)                                                                                   ZilchBindInternalStaticFieldGetSet(Field)
  #define ZilchBindInternalStaticFieldGetAs(Field, Name)                                                                      ZilchBindFieldHelper(builder, type, Static, &ZilchSelf::Field, Name, Get)
  #define ZilchBindStaticFieldGetAs(Field, Name)                                                                              ZilchBindInternalStaticFieldGetAs(Field, Name)
  #define ZilchBindInternalStaticFieldSetAs(Field, Name)                                                                      ZilchBindFieldHelper(builder, type, Static, &ZilchSelf::Field, Name, Set)
  #define ZilchBindStaticFieldSetAs(Field, Name)                                                                              ZilchBindInternalStaticFieldSetAs(Field, Name)
  #define ZilchBindInternalStaticFieldGetSetAs(Field, Name)                                                                   ZilchBindFieldHelper(builder, type, Static, &ZilchSelf::Field, Name, GetSet)
  #define ZilchBindStaticFieldGetSetAs(Field, Name)                                                                           ZilchBindInternalStaticFieldGetSetAs(Field, Name)
  #define ZilchBindInternalInstanceFieldGet(Field)                                                                            ZilchBindFieldHelper(builder, type, Instance, &ZilchSelf::Field, #Field, Get)
  #define ZilchBindFieldGet(Field)                                                                                            ZilchBindInternalInstanceFieldGet(Field)
  #define ZilchBindInternalInstanceFieldSet(Field)                                                                            ZilchBindFieldHelper(builder, type, Instance, &ZilchSelf::Field, #Field, Set)
  #define ZilchBindFieldSet(Field)                                                                                            ZilchBindInternalInstanceFieldSet(Field)
  #define ZilchBindInternalInstanceFieldGetSet(Field)                                                                         ZilchBindFieldHelper(builder, type, Instance, &ZilchSelf::Field, #Field, GetSet)
  #define ZilchBindFieldGetSet(Field)                                                                                         ZilchBindInternalInstanceFieldGetSet(Field)
  #define ZilchBindInternalInstanceFieldGetAs(Field, Name)                                                                    ZilchBindFieldHelper(builder, type, Instance, &ZilchSelf::Field, Name, Get)
  #define ZilchBindFieldGetAs(Field, Name)                                                                                    ZilchBindInternalInstanceFieldGetAs(Field, Name)
  #define ZilchBindInternalInstanceFieldSetAs(Field, Name)                                                                    ZilchBindFieldHelper(builder, type, Instance, &ZilchSelf::Field, Name, Set)
  #define ZilchBindFieldSetAs(Field, Name)                                                                                    ZilchBindInternalInstanceFieldSetAs(Field, Name)
  #define ZilchBindInternalInstanceFieldGetSetAs(Field, Name)                                                                 ZilchBindFieldHelper(builder, type, Instance, &ZilchSelf::Field, Name, GetSet)
  #define ZilchBindFieldGetSetAs(Field, Name)                                                                                 ZilchBindInternalInstanceFieldGetSetAs(Field, Name)
  #define ZilchBindExternalStaticFieldGet(NamespaceAndClass, Field)                                                           ZilchBindFieldHelper(builder, type, Static, &NamespaceAndClass::Field, #Field, Get)
  #define ZilchBindExternalStaticFieldSet(NamespaceAndClass, Field)                                                           ZilchBindFieldHelper(builder, type, Static, &NamespaceAndClass::Field, #Field, Set)
  #define ZilchBindExternalStaticFieldGetSet(NamespaceAndClass, Field)                                                        ZilchBindFieldHelper(builder, type, Static, &NamespaceAndClass::Field, #Field, GetSet)
  #define ZilchBindExternalStaticFieldGetAs(NamespaceAndClass, Field, Name)                                                   ZilchBindFieldHelper(builder, type, Static, &NamespaceAndClass::Field, Name, Get)
  #define ZilchBindExternalStaticFieldSetAs(NamespaceAndClass, Field, Name)                                                   ZilchBindFieldHelper(builder, type, Static, &NamespaceAndClass::Field, Name, Set)
  #define ZilchBindExternalStaticFieldGetSetAs(NamespaceAndClass, Field, Name)                                                ZilchBindFieldHelper(builder, type, Static, &NamespaceAndClass::Field, Name, GetSet)
  #define ZilchBindExternalInstanceFieldGet(NamespaceAndClass, Field)                                                         ZilchBindFieldHelper(builder, type, Instance, &NamespaceAndClass::Field, #Field, Get)
  #define ZilchBindExternalFieldGet(NamespaceAndClass, Field)                                                                 ZilchBindExternalInstanceFieldGet(NamespaceAndClass, Field)
  #define ZilchBindExternalInstanceFieldSet(NamespaceAndClass, Field)                                                         ZilchBindFieldHelper(builder, type, Instance, &NamespaceAndClass::Field, #Field, Set)
  #define ZilchBindExternalFieldSet(NamespaceAndClass, Field)                                                                 ZilchBindExternalInstanceFieldSet(NamespaceAndClass, Field)
  #define ZilchBindExternalInstanceFieldGetSet(NamespaceAndClass, Field)                                                      ZilchBindFieldHelper(builder, type, Instance, &NamespaceAndClass::Field, #Field, GetSet)
  #define ZilchBindExternalFieldGetSet(NamespaceAndClass, Field)                                                              ZilchBindExternalInstanceFieldGetSet(NamespaceAndClass, Field)
  #define ZilchBindExternalInstanceFieldGetAs(NamespaceAndClass, Field, Name)                                                 ZilchBindFieldHelper(builder, type, Instance, &NamespaceAndClass::Field, Name, Get)
  #define ZilchBindExternalFieldGetAs(NamespaceAndClass, Field, Name)                                                         ZilchBindExternalInstanceFieldGetAs(NamespaceAndClass, Field, Name)
  #define ZilchBindExternalInstanceFieldSetAs(NamespaceAndClass, Field, Name)                                                 ZilchBindFieldHelper(builder, type, Instance, &NamespaceAndClass::Field, Name, Set)
  #define ZilchBindExternalFieldSetAs(NamespaceAndClass, Field, Name)                                                         ZilchBindExternalInstanceFieldSetAs(NamespaceAndClass, Field, Name)
  #define ZilchBindExternalInstanceFieldGetSetAs(NamespaceAndClass, Field, Name)                                              ZilchBindFieldHelper(builder, type, Instance, &NamespaceAndClass::Field, Name, GetSet)
  #define ZilchBindExternalFieldGetSetAs(NamespaceAndClass, Field, Name)                                                      ZilchBindExternalInstanceFieldGetSetAs(NamespaceAndClass, Field, Name)
  #define ZilchBindCustomStaticFieldGet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                    ZilchBindFieldHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Field, #Field, Get)
  #define ZilchBindCustomStaticFieldSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                    ZilchBindFieldHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Field, #Field, Set)
  #define ZilchBindCustomStaticFieldGetSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                 ZilchBindFieldHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Field, #Field, GetSet)
  #define ZilchBindCustomStaticFieldGetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                            ZilchBindFieldHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Field, Name, Get)
  #define ZilchBindCustomStaticFieldSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                            ZilchBindFieldHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Field, Name, Set)
  #define ZilchBindCustomStaticFieldGetSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                         ZilchBindFieldHelper(ZilchBuilder, ZilchType, Static, &NamespaceAndClass::Field, Name, GetSet)
  #define ZilchBindCustomInstanceFieldGet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                  ZilchBindFieldHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Field, #Field, Get)
  #define ZilchBindCustomFieldGet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                          ZilchBindCustomInstanceFieldGet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)
  #define ZilchBindCustomInstanceFieldSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                  ZilchBindFieldHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Field, #Field, Set)
  #define ZilchBindCustomFieldSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                          ZilchBindCustomInstanceFieldSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)
  #define ZilchBindCustomInstanceFieldGetSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                               ZilchBindFieldHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Field, #Field, GetSet)
  #define ZilchBindCustomFieldGetSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)                                       ZilchBindCustomInstanceFieldGetSet(ZilchBuilder, ZilchType, NamespaceAndClass, Field)
  #define ZilchBindCustomInstanceFieldGetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                          ZilchBindFieldHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Field, Name, Get)
  #define ZilchBindCustomFieldGetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                                  ZilchBindCustomInstanceFieldGetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)
  #define ZilchBindCustomInstanceFieldSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                          ZilchBindFieldHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Field, Name, Set)
  #define ZilchBindCustomFieldSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                                  ZilchBindCustomInstanceFieldSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)
  #define ZilchBindCustomInstanceFieldGetSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                       ZilchBindFieldHelper(ZilchBuilder, ZilchType, Instance, &NamespaceAndClass::Field, Name, GetSet)
  #define ZilchBindCustomFieldGetSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)                               ZilchBindCustomInstanceFieldGetSetAs(ZilchBuilder, ZilchType, NamespaceAndClass, Field, Name)
}

// End header protection
#endif

namespace Zilch
{
  // Instantiates an array template when requested
  BoundType* InstantiateArray
  (
    LibraryBuilder& builder,
    StringParam baseName,
    StringParam fullyQualifiedName,
    const Array<Type*>& templateTypes,
    const void* userData
  );
}

// End header protection
#endif
/*
cdecode.h - c header for a base64 decoding algorithm

This is part of the libb64 project, and has been placed in the public domain.
For details, see http://sourceforge.net/projects/libb64
*/

#ifndef BASE64_CDECODE_H
#define BASE64_CDECODE_H

#pragma once

typedef enum
{
	step_a, step_b, step_c, step_d
} base64_decodestep;

typedef struct
{
	base64_decodestep step;
	char plainchar;
} base64_decodestate;

void base64_init_decodestate(base64_decodestate* state_in);

int base64_decode_value(char value_in);

size_t base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in);

#endif /* BASE64_CDECODE_H */

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_CODE_GENERATOR_HPP
#define ZILCH_CODE_GENERATOR_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SYNTAX_TREE_HELPERS_HPP
#define ZILCH_SYNTAX_TREE_HELPERS_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ERROR_HANDLER_HPP
#define ZILCH_ERROR_HANDLER_HPP

// Includes
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_ERROR_DATABASE_HPP
#define ZILCH_ERROR_DATABASE_HPP

// Includes

namespace Zilch
{
  // All the possible errors in the language
  namespace ErrorCode
  {
    enum Enum
    {
      Invalid = -1,

      // Include the generated error enumeration values
AttributeNotComplete = 0,
AttributesNotAttached = 1,
AttributeTypeNotFound = 2,
BaseClassInitializerMustComeFirst = 3,
BaseClassInitializerRequiresBaseClassInheritance = 4,
BaseInitializerRequired = 5,
BinaryOperatorRightOperandNotFound = 6,
BlockCommentNotComplete = 7,
BlockCommentNotFound = 8,
BreakCountMustBeGreaterThanZero = 9,
BreakLoopNotFound = 10,
CannotCreateType = 11,
CannotReplaceTemplateInstanceWithNonTemplateType = 12,
CannotReplaceTemplateInstanceWithTemplateArguments = 13,
CastTypeNotFound = 14,
ClassBodyNotComplete = 15,
ClassBodyNotFound = 16,
ClassNameNotFound = 17,
CompositionCycleDetected = 18,
ConditionMustBeABooleanType = 19,
ConstructorCallNotFound = 20,
ContinueLoopNotFound = 21,
CreatedTypeNotFound = 22,
CreationInitializeMemberExpectedInitialValue = 23,
CreationInitializerExpectedExpression = 24,
CreationInitializerExpectedSubElement = 25,
CreationInitializerNotComplete = 26,
CustomError = 27,
DelegateReturnTypeNotFound = 28,
DeletingNonReferenceType = 29,
DeletingNonWritableValue = 30,
DoWhileBodyNotComplete = 31,
DoWhileBodyNotFound = 32,
DoWhileConditionalExpressionNotComplete = 33,
DoWhileConditionalExpressionNotFound = 34,
DuplicateLocalVariableName = 35,
DuplicateMemberName = 36,
DuplicateTypeName = 37,
EnumBodyNotComplete = 38,
EnumBodyNotFound = 39,
EnumDuplicateValue = 40,
EnumNameNotFound = 41,
EnumValueRequiresIntegerLiteral = 42,
ExternalTypeNamesCollide = 43,
ForEachInKeywordNotFound = 44,
ForEachRangeExpressionNotFound = 45,
ForEachVariableDeclarationNotFound = 46,
ForLoopBodyNotComplete = 47,
ForLoopBodyNotFound = 48,
ForLoopExpressionsNotComplete = 49,
ForLoopExpressionsNotFound = 50,
FunctionArgumentListNotComplete = 51,
FunctionArgumentListNotFound = 52,
FunctionBodyNotComplete = 53,
FunctionBodyNotFound = 54,
FunctionCallExpectedAfterInitializer = 55,
FunctionCallNamedArgumentNotFound = 56,
FunctionCallNotComplete = 57,
FunctionCallOnNonCallableType = 58,
FunctionNameNotFound = 59,
FunctionParameterNotFound = 60,
FunctionReturnTypeNotFound = 61,
GetFoundAfterSet = 62,
GroupingOperatorNotComplete = 63,
IfBodyNotComplete = 64,
IfBodyNotFound = 65,
IfConditionalExpressionNotComplete = 66,
IfConditionalExpressionNotFound = 67,
IndexerIndicesNotFound = 68,
IndexerNotComplete = 69,
InternalError = 70,
InvalidBinaryOperation = 71,
InvalidEscapeInStringLiteral = 72,
InvalidNumberOfTemplateArguments = 73,
InvalidTypeCast = 74,
InvalidUnaryOperation = 75,
AttributeArgumentMustBeLiteral = 76,
LocalCreateMustBeValueType = 77,
LocalVariableReferenceNotFound = 78,
LoneTypeShouldOnlyAppearInAccessingStatics = 79,
LoopBodyNotComplete = 80,
LoopBodyNotFound = 81,
MemberAccessNameNotFound = 82,
MemberNotFound = 83,
MemberVariableTypesCannotBeInferred = 84,
MultipleInheritanceNotSupported = 85,
NoConstructorsProvided = 86,
NotAllPathsReturn = 87,
OnlyOneDestructorAllowed = 88,
OverloadsCannotBeTheSame = 89,
ParameterTypeNotFound = 90,
ParameterTypeSpecifierNotFound = 91,
ParsingNotComplete = 92,
PropertyDeclarationNotComplete = 93,
PropertyDelegateOperatorRequiresProperty = 94,
PropertyDelegateRequiresGetOrSet = 95,
ReadingFromAWriteOnlyValue = 96,
ReferencesOnlyToNamedValueTypes = 97,
ReferenceToUndefinedType = 98,
ReturnTypeMismatch = 99,
ReturnValueNotFound = 100,
ReturnValueUnexpected = 101,
ScopeBodyNotComplete = 102,
ScopeBodyNotFound = 103,
SendsEventStatementNameNotFound = 104,
SendsEventStatementNotComplete = 105,
SendsEventStatementTypeNotFound = 106,
SendsEventStatementTypeSpecifierNotFound = 107,
StatementSeparatorNotFound = 108,
StatementsWillNotBeExecutedEarlyReturn = 109,
StaticCannotBeOverriding = 110,
StaticCannotBeVirtual = 111,
StringInterpolantExpectedExpression = 112,
StringInterpolantNotComplete = 113,
StringLiteralNotComplete = 114,
StructsCanOnlyContainValueTypes = 115,
TemplateArgumentNotFound = 116,
TemplateTypeArgumentsNotComplete = 117,
ThrowExceptionExpressionNotFound = 118,
ThrowTypeMustDeriveFromException = 119,
TimeoutBodyNotComplete = 120,
TimeoutBodyNotFound = 121,
TimeoutSecondsExpectedIntegerLiteral = 122,
TimeoutSecondsMustBeNonZeroPositive = 123,
TimeoutSecondsNotComplete = 124,
TimeoutSecondsNotFound = 125,
TypeIdExpressionNotComplete = 126,
TypeIdExpressionNotFound = 127,
UnableToResolveFunction = 128,
UnaryOperatorOperandNotFound = 129,
UnidentifiedSymbol = 130,
UnnecessaryVirtualAndOverride = 131,
VariableInitializationNotComplete = 132,
VariableInitialValueNotFound = 133,
VariableMustBeInitialized = 134,
VariableNameNotFound = 135,
VariableTypeMismatch = 136,
VariableTypeNotFound = 137,
WhileBodyNotComplete = 138,
WhileBodyNotFound = 139,
WhileConditionalExpressionNotComplete = 140,
WhileConditionalExpressionNotFound = 141,
WritingToAReadOnlyValue = 142,

      Count
    };
  }

  // Store example error information and how it was fixed
  class ErrorExample
  {
  public:
    // The lines of code where the error can be seen
    String ErrorCode;

    // The same lines of code as above, but with the error fixed
    String FixedCode;

    // A brief explanation of the fix
    String ExplanationOfFix;
  };

  // Store information about a particular error
  class ErrorInfo
  {
  public:
    // The error itself (possibly a context sensative string)
    String Error;

    // The name of the error
    String Name;

    // A reason given for why the error occurs that generally explains to the user why it exists and common pitfalls (human friendly!)
    String Reason;

    // A series of examples as to where the error occurs and examples of fixes (as well as a brief explanation)
    Array<ErrorExample> Examples;
  };

  // A created database that stores all the errors
  class ErrorDatabase
  {
  public:

    // Constructor
    ErrorDatabase();

    // Get the error info for a given error code
    const ErrorInfo& GetErrorInfo(ErrorCode::Enum errorCode) const;

  private:

    // Store an array of all the errors and their information
    Array<ErrorInfo> Errors;
  };

  // This structure is what gets reported to the user
  class ErrorDetails
  {
  public:
    // Constructor
    ErrorDetails(const ErrorInfo& info, const CodeLocation& location, ErrorCode::Enum code, va_list args);

    // The specific error code for the error
    ErrorCode::Enum ErrorCode;

    // The location that the error occurred (file/place, line, etc)
    const CodeLocation& Location;

    // Other locations associated with the error
    // For example, duplicate class names would include the other place where the class was defined
    // Never rely upon this being set in certain errors, as sometimes the locations are unknown and do not get populated
    Array<const CodeLocation*> AssociatedOtherLocations;

    // A reason given for why the error occurs that generally explains to the user why it exists and common pitfalls (human friendly!)
    String Reason;

    // The exact error message, including context
    String ExactError;

    // A series of examples as to where the error occurs and examples of fixes (as well as a brief explanation)
    const Array<ErrorExample>& Examples;

    // Get the standard formatting for error messages
    String GetFormattedMessage(MessageFormat::Enum format) const;

  private:

    // Not copyable
    ZilchNoCopy(ErrorDetails);
  };
}

// End header protection
#endif

namespace Zilch
{
  // Type-defines
  typedef void (*ErrorCallback)(const ErrorDetails& errorDetails, const void* userData);
  typedef Array<const CodeLocation*> LocationArray;

  // The default error callback prints compiler errors to stderr
  void DefaultErrorCallback(const ErrorDetails& errorDetails, const void* userData);

  // This class provides a general output handler that we can use in all modules (for outputting messages, warnings, and errors)
  class CompilationErrors
  {
  public:

    // Constructor
    CompilationErrors();

    // Add a callback to the error handler
    void AddCallback(ErrorCallback callback, const void* userData);

    // Print out an error message with extra context (one extra location, given a va_list)
    void RaiseArgs(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, va_list args);

    // Print out an error message (given a va_list)
    void RaiseArgs(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, va_list args);

    // Print out an error message with extra context (multiple locations, given a va_list)
    void RaiseArgs(const CodeLocation& location, ErrorCode::Enum errorCode, va_list args);

    // Print out an error message with extra context (one extra location)
    void Raise(const CodeLocation& location, StringParam extra, const CodeLocation& associatedLocation, ErrorCode::Enum errorCode, ...);

    // Print out an error message with extra context (multiple locations)
    void Raise(const CodeLocation& location, StringParam extra, const LocationArray& associatedLocations, ErrorCode::Enum errorCode, ...);

    // Print out an error message
    void Raise(const CodeLocation& location, ErrorCode::Enum errorCode, ...);

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructableBuffer ComplexUserData;

  public:

    // If set to true, all operations will cease and the stack will be unwound
    // This is used internally for error handling
    bool WasError;

    // If set to true, then any errors we get after the 'WasError' flag is
    // set will be ignored. In general this is only set in a few specific
    // cases and should not be set by the user as it can lead to missed errors
    bool IgnoreMultipleErrors;

    // If this is set, errors will be reported but ignored (which allows parsing and syntaxing to continue)
    bool TolerantMode;

    // Store an error database along with this error handler
    ErrorDatabase Database;

  private:

    // An error delegate is a structure that stores the callback and user-data
    class ErrorDelegate
    {
    public:
      // The associated callback / method
      ErrorCallback Callback;

      // The 'this' pointer to the object
      const void* UserData;
    };

    // Store an array of all error handlers
    PodArray<ErrorDelegate> ErrorHandlers;
  };
}

// End header protection
#endif

namespace Zilch
{
  // This list is used to hold nodes in the tree
  template <typename ValueType>
  class DoublePointerArray : public PodArray<ValueType**>
  {
  public:
    // Type-defines
    typedef PodArray<ValueType**> base;
    
    // Add a node, as long as the value is not null
    template <typename T>
    bool Add(T*& value) // where T : SyntaxNode*
    {
      // Check the value to see if it's null
      if (value != nullptr)
      {
        // It's not, so push it on and return success
        base::push_back((ValueType**)&value);
        return true;
      }

      // We failed to add the node since it was null
      return false;
    }

  private:
    // Don't allow direct pushing back
    void push_back(const ValueType**& item);
    ValueType**& push_back();
  };

  // This list is used to hold nodes in the tree
  template <typename ValueType>
  class PopulatingPointerArray : public PodBlockArray<ValueType*>
  {
  public:
    // Type-defines
    typedef PodBlockArray<ValueType*> base;
    
    // Add a node, as long as the value is not null
    ValueType* Add(ValueType* value)
    {
      // Check the value to see if it's null
      if (value != nullptr)
      {
        // It's not, so push it on and return success
        base::push_back(value);
      }

      // Return whatever was added, so it can be checked if it was valid
      return value;
    }

    // Populates an external list with pointers to each syntax node
    template <typename T>
    void Populate(DoublePointerArray<T>& childrenOut)
    {
      // Reserve space for performance
      childrenOut.reserve(childrenOut.size() + this->size());

      // Loop throuhg all the nodes
      for (size_t i = 0; i < this->size(); ++i)
      {
        childrenOut.Add((*this)[i]);
      }
    }

  private:
    // Don't allow direct pushing back
    void push_back(const ValueType*& item);
    ValueType*& push_back();
  };

  // This list is used to hold nodes of any type in the tree
  template <typename T>
  class NodeList : public PopulatingPointerArray<T>
  {
  };

  // Type-defines
  typedef DoublePointerArray<SyntaxNode> NodeChildren;
  typedef DoublePointerArray<SyntaxType> SyntaxTypes;
  typedef PopulatingPointerArray<SyntaxType> SyntaxTypeList;

  template <typename TreeOwnerType, typename ContextType>
  class BranchWalker;
  
  namespace WalkerFlags
  {
    enum Enum
    {
      None = 0,
      ChildrenNotHandled = 1,
      PreventOtherWalkers = 2,
      Error = 4
    };
    typedef size_t Type;
  }

  template <typename TreeOwnerType, typename ContextType>
  class WalkerContext
  {
  public:
    // Store a pointer back to the walker
    BranchWalker<TreeOwnerType, ContextType>* Walker;

    // These flags get reset with every walk
    WalkerFlags::Type Flags;
  };

  template <typename TreeOwnerType, typename ContextType>
  class BranchWalker
  {
  public:

    // Constructor
    BranchWalker(CompilationErrors* errors = nullptr) :
      WasError(false),
      Errors(errors)
    {
    }

    // The member function type that we'd like to be able to traverse our trees
    typedef void (TreeOwnerType::*MemberFn)(SyntaxNode*& node, ContextType* context);

    // Register a visitor, and the condition is implied to be 
    template <typename ChildType>
    void Register(void (TreeOwnerType::*visitor)(ChildType*& node, ContextType* context))
    {
      RegisterInternal((MemberFn) visitor, ZilchTypeId(ChildType), false);
    }

    // Register a visitor, for a more derived child type
    template <typename DerivedChildType, typename ChildType>
    void RegisterDerived(void (TreeOwnerType::*visitor)(ChildType*& node, ContextType* context))
    {
      RegisterInternal((MemberFn) visitor, ZilchTypeId(DerivedChildType), false);
    }

    // Register a visitor that will visit any node of this base type, even if it derives from it
    template <typename ChildType>
    void RegisterNonLeafBase(void (TreeOwnerType::*visitor)(ChildType*& node, ContextType* context))
    {
      RegisterInternal((MemberFn) visitor, ZilchTypeId(ChildType), true);
    }

    template <typename NodeType>
    void GenericWalkChildren(TreeOwnerType* owner, NodeType*& node, ContextType* context)
    {
      // Now we need to go through every child that wasn't visited
      NodeChildren children;
      node->PopulateChildren(children);

      // Loop through all of the children that matched that type (including derived types)
      for (size_t i = 0; i < children.size(); ++i)
      {
        // Get the current child
        SyntaxNode*& child = *children[i];

        // Walk down to the children
        Walk(owner, child, context);

        // If the error handler is available and an error ocurred...
        if (this->Errors != nullptr && this->Errors->WasError)
          return;
      }
    }

    // Using the registered visitors, visit all of the direct child nodes
    template <typename NodeType>
    void Walk(TreeOwnerType* owner, NodeList<NodeType>& nodes, ContextType* context)
    {
      // Loop through all the nodes in the list
      for (size_t i = 0; i < nodes.size(); ++i)
      {
        // Get the current node
        NodeType*& node = nodes[i];

        // Walk this specific node
        this->Walk(owner, node, context);
      }
    }

    // Checks to see if any errors have occurred
    bool HasErrorOccurred()
    {
      return this->WasError || (this->Errors != nullptr && this->Errors->WasError);
    }

    // Using the registered visitors, visit all of the direct child nodes
    template <typename NodeType>
    void Walk(TreeOwnerType* owner, NodeType*& node, ContextType* context)
    {
      // Early out if an error occurred
      if (this->HasErrorOccurred())
        return;

      // Set the walker on the context
      context->Walker = this;

      // Error checking
      ErrorIf(node == nullptr, "You should never attempt to traverse a null node");

      // Get the node type
      BoundType* nodeType = node->ZilchGetDerivedType();

      // Were the children walked over (or explicitly ignored)?
      bool childrenWereHandled = false;

      // Loop through all the visitors
      for (size_t i = 0; i < this->Visitors.size(); ++i)
      {
        // Get the current visitor
        VisitorInfo& visitor = this->Visitors[i];

        // As long as the node we're visiting is somehow derived from the node visitor type
        if (nodeType == visitor.NodeType || (visitor.IsNonLeafBase && TypeBinding::IsA(nodeType, visitor.NodeType)))
        {
          // Clear any flags before visiting this node
          context->Flags = WalkerFlags::None;

          // Invoke the visitor on that child
          (owner->*(visitor.Visitor))((SyntaxNode*&)node, context);

          // Store and reset the flags again
          WalkerFlags::Type flags = context->Flags;
          context->Flags = WalkerFlags::None;

          // If any kind of error occurred, early out
          if (flags & WalkerFlags::Error || this->HasErrorOccurred())
          {
            // Set an error flag so we won't do any more visiting
            this->WasError = true;
            return;
          }

          // If the children were walked by this visitor, then mark it so
          // This just means we will not generically walk the tree later
          if ((flags & WalkerFlags::ChildrenNotHandled) == 0)
            childrenWereHandled = true;

          // If we don't want anyone else to visit this node after us...
          // Note: We do not 'return' because we may still want to generically walk it's children
          if (flags & WalkerFlags::PreventOtherWalkers)
            break;

          // If the node was ever cleared...
          if (node == nullptr)
            return;

          // If the error handler is available and an error ocurred...
          if (this->Errors != nullptr && this->Errors->WasError)
            return;
        }
      }

      // Check if the children were not visited...
      if (childrenWereHandled == false)
      {
        // Generically walk all the children since nobody visited this poor old node
        this->GenericWalkChildren(owner, node, context);
      }
    }

  private:

    // Register a visitor
    void RegisterInternal(MemberFn visitor, BoundType* childTypeToVisit, bool isNonLeafBase)
    {
      VisitorInfo info;
      info.Visitor = visitor;
      info.NodeType = childTypeToVisit;
      info.IsNonLeafBase = isNonLeafBase;

      // Add the node to the children
      this->Visitors.push_back(info);
    }

  public:

    // If an error occurred, this will be set
    // This must be cleared before reusing a walker
    bool WasError;

    // Store a reference to the error handler (may be null)
    CompilationErrors* Errors;

  private:

    // Information about the visitors
    class VisitorInfo
    {
    public:
      // Constructor
      VisitorInfo() :
        Visitor(nullptr),
        NodeType(nullptr),
        IsNonLeafBase(false)
      {
      }

      MemberFn Visitor;
      BoundType* NodeType;
      bool IsNonLeafBase;
    };

    // The visitors that have been registered
    typedef Array<VisitorInfo> VisitorArray;

    // Store all the visitors
    VisitorArray Visitors;

    // Not copyable
    ZilchNoCopy(BranchWalker);
  };
}

#endif

namespace Zilch
{
  // The context we use to generate code
  class GeneratorContext : public WalkerContext<CodeGenerator, GeneratorContext>
  {
  public:
    // Store the current function that we're building
    FunctionArray FunctionStack;

    // Store the current type that we're building
    Array<BoundType*> ClassTypeStack;
  };

  // This class uses the syntax tree (after type checking) to generate a byte-code known as the "three-address"
  class CodeGenerator
  {
  public:

    // Constructor
    CodeGenerator();

    // Generates a buffer of op-codes from the given syntax-tree
    LibraryRef Generate(SyntaxTree& syntaxTree, LibraryBuilder& builder);

  private:

    // Store the class in the code context
    void ClassContext(ClassNode*& node, GeneratorContext* context);

    // When we encounter a function definition inside the syntax tree, this will be called to generated a function
    void GenerateFunction(FunctionNode*& node, GeneratorContext* context);

    // When we encounter a class definition inside the syntax tree, this will be called to generated a preconstructor
    void GeneratePreConstructorAndPushClassContext(ClassNode*& node, GeneratorContext* context);

    // Generate the properties for enum values
    void GenerateEnumValueProperties(EnumValueNode*& node, GeneratorContext* context);

    // Generate the properties for event names
    void GenerateEventNameProperties(SendsEventNode*& node, GeneratorContext* context);

    // Store the class in the code context
    void ClassAndPreconstructorContext(ClassNode*& node, GeneratorContext* context);

    // Store the function in the code context
    void FunctionContext(GenericFunctionNode*& node, GeneratorContext* context);

    // Generate out of scope destructors
    void GenerateOutOfScope(ScopeNode*& node, GeneratorContext* context);

    // Generate the storage for parameters
    void GenerateParameter(ParameterNode*& node, GeneratorContext* context);

    // Generate the storage for variables
    void GenerateLocalVariable(LocalVariableNode*& node, GeneratorContext* context);

    // Generate debug breakpoints
    void GenerateDebugBreak(DebugBreakNode*& node, GeneratorContext* context);

    // Generate the initialization of member variables
    void GenerateMemberVariablePreConstructor(MemberVariableNode*& node, GeneratorContext* context);

    // Generate opcode for timeout statements
    void GenerateTimeout(TimeoutNode*& node, GeneratorContext* context);

    // Generate opcode for if statements
    void GenerateIfRoot(IfRootNode*& node, GeneratorContext* context);

    // Generate all the statements and the continue jumps inside
    void GenerateLoopStatementsAndContinues(GeneratorContext* context, LoopScopeNode* node);

    // Generate all the statements inside a node
    void GenerateStatements(GeneratorContext* context, ScopeNode* node);

    // Generate the backwards jump that most loops use to go back to the beginning
    void GenerateBackwardsLoopJump(GeneratorContext* context, size_t backwardsJumpInstructionIndex, const CodeLocation& debugLocation);

    // Generate the code for break statements in the loop
    void GenerateLoopBreaks(GeneratorContext* context, LoopScopeNode* node);

    // Generate opcode for while statements
    void GenerateWhile(WhileNode*& node, GeneratorContext* context);

    // Generate opcode for do while statements
    void GenerateDoWhile(DoWhileNode*& node, GeneratorContext* context);

    // Generate opcode for for statements
    void GenerateFor(ForNode*& node, GeneratorContext* context);

    // Generate opcode for loop statements
    void GenerateLoop(LoopNode*& node, GeneratorContext* context);

    // Generate opcode for scope statements
    void GenerateScope(ScopeNode*& node, GeneratorContext* context);

    // Generate opcode for break statements
    void GenerateBreak(BreakNode*& node, GeneratorContext* context);

    // Generate opcode for continue statements
    void GenerateContinue(ContinueNode*& node, GeneratorContext* context);

    // Generate opcode for binary operations
    void GenerateBinaryOperation(BinaryOperatorNode*& node, GeneratorContext* context);

    // Generate opcode for unary operations
    void GenerateUnaryOperation(UnaryOperatorNode*& node, GeneratorContext* context);

    // Generate opcode for the unary property delegate operator
    void GeneratePropertyDelegateOperation(PropertyDelegateOperatorNode*& node, GeneratorContext* context);

    // Generate opcode for member accesses (function, data, etc)
    void GenerateMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for data-member accesses
    void GenerateFieldAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for function-member accesses
    void GenerateFunctionDelegateMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for property-member 'get'
    void GeneratePropertyGetMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for property-member 'set'
    void GeneratePropertySetMemberAccess(MemberAccessNode*& node, GeneratorContext* context);

    // Generate opcode for the initializers in the initializer list (base, this, etc)
    void GenerateInitializer(InitializerNode*& node, GeneratorContext* context);

    // Allocate a delegate opcode of type T
    template <typename T>
    T& DelegateOpcode
    (
      Function*           caller,
      Function*           toCall,
      OperandIndex        delegateDest,
      const CodeLocation& location,
      Instruction::Enum   instruction,
      DebugOrigin::Enum   debug
    );

    // Create an instance delegate for the given type or source (the this handle will be created)
    void CreateInstanceDelegateAndThisHandle
    (
      Function*           caller,
      Function*           toCall,
      Type*               thisType,
      const Operand&      thisSource,
      Operand&            delegateDestOut,
      bool                canBeVirtual,
      const CodeLocation& location,
      DebugOrigin::Enum   debug
    );

    // Create an instance delegate for the given type or source (we provide the this handle)
    void CreateInstanceDelegateWithThisHandle
    (
      Function*           caller,
      Function*           toCall,
      const Operand&      thisHandle,
      Operand&            delegateDestOut,
      bool                canBeVirtual,
      const CodeLocation& location,
      DebugOrigin::Enum   debug
    );

    // Create a static delegate for the given type or source
    void CreateStaticDelegate
    (
      Function*           caller,
      Function*           toCall,
      Operand&            delegateDest,
      const CodeLocation& location,
      DebugOrigin::Enum   debug
    );

    // Generate opcode for type-casts
    void GenerateTypeCast(TypeCastNode*& node, GeneratorContext* context);
    
    // Generate the retrieval of a type
    void GenerateTypeId(TypeIdNode*& node, GeneratorContext* context);

    // Generate opcode for referencing local and parameter variables
    void GenerateLocalVariableReference(LocalVariableReferenceNode*& node, GeneratorContext* context);

    // Generate opcode for return values
    void GenerateReturnValue(ReturnNode*& node, GeneratorContext* context);

    // Generate opcode for function calls
    void GenerateFunctionCall(FunctionCallNode*& node, GeneratorContext* context);

    // Generate the opcode for a function call (*before* opcode for argument copying)
    void GenerateCallOpcodePreArgs(Function* caller, DelegateType* delegateTypeToCall, const Operand& delegateLocal, const CodeLocation& location, DebugOrigin::Enum debugOrigin);

    // Generate the opcode for a function call (*after* opcode for argument copying)
    void GenerateCallOpcodePostArgs(Function* caller, DelegateType* delegateTypeToCall, Operand* returnAccessOut, const CodeLocation& location, DebugOrigin::Enum debugOrigin);

    // Collect all the values used in expressions
    void CollectValue(ValueNode*& node, GeneratorContext* context);

    // Collect all the string interpolant expressions
    void GenerateStringInterpolants(StringInterpolantNode*& node, GeneratorContext* context);

    // Generate opcode for deleting objects in memory
    void GenerateDelete(DeleteNode*& node, GeneratorContext* context);

    // Generate opcode for throwing an exception
    void GenerateThrow(ThrowNode*& node, GeneratorContext* context);

    // Finds all the new calls and generates opcode to create objects
    void GenerateCreationCall(CreationCallNode*& node, GeneratorContext* context);

    // Invokes 'Add' and intializes members on a newly created object (via creation call node)
    void GenerateCreationInitializer(CreationInitializerNode*& node, GeneratorContext* context);
    
    // Forwards access from another expression node (the operand)
    void GenerateUnnamedOperand(UnnamedOperandNode*& node, GeneratorContext* context);

    // Allocate a local on a function (and setup an access to point at it)
    void CreateLocal(Function* function, size_t size, Operand& accessOut);

    // Create a r-value unary operator opcode
    void CreateRValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin);

    // Create a l-value unary operator opcode
    void CreateLValueUnaryOpcode(Function* function, UnaryOperatorNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin);

    // Create a conversion opcode
    void CreateConversionOpcode(Function* function, TypeCastNode& node, Instruction::Enum instruction, DebugOrigin::Enum debugOrigin);

    // Determine the proper opcode for unary operations
    void GenerateUnaryOp(Function* function, UnaryOperatorNode& node, DebugOrigin::Enum debugOrigin);

    // Determine the proper opcode for conversion operations
    void GenerateConversion(Function* function, TypeCastNode& node, DebugOrigin::Enum debugOrigin);

    // Create a copy opcode
    void CreateCopyOpcode(Function* function, CopyMode::Enum mode, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy operations (we're initializing the return value)
    void GenerateCopyToReturn(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy operations (we're initializing memory)
    void GenerateCopyInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy parameter operations
    void GenerateCopyToParameter(Function* function, Type* type, const Operand& source, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for copy return operations
    void GenerateCopyFromReturn(Function* function, Type* type, OperandIndex sourceRegister, OperandIndex destRegister, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

    // Determine the proper opcode for creating a handle
    void GenerateHandleInitialize(Function* function, Type* type, const Operand& source, const Operand& destination, DebugOrigin::Enum debugOrigin, const CodeLocation& location);

  private:

    // Store all the walkers
    BranchWalker<CodeGenerator, GeneratorContext> FunctionWalker;
    BranchWalker<CodeGenerator, GeneratorContext> GeneratorWalker;
    BranchWalker<CodeGenerator, GeneratorContext> PropertySetWalker;

    // The library that we're currently building
    LibraryBuilder* Builder;
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SYNTAX_TREE_HPP
#define ZILCH_SYNTAX_TREE_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TOKEN_HPP
#define ZILCH_TOKEN_HPP

// Includes

namespace Zilch
{
  // This struct is given back to the user when asking for tokens
  class UserToken
  {
  public:
    // Default constructor
    UserToken();

    // Constructor for a special type of token
    UserToken(StringParam token, Grammar::Enum tokenId);

    String Token;
    Grammar::Enum TokenId;
    CodeLocation Location;
    size_t Start;
    size_t Length;
  };

  // A classifcation of tokens (not the specific token, but rather a category)
  namespace TokenCategory
  {
    enum Enum
    {
      Keyword,
      Symbol,
      Unknown,
    };
  }
}

// End header protection
#endif

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SHARED_HPP
#define ZILCH_SHARED_HPP

// Includes

// We need to make a specialization because the hash maps do not work with enums
// On other compilers, the 'Enum' type is actually an int, which would produce a
// duplicate definition compiler error since a specialization of int already exists
#ifdef _MSC_VER
template<>
class Zero::HashPolicy<Zilch::Grammar::Enum> : public Zero::ComparePolicy<size_t>
{
public:
  inline size_t operator()(const Zilch::Grammar::Enum& value) const
  {
    return HashUint(*(unsigned int*)&value);
  }
};
#endif

namespace Zilch
{
  // What type of IO an expression allows
  namespace IoMode
  {
    enum Enum
    {
      // Some expressions we ignore their io-usage (but never the io of the expression itself)
      // Examples being expressions used as a standalone statement (nobody reads/writes)
      Ignore = 0,
      // A variable is readable (constants, temporaries, property get)
      ReadRValue = 1,
      // A variable is writable (variables, property set)
      WriteLValue = 2,
      // We're strictly doing a property 'set', which means 'WriteLValue' should be set
      // This is used to let handle and delegate properties know that they are initializing
      // a value rather than assigning a value (when assignment '=' is used)
      StrictPropertySet = 4,
      // If the access type was not set, we either haven't resolved it or it's a bug
      NotSet = (uint)-1
    };
  }

  // This struct is given back to the user when asking for tokens
  class BinaryOperator
  {
  public:
    // Constructor
    BinaryOperator();

    // The hash function which allows us to put it in a hash container
    size_t Hash() const;

    // The hash function which allows us to put it in a hash container
    bool operator==(const BinaryOperator& rhs) const;

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    // In a binary operator, these include the left and right hand types
    Type* Lhs;
    Type* Rhs;

    // If the left or right hand argument needs to be casted for this operation to work
    // This only appears when the direct operator does not exist, but an implicit cast of one side, or the other, or both exists
    Type* CastLhsTo;
    Type* CastRhsTo;

    // The resulting type of the operation
    Type* Result;

    // The operator used in grammar to represent
    Grammar::Enum Operator;

    // The resulting instruction
    Instruction::Enum Instruction;

    // If the operation is communative but it's between two different types, this tells
    // us if the opcode requires the arguments to be flipped (to reduce opcodes)
    bool FlipArguments;

    // Whether or not this results in an l-value or r-value
    IoMode::Enum Io;
  };

  // This struct is given back to the user when asking for tokens
  class UnaryOperator
  {
  public:
    // Constructor
    UnaryOperator();

    // The hash function which allows us to put it in a hash container
    size_t Hash() const;

    // The hash function which allows us to put it in a hash container
    bool operator==(const UnaryOperator& rhs) const;

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    // In a unary operator, this is the operand
    Type* Operand;

    // The resulting type of the operation
    Type* Result;

    // The operator used in grammar to represent
    Grammar::Enum Operator;

    // The resulting instruction
    Instruction::Enum Instruction;

    // Whether or not this results in an l-value or r-value
    IoMode::Enum Io;
  };

  // Tells us which way an operator evaluates it's arguments
  namespace OperatorAssociativity
  {
    enum Enum
    {
      RightToLeft,
      LeftToRight
    };
  }

  // Lets us query information about the validity of a cast, as well as what kind it will be
  class CastOperator
  {
  public:
    // Constructor
    CastOperator();

    // The hash function which allows us to put it in a hash container
    size_t Hash() const;

    // The hash function which allows us to put it in a hash container
    bool operator==(const CastOperator& rhs) const;

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    // Only used for efficient query / lookup
    // These may be null in cases other than primitive casts
    Type* From;
    Type* To;

    // The operator used in grammar to represent
    CastOperation::Enum Operation;

    // The resulting instruction if a single one exists (eg ConvertRealToInteger)
    // Only valid when the cast operation is Primitive
    // Otherwise if no direct instruction exists, the instruction will be set to 'InvalidInstruction'
    Instruction::Enum PrimitiveInstruction;

    // If we allow this cast to be implicit (default false)
    // If true, then the syntaxer will automatically allow it in cases
    // such as return, passing parameters, resolving overloads, etc
    bool CanBeImplicit;

    // Some casts require actual instructions to run
    // Ex: Real to Integer must perform a floating point conversion, Integer to the special Any type, etc
    // Other casts can be directly raw convertable with no execution
    // Ex: An enum value to an Integer, or a derived class to a base class (Cat to Animal)
    // This will be set if the cast type requires any sort of code generation / execution
    bool RequiresCodeGeneration;
  };

  // Tells us which way an operator evaluates it's arguments
  namespace OperatorArity
  {
    enum Enum
    {
      Unary,
      Binary
    };
  }

  // Encompasses everything we need to know about operator precedence
  class UntypedOperator
  {
  public:
    // Constructor
    UntypedOperator();

    // Whether this operator was valid or not (a non-existant operator is invalid)
    bool IsValid;

    Grammar::Enum Operator;
    size_t Precedence;
    OperatorAssociativity::Enum Associativity;
    OperatorArity::Enum Arity;
  };

  // Contains information that is shared between the syntaxer and the code generator
  class Shared
  {
  public:

    // Get the instance of the singleton
    static Shared& GetInstance();

    // Lookup a binary operator between two types
    // Both entries for communative operators will exist, eg, scalar * vector and vector * scalar
    BinaryOperator GetBinaryOperator(Type* lhs, Type* rhs, Grammar::Enum oper, bool allowRecursiveLookup = true);

    // Lookup a unary operator
    UnaryOperator GetUnaryOperator(Type* type, Grammar::Enum oper);

    // Lookup any cast operators from this type to any other type
    Array<CastOperator> GetPrimitiveCastOperatorsFrom(Type* from);

    // Lookup a cast operator (can be explicit or implicit)
    CastOperator GetCastOperator(Type* from, Type* to);

    // Get a structure that represents the precedence and associativity of an operator, regardless of types
    UntypedOperator GetOperatorPrecedence(Grammar::Enum oper, OperatorArity::Enum arity);

    // Gets all the operators stored in an array thats indexed by precedence
    // Note: Precedence starts at 0 and ends at size() - 1
    const Array<Array<UntypedOperator> >& GetPrecedences();

  private:

    // Construct the shared object
    Shared();

    // Adds a binary operator
    void AddBinary(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io, bool flip);

    // Adds a binary communative operator (which adds the reversed operator too)
    void AddBinaryCommunative(Type* type1, Type* type2, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);

    // Adds a binary non-communative operator (the reverse will not be added)
    void AddBinaryNonCommunative(Type* lhs, Type* rhs, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);
    
    // Adds a binary operator where the operands are the same type
    // Note: If the operator is the same type, we don't care if it's communative or not because we always perform
    // the operation in the correct order, and we only need one opcode to represent it
    void AddBinary(Type* sameType, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);

    // Adds a unary operator
    void AddUnary(Type* operand, Type* result, Grammar::Enum oper, Instruction::Enum instruction, IoMode::Enum io);

    // Adds a primitive cast operator (must have an instruction
    void AddPrimitiveCast(Type* fromType, Type* toType, Instruction::Enum instruction, bool canBeImplicit);

    // Adds an operator to the precedence chart (maps it both ways)
    void AddPrecedence(size_t precedence, OperatorAssociativity::Enum associativity, OperatorArity::Enum arity, Grammar::Enum oper);

  private:

    // Special binary operators
    BinaryOperator HandleAssignment;
    BinaryOperator HandleEquality;
    BinaryOperator HandleInequality;
    BinaryOperator ValueAssignment;
    BinaryOperator ValueEquality;
    BinaryOperator ValueInequality;
    BinaryOperator DelegateAssignment;
    BinaryOperator DelegateEquality;
    BinaryOperator DelegateInequality;
    BinaryOperator AnyAssignment;
    BinaryOperator AnyEquality;
    BinaryOperator AnyInequality;

    // Our hash set of binary operators that get registered once (hence the singleton)
    HashSet<BinaryOperator> BinaryOperators;

    // Our hash set of unary operators that get registered once (hence the singleton)
    HashSet<UnaryOperator> UnaryOperators;
    
    // Special cast operators
    // RawImplicitCast includes same-cast, up-cast, null-cast, any-delegate-cast
    CastOperator RawImplicitCast;
    CastOperator DynamicDownCast;
    CastOperator ToAnyCast;
    CastOperator FromAnyCast;
    CastOperator EnumIntegerCast;
    CastOperator IntegerEnumCast;
    CastOperator NullToDelegate;

    // Our hash set of casting operators that get registered once (hence the singleton)
    HashSet<CastOperator> CastOperators;

    // Associate all the cast operators from this type to any other type
    ZilchTodo("This should actually use some kind of policy because we're not hashing types correctly (works because we only care about BoundType* right now, Real/Integer, etc )");
    HashMap<Type*, Array<CastOperator> > PrimitiveCastOperatorsFrom;

    // We use this as a key into a hash map
    class OperatorWithArity
    {
    public:
      // Define these so we can be used as a key
      bool operator==(const OperatorWithArity& rhs) const;
      size_t Hash() const;

      Grammar::Enum Operator;
      OperatorArity::Enum Arity;
    };

    // We map operators to their precedence and back (useful for code formatters and documentation)
    HashMap<OperatorWithArity, UntypedOperator> OperatorToPrecedence;
    Array<Array<UntypedOperator> > PrecedenceToOperators;
  };
}

// End header protection
#endif

namespace Zilch
{
  ZilchStaticLibrary(Syntax);

  namespace EvaluationMode
  {
    enum Enum
    {
      // Parses the entire project (including classes, functions, members, etc)
      Project,

      // Parses just a single input expression
      Expression,
    };
  }

  // This tree stores the parsed language in a format that's easy to traverse
  class SyntaxTree
  {
  public:

    // Friends
    friend class Parser;

    // Constructor
    SyntaxTree();

    // Destructor
    ~SyntaxTree();

    // Get the graphviz representation for debugging purposes
    String GetGraphVizRepresentation();

    // Show the graphviz representation for debugging purposes
    void ShowGraphVizRepresentation();

  public:

    // The root of the tree
    RootNode* Root;

    // A singlular expression to be evaluated (or null if we're compiling an entire tree)
    ExpressionNode* SingleExpression;

    // Not copyable
    ZilchNoCopy(SyntaxTree);
  };

  #define ZilchClonableNode(Type)                   \
    ~Type()                                         \
    {                                               \
      this->DestroyChildren();                      \
    }                                               \
    Type* Clone() const override                    \
    {                                               \
      Type* clone = new Type(*this);                \
                                                    \
      NodeChildren children;                        \
      clone->PopulateChildren(children);            \
      clone->PopulateNonTraversedChildren(children);\
      for (size_t i = 0; i < children.size(); ++i)  \
      {                                             \
        SyntaxNode*& child = *children[i];          \
        child = child->Clone();                     \
      }                                             \
                                                    \
      SyntaxTypes types;                            \
      clone->PopulateSyntaxTypes(types);            \
      for (size_t i = 0; i < types.size(); ++i)     \
      {                                             \
        SyntaxType*& type = *types[i];              \
        type = type->Clone();                       \
      }                                             \
                                                    \
      SyntaxNode::FixParentPointers(clone, nullptr);\
                                                    \
      return clone;                                 \
    }

  #define ZilchClonableType(Type)                   \
    ~Type()                                         \
    {                                               \
      this->DestroyChildren();                      \
    }                                               \
    Type* Clone() const override                    \
    {                                               \
      Type* clone = new Type(*this);                \
                                                    \
      SyntaxTypes types;                            \
      clone->PopulateSyntaxTypes(types);            \
      for (size_t i = 0; i < types.size(); ++i)     \
      {                                             \
        SyntaxType*& type = *types[i];              \
        type = type->Clone();                       \
      }                                             \
                                                    \
      return clone;                                 \
    }

  // A pre-type representation for the syntax tree
  class SyntaxType : public IZilchObject
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareBaseType(SyntaxType, TypeCopyMode::ReferenceType);

    // Destructor
    virtual ~SyntaxType() {};

    // Convert the node to a string representation
    virtual String ToString() const = 0;

    // Clones a syntax type
    virtual SyntaxType* Clone() const = 0;

    // Tells us if a particular declarations of a syntax type is a template instantiation
    virtual bool IsTemplateInstantiation() const;

    // Populates an array with any syntax types that this type refers to
    virtual void PopulateSyntaxTypes(SyntaxTypes& typesOut);

  protected:
    
    // Destroys all the children (used for cleanup)
    void DestroyChildren();
  };

  class AnySyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(AnySyntaxType, SyntaxType);
    ZilchClonableType(AnySyntaxType);

    // SyntaxType interface
    String ToString() const override;
  };

  class IndirectionSyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IndirectionSyntaxType, SyntaxType);
    ZilchClonableType(IndirectionSyntaxType);

    // Constructor
    IndirectionSyntaxType();

    // The syntax type that we refer to
    SyntaxType* ReferencedType;

    // SyntaxType interface
    String ToString() const override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;
  };

  class BoundSyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(BoundSyntaxType, SyntaxType);
    ZilchClonableType(BoundSyntaxType);

    // Store the name of the type
    String TypeName;

    // Template arguments (if we have any)
    SyntaxTypeList TemplateArguments;
    
    // SyntaxType interface
    bool IsTemplateInstantiation() const override;
    String ToString() const override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;
  };

  //class TypeOfSyntaxType : public SyntaxType
  //{
  //public:
  //  // Declare the class for RTTI
  //  ZilchDeclareDerivedType(NamedSyntaxType, SyntaxType);
  //  ZilchClonableType(NamedSyntaxType);

  //  // Store the name of the type
  //  String TypeName;

  //  // Template arguments (if we have any)
  //  SyntaxTypeList TemplateArguments;
  //  
  //  // SyntaxType interface
  //  bool IsTemplateInstantiation() const override;
  //  String ToString() const override;
  //  void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;
  //};

  // A parameter that belongs inside of a delegate declaration
  class DelegateSyntaxParameter
  {
  public:
    // Constructor
    DelegateSyntaxParameter();

    // A parameter generally has a name
    const UserToken* Name;

    // A parameter also has a type
    SyntaxType* Type;
  };

  class DelegateSyntaxType : public SyntaxType
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DelegateSyntaxType, SyntaxType);
    ZilchClonableType(DelegateSyntaxType);

    // Constructor
    DelegateSyntaxType();

    // Template arguments (if we have any)
    SyntaxTypeList TemplateArguments;

    // Store the variable types as well as thier names
    Array<DelegateSyntaxParameter> Parameters;

    // The return type of the delegate (or null for no return type)
    SyntaxType* Return;
    
    // SyntaxType interface
    bool IsTemplateInstantiation() const override;
    String ToString() const override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;
  };

  // A syntax node represents any syntactical entity in the syntax tree
  class SyntaxNode : public IZilchObject
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareBaseType(SyntaxNode, TypeCopyMode::ReferenceType);

    // Constructor
    SyntaxNode();

    // Destructor
    virtual ~SyntaxNode() {};

    // Copy constructor
    SyntaxNode(const SyntaxNode& toCopy);

    // Convert the node to a string representation
    virtual String ToString() const;

    // Clones a node
    virtual SyntaxNode* Clone() const = 0;

    // Populates an array with the children of this node
    virtual void PopulateChildren(NodeChildren& childrenOut);

    // Populates an array with the non-traversed children of this node
    virtual void PopulateNonTraversedChildren(NodeChildren& childrenOut);

    // Populates an array with any syntax types that this node refers to
    virtual void PopulateSyntaxTypes(SyntaxTypes& typesOut);

    // Fix all the parent pointers so they point up to their parents
    static void FixParentPointers(SyntaxNode* node, SyntaxNode* parent);

    // Get the merged/trimmed comments for this node
    String GetMergedComments();

  protected:

    // Destroys all the children (used for cleanup)
    void DestroyChildren();

  private:

    // Directly add a child (regardless of lock mode)
    void DirectAdd(SyntaxNode* node);

    // Directly remove a child (regardless of lock mode)
    void DirectRemove(SyntaxNode* node);

  public:

    // Store the parent pointer
    SyntaxNode* Parent;

    // The location that the syntax node originated from
    CodeLocation Location;

    // Any comments collected for this syntax node (used for documentation / translation)
    StringArray Comments;
  };

  // Whether or not we're virtual or overriding
  namespace VirtualMode
  {
    enum Enum
    {
      NonVirtual,
      Virtual,
      Overriding
    };
  }

  // A root node is the root of a syntax tree
  class RootNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(RootNode, SyntaxNode);
    ZilchClonableNode(RootNode);

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Store all the root level classes
    NodeList<ClassNode> Classes;

    // Store all the root level enums
    NodeList<EnumNode> Enums;

    // Contains all classes, enums, etc in the order they are declared
    NodeList<SyntaxNode> NonTraversedNonOwnedNodesInOrder;
  };

  // An attribute that can be attached to classes, functions, member variables, etc
  class AttributeNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(AttributeNode, SyntaxNode);
    ZilchClonableNode(AttributeNode);

    // Default constructor
    AttributeNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The attribute type name
    const UserToken* TypeName;

    // An optional node for when the user wants to pass parameters to an attribute
    FunctionCallNode* AttributeCall;
  };

  // A statement node represents any kind of statement
  class StatementNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(StatementNode, SyntaxNode);

    // Returns if the given node is used as a statement
    // For example: Expressions are statements, but are only considered
    // being used as a statement when they appear alone, eg 'i += 5;'
    static bool IsNodeUsedAsStatement(SyntaxNode* node);
  };

  // An evaluatable node represents anything that can be evaluated into a value (expressions, function calls, values, etc)
  class ExpressionNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ExpressionNode, StatementNode);

    // Constructor
    ExpressionNode();

    // Store the type along with the expression (this will be filled in later)
    Type* ResultType;

    // Stores how we access this particular expression (stack, member, etc)
    Operand Access;

    // How people are allowed to use this value
    IoMode::Enum Io;

    // How it is trying to be used by it's parent node
    // If this value conflicts with the node's IO mode, then it will result in an error
    // This value is also used to determine whether we call the get/set or both for properties
    IoMode::Enum IoUsage;

    // This determines whether or not this node is being used as a statement
    // See 'IsNodeUsedAsStatement' on StatementNode
    bool IsUsedAsStatement;
  };

  // A node that only exists to forward access to another node (for example, used in creation initializers)
  // This node does not have any children
  class UnnamedOperandNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(UnnamedOperandNode, ExpressionNode);
    ZilchClonableNode(UnnamedOperandNode);

    // Constructor
    UnnamedOperandNode();
    
    // This node is NOT owned by this node, and therefore it is NOT a child
    // Be very careful, as this is technically an unsafe reference to another node in the tree
    // If that node is removed, then this value becomes garbage (technically it should be relative via parent)
    ExpressionNode* ToBeForwarded;
  };

  // A binary-operator node represents a binary operator and its operands
  class BinaryOperatorNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(BinaryOperatorNode, ExpressionNode);
    ZilchClonableNode(BinaryOperatorNode);

    // Constructor
    BinaryOperatorNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The left and right arguments that the binary operator is being applied to
    ExpressionNode* LeftOperand;
    ExpressionNode* RightOperand;

    // All the info we need about the operator (filled out by the syntaxer)
    BinaryOperator OperatorInfo;

    // The operator that tells us what kind of binary operation this is
    const UserToken* Operator;
  };

  // A unary-operator node represents a unary operator and its operand
  class UnaryOperatorNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(UnaryOperatorNode, ExpressionNode);
    ZilchClonableNode(UnaryOperatorNode);

    // Constructor
    UnaryOperatorNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The single argument of the unary operator
    ExpressionNode* Operand;

    // All the info we need about the operator
    UnaryOperator OperatorInfo;

    // The operator that tells us what kind of unary operation this is
    const UserToken* Operator;
  };

  // A unary-operator node represents a unary operator and its operand
  class PropertyDelegateOperatorNode : public UnaryOperatorNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(PropertyDelegateOperatorNode, UnaryOperatorNode);
    ZilchClonableNode(PropertyDelegateOperatorNode);

    // Constructor
    PropertyDelegateOperatorNode();

    // The property we're associated with
    Property* AccessedProperty;
  };

  // A type-cast node represents a type cast from an expression to a specified type
  class TypeCastNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TypeCastNode, ExpressionNode);
    ZilchClonableNode(TypeCastNode);

    // Constructor
    TypeCastNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The type of cast operation we do
    CastOperator OperatorInfo;

    // Store the expression that will be casted
    ExpressionNode* Operand;

    // Name of the type that we represent
    SyntaxType* Type;
  };

  // A post expression node represents right hand operators (call, indexer, access, etc)
  class PostExpressionNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(PostExpressionNode, ExpressionNode);

    // Constructor
    PostExpressionNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Post expressions are special expressions that come after an operand
    ExpressionNode* LeftOperand;
  };

  // An indexer call node represents a list of passed in arguments used in an indexer call
  class IndexerCallNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IndexerCallNode, PostExpressionNode);
    ZilchClonableNode(IndexerCallNode);
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The list of arguments, provided in order, to the indexer
    NodeList<ExpressionNode> Arguments;
  };

  // A function call node represents a list of passed in arguments used in a function call
  class FunctionCallNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(FunctionCallNode, PostExpressionNode);
    ZilchClonableNode(FunctionCallNode);

    // Constructor
    FunctionCallNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;

    // An array of all the names given to the arguments
    // Empty if we're doing a standard call
    StringArray ArgumentNames;

    // Store the actual expressions passed in for each argument
    NodeList<ExpressionNode> Arguments;

    // Maps the arguments in their passed in order to the actual argument order of the function
    PodArray<size_t> ArgumentMap;

    // If the call is done in named style, then we have no argument names
    bool IsNamed;
  };

  namespace MemberAccessType
  {
    enum Enum
    {
      Invalid,
      Field,
      Property,
      Function,
      Dynamic
    };
  }

  // A member-access node represents accessing a member / field
  class MemberAccessNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(MemberAccessNode, PostExpressionNode);
    ZilchClonableNode(MemberAccessNode);

    // Constructor
    MemberAccessNode();
    
    // SyntaxNode interface
    String ToString() const override;

    // The name that we're accessing
    String Name;

    // The operator used to access (eg '.')
    const UserToken* Operator;

    // The type of member we're accessing
    MemberAccessType::Enum MemberType;
    
    // If this node is a property access node, then this refers to which property
    Property* AccessedProperty;

    // If this node is a field access node, then this refers to which field
    Field* AccessedField;

    // This is needed since a function can actually be overloaded
    const FunctionArray* OverloadedFunctions;
    Function* AccessedFunction;
  };

  // A type member reference node refers to a member access upon a type
  class TypeMemberAccessNode : public MemberAccessNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TypeMemberAccessNode, MemberAccessNode);
    ZilchClonableNode(TypeMemberAccessNode);

    // Constructor
    TypeMemberAccessNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The syntax type that we are accessing
    SyntaxType* ReferencedSyntaxType;

    // The type we resolve to what we're accessing
    Type* ReferencedType;
  };

  // Lets us get the runtime type object that describes a type
  class TypeIdNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TypeIdNode, ExpressionNode);
    ZilchClonableNode(TypeIdNode);

    // Constructor
    TypeIdNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The syntax type that we need runtime type identification for
    // This may be null if the 'value' expression node is set
    SyntaxType* CompileTimeSyntaxType;

    // The expression we need to get the type of
    // This may be null if a sytax type is set!
    ExpressionNode* Value;

    // The type we resolved for the expression or static type given to
    // typeid at compile time. In the case of handles and delegates,
    // the type will be resolved further in opcode
    Type* CompileTimeType;
  };

  namespace CreationMode
  {
    enum Enum
    {
      Invalid,
      Inferred,
      New,
      Local
    };
  }

  // Represents a call to create an object of a given type
  class CreationCallNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(CreationCallNode, ExpressionNode);
    ZilchClonableNode(CreationCallNode);

    // Constructor
    CreationCallNode();

    // SyntaxNode interface
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The token we used to create this (new, local, etc)
    CreationMode::Enum Mode;

    // Name of the type that we represent
    BoundSyntaxType* CreatedSyntaxType;

    // The type that's being created
    BoundType* CreatedType;

    // The constructor we're running, or null for pre-constructor only
    Function* ConstructorFunction;

    // We always create a handle to the type; for example, new always returns a handle, and we
    // always need a handle for preconstructor and constructor calls, even on local objects
    OperandIndex ThisHandleLocal;
  };

  // When we want to initialize a type we can also initialize particular members
  class CreationMemberInitializerNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(CreationMemberInitializerNode, SyntaxNode);
    ZilchClonableNode(CreationMemberInitializerNode);

    // Constructor
    CreationMemberInitializerNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The name of the member that we're initializing
    UserToken MemberName;

    // The value that we want to initialize the member to
    ExpressionNode* Value;
  };

  // When we want to initialize a type we can also add values to it (generally for containers)
  class CreationAddInitializerNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(CreationAddInitializerNode, SyntaxNode);
    ZilchClonableNode(CreationAddInitializerNode);
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // These arguments get directly passed in to a call to add on the given container
    NodeList<ExpressionNode> Arguments;
  };
  
  // When we want to initialize a type (either a container, with .Add calls, or members of a class / properties)
  // This node comes after a type has been fully constructed
  // The left hand side should typically be the FunctionCallNode (whose left is the CreationCallNode)
  class CreationInitializerNode : public PostExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(CreationInitializerNode, PostExpressionNode);
    ZilchClonableNode(CreationInitializerNode);

    // Constructor
    CreationInitializerNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // All the elements we want to add to the container (by literally invoking .Add)
    NodeList<CreationAddInitializerNode> AddValues;

    // All the members we want to initialize
    NodeList<CreationMemberInitializerNode> InitailizeMembers;

    // The above element expressions get translated directly into statements
    // This is primarily used for code generation (the above is just syntactic sugar)
    // For example, for the 'add values' to a container, it gets translated into object.Add(value, value...)
    // Member initializers get translated into object.MemberName = value;
    // Warning: many of these nodes point unsafely at another node above in the tree (eg at the creation call itself)
    NodeList<ExpressionNode> InitializerStatements;
  };

  // A variable node represents any variable declaration
  class VariableNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(VariableNode, StatementNode);

    // Constructor
    VariableNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // Check if the node is inferred (denoted by ResultSyntaxType being null)
    bool IsInferred() const;

    // Store the variable name
    String Name;

    // The initial value assigned to the variable
    ExpressionNode* InitialValue;

    // Is the variable static?
    bool IsStatic;

    // Name of the type that we represent
    SyntaxType* ResultSyntaxType;
  };

  // A local variable node represents a local variable declaration (such as one inside a function)
  class LocalVariableNode : public VariableNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LocalVariableNode, VariableNode);
    ZilchClonableNode(LocalVariableNode);

    // Constructor
    LocalVariableNode();

    // Store a pointer that gives information about the local variable
    Variable* CreatedVariable;

    // A pointer to the attributes this function has
    NodeList<AttributeNode> Attributes;
  };

  // A parameter node represents the parameter of a function
  class ParameterNode : public LocalVariableNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ParameterNode, LocalVariableNode);
    ZilchClonableNode(ParameterNode);

    // Constructor
    ParameterNode();

    // Which parameter this is in the function
    size_t ParameterIndex;
  };

  // A member variable node represents a member variable declaration (such as one inside a class)
  class MemberVariableNode : public VariableNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(MemberVariableNode, VariableNode);
    ZilchClonableNode(MemberVariableNode);
    
    // Constructor
    MemberVariableNode();

    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Store the associated member on this node
    Field* CreatedField;
    Property* CreatedProperty;

    // Store the parent class type
    BoundType* ParentClassType;

    // Store the resulting type of the node
    Type* ResultType;

    // The get and set functions for this variable
    // In the case of a property, we always know that either the get or set will exist (or both)
    // In the case of a member variable, both will always exist, but will be generated
    FunctionNode* Get;
    FunctionNode* Set;

    // Whether or not this is a property
    // Note that this also tells us if the get/set are generated
    bool IsProperty;

    // A pointer to the attributes this function has
    NodeList<AttributeNode> Attributes;

    // Is the function a virtual function (or overriding)?
    VirtualMode::Enum Virtualized;
  };

  // A value node represents any constant or identifier value
  class ValueNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ValueNode, ExpressionNode);
    ZilchClonableNode(ValueNode);

    // Constructor
    ValueNode();
    
    // SyntaxNode interface
    String ToString() const override;

    // Store the token that represents the value
    UserToken Value;
  };

  // String interpolants are basically advanced efficient string concatenations with values
  class StringInterpolantNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(StringInterpolantNode, ExpressionNode);
    ZilchClonableNode(StringInterpolantNode);

    // Constructor
    StringInterpolantNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // All the elements of the interpolant, in order of concatenation
    // The elements will be converted into string types during the interpolation
    NodeList<ExpressionNode> Elements;
  };

  // A delete node represents explicit deletion of an object
  class DeleteNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DeleteNode, StatementNode);
    ZilchClonableNode(DeleteNode);

    // Constructor
    DeleteNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The object that we'd like to delete
    ExpressionNode* DeletedObject;
  };

  // An return node represents the return statement for a function
  class ReturnNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ReturnNode, StatementNode);
    ZilchClonableNode(ReturnNode);

    // Constructor
    ReturnNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Store the expression that is to be returned by this statement
    ExpressionNode* ReturnValue;

    // If this is a debug return, then we will ignore flow control errors
    bool IsDebugReturn;
  };

  // A scope node represends a type of scope
  class ScopeNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ScopeNode, StatementNode);
    ZilchClonableNode(ScopeNode);

    // Constructor
    ScopeNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The statements executed if the condition is met
    NodeList<StatementNode> Statements;

    // Tells us if this is a closed path
    // Note that if the processed statements mark this node
    // as being a full return, then the scope node itself
    // needs to report to its parent scope that it is a full return
    bool AllPathsReturn;
    bool IsDebugReturn;

    // Any variables that belong to this scope
    VariableMap ScopedVariables;
  };

  // Allows code to run for a period of time before it throws an exception and 'times out'
  class TimeoutNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TimeoutNode, ScopeNode);
    ZilchClonableNode(TimeoutNode);

    // Constructor
    TimeoutNode();

    // The number of seconds that the timeout will last for
    size_t Seconds;
  };

  // An if node represents the if-then else-if else construct
  class IfNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IfNode, ScopeNode);
    ZilchClonableNode(IfNode);

    // Constructor
    IfNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // Marks whether this is the first part of the if statement (not an else if or else)
    bool IsFirstPart;

    // The conditional expression used in this if statement
    // Non null for all if elses, and only the last CAN be null, but may not be null!
    ExpressionNode* Condition;
  };

  // We hold all parts of the if as children
  class IfRootNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(IfRootNode, StatementNode);
    ZilchClonableNode(IfRootNode);

    // Constructor
    IfRootNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // All parts of the if statement
    // The first node in this list is the if itself (not an else!)
    // All nodes after that are 'else if' nodes and have conditions, except
    // the last one can omit the condition and be just an 'else' node
    NodeList<IfNode> IfParts;
  };

  // Declares that a class sends a particular type of event
  class SendsEventNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(SendsEventNode, SyntaxNode);
    ZilchClonableNode(SendsEventNode);

    // Constructor
    SendsEventNode();

    // SyntaxNode interface
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The type of event we send
    SyntaxType* EventType;

    // The name of the event we send
    const UserToken* Name;

    // The static property that allows users access to the event (string type)
    Property* EventProperty;
  };

  // An break node represents the break statement in a loop
  class BreakNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(BreakNode, StatementNode);
    ZilchClonableNode(BreakNode);

    // Constructor
    BreakNode();

    // How many scopes we wish to break out of (default 1)
    size_t ScopeCount;

    // The instruction index for where the jump occurs
    size_t InstructionIndex;

    // The jump opcode that's associated with our continue (where we jump to)
    // We need to store this so that, after we build code for a function, we can
    // come back to this statement and setup the jump to the end of the loop
    RelativeJumpOpcode* JumpOpcode;
  };

  // An break node represents a debug breakpoint in the virtual machine
  class DebugBreakNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DebugBreakNode, StatementNode);
    ZilchClonableNode(DebugBreakNode);
  };

  // An continue node represents the continue statement in a loop
  class ContinueNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ContinueNode, StatementNode);
    ZilchClonableNode(ContinueNode);

    // Constructor
    ContinueNode();

    // The instruction index for where the jump occurs
    size_t InstructionIndex;

    // The jump opcode that's associated with our continue (where we jump to)
    // We need to store this so that, after we build code for a function, we can
    // come back to this statement and setup the jump to the end of the loop
    RelativeJumpOpcode* JumpOpcode;
  };

  // Represents throwing an exception in langugae
  class ThrowNode : public StatementNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ThrowNode, StatementNode);
    ZilchClonableNode(ThrowNode);

    // Constructor
    ThrowNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The exception to be thrown
    ExpressionNode* Exception;
  };

  // A loop scope is a scope that we can break out of or continue from
  class LoopScopeNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LoopScopeNode, ScopeNode);

    // Default constructor
    LoopScopeNode();

    // Copy constructor
    LoopScopeNode(const LoopScopeNode& toCopy);

    // Store a list of any break statements that are targeted at us
    Array<BreakNode*> Breaks;

    // Store a list of any continue statements that are targeted at us
    Array<ContinueNode*> Continues;
  };

  // A loop that contains a conditional expression
  class ConditionalLoopNode : public LoopScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ConditionalLoopNode, LoopScopeNode);

    // Constructor
    ConditionalLoopNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The conditional expression used in this if statement
    ExpressionNode* Condition;
  };

  // A while node represents the a while loop
  class WhileNode : public ConditionalLoopNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(WhileNode, ConditionalLoopNode);
    ZilchClonableNode(WhileNode);
  };

  // A do-while node represents the a do-while loop
  class DoWhileNode : public ConditionalLoopNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DoWhileNode, ConditionalLoopNode);
    ZilchClonableNode(DoWhileNode);
  };

  // A for node represents the a for loop
  class ForNode : public ConditionalLoopNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ForNode, ConditionalLoopNode);
    ZilchClonableNode(ForNode);

    // Constructor
    ForNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // The creation of the variable (the first part)
    LocalVariableNode* ValueVariable;

    // Only used in the case of 'foreach' to store a temporary range variable
    LocalVariableNode* RangeVariable;

    // Alternative, instead of a variable we could have an initialization expression
    ExpressionNode* Initialization;

    // The iterator expression of the for loop (the last part)
    ExpressionNode* Iterator;
  };

  // A for node represents the a for loop
  class ForEachNode : public ForNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ForEachNode, ForNode);
    ZilchClonableNode(ForEachNode);

    // Constructor
    ForEachNode();
    
    // SyntaxNode interface
    void PopulateNonTraversedChildren(NodeChildren& childrenOut) override;
    
    // The original variable that was declared
    // This is not used by the Syntaxer or CodeGenerator (only there for translation and other purposes)
    LocalVariableNode* NonTraversedVariable;

    // The original range we used (eg, array.All)
    // This is not used by the Syntaxer or CodeGenerator (only there for translation and other purposes)
    ExpressionNode* NonTraversedRange;
  };

  // A loop node represents the a loop
  class LoopNode : public LoopScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LoopNode, LoopScopeNode);
    ZilchClonableNode(LoopNode);
  };

  // A generic function only takes parameters, has no returns and is not marked as static
  class GenericFunctionNode : public ScopeNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(GenericFunctionNode, ScopeNode);

    // Constructor
    GenericFunctionNode();
    
    // SyntaxNode interface
    void PopulateChildren(NodeChildren& childrenOut) override;

    // A genetated type for this function (the type is the signature type)
    DelegateType* Type;

    // The function definition that this node represents (will be filled in later)
    Function* DefinedFunction;

    // The parameters defined for the function (names, types, defaults, etc)
    NodeList<ParameterNode> Parameters;

    // A pointer to the attributes this function has
    NodeList<AttributeNode> Attributes;

    // For auto-complete, one of the methods we use is to build a psuedo class and function
    // that we evaluate expressions within. This works for most expressions, except when the
    // expression relies upon the 'this' variable, in which the type would result in the pseudo class
    // Therefore, we actually replace the type with the old previously compiled version if it exists
    //BoundType* SubstituteTypeOfThisVariable;
  };

  // A function node represent the definition of a function
  class FunctionNode : public GenericFunctionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(FunctionNode, GenericFunctionNode);
    ZilchClonableNode(FunctionNode);

    // Constructor
    FunctionNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The given name of the function
    String Name;

    // The return type of the function (or null if there is none)
    SyntaxType* ReturnType;

    // Is the function a static function?
    bool IsStatic;

    // Is the function a virtual function (or overriding)?
    VirtualMode::Enum Virtualized;
  };

  // Note that represents an initializer in the initailizer list
  class InitializerNode : public ExpressionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(InitializerNode, ExpressionNode);
    ZilchClonableNode(InitializerNode);

    // Constructor
    InitializerNode();
    
    // Whatever it is we're initializing (this or base)
    const UserToken* InitializerType;

    // The function that this initializer invoke
    Function* InitializerFunction;
  };

  // A constructor is a specialized function for creating and initializing an object
  class ConstructorNode : public GenericFunctionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ConstructorNode, GenericFunctionNode);
    ZilchClonableNode(ConstructorNode);

    // Constructor
    ConstructorNode();

    // These are not owned initializers (technically the first statements in the constructor own them)
    // Hence we do not override 'PopulateChildren' and output these
    // If the initializers exist as the first statements, these MUST be set to be a valid tree
    // The presense of the base initializer tells us if we initialized our base or not
    InitializerNode* BaseInitializer;
    InitializerNode* ThisInitializer;
  };

  // A destructor is a specialized function for destroying an object
  class DestructorNode : public GenericFunctionNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(DestructorNode, GenericFunctionNode);
    ZilchClonableNode(DestructorNode);
  };

  // A class node represents the definition of a class
  class ClassNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(ClassNode, SyntaxNode);
    ZilchClonableNode(ClassNode);

    // Constructor
    ClassNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The name of the class
    String Name;

    // If the node represents a value type or not
    TypeCopyMode::Enum CopyMode;

    // The resolved type of the class
    BoundType* Type;

    // The names of the parent types
    SyntaxTypeList Inheritance;

    // Any template arguments
    Array<const UserToken*> TemplateArguments;

    // A list of member variables defined in the class
    NodeList<MemberVariableNode> Variables;

    // A list of functions defined in the class
    NodeList<FunctionNode> Functions;

    // A list of constructors defined in the class
    NodeList<ConstructorNode> Constructors;

    // A list of events that we send
    NodeList<SendsEventNode> SendsEvents;

    // A singular destructor
    DestructorNode* Destructor;

    // Contains all types of members that a class can have in the order they are declared (generally used for formatting)
    NodeList<SyntaxNode> NonTraversedNonOwnedNodesInOrder;

    // This function basically acts as a constructor that initializes all the members before we run the invoked constructor
    Function* PreConstructor;

    // A pointer to the attributes this class has
    NodeList<AttributeNode> Attributes;

    // Only valid when the class is a templated class
    // This is used for when the syntax tree for the class gets cloned
    // in order to make a template instantiation
    // (this is how we know it is a clone and not the original source!)
    const BoundSyntaxType* TemplateInstantiation;

    // Check if this class is a templated class
    bool IsTemplate() const;
  };

  // An enum value declared within an enum
  class EnumValueNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(EnumValueNode, SyntaxNode);
    ZilchClonableNode(EnumValueNode);

    // Constructor
    EnumValueNode();

    // SyntaxNode interface
    String ToString() const override;

    // The name of the value
    String Name;
    
    // The integral value of this entry (or null if there is no user set value)
    const UserToken* Value;

    // The actual value assigned to this enum entry (Syntaxer)
    Integer IntegralValue;

    // The static property that we use at runtime to get the value
    Property* IntegralProperty;
  };

  // An enum node represents constant integral values that count up (or bitwise flags)
  class EnumNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(EnumNode, SyntaxNode);
    ZilchClonableNode(EnumNode);

    // Constructor
    EnumNode();
    
    // SyntaxNode interface
    String ToString() const override;
    void PopulateChildren(NodeChildren& childrenOut) override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The name of the enum
    String Name;

    // Whether or not this enum is considered to be flags
    // Flags allow operations such as bitwise or/and/xor
    bool IsFlags;

    // The resolved type of the enum
    BoundType* Type;

    // The names of the parent type, or null if we don't have one
    SyntaxType* Inheritance;

    // A list of enum values (integral constants)
    // These values may have a user set value or may be auto-picked
    NodeList<EnumValueNode> Values;

    // A pointer to the attributes this class has
    NodeList<AttributeNode> Attributes;
  };

  // A type-define node represnts 
  class TypeDefineNode : public SyntaxNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(TypeDefineNode, SyntaxNode);
    ZilchClonableNode(TypeDefineNode);

    // Constructor
    TypeDefineNode();

    // SyntaxNode interface
    String ToString() const override;
    void PopulateSyntaxTypes(SyntaxTypes& typesOut) override;

    // The name that we're giving the type-definition
    const UserToken* Name;

    // The type that we represent
    SyntaxType* Type;
  };

  // A local variable reference node replaces a generic identifier node
  class LocalVariableReferenceNode : public ValueNode
  {
  public:
    // Declare the class for RTTI
    ZilchDeclareDerivedType(LocalVariableReferenceNode, ValueNode);
    ZilchClonableNode(LocalVariableReferenceNode);

    // Constructor
    LocalVariableReferenceNode();

    // SyntaxNode interface
    String ToString() const override;

    // Store a reference to the variable
    Variable* AccessedVariable;
  };
}

// End header protection
#endif/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_TOKENIZER_HPP
#define ZILCH_TOKENIZER_HPP

// Includes

namespace Zilch
{
  // This class parses the input stream using a grammar
  class Tokenizer
  {
  public:

    // Constructor
    Tokenizer(CompilationErrors& errors);

    // Parse data from a null terminated memory pointer
    bool Parse(const CodeEntry& entry, Array<UserToken>& tokensOut, Array<UserToken>& commentsOut);

    // Finalizes a token stream
    void Finalize(Array<UserToken>& tokensOut);

    // Commonly used imposter tokens for generated code
    static const UserToken* GetBaseToken();
    static const UserToken* GetThisToken();
    static const UserToken* GetValueToken();
    static const UserToken* GetAccessToken();
    static const UserToken* GetAssignmentToken();

  private:

    // Initialize the internals
    void InitializeInternals();

    // Reads back a character out of the input stream
    inline char ReadCharacter();

    // Traverse through the rest of the input buffer and compare it to the given string
    bool DiffString(const char* string);

    // Attempts to read a keyword or a symbol (any non-varying token)
    inline bool ReadKeywordOrSymbol(UserToken* outToken, size_t& lastAcceptedPos, char& character, TokenCategory::Enum& tokenType);

    // Attempt to read an identifier
    bool ReadIdentifier(UserToken* outToken, bool startedFromKeyword, size_t& lastAcceptedPos, char& character);

    // Attempt to read a number (both real or integer)
    bool ReadNumber(UserToken* outToken, size_t& lastAcceptedPos, char& character);

    // Attempt to read a string
    bool ReadString(UserToken* outToken, size_t& lastAcceptedPos, char& character);

    // Attempts to read a token
    bool ReadToken(UserToken* outToken);

    // Update what line and character we're on
    void UpdateLineAndCharacterNumber(char character);

    // Skip to the end of the line via modifying the position
    String SkipToEndOfLine();

    // Parse the data
    bool ParseInternal(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut);

  public:

    // When set, we will parse the special '`' characters in strings to mean string interpolation (default true)
    bool EnableStringInterpolation;

  private:

    // The token that means 'end of file'
    UserToken Eof;

    // Store a reference to the error handler
    CompilationErrors& Errors;

    // The script string that needs to be tokenized
    String Data;

    // If the last character we read was a carriage return
    // This is to support the CRLF style newlines (which only counts as one line, not two)
    bool WasCarriageReturn;

    // The position in the data stream
    size_t Position;

    // The most forward position we've reached
    size_t ForwardPosition;

    // The location that we're at in the tokenizer (only updated when we read full tokens)
    CodeLocation Location;

    // The location that we're at in the tokenizer that is updated with every character read
    size_t Character;
    size_t Line;

    // The depth of comment we're in (how many nested block comments inside of block comments)
    size_t CommentDepth;

    // Not copyable
    ZilchNoCopy(Tokenizer);
  };

  // Character utilities that we use for tokenizing
  class CharacterUtilities
  {
  public:
    // Detect if a character is a white-space character
    static bool IsWhiteSpace(char c);

    // Detect if a character is alpha
    static bool IsAlpha(char c);

    // Detect if a character is numeric
    static bool IsNumeric(char c);

    // Detect if a character is alpha-numeric
    static bool IsAlphaNumeric(char c);

    // Detect if a character is uppercase
    static bool IsUpper(char c);

    // Is this a valid escape character in a string literal
    static bool IsStringEscapee(char c);
  };
}

// End header protection
#endif/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_SYNTAXER_HPP
#define ZILCH_SYNTAXER_HPP

// Includes

namespace Zilch
{
  // A context we use to collect all class types
  class ClassContext : public WalkerContext<Syntaxer, ClassContext>
  {
  public:
    // Store all the classes we're compiling
    Array<BoundType*> AllClasses;
  };

  // A context used for walking everything (classes, functions, expressions, etc)
  class TypingContext : public WalkerContext<Syntaxer, TypingContext>
  {
  public:
    // Store the current function that we're building
    FunctionArray FunctionStack;

    // Store the current type that we're building
    Array<BoundType*> ClassTypeStack;

    // In general it should not be required to clear this context, however, because of
    // tolerant mode it is possible to end a tree walk and still have data in the context stacks
    // If we are not in tolerant mode, this will assert if anything is leftover
    void Clear(bool tolerantMode);
  };

  // This class implements a recursive descent parser that parses
  // through the token stream that we get from the tokenizer
  class Syntaxer
  {
  public:

    // Friends
    friend class CodeGenerator;
    friend class Overload;

    // Constructor
    Syntaxer(CompilationErrors& errors);

    // Destructor
    ~Syntaxer();

    // Perform type collecting, assigning, and checking on the tree or an individual expression
    void ApplyToTree
    (
      SyntaxTree& syntaxTree,
      LibraryBuilder& builder,
      const Array<TypeParsedDelegate>& typeParseCallbacks,
      const Module& dependencies
    );

    // Retrieves/resolves a type if it exists
    Type* RetrieveType(const SyntaxType* syntaxType, const CodeLocation& location, const Module& dependencies);

  private:

    // Walk through all dependenices, collect all their types and store them in a map
    void PopulateDependencies();

    // Print out an error message corresponding to a given node
    void ErrorAt(SyntaxNode* node, ErrorCode::Enum errorCode, ...);

    // Print out an error message corresponding to a given node
    void ErrorAtArgs(SyntaxNode* node, ErrorCode::Enum errorCode, va_list argList);

    // Compute the size of the type
    void ComputeSize(BoundType* type, const HashMap<Type*, BoundType*>& ourClasses, const CodeLocation& location);

    // Replace a populated array of syntax types
    void ReplaceTypes(SyntaxTypes& types, Array<const UserToken*>& names, const BoundSyntaxType* instanceType, const CodeLocation& location);

    // Recursively perform a templated replacement of certain parameters
    void PerformTemplateReplacement(SyntaxType* type, Array<const UserToken*>& names, const BoundSyntaxType* instanceType);
    void PerformTemplateReplacement(SyntaxNode* node, Array<const UserToken*>& names, const BoundSyntaxType* instanceType);

    // Retrieves a type by name (for cases where you expect the type to exist
    BoundType* RetrieveBoundType(const BoundSyntaxType* type, const CodeLocation& location);

    // Retrieves a type if it exists (or potentially creates a type if it's a qualified version of a type that exists)
    Type* RetrieveType(const SyntaxType* syntaxType, const CodeLocation& location);

    // Make sure we don't have another class/struct/enum of the same name
    // Sets WasError if another type exists of the same name
    void PreventDuplicateTypeNames(StringParam name, const CodeLocation& location);

    // Make sure we don't have another member of the same name (an exception is made for functions due to overloading)
    // Sets WasError if another type exists of the same name
    void PreventDuplicateMemberNames(BoundType* type, StringParam memberName, const CodeLocation& location, bool isStatic, bool isFunction);

    // Collect a class type
    void CollectClass(ClassNode*& node, ClassContext* context);

    // Collect an enum type
    void CollectEnum(EnumNode*& node, ClassContext* context);

    // Collect all template instantiations
    void CollectTemplateInstantiations(SyntaxNode*& node, ClassContext* context);

    // Given a list of syntax types, attempt to instantiate any referenced templates from them (recursive)
    void InstantiateTemplatesFromSyntaxTypes(SyntaxTypes& types, ClassContext* context, const CodeLocation& location);
    
    // Setup a class instance for a given class node (called by CollectClass, and CollectTemplateInstantiations)
    void SetupClassInstance(ClassNode* node, ClassContext* context);

    // Read all the attributes from an attribute node list into an array of attributes
    void ReadAttributes(SyntaxNode* parentNode, NodeList<AttributeNode>& nodes, Array<Attribute>& attributesOut);

    // Setup the inheritance chain (including interfaces and base class)
    void CollectClassInheritance(ClassNode*& node, TypingContext* context);

    // Collect all instances of send events declarations
    void CollectSendsEvents(SendsEventNode*& node, TypingContext* context);

    // Setup the inheritance chain for enums (only one parent, no interfaces)
    void CollectEnumInheritance(EnumNode*& node, TypingContext* context);

    // Collect/setup all the functions
    void SetupGenericFunction(GenericFunctionNode* node, TypingContext* context, String name, FunctionOptions::Enum options, Type* returnType);

    // Collect all the constructors
    void CollectConstructor(ConstructorNode*& node, TypingContext* context);

    // Collect the destructor (if it exists)
    void CollectDestructor(DestructorNode*& node, TypingContext* context);

    // Collect all the functions
    void CollectFunction(FunctionNode*& node, TypingContext* context);

    // Collect the member variables
    void CollectMemberVariableAndProperty(MemberVariableNode*& node, TypingContext* context);

    // Collect the member properties
    void CollectPropertyGetSet(MemberVariableNode*& node, TypingContext* context);

    // Store the class in the code context
    void PushClass(ClassNode*& node, TypingContext* context);

    // Process all statements in a scope
    void ProcessScopeStatements(ScopeNode* node, TypingContext* context);

    // Helper functions
    template <typename FunctionNodeType>
    void PushFunctionHelper
    (
      FunctionNodeType* node,
      TypingContext* context,
      void (Syntaxer::*postArgs)(FunctionNodeType* node)
    );

    // Store the function in the code context
    void PushFunction(GenericFunctionNode*& node, TypingContext* context);

    // Store the constructor function in the code context
    void CheckInitializerList(ConstructorNode* node);
    void PushConstructor(ConstructorNode*& node, TypingContext* context);

    // Assign a type to any child value node
    void DecorateValue(ValueNode*& node, TypingContext* context);

    // Let the string interpolant know it's of a string type
    void DecorateStringInterpolant(StringInterpolantNode*& node, TypingContext* context);
    
    // Assign a type to the initializer
    void DecorateInitializer(InitializerNode*& node, TypingContext* context);

    // Handle checking that the creation call is valid for its type (also infers new/local if not provided)
    void DecorateCreationCall(CreationCallNode*& node, TypingContext* context);

    // Handle initializing a created object (or adding to a container)
    void DecorateCreationInitializer(CreationInitializerNode*& node, TypingContext* context);
    
    // Handle forwarding values from an unnamed operand (the node it referes to should have been processed!)
    void DecorateUnnamedOperand(UnnamedOperandNode*& node, TypingContext* context);

    // Make sure type-id results in a type
    void DecorateTypeId(TypeIdNode*& node, TypingContext* context);

    // Assign member variable types (if required), and check that the initialization type matches
    void CheckMemberVariable(MemberVariableNode*& node, TypingContext* context);

    // Assign local variable types (if required), and check that the initialization type matches
    void CheckLocalVariable(LocalVariableNode*& node, TypingContext* context);

    // Check the type of an delete statement's expression
    void CheckDelete(DeleteNode*& node, TypingContext* context);

    // Check that the type of a throw statement is an exception type (inherits from)
    void CheckThrow(ThrowNode*& node, TypingContext* context);

    // Check the condition and statements in a conditional loop
    void CheckConditionalLoop(ConditionalLoopNode* node, TypingContext* context);

    // Check the type of an while statement's condition
    void CheckWhile(WhileNode*& node, TypingContext* context);

    // Check the type of an do while statement's condition
    void CheckDoWhile(DoWhileNode*& node, TypingContext* context);

    // Check the type of an for statement's condition
    void CheckFor(ForNode*& node, TypingContext* context);

    // Checks the statements within a loop node
    void CheckLoop(LoopNode*& node, TypingContext* context);

    // Checks the statements within a scope node
    void CheckScope(ScopeNode*& node, TypingContext* context);

    // Checks the statements within a timeout node
    void CheckTimeout(TimeoutNode*& node, TypingContext* context);

    // Check the type of an if statement's condition
    void CheckIfRoot(IfRootNode*& node, TypingContext* context);

    // Check the type of an if statement's condition
    void CheckIf(IfNode*& node, TypingContext* context);

    // Find a loop scope node above our own node in the tree
    LoopScopeNode* FindLoopScope(size_t scopeCount, SyntaxNode* parent);

    // Check the type of an break statement's condition
    void CheckBreak(BreakNode*& node, TypingContext* context);

    // Check the type of an continue statement's condition
    void CheckContinue(ContinueNode*& node, TypingContext* context);

    // Resolve a local variable reference (get the variable its referencing)
    void ResolveLocalVariableReference(LocalVariableReferenceNode*& node, TypingContext* context);

    // Mark the parent scope node as being a complete path
    void MarkParentScopeAsAllPathsReturn(SyntaxNode* parent, bool isDebugReturn);

    // If the types are the same, no conversion is applied and the node is left alone
    // If the types are different and an implicit conversion exists, then it will reparent the expression to a TypeCastNode
    // Otherwise, it will return false since no conversion is available
    // Note: Always remember to pass the actual node pointer in instead of a stack local so we can modify it in place!
    static bool ImplicitConvertAfterWalkAndIo(ExpressionNode*& nodeToReparent, Type* toType);

    // Check the type of a return value
    void CheckReturn(ReturnNode*& node, TypingContext* context);

    // Assign a type to a type cast expression (and check the type)
    void DecorateCheckTypeCast(TypeCastNode*& node, TypingContext* context);

    // Assign a type to a function call (and check the type)
    void DecorateCheckFunctionCall(FunctionCallNode*& node, TypingContext* context);

    // Check that the binary operator is valid and that it's types are valid
    void DecorateCheckBinaryOperator(BinaryOperatorNode*& node, TypingContext* context);

    // Check that the unary operator is valid and that it's types are valid
    void DecorateCheckPropertyDelegateOperator(PropertyDelegateOperatorNode*& node, TypingContext* context);

    // Check that the unary operator is valid and that it's types are valid
    void DecorateCheckUnaryOperator(UnaryOperatorNode*& node, TypingContext* context);

    // Check all expressions and verify that their io modes are being used properly
    void CheckExpressionIoModes(ExpressionNode*& node, TypingContext* context);

    // Make sure all nodes know which library, class, and function they belong to
    void DecorateCodeLocations(SyntaxNode*& node, TypingContext* context);

    // Utility for replacing/clarifying a member access operator (works with both static and instance members)
    void ResolveMemberAccess(MemberAccessNode* node, const Resolver& resolver);

    // Resolve the node type of a member (after a member access operator...)
    void ResolveMember(MemberAccessNode*& node, TypingContext* context);

    // Resolve the node type of a member on a type
    void ResolveTypeMember(TypeMemberAccessNode*& node, TypingContext* context);

  private:

    // Store a pointer to the current syntax tree
    SyntaxTree* Tree;

    // A list of callbacks to invoke when we parse/discover a type
    const Array<TypeParsedDelegate>* TypeParsedHandlers;

    // Store a reference to the error handler
    CompilationErrors& Errors;

    // The library builder we use to generate the library
    LibraryBuilder* Builder;

    // All the other libraries we depend upon
    const Module* Dependencies;

    // All the dependency libraries, and our own (useful for generic searching)
    LibraryArray AllLibraries;

    // Store a map of all the named external types
    BoundTypeMap ExternalBoundTypes;

    // All named tempalte types
    HashMap<String, ClassNode*> InternalBoundTemplates;

    // A map that allows us to cut down on the number of qualified types we allocate
    TypeToIndirect IndirectTypes;

    // All the branch walkers
    BranchWalker<Syntaxer, ClassContext>  ClassWalker;
    BranchWalker<Syntaxer, ClassContext>  TemplateWalker;
    BranchWalker<Syntaxer, TypingContext> MemberWalker;
    BranchWalker<Syntaxer, TypingContext> FunctionWalker;
    BranchWalker<Syntaxer, TypingContext> LocationWalker;
    BranchWalker<Syntaxer, TypingContext> TypingWalker;
    BranchWalker<Syntaxer, TypingContext> ExpressionWalker;

    // Not copyable
    ZilchNoCopy(Syntaxer);
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_VIRTUAL_MACHINE_HPP
#define ZILCH_VIRTUAL_MACHINE_HPP

// Includes

namespace Zilch
{
  // This class is responsible for executing a stream of opcodes
  class VirtualMachine
  {
  public:

    // Execute a function, starting from a given stack frame
    static void ExecuteNext(Call& call, ExceptionReport& report);

    // Return the value of an enum property (the user data contains the value)
    static void EnumProperty(Call& call, ExceptionReport& report);

    // Return an events name string (the user data contains the value)
    static void EventsProperty(Call& call, ExceptionReport& report);

    // Executes a destructor not actually from opcode, but
    // rather from a separate handle list on the ClassType
    static void PostDestructor(BoundType* boundType, byte* objectData);

    // Generic integral power (expands to other integral sizes)
    template <typename T>
    static inline T IntegralPower(T base, T exponent)
    {
      T result = exponent >= 0;
      while (exponent && result)
      {
          if (exponent & 1)
          {
              result *= base;
          }

          exponent >>= 1;
          base *= base;
      }

      return result;
    }

    // A generic wrapper around 'raise to a power'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericPow(T& out, const T& base, const T& exponent)
    {
      out = pow(base, exponent);
    }

    // A generic wrapper around 'modulus / remainder'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericMod(T& out, const T& value, const T& mod)
    {
      out = value % mod;
    }

    // A generic wrapper around 'increment'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericIncrement(T& value)
    {
      ++value;
    }

    // A generic wrapper around 'decrement'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename T>
    static inline void GenericDecrement(T& value)
    {
      --value;
    }

    // Checks if a value is zero or contains any zeros (in the case of vectors)
    template <typename T>
    static inline bool GenericIsZero(const T& value)
    {
      return value == 0;
    }

    // A generic wrapper around 'vector raise to a scalar power'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename VectorType, typename ScalarType>
    static inline void GenericScalarPow(VectorType& out, const VectorType& base, const ScalarType& exponent);

    // A generic wrapper around 'vector modulus / remainder by a scalar'
    // Note that in cases of compound assignment, the value can be the out!
    template <typename VectorType, typename ScalarType>
    static inline void GenericScalarMod(VectorType& out, const VectorType& value, const ScalarType& mod)
    {
      out = value % mod;
    }
  };

  // Note: These HAVE to be declared in namespace scope according to the C++ spec (cannot be put inside the class)
  // Specializations for Pow
  template <>
  inline void VirtualMachine::GenericPow<Integer>(Integer& out, const Integer& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Integer2>(Integer2& out, const Integer2& base, const Integer2& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Integer3>(Integer3& out, const Integer3& base, const Integer3& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Integer4>(Integer4& out, const Integer4& base, const Integer4& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Real2>(Real2& out, const Real2& base, const Real2& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Real3>(Real3& out, const Real3& base, const Real3& exponent);
  template <>
  inline void VirtualMachine::GenericPow<Real4>(Real4& out, const Real4& base, const Real4& exponent);
  template <>
  inline void VirtualMachine::GenericPow<DoubleInteger>(DoubleInteger& out, const DoubleInteger& base, const DoubleInteger& exponent);

  // Specializations for Mod
  template <>
  inline void VirtualMachine::GenericMod<Real>(Real& out, const Real& value, const Real& mod);
  template <>
  inline void VirtualMachine::GenericMod<Real2>(Real2& out, const Real2& value, const Real2& mod);
  template <>
  inline void VirtualMachine::GenericMod<Real3>(Real3& out, const Real3& value, const Real3& mod);
  template <>
  inline void VirtualMachine::GenericMod<Real4>(Real4& out, const Real4& value, const Real4& mod);
  template <>
  inline void VirtualMachine::GenericMod<DoubleReal>(DoubleReal& out, const DoubleReal& value, const DoubleReal& mod);

  // Specializations for Scalar Pow
  template <>
  inline void VirtualMachine::GenericScalarPow<Integer2, Integer>(Integer2& out, const Integer2& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Integer3, Integer>(Integer3& out, const Integer3& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Integer4, Integer>(Integer4& out, const Integer4& base, const Integer& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Real2, Real>(Real2& out, const Real2& base, const Real& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Real3, Real>(Real3& out, const Real3& base, const Real& exponent);
  template <>
  inline void VirtualMachine::GenericScalarPow<Real4, Real>(Real4& out, const Real4& base, const Real& exponent);

  // Specializations for Scalar Mod
  template <>
  inline void VirtualMachine::GenericScalarMod<Real2, Real>(Real2& out, const Real2& value, const Real& mod);
  template <>
  inline void VirtualMachine::GenericScalarMod<Real3, Real>(Real3& out, const Real3& value, const Real& mod);
  template <>
  inline void VirtualMachine::GenericScalarMod<Real4, Real>(Real4& out, const Real4& value, const Real& mod);

  // Specializations for Scalar Increment
  template <>
  inline void VirtualMachine::GenericIncrement<Real2>(Real2& out);
  template <>
  inline void VirtualMachine::GenericIncrement<Real3>(Real3& out);
  template <>
  inline void VirtualMachine::GenericIncrement<Real4>(Real4& out);

  // Specializations for Scalar Decrement
  template <>
  inline void VirtualMachine::GenericDecrement<Real2>(Real2& out);
  template <>
  inline void VirtualMachine::GenericDecrement<Real3>(Real3& out);
  template <>
  inline void VirtualMachine::GenericDecrement<Real4>(Real4& out);

  // Specializations for IsZero
  template <>
  inline bool VirtualMachine::GenericIsZero<Integer2>(const Integer2& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Integer3>(const Integer3& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Integer4>(const Integer4& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Real2>(const Real2& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Real3>(const Real3& value);
  template <>
  inline bool VirtualMachine::GenericIsZero<Real4>(const Real4& value);
}

// Crash report capture variables
// This is an attempt to force crash reports to store a variable / indirectly referenced memory (not thread safe either)
// Do NOT ever attempt to access this variable or do anything with it in code
extern byte* ZilchLastRunningOpcode;
extern Zilch::Function* ZilchLastRunningFunction;
extern size_t ZilchLastRunningOpcodeLength;

// End header protection
#endif
/**************************************************************\
* Author: Joshua Davis
* Copyright 2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_MATRIX_HPP
#define ZILCH_MATRIX_HPP

namespace Zilch
{

  // User data for a single matrix so that functions can be generic
  // to matrices of different sizes and types
  class MatrixUserData
  {
  public:
    MatrixUserData()
      : SizeX(4), SizeY(4), ElementTypeIndex(0)
    {

    }

    MatrixUserData(size_t sizeX, size_t sizeY, size_t elementTypeIndex)
      : SizeX(sizeX), SizeY(sizeY), ElementTypeIndex(elementTypeIndex)
    {

    }

    size_t SizeX;
    size_t SizeY;
    // What kind of matrix this is (Real, Integer, Boolean).
    // This is an index into Core::MatrixElementTypes.
    size_t ElementTypeIndex;
  };

  // Create all of the matrix types and their functions on the math class
  void CreateMatrixTypes(LibraryBuilder& builder);

}//namespace Zilch

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_DEBUGGING_HPP
#define ZILCH_DEBUGGING_HPP

// Includes

/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_WEB_SOCKET_HPP
#define ZILCH_WEB_SOCKET_HPP

// Includes

namespace Zilch
{
  ZilchStaticLibrary(WebSockets);

  namespace Events
  {
    // Sent when the listener accepts a connection
    // This event MUST be handled, otherwise the accepted web-sockets will leak
    ZilchDeclareEvent(WebSocketAcceptedConnection, WebSocketEvent);

    // Sent any time the threaded web-socket receives data
    ZilchDeclareEvent(WebSocketReceivedData, WebSocketEvent);

    // Sent any time the threaded web-socket encounters an error
    // This should generally always be followed by a disconnect event
    ZilchDeclareEvent(WebSocketError, WebSocketEvent);

    // Sent any time the threaded web-socket is closed
    // If an error occurs, the web-socket is automatically closed and this event will be sent
    ZilchDeclareEvent(WebSocketDisconnected, WebSocketEvent);
  }

  // Describes the raw types of packets we can receive
  // The only packets that the user will recieve is Text and Binary
  // (all other packets are handled internally)
  namespace WebSocketPacketType
  {
    enum Enum
    {
      Invalid       = -1,
      Continuation  = 0x00,
      Text          = 0x01,
      Binary        = 0x02,
      // Reserved Non-Control Frames 0x03-0x07
      Close         = 0x08,
      Ping          = 0x09,
      Pong          = 0x0A
      // Reserved Control Frames 0x0B-0x0F
    };
  }

  // Forward declarations
  class ThreadedWebSocketConnection;

  // An event sent out whenever a web socket connection changes or receives data
  class WebSocketEvent : public EventData
  {
  public:
    ZilchDeclareDerivedType(WebSocketEvent, EventData);

    // Default constructor
    WebSocketEvent();

    // The connection involved in the event
    ThreadedWebSocketConnection* Connection;

    // If we received data, this will contain the data we received (otherwise will be empty if not applicable)
    WebSocketPacketType::Enum PacketType;

    // Any data that was received by the connection (or empty if not applicable)
    // The data can be binary or text, depending on PacketType
    String Data;

    // If any error occurred, this status will hold the error message and state
    Status ErrorStatus;
  };

  // A connection that we can communicate on (could be from cient to server, or server to client)
  // With the blocking version, the user must properly respond to the Close and Ping messages
  // The threaded version internally takes care of these messages
  class BlockingWebSocketConnection
  {
  public:

    // Constructor
    BlockingWebSocketConnection();
    
    // All the values we read from the HTTP headers
    HashMap<String, String> Headers;

    // Send a full packet to the remote end
    // This function will block until the entire packet is sent
    // It is safe to call this function from another thread (only one thread at a time though)
    void SendFullPacket(Status& status, const byte* data, size_t length, WebSocketPacketType::Enum packetType);

    // Receives an entire packet of data into an array
    // This function will block until the entire packet is received, or an error occurs
    // It is safe to call this function from another thread (only one thread at a time though)
    // Note: We use strings both as text and binary blobs of data
    // If we return an 'Invalid' packet, it means the connection was disconnected or an error occurred (check status)
    // The packet types we receive can be Text, Binary, Close, or Ping
    // Close must be responeded to by sending a Close message back, and Ping must be responded to by sending back a Pong
    WebSocketPacketType::Enum ReceiveFullPacket(Status& status, String& dataOut);
    
    // Checks if the connection is initialized
    bool IsValid();

    // The connection to the remote host (we can send and receive on this connection)
    Socket RemoteSocket;

    // The address of the remote host (only here for the user and debugging)
    SocketAddress RemoteAddress;
    
    //******** Internal ********//
    
    // As we read data, we place it into this buffer
    Array<byte> ReadData;
  };

  // Listens for incoming web-socket connections
  // This class should only be initialized and closed once (it should not be reused)
  class BlockingWebSocketListener
  {
  public:

    // Constructor
    BlockingWebSocketListener();

    // Host a server on a given port and initialize the internal socket
    void Initialize(Status& status, int port);

    // Closes the socket
    void Close(Status& status);

    // Checks if the object is initialized
    bool IsValid();

    // Blocks until we receive an incoming connection
    // This method performs the full web-socket authentication and will not complete
    // until either the connection fails, or the socket is acceptped
    // Ideally the server should be run on another thread due to blocking
    void Accept(Status& status, BlockingWebSocketConnection& connectionOut);

    // The socket that we listen for incoming connections on
    Socket ListenerSocket;
  };

  // A threaded version of the blocking web-socket connection
  // This class can only be initialized from a ThreadedWebSocketListener
  // This class maintains a send and receive thread, and when updated we pull data
  // Either the user or the ThreadedWebSocketServer must periodically call Update from the owning thread
  // All send and update functions are safe to call from the owning thread (not multiple!)
  // Once this connection has been terminated, it may not be used again
  class ThreadedWebSocketConnection : public EventHandler
  {
  public:
    // sends WebSocketReceivedData : WebSocketEvent;
    // sends WebSocketError : WebSocketEvent;
    // sends WebSocketDisconnected : WebSocketEvent;

    // Default constructor
    ThreadedWebSocketConnection();

    // Destructor (terminates threads and closes the socket)
    ~ThreadedWebSocketConnection();

    // Send a single message
    // You should only ever send the Text or Binary packet types
    void SendPacket(StringParam message, WebSocketPacketType::Enum packetType);
    
    // Checks if the connection is initialized
    bool IsValid();

    // Shuts down a connection and closes the socket
    // Only the first call will actually terminate the socket (multiple calls allowed)
    void Close();

    // Pumps both recieved messages and events such as a disconnect
    // If a thread terminates early, or the socket becomes no longer writable, Close will be called and an event will be sent
    void Update();
    
    //******** Internal ********//

    // Thread entrypoints for receive, and send
    static OsInt ReceiveEntryPoint(void* context);
    static OsInt SendEntryPoint(void* context);

    // Sets the web-socket and spins up the send/receive threads
    // We can only be initialized by a listener (after our blocking WebSocket has been initialized)
    void Initialize();
    
    // The thread we receive data on (receive is a blocking call)
    Thread ReceiveThread;

    // We must lock the array of receive messages/errors it before reading or modifying it
    ThreadLock IncomingLock;

    // This array is locked by the web-socket receiving thread (and send thread when errors occur)
    // Any read in messages are enqued here and dispatched when the connection is updated
    // Note: We use strings both as text and binary blobs
    Array<WebSocketEvent> ThreadIncomingEvents;

    // This array of recieved messages is maintained by the owning thread, and is regularly swapped with the 'ThreadReceiveMessages'
    Array<WebSocketEvent> OwnerIncomingEvents;

    // The send outgoing messages on (send is a blocking call)
    Thread SendThread;

    // We must lock the array of send messages it before reading or modifying it
    ThreadLock SendLock;

    // This array is locked by the web-socket sending thread
    // Any messages we want sent should just get added here, and the
    // 'send' event should be signaled once a message is added (or multiple)
    // If the send event is signaled and there are no messages, it means we are being destroyed
    // Note: We use strings both as text and binary blobs
    Array<WebSocketEvent> SendMessages;

    // Every time we add a message to the queue of messages to be sent we
    // signal this event, this will wake up the send thread
    // The send thread will then swap array pointers with the 'SendMessages',
    // which will very quickly pull all the messages off and clear messages to be sent
    // If the send event is signaled and there are no messages, it means we are being destroyed
    OsEvent SendEvent;

    // The web socket we communicate on (where we send our messages, and receive from)
    // All operations are done on other threads (that we properly lock and make safe to pull into the owning thread)
    BlockingWebSocketConnection BlockingConnection;
  };

  
  // Listens for incoming web-socket connections on a thread
  // Can only be used once (once it is closed, it should be removed)
  // Must be preriodically updated by the owning thread, which will then dispatch events for accepted connections
  class ThreadedWebSocketListener : public EventHandler
  {
  public:
    // sends WebSocketAcceptedConnection : WebSocketEvent;
    // sends WebSocketError : WebSocketEvent;

    // Default constructor
    ThreadedWebSocketListener();

    // Destructor (terminates threads and closes the socket)
    ~ThreadedWebSocketListener();

    // Start listening and accepting connections on a given port
    // This also initializes the listener and should only be called once
    void Initialize(int port);

    // Shuts down a connection and closes the socket
    // Only the first call will actually terminate the socket (multiple calls allowed)
    void Close();

    // Checks if the object is initialized
    bool IsValid();
    
    // Updates the web socket connection, which pumps both recieved messages and events such as a disconnect
    void Update();
    
    //******** Internal ********//

    // The thread entrypoint we use for accepting socket connections
    static OsInt AcceptEntryPoint(void* context);

    // The current connection that we are processing
    // It is NOT safe to access this connection from the owning thread, unless using the 'AcceptingConnectionLock'
    // Note: The only action we should use the AcceptingConnectionLock for is terminating
    // the socket for the accepting connection upon our destruction
    ThreadedWebSocketConnection* AcceptingConnection;

    // Whenever the accepting thread creates a connection, it needs to lock to ensure that the owning thread
    // is not also accessing the accepting connection
    // If the accepting thread locks and finds the blocking listening socket to be terminated, we will immediately return
    ThreadLock AcceptingConnectionLock;

    // Anytime a connection is accepted or an error occurs, this must be locked (to write to ThreadIncomingEvents)
    ThreadLock IncomingLock;

    // We maintain a list of all connections that we accept and errors that occur
    Array<WebSocketEvent> ThreadIncomingEvents;

    // This array of recieved messages is maintained by the owning thread, and is regularly swapped with the 'ThreadReceiveMessages'
    Array<WebSocketEvent> OwnerIncomingEvents;

    // The thread we accept connections on
    Thread AcceptThread;

    // We tell the blocking listener to accept connections on the accepting thread
    BlockingWebSocketListener BlockingListener;
  };

  // The web-socket server maintains threaded web-socket connections and invokes
  // callbacks for when connections are received and fully handshook, or closed
  // The thread that owns the server is responsible for occasionally pumping events via Update
  class ThreadedWebSocketServer : public EventHandler
  {
  public:
    // Events will be forwarded from owned connections to the server
    // sends WebSocketAcceptedConnection : WebSocketEvent;
    // sends WebSocketError : WebSocketEvent;
    // sends WebSocketReceivedData : WebSocketEvent;
    // sends WebSocketDisconnected : WebSocketEvent;

    // Default constructor that sets the max connections
    ThreadedWebSocketServer(size_t maxConnections = 64);

    // Destructor (terminates all connections)
    ~ThreadedWebSocketServer();

    // Start listening and accepting connections on a given port
    void Host(int port);

    // Tells us if the server has been initialized (specifically, the listener)
    bool IsValid();

    // Updates the web socket connection, which pumps accepted
    // connections and all sends/recieves on stored connections
    void Update();
    
    // Send a message to all connections
    void SendPacketToAll(StringParam message, WebSocketPacketType::Enum packetType);

    // The maximum number of connections we'll accept
    size_t MaximumConnections;

    // The connections we maintain and accept
    Array<ThreadedWebSocketConnection*> Connections;

    
    //******** Internal ********//

    // Occurs when our listener accepts a connection (only when updating the listener)
    void OnAcceptedConnection(WebSocketEvent* event);

    // The listener we use to accept connections
    ThreadedWebSocketListener Listener;
  };
}

// End header protection
#endif

namespace Zilch
{
  namespace Events
  {
    // Sent repeatedly when the program is frozen by the debugger (a breakpoint is hit, or it is paused)
    // In general no logic that can affect the state of debugging should ever be run within this event handler
    // However, it can be used to draw screen overlays and other indicators to the user
    ZilchDeclareEvent(DebuggerPauseUpdate, DebuggerEvent);

    // Sent when we first pause execution (such as entering a breakpoint or clicking pause)
    ZilchDeclareEvent(DebuggerPause, DebuggerEvent);

    // Sent when we resume execution after being paused
    // Note that stepping a single line will resume and then pause again
    ZilchDeclareEvent(DebuggerResume, DebuggerEvent);
  }

  // When the debugger pauses or resumes, we send this event out
  class DebuggerEvent : public EventData
  {
  public:
    // The debugger we're currently paused inside of
    Debugger* RunningDebugger;

    // The state we're currently paused inside of (last running)
    ExecutableState* State;

    // The location of where we're at in script (generally where we're paused)
    CodeLocation* Location;
  };

  // Every platform should define an error handler
  bool DebugErrorHandler(ErrorSignaler::ErrorData& errorData);

  // Any data we receive from the debugger
  class DebuggerMessage
  {
  public:
    // The root of the json tree
    JsonValue* JsonRoot;

    // The message that we're currently processing
    String Type;
  };

  // The debugger message handler function
  typedef void (*MessageFn)(const DebuggerMessage& message, void* userData);

  namespace DebuggerAction
  {
    enum Enum
    {
      Resume,
      Pause,
      StepOver,
      StepIn,
      StepOut
    };
  }

  // The debugger hosts a web-socket connection and allows an external program to
  // place breakpoints, step over lines, see the call stack, inspect variables, etc
  // The debugger is NOT thread safe, so only ExecutableStates from the same thread
  // should be added to the debugger. Note however that you can create multiple
  // debuggers hosted on different ports for different threads
  // Note: The debugger must be periodically updated
  class Debugger : public EventHandler
  {
  public:
    // sends DebuggerPauseUpdate : DebuggerEvent;
    // sends DebuggerPause : DebuggerEvent;
    // sends DebuggerResume : DebuggerEvent;

    // Constructor
    Debugger();

    // Destructor
    ~Debugger();

    // Starts the debugger hosting on a given port
    void Host(int port);

    // Tells us if the debugger has been initialized (basically if we started hosting or not)
    bool IsValid();

    // The debugger must be periodically updated to ensure that it receives remote messages
    void Update();

    // Adds a project whose files we track
    // We use the hashes of the code from each file to show code entries in the debugger (as well as file name)
    void AddProject(Project* project);

    // Remove a project that we no longer want to track
    void RemoveProject(Project* project);

    // Adds a state to be debugged (this will inform any running debuggers of the new state)
    // Be sure to remove any states that get deleted (they will not be automatically removed!)
    // A state can only be added once (multiple times will be ignored)
    void AddState(ExecutableState* state);

    // Removes a state from the list of states to be debugged
    // It is safe to call this more than once (and can be called even when the state was not added)
    void RemoveState(ExecutableState* state);

    // When we receive a custom json message, this will attempt to handle it
    void AddMessageHandler(StringParam type, MessageFn callback, void* userData);

  private:

    // Send a single message
    void SendPacket(StringParam message);

    // Send a single json built message (helper function)
    void SendPacket(const JsonBuilder& message);

    // When we resume execution, we want to tell the remote client to clear the execution point
    void SetExecutionPoint(CodeLocation* codeLocation, ExecutableState* state);

    // When we resume execution, we want to tell the remote client to clear the execution point
    void ClearExecutionPoint();

    // Updates the view of executable states and their files
    void UpdateExplorerView();

    // The break loop will pause all execution on this thread, only processing debugger messages
    void PauseExecution(CodeLocation* codeLocation, ExecutableState* state);

    // Checks if a type has any debuggable properties (expandable)
    static bool HasDebuggableProperties(Type* type);

    // Called when the remote debugger connects to us
    void OnAcceptedConnection(WebSocketEvent* event);

    // Called by the same thread the debugger / states are on
    // This will process all incoming messages, such as breakpoint, step, continue, etc
    void OnReceivedData(WebSocketEvent* event);

    // Called when we encounter any errors with a connection or the listener (server)
    void OnError(WebSocketEvent* event);

    // Called when the remote debugger disconnects
    void OnDisconnected(WebSocketEvent* event);

    // Attempts to find a code entry by hash (first starting with the project, then with each executable state)
    CodeEntry* FindCodeEntry(size_t hash);

    // Messages from the client:
    // When we receive a remote message to add a breakpoint for a code file and line
    static void OnChangeBreakpoint(const DebuggerMessage& message, void* userData);

    // When we receive a remote message to remove a breakpoint for a code file and line
    static void OnRemoveBreakpoint(const DebuggerMessage& message, void* userData);

    // When the client sends us a common command like pause, resume, step over, etc
    static void OnPause(const DebuggerMessage& message, void* userData);
    static void OnResume(const DebuggerMessage& message, void* userData);
    static void OnStepOver(const DebuggerMessage& message, void* userData);
    static void OnStepIn(const DebuggerMessage& message, void* userData);
    static void OnStepOut(const DebuggerMessage& message, void* userData);
    
    // When the user attempted to view an item in the explorer, we're repsonsible for sending what to show
    static void OnViewExplorerItem(const DebuggerMessage& message, void* userData);
    
    // When the debugger attempts to query an expression (such as when hovering over a variable or watching an expression)
    static void OnQueryExpression(const DebuggerMessage& message, void* userData);

    // Callbacks from the state:
    // Every time the executable state steps into an opcode, this function is called
    static void OnOpcodePreStep(ExecutableState* state, size_t programCounter, CodeLocation* location, const void* userData);

    // Every time the executable state steps into a function, this function is called
    static void OnEnterFunction(ExecutableState* state, Function* function, size_t stackOffset, CodeLocation* location, const void* userData);

    // Every time the executable state steps out of a function, this function is called
    static void OnExitFunction(ExecutableState* state, Function* function, size_t stackOffset, CodeLocation* location, const void* userData);

    // Every time the executable state steps out of a function, this function is called
    static void OnException(ExecutableState* state, Exception* exception, const void* userData);

    // Whenever we print anything out using the console, we want to know about it
    void OnConsoleWrite(ConsoleEvent* event);

  private:

    // This data must be cleared properly upon the client disconnecting
    //******** BEGIN CLEARED DATA ********//
    
    // The last action that was queued up by the debugger for the current state
    DebuggerAction::Enum Action;

    // As we walk over lines of code (callbacks from any running ExecutableState)
    // we will check to see if the line exists in this breakpoints map
    // The map maps from code hash values to line numbers
    HashMap<size_t, HashSet<size_t> > Breakpoints;

    // Store the last location id and line
    CodeLocation LastLocation;

    // The last call stack position (how deep we were)
    size_t LastCallStackDepth;

    // The last state that we were accessing
    ExecutableState* LastState;

    // When we're doing stepping, we need to save the last location here (but not update it with each opcode step)
    CodeLocation StepLocation;

    // The call stack depth where we're stepping out of (state context relative operations)
    size_t StepOutOverCallStackDepth;

    // The state we were using when stepping out / over (state context relative operations)
    ExecutableState* StepOutOverState;

    //******** END CLEARED DATA ********//

    // The states we are currently debugging
    Array<ExecutableState*> States;

    // The projects whose code we are currently viewing
    Array<Project*> Projects;

    // We need to check if any projects change files, then update the remote end if that happens
    // Currently we just scan the projects each update for any changes (we detect changes by looking for hash code changes)
    unsigned long long AllProjectsHashCode;

    // When we recieve messages from the remote client, we look here to handle any messages
    class DebuggerMessageDelegate
    {
    public:
      MessageFn MessageCallback;
      void* UserData;
    };
    HashMap<String, DebuggerMessageDelegate> MessageHandlers;

    // Accepts connections and manages our remote connection
    ThreadedWebSocketServer Server;
  };

  // All information the debugger needs to know per state
  class DebuggerState
  {
  public:
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_PROJECT_HPP
#define ZILCH_PROJECT_HPP

// Includes

namespace Zilch
{
  // Returned when we perform an auto-complete query on the Project
  class AutoCompleteInfo
  {
  public:
    // Constructor
    AutoCompleteInfo();

    // The nearest type we found to the left of the cursor (can be null if we were unable to find it)
    Type* NearestType;

    // If the value we're accessing is a literal value (such as "hello", 5, 3.3, true, false, etc)
    bool IsLiteral;

    // Whether or not we were accessing statics or instance members of the type
    bool IsStatic;

    // In the case that we were accessing overloaded functions, these are our options
    FunctionArray Overloads;

    // We build an incomplete library to keep references to types alive
    LibraryRef IncompleteLibrary;

    // Functions that we generate only to facilitate auto-complete on delegates
    Array<Function> FakeDelegateFunctions;
  };

  // The project contains all the files that are being compiled together
  class Project
  {
  public:
    friend class Debugger;

    // Constructor
    Project(CompilationErrors& errors);

    // Adds a code to the project
    // The origin is the display name (typically the file name)
    // Any time any error occurs with compilation, or anything that references
    // this particular block of code will be linked up to the code user-data
    void AddCodeFromString(StringParam code, StringParam origin = CodeString, void* codeUserData = nullptr);

    // Adds code from a file (see AddCode)
    // Returns true if it succeeded, false otherwise
    bool AddCodeFromFile(StringParam fileName, void* codeUserData = nullptr);

    // Clears out the project (removes all files)
    void Clear();

    // Reads a text file into a string, returns true on success, false on failure
    static bool ReadTextFile(StringParam fileName, String& textOut);

    // Add a callback to the project that tells us when a type gets parsed
    void AddTypeParsedCallback(TypeParsedCallback callback, void* userData);

    // Tokenizes all files into a token stream
    bool Tokenize(Array<UserToken>& tokensOut, Array<UserToken>& commentsOut);

    // Attach all the parsed comments to the syntax tree nodes that are nearby
    void AttachCommentsToNodes(SyntaxTree& syntaxTree, Array<UserToken>& comments);

    // Compiles the project into an unchecked syntax tree (only parsed)
    bool CompileUncheckedSyntaxTree(SyntaxTree& syntaxTreeOut, Array<UserToken>& tokensOut, EvaluationMode::Enum evaluation);

    // Compiles the project into a checked syntax tree
    bool CompileCheckedSyntaxTree
    (
      SyntaxTree& syntaxTreeOut,
      LibraryBuilder& builder,
      Array<UserToken>& tokensOut,
      const Module& dependencies,
      EvaluationMode::Enum evaluation
    );

    // Compiles the project into a single library
    LibraryRef Compile(StringParam libraryName, const Module& dependencies, EvaluationMode::Enum evaluation);

    // Attempt to compile the code in tolerant mode, and return the type nearest to the left hand side of a given cursor
    // This function is generally used for auto-completion lists and will attempt to return the type left of the cursor
    // The minimum code you can provide to the project is a single class (the one that the cursor is inside of, typically the whole file being edited)
    // The old library can be a nullptr, however it is generally recommended to provide it if it has previously been compiled
    // since it will allow the auto-completer to resolve local types too
    void GetAutoCompleteInfo(const Module& dependencies, size_t cursorPosition, StringParam cursorOrigin, AutoCompleteInfo& resultOut);

    // A pointer to any data the user wants to attach
    mutable const void* UserData;

    // Any user data that cant simply be represented by a pointer
    // Data can be written to the buffer and will be properly destructed
    // when this object is destroyed (must be read in the order it's written)
    mutable DestructableBuffer ComplexUserData;

  private:

    // Store an array of all type parsed callbacks handlers
    Array<TypeParsedDelegate> TypeParsedHandlers;

    // All the code that makes up this project
    Array<CodeEntry> Entries;

    // A special constant that means we don't have a cursor
    static const size_t NoCursor = (size_t)-1;

    // When attempting to generate code-completion, this is the cursor position for the user
    String CursorOrigin;
    size_t CursorPosition;

    // Store a reference to the error handler
    CompilationErrors& Errors;

    // Not copyable
    ZilchNoCopy(Project);
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_FORMATTER_HPP
#define ZILCH_FORMATTER_HPP

// Includes

namespace Zilch
{
  // Lets us define what lines tokens will go on, or if it relies upon a default setting
  // Used mostly for specifying styles of curley braces (eg. K&R style, Allman style, etc)
  namespace LineStyle
  {
    enum Enum
    {
      UseGlobalDefault,
      SameLine,
      NextLine,
      NextLineIndented
    };
  }
  
  // Lets us define whether we indent in certain places, or if it relies upon a default setting
  namespace IndentStyle
  {
    enum Enum
    {
      UseGlobalDefault,
      Indented,
      NotIndented
    };
  }
  
  // Lets us define if we want spaces before, after, or around both sides of a token,
  // or if it relies upon a default setting
  namespace SpaceStyle
  {
    enum Enum
    {
      UseGlobalDefault,
      None,
      Before,
      After,
      BeforeAndAfter
    };
  }

  // Allows us to specify almost every aspect of code formatting
  // The default values used here reflect the official coding standard of Zilch
  class CodeFormat
  {
  public:

    // Constructor
    CodeFormat();

    // If we use tabs for indents or spaces if false (default: false)
    bool IsTabs;

    // How many tabs or spaces we use when indenting (default: 2)
    size_t Identation;

    // Will remove whitespace from empty lines or fill whitespace if set to false (default: false)
    bool StripWhiteSpaceFromEmptyLines;

    // Whether we automatically indent after scopes, unless we override specific cases (default: Indented)
    IndentStyle::Enum IndentGlobalDefault;

    // Whether functions, properties, and fields get indented inside a class (default: UseGlobalDefault)
    IndentStyle::Enum IndentClassContents;

    // Whether values inside an enum are indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentEnumContents;

    // Whether statements inside a function's scope get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentFunctionContents;

    // Whether statements inside a function's scope get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentPropertyContents;

    // Whether statements inside a function's scope get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentGetSetContents;

    // Whether statements inside any other scope (such as an if statement) get indented (default: UseGlobalDefault)
    IndentStyle::Enum IndentScopeContents;

    // Where the braces go for any scope, unless we override specific cases (default: NextLine)
    LineStyle::Enum LineStyleGlobalDefaultScope;

    // Where the braces go for a class scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleClassScope;

    // Where the braces go for a enum/flags scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleEnumScope;

    // Where the braces go for a function scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleFunctionScope;

    // Where the braces go for a property scope (default: UseGlobalDefault)
    LineStyle::Enum LineStylePropertyScope;

    // Where the braces go for a get/set scope inside a property scope (default: UseGlobalDefault)
    LineStyle::Enum LineStyleGetSetScope;

    // Where the braces go for any other type of scope (for example, if statements) (default: UseGlobalDefault)
    LineStyle::Enum LineStyleBlockScope;

    // Where the initializer list colon is placed (default: SameLine)
    LineStyle::Enum LineStyleInitializerList;

    // Whether we put spaces around colons, unless we override specific cases (default: BeforeAndAfter)
    SpaceStyle::Enum SpaceStyleGlobalDefaultColon;

    // Whether we put spaces around the colon in an inheritance list (after the class keyword) (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInheritanceColon;

    // Whether we put spaces around the colon in an initializer list (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInitializerListColon;

    // Whether we put spaces around the colon that specifices a type (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleTypeColon;

    // Whether we put spaces around the colon that specifices a type (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleNamedArgumentColon;

    // Whether we put spaces around commas, unless we override specific cases (default: After)
    SpaceStyle::Enum SpaceStyleGlobalDefaultComma;

    // Whether we put spaces around the commas in an inheritance list (after the class keyword) (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInheritanceComma;

    // Whether we put spaces around the commas in an initializer list (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleInitializerListComma;

    // Whether we put spaces around the commas in a parameter list for a function definition (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleFunctionDefinitionParameterComma;

    // Whether we put spaces around the commas in a parameter list for a function invokation (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleFunctionCallParameterComma;

    // Whether we put spaces around the commas in a parameter list for a template definition (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleTemplateDefinitionParameterComma;

    // Whether we put spaces around the commas in a parameter list for a template instantiation (default: UseGlobalDefault)
    SpaceStyle::Enum SpaceStyleTemplateInstantiationParameterComma;

    // Whether we put a space after the comment // or /* (default: true)
    bool SpaceAfterComment;
  };

  // The type of scope we emit
  namespace ScopeType
  {
    enum Enum
    {
      Class,
      Enumeration,
      Function,
      Property,
      GetSet,
      Block
    };
  }

  // This class can be used to directly emit Zilch code as text
  // It's mostly a convenience (handles scoping, formatting, spaces, keywords, etc)
  class ZilchCodeBuilder : public StringBuilderExtended
  {
  public:
    // Constructor
    ZilchCodeBuilder();
    
    // Writes out a keyword
    void WriteKeywordOrSymbol(Grammar::Enum token);

    // Writes out a keyword with spacing rules
    void WriteKeywordOrSymbolSpaceStyle(Grammar::Enum token, SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault);

    // Add a scope to the builder, which typically will indent the contents and emit a 'begin scope' token
    void BeginScope(ScopeType::Enum scope);

    // Ends a scope, which typically will unindent and emit an 'end scope' token
    void EndScope();

    // Creates a new line, and indents it to the current indentation level
    // Note that if this line is empty, it will be indented all the way, which means
    // we need to do a post-pass over the string in case 'StripWhiteSpaceFromEmptyLines' is set
    void WriteLineIndented();

    // We only overwrite this so we can count lines
    // Note: This function is NOT virtual, which means that calling any
    // WriteLine overloads on the base will fail to count lines properly
    void WriteLine();

    // Creates a new line based on the line style
    void WriteLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault);

    // Write a single indent at the latest position
    void WriteIndent();

    // Write a single space
    void WriteSpace();

    // Outputs the final string
    // This also removes trailing whitespace, and modifies space for empty lines
    // depending on the setting 'StripWhiteSpaceFromEmptyLines'
    String ToString();

    // Get the current line that we're on
    size_t GetLine();

  private:

    // Get the preferred line rule
    static LineStyle::Enum GetLineStyle(LineStyle::Enum specific, LineStyle::Enum globalDefault);

    // Get the preferred indent rule
    static IndentStyle::Enum GetIndentStyle(IndentStyle::Enum specific, IndentStyle::Enum globalDefault);

    // Get the preferred space rule
    static SpaceStyle::Enum GetSpaceStyle(SpaceStyle::Enum specific, SpaceStyle::Enum globalDefault);

  public:

    // The format we emit the code in
    CodeFormat Format;

  private:

    // Styling information for a scope
    class ScopeStyle
    {
    public:
      // Constructor
      ScopeStyle();

      bool BracesIndented;
      bool InnardsIndented;
    };

    // This is the level of scope we're at (an empty array means root / flat level)
    Array<ScopeStyle> Scopes;

    // The current indentation level we're at. Indentation usually increases as we increase scope
    size_t Indentation;

    // The current line that we're on
    size_t Line;
  };

  class ScopeLastNode
  {
  public:
    // Constructor
    ScopeLastNode();

    SyntaxNode* LastNode;
    SyntaxNode* AssociatedScope;
  };

  // The context we use to generate code
  class CodeFormatterContext : public WalkerContext<CodeFormatter, CodeFormatterContext>
  {
  public:
    // Constructor
    CodeFormatterContext();

    // The current functions we're generating code for
    FunctionArray FunctionStack;

    // The current classes we're generating code for
    Array<BoundType*> ClassTypeStack;

    // Where we emit formatted code to
    ZilchCodeBuilder Builder;

    // At the top of this stack contains the last statement we processed
    // for the current scope we're in. Every time we enter a scope, a 
    // statement is pushed on the stack (first null, then the last statement)
    Array<ScopeLastNode> FormatScopes;
  };

  // Responsible for converting a syntax tree back into code
  // This is incredibly useful for auto-formatting Zilch code, or translating into other languages
  class CodeFormatter
  {
  public:

    // Constructor
    CodeFormatter();

    // Formats a syntax tree back into code
    // The syntax tree can be 'unchecked', but must not be invalid (missing syntax types, etc)
    String FormatTree(SyntaxTree& syntaxTree, const CodeFormat& format);

  private:
    
    static bool IsDirectlyWithinScope(SyntaxNode* node);
    static size_t CountAttributes(SyntaxNode* node);

    void FormatCommentsAndLines(SyntaxNode*& node, CodeFormatterContext* context);

    // Handles delimiting of statements that require it
    void FormatStatement(StatementNode*& node, CodeFormatterContext* context);

    // Free (scoped) statements
    void FormatIf(IfNode*& node, CodeFormatterContext* context);
    void FormatLoop(LoopNode*& node, CodeFormatterContext* context);
    void FormatWhile(WhileNode*& node, CodeFormatterContext* context);
    void FormatDoWhile(DoWhileNode*& node, CodeFormatterContext* context);
    void FormatFor(ForNode*& node, CodeFormatterContext* context);
    void FormatForEach(ForEachNode*& node, CodeFormatterContext* context);

    // Delimited statements
    void FormatReturn(ReturnNode*& node, CodeFormatterContext* context);
    void FormatDelete(DeleteNode*& node, CodeFormatterContext* context);
    void FormatBreak(BreakNode*& node, CodeFormatterContext* context);
    void FormatDebugBreak(DebugBreakNode*& node, CodeFormatterContext* context);
    void FormatContinue(ContinueNode*& node, CodeFormatterContext* context);
    void FormatThrow(ThrowNode*& node, CodeFormatterContext* context);

    // Expressions (do not require emitting newline in front)
    void FormatBinaryOperator(BinaryOperatorNode*& node, CodeFormatterContext* context);
    void FormatUnaryOperator(UnaryOperatorNode*& node, CodeFormatterContext* context);
    void FormatTypeCast(TypeCastNode*& node, CodeFormatterContext* context);
    void FormatIndexerCall(IndexerCallNode*& node, CodeFormatterContext* context);
    void FormatFunctionCall(FunctionCallNode*& node, CodeFormatterContext* context);
    void FormatMemberAccess(MemberAccessNode*& node, CodeFormatterContext* context);
    void FormatTypeMemberAccess(TypeMemberAccessNode*& node, CodeFormatterContext* context);
    void FormatLocalVariable(LocalVariableNode*& node, CodeFormatterContext* context);
    void FormatParameter(ParameterNode*& node, CodeFormatterContext* context);
    void FormatCreationCall(CreationCallNode*& node, CodeFormatterContext* context);
    void FormatValue(ValueNode*& node, CodeFormatterContext* context);
    void FormatStringInterpolant(StringInterpolantNode*& node, CodeFormatterContext* context);
    void FormatTypeId(TypeIdNode*& node, CodeFormatterContext* context);
    

    // Format a class back into Zilch format
    void FormatAttributes(NodeList<AttributeNode>& attributes, ZilchCodeBuilder& builder);
    void FormatEnum(EnumNode*& node, CodeFormatterContext* context);
    void FormatEnumValue(EnumValueNode*& node, CodeFormatterContext* context);
    void FormatClass(ClassNode*& node, CodeFormatterContext* context);
    void FormatSendsEvent(SendsEventNode*& node, CodeFormatterContext* context);
    void FormatMemberVariable(MemberVariableNode*& node, CodeFormatterContext* context);
    template <typename NodeType, typename FunctionType>
    void FormatGenericFunctionHelper(NodeType* node, CodeFormatterContext* context, FunctionType emitPostArgs);
    void FormatFunction(FunctionNode*& node, CodeFormatterContext* context);
    void FormatConstructor(ConstructorNode*& node, CodeFormatterContext* context);
    void FormatDestructor(DestructorNode*& node, CodeFormatterContext* context);
    
  private:

    // Store all the walkers
    BranchWalker<CodeFormatter, CodeFormatterContext> Walker;
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HASH_CONTAINER_HPP
#define ZILCH_HASH_CONTAINER_HPP

// Includes

namespace Zilch
{
  typedef HashMap<Any, Any> AnyHashMap;
  typedef HashSet<Any> AnyHashSet;
  typedef Pair<Any, Any> AnyKeyValue;
}

// End header protection
#endif
///////////////////////////////////////////////////////////////////////////////
///
/// \file File.hpp
/// Declaration of the Os file class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

// File Read Write Mode
DeclareEnum4(FileMode,
     // Open file for reading, reading starts at beginning of file
     // If the file does not exist opening will fail
     Read,
     // Open file for writing, if the file exists it be truncated to zero
     // If the file does not exist it will be created
     Write,
     // Open file for writing, writing starts at the end of the file
     // If the file does not exist it will be created
     Append,
     // Open for reading and writing, reading/writing starts at the beginning of file
     // If the file does not exist it will be created
     ReadWrite);

// Hint on how the file will be accessed
DeclareEnum2(FileAccessPattern, Sequential, Random);

// Position in file
typedef u64 FilePosition;

// Used in file Seek
DeclareEnum3(FileOrigin, Current, Begin, End);

byte* ReadFileIntoMemory(cstr path, size_t& fileSize, size_t extra = 0);
DataBlock ReadFileIntoDataBlock(cstr path);
size_t WriteToFile(cstr filePath, byte * pData, size_t bufferSize);

/// Os file class
class File
{
public:
  static const int MaxPath = 260;
  static const int PlatformMaxPath;

  File();
  ~File();
  
  /// Open the file
  bool Open(cstr filePath, FileMode::Enum mode, FileAccessPattern::Enum accessPattern);

  /// Close the file
  void Close();
  
  /// Current read/write position in the file
  FilePosition Tell();
  
  /// Move the read write position to a new filePosition realative to origin
  void Seek(FilePosition filePosition, FileOrigin::Enum origin = FileOrigin::Begin);  
  
  /// Write data to the file
  size_t Write(byte* data, size_t sizeInBytes);
  
  /// Read data from the file
  size_t Read(byte* data, size_t sizeInBytes);

  /// Force all reads / write to the disk
  void Flush();
  
  /// Size of the file when opened (not current)
  size_t Size();
  
  /// Is the file currently open?
  bool IsOpen();

private:
  ZeroDeclarePrivateData(File, 300);
};

}//namespace Zero
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_OVERLOAD_RESOLVER_HPP
#define ZILCH_OVERLOAD_RESOLVER_HPP

// Includes

namespace Zilch
{
  // We perform overload checking in three passes
  namespace OverloadPass
  {
    enum Enum
    {
      // Attempt to find a direct overload that works (exact signature match)
      NoImplicitConversion,
      
      // Now attempt to find an overload that works without any code generation
      // For example, if we have an overload that takes an Animal and we pass in a Cat
      // (only syntax conversion required, no actual code generation)
      RawImplicitConversion,

      // Lastly, if we really need to do a proper conversion (like Integer to Real)
      AnyImplicitConversion
    };
  }

  // A class that's responsible for resolving overloads
  class Overload
  {
  public:
    // Resolve an overload between a function call and the list of functions overloaded under the same name
    static bool ResolveAndImplicitConvert
    (
      const FunctionArray* functions,
      Function*& resolvedFunction,
      FunctionCallNode& functionCallNode
    );

    // Report an error based on the overload result
    static void ReportError
    (
      CompilationErrors& errors,
      const CodeLocation& location,
      const FunctionArray* functions,
      const FunctionCallNode& functionCallNode
    );

    // Report an error based on a single delegate type
    static void ReportSingleError
    (
      CompilationErrors& errors,
      const CodeLocation& location,
      const DelegateType* type,
      const FunctionCallNode& functionCallNode
    );

    // Get function call signature string
    static void GetFunctionCallSignatureString(StringBuilder& builder, const FunctionCallNode& functionCallNode);

    // Test a single function against a function call (performs all overload passes)
    // Note: This will modify the function call node if it needs to add implicit casts
    static bool TestCallAndImplicitConvert(DelegateType* delegateType, FunctionCallNode& functionCallNode);

    // Perform a single pass of the overload detection
    // Note: If we failed the first two passes and pass the 'AnyImplicitConversion' test, then we must generate
    // TypeCastNodes to perform implicit casts on the function call's arguments
    static bool TestDelegateTypeVsCall(DelegateType* delegateType, FunctionCallNode& functionCallNode, OverloadPass::Enum pass);

    // Generates any necessary casts for calling the function
    // This should only be called AFTER the 'AnyImplicitConversion' test has passed
    // Note: This function will modify the 'FunctionCallNode'
    static void GenerateImplicitCasts(DelegateType* delegateType, FunctionCallNode& functionCallNode);

    // Detect any ambiguities between one function signature and a list of other function signatures
    //static void DetectAmbiguities(FunctionArray& functions, Function* function);
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_PARSER_HPP
#define ZILCH_PARSER_HPP

// Includes

namespace Zilch
{
  // This class implements a recursive descent parser that parses
  // through the token stream that we get from the tokenizer
  class Parser
  {
  public:

    // Constructor
    Parser(CompilationErrors& errors);

    // Parses all scripts in a project into an syntax tree (with classes, functions, members, etc)
    void ParseIntoTree(const Array<UserToken>& tokens, SyntaxTree& syntaxTree, EvaluationMode::Enum evaluation);

    // Parses a single expression in the context of a function (evaluation of local variables, etc)
    void ParseExpressionInFunctionAndClass(const Array<UserToken>& expression, const Array<UserToken>& function, const Array<UserToken>& classTokensWithoutFunction, SyntaxTree& syntaxTree);

    // From a token stream, just attempt to parse a single type
    SyntaxType* ParseType(const Array<UserToken>& type);

    // Checks if a token either has zero elements, or if the only element is the End/Eof element
    static bool IsTokenStreamEmpty(const Array<UserToken>& tokens);

  private:

    // Type-defines
    typedef ExpressionNode* (Parser::*ExpressionFn)();

    // Print out an error message corresponding to the current token
    void ErrorHere(ErrorCode::Enum errorCode, ...);

    // Print out an error message corresponding to the current token
    void ErrorHereArgs(ErrorCode::Enum errorCode, va_list argList);

    // Print out an error message corresponding to the current token (with extra context if needed)
    void ErrorHereArgs(ErrorCode::Enum errorCode, StringParam extra, va_list argList);

    // Set the starting line and character of a syntax node
    void SetNodeLocationStartHere(SyntaxNode* node);

    // Set the primary line and character of a syntax node
    void SetNodeLocationPrimaryHere(SyntaxNode* node);

    // Set the ending line and character of a syntax node
    void SetNodeLocationEndHere(SyntaxNode* node);

    // Set the starting line and character of a syntax node (at the last saved token)
    void SetNodeLocationStartToLastSave(SyntaxNode* node);

    // Set the starting line and character of a syntax node (at the last saved token)
    void SetNodeLocationPrimaryToLastSave(SyntaxNode* node);

    // Set the ending line and character of a syntax node (at the last saved token)
    void SetNodeLocationEndToLastSave(SyntaxNode* node);

    // Set the starting line and character of a syntax node to a given token's position
    static void SetNodeLocationStartToToken(SyntaxNode* node, const UserToken& token);

    // Set the starting line and character of a syntax node to a given token's position
    static void SetNodeLocationPrimaryToToken(SyntaxNode* node, const UserToken& token);

    // Set the ending line and character of a syntax node to a given token's position
    static void SetNodeLocationEndToToken(SyntaxNode* node, const UserToken& token);

    // Saves the tokens position onto the stack
    void SaveTokenPosition();

    // Recalls the token position by using the value on the top of the stack
    void RecallTokenPosition();

    // Accepts the current token position as the new token position, and removes the saved version from the stack
    void AcceptTokenPosition();

    // Attempts to accept any one of the given tokens, and outputs the one that matches (also moves the token index ahead by one)
    bool AcceptAnyArgs(size_t parameters, const UserToken** out_token, va_list vl);

    // Attempts to accept any one of the given tokens, and outputs the one that matches (also moves the token index ahead by one)
    bool AcceptAny(size_t parameters, const UserToken** out_token, ...);

    // Accepts the tokens in the order that they're given (moves the token index ahead by the number of tokens passed in, if they all match)
    bool Accept(size_t parameters, ...);

    // Accepts the tokens in the order that they're given and returns values out through parameters
    bool AcceptAndRetrieve(size_t parameters, ...);

    // Expects a given grammar constant, and otherwise produces an error (variadic for the error context)
    bool Expect(Grammar::Enum grammarConstant, ErrorCode::Enum errorCode, ...);

    // Expects a given grammar constant, and otherwise produces an error (variadic for the error context)
    bool ExpectAndRetrieve(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, ...);

    // Expects a given grammar constant, and otherwise produces an error (variadic for the error context)
    bool ExpectAndRetrieveArgs(Grammar::Enum grammarConstant, const UserToken*& outToken, ErrorCode::Enum errorCode, va_list vl);

    // A helper function to read the contents of a delgate syntax type
    bool ReadDelegateTypeContents(DelegateSyntaxType* delegateSyntaxType);

    // Read a named type for the typing system
    BoundSyntaxType* ReadBoundTypeInfo();

    // Read a type for the typing system
    SyntaxType* ReadTypeInfo();

    // Typically only used in tolerant mode, this will skip tokens until we find the ending scope
    // It will also properly count scopes up and down as it looks for the end
    // Returns true if it find the end (and will advance the token), or false and the token will not move
    bool MoveToScopeEnd();

    // Find the nearest scope to a given code location
    // Generally this is only used for auto-complete
    static ScopeNode* FindNearestScope(SyntaxNode* root, const CodeLocation& location);

    // Tests if a list of attributes contains a particular attribute by name
    static bool IsAttributePresent(NodeList<AttributeNode>& attributes, StringParam name);

    // Parse an attribute defintion
    void ParseAllOptionalAttributes();

    // Parse a single attribute (not a group)
    bool ParseOneOptionalAttribute();

    // Apply the last attribute to a node
    void AttachLastAttributeToNode(NodeList<AttributeNode>& attributes);

    // Accept a type specifier (return type for a function)
    // Returns true if it parses successfully, false otherwise (note that no type specifier will return true!)
    bool AcceptOptionalTypeSpecifier(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, ...);

    // Accept a type specifier (return type for a function)
    // Returns true if it parses successfully, false otherwise (note that no type specifier will return true!)
    bool AcceptOptionalTypeSpecifierArgs(SyntaxType*& outSyntaxType, ErrorCode::Enum notFound, va_list args);

    // Expect an argument list
    bool ExpectArgumentList(GenericFunctionNode* node, String functionName);

    // Parse a scope body
    bool ExpectScopeBody(GenericFunctionNode* node, String functionName);

    // Parse a variable defintion
    LocalVariableNode* LocalVariable(bool initialized = true);

    // Parse a variable defintion
    MemberVariableNode* MemberVariable();

    // Parse a class defintion
    ClassNode* Class();

    // Parse an enum defintion
    EnumNode* Enum();

    // Parse an enum value (an integral constant with a name)
    EnumValueNode* EnumValue();

    // Parse a specialized function (code reuse)
    template <typename FunctionNodeType>
    FunctionNodeType* SpecializedFunction
    (
      Grammar::Enum type,
      String functionName,
      bool (Parser::*postArgs)(FunctionNodeType* node)
    );

    // Parse a function definition
    FunctionNode* Function();

    // Generate the standard function node for a get set
    FunctionNode* GenerateGetSetFunctionNode(MemberVariableNode* variable, bool isGet);

    // Parse a get/set function definition
    FunctionNode* GetSetFunctionBody(MemberVariableNode* variable, bool isGet);

    // Parse a constructor definition
    ConstructorNode* Constructor();
    bool ConstructorInitializerList(ConstructorNode* node);

    // Parse a destructor definition
    DestructorNode* Destructor();

    // Parse a sends statement
    SendsEventNode* SendsEvent();

    // Parse a function parameter
    ParameterNode* Parameter();

    // A binary operator helper for parsing expressions (with right to left associativity)
    ExpressionNode* BinaryOperatorRightToLeftAssociative(ExpressionFn currentPrecedence, ExpressionFn nextPrecedence, int parameters, ...);

    // A binary operator helper for parsing expressions (with left to right associativity)
    ExpressionNode* BinaryOperatorLeftToRightAssociative(ExpressionFn nextPrecedence, int parameters, ...);

    // Parse an expression (including all precedent levels of operators, lower number = lower precedence)
    ExpressionNode* Expression();
    ExpressionNode* Expression00();
    ExpressionNode* Expression01();
    ExpressionNode* Expression02();
    ExpressionNode* Expression03();
    ExpressionNode* Expression04();
    ExpressionNode* Expression05();
    ExpressionNode* Expression06();
    ExpressionNode* Expression07();
    ExpressionNode* Expression08();
    ExpressionNode* Expression09();
    ExpressionNode* Expression10();
    ExpressionNode* Expression11();
    ExpressionNode* Expression12();
    ExpressionNode* Expression13();
    ExpressionNode* Expression14();

    // The post-expression takes care of right hand side operataors whose operands arent exactly a "single" expression
    PostExpressionNode* PostExpression();

    // Parse an indexer call
    IndexerCallNode* IndexerCall();

    // Parse a function call
    FunctionCallNode* FunctionCall();

    // Parse a member access
    MemberAccessNode* MemberAccess();

    // Parse a delete statement
    StatementNode* Delete();

    // Parse a return statement
    StatementNode* Return();

    // Parse a break statement
    StatementNode* Break();

    // Parse a debug breakpoint statement
    StatementNode* DebugBreak();

    // Parse a continue statement
    StatementNode* Continue();

    // Parse a throw statement
    StatementNode* Throw();

    // Parse a statement
    StatementNode* Statement();

    // Parse a delimited statement
    StatementNode* DelimitedStatement();

    // Parse a free statement
    StatementNode* FreeStatement();

    // Parse a scope statement
    StatementNode* Scope();

    // Parse a timeout statement
    StatementNode* Timeout();

    // Parse an if statement
    IfRootNode* If();

    // Parse an if statement's body
    void IfBody(ExpressionNode* condition, IfRootNode* root);

    // Parse an if statement's condition
    ExpressionNode* IfCondition();

    // Parse an else statment (with a possible condition)
    void Else(IfRootNode* root);

    // Parse a for statement
    StatementNode* For();

    // Parse a foreach statement
    StatementNode* ForEach();

    // Parse an while statement
    StatementNode* While();

    // Parse an do-while statement
    StatementNode* DoWhile();

    // Parse a loop statement
    StatementNode* Loop();

    // Read a creation call (like "new" or "local")
    ExpressionNode* CreationCall();

    // Read a type-id expression (which returns type information)
    ExpressionNode* TypeId();

    // Read a type member access (static methods, members, properties)
    TypeMemberAccessNode* TypeMemberAccess();

    // Create a string literal value node (always sets the token directly to be a string literal)
    ValueNode* CreateStringLiteral(const UserToken* token);

    // Parse a string interpolant
    StringInterpolantNode* StringInterpolant();

    // Parse a value
    ExpressionNode* Value();

    // Read attributes for static, virtual, and overriding and apply them to a node
    // Expects that the node has the IsStatic and Virtualized members
    template <typename Node>
    void ApplyVirtualAndStaticAttributes(Node* node);

  private:

    // The last attribute we parsed, which will be attached to whatever node follows it
    NodeList<AttributeNode> LastAttributes;

    // Store a reference to the error handler
    CompilationErrors& Errors;

    // The tokenizer we'll use that stores the input stream of tokens
    const Array<UserToken>* TokenStream;

    // This stack maintains any saved token positions (makes it easy to recall if necessary)
    PodArray<size_t> TokenPositions;

    // The index of the token we're currently parsing
    size_t TokenIndex;

    // Not copyable
    ZilchNoCopy(Parser);
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Joshua Davis
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_RANDOM_HPP
#define ZILCH_RANDOM_HPP

///////////////////////////////////////////////////////////////////////////////
///
/// \file Random.hpp
/// Declaration of the Random number and vector generation functions.
/// 
/// Authors: Chris Peters, Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
//The following comment is required to use the Mersenne Twister
/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.                          

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/
#pragma once

#include <stdlib.h>

namespace Math
{
//----------------------------------------------------------------------- Random
class Random
{
public:
  ///Seeds with a call to the "time" function
  Random(void);
  Random(int initialSeed);

  uint GetSeed();
  void SetSeed(uint seed);

  ///Generates a random number on the [0, 32,767] interval.
  uint Next(void);

  ///Generates a random number on the [0, 4,294,967,295] interval.
  u32 Uint32(void);

  ///Generates a random number on the [0, 18,446,744,073,709,551,616] interval.
  u64 Uint64(void);

  ///Generates a random number on the [0,1]-real-interval.
  float Float(void);

  ///Generates a random boolean value;
  bool Bool(void);

  ///Returns an integer value in the range of [min, max]
  int IntRangeInIn(int min, int max);

  ///Returns an integer value in the range of [min, max)
  int IntRangeInEx(int min, int max);

  ///Returns a integer value in the range of 
  ///[base - variance, base + variance]
  int IntVariance(int base, int variance);

  ///Returns a floating point value in the range of [min, max]
  float FloatRange(float min, float max);

  ///Returns a floating point value in the range of 
  ///[base - variance, base + variance]
  float FloatVariance(float base, float variance);

  Vector2 PointOnUnitCircle(void);

  ///Returns a point on a unit circle with the x-axis going through the center
  ///of the circle.
  Vector3 PointOnUnitCircleX(void);

  ///Returns a point on a unit circle with the y-axis going through the center
  ///of the circle.
  Vector3 PointOnUnitCircleY(void);

  ///Returns a point on a unit circle with the z-axis going through the center
  ///of the circle.
  Vector3 PointOnUnitCircleZ(void);
  

  Vector3 PointOnUnitCircle(uint axis);

  Vector3 PointOnUnitSphere(void);

  Vector3 PointInUnitSphere(void);

  ///Generate uniform random quaternion
  Quaternion RotationQuaternion(void);

  ///Randomly generates a Vec22 with its length between min and max
  Vector2 ScaledVector2(float minLength, float maxLength);

  ///Randomly generates a Vec3 with its length between min and max
  Vector3 ScaledVector3(float minLength, float maxLength);

  ///Generate uniform random matrix
  Matrix3 RotationMatrix(void);
  void RotationMatrix(Mat3Ptr matrix);

  // Randomly rolls a number in the range [1, sides]
  int DieRoll(uint sides);

  float BellCurve(float center, float range, float standardDeviation);

  static const uint cRandMax = 0x7FFF;

private:

  // Global seed only when we don't seed the random
  // This is set every time anyone calls 'Next()', even if it's not used by the class
  static uint mGlobalSeed;

  uint mSeed;
};

//------------------------------------------------------------- Mersenne Twister
class MersenneTwister
{
public:
  ///Seeds with a call to the "time" function.
  MersenneTwister(void);

  ///Initializes the internal array with a seed.
  MersenneTwister(uint seed);

  ///Initialize by an array with array-length. "keys" is the array for 
  ///initializing keys. "keyLength" is its length.
  MersenneTwister(uint keys[], uint keyLength);

  ///Initializes the values with a seed.
  void Initialize(uint seed);

  ///Initialize by an array with array-length. "keys" is the array for 
  ///initializing keys. "keyLength" is its length.
  void Initialize(uint keys[], uint keyLength);

  ///Generates a random number on the [-2,147,483,648, 2,147,483,648] interval.
  int Int(void);

  ///Generates a random number on the [0, 4,294,967,295] interval.
  uint Uint(void);

  ///Generates a random number on the [0,1]-real-interval.
  float Float(void);

private:
  static const uint cN = 624;
  uint mValues[cN]; //The array for the state vector.
  uint mIndex;       //Index == cN+1 means the values aren't initialized.
};

}// namespace Math

namespace Zilch
{
  // Contains utility functions for random generation
  class Random
  {
  public:
    ZilchDeclareBaseType(Random, TypeCopyMode::ReferenceType);

    // Seeds the the random number generator
    void Seed(uint seed);

    // Returns the max integer value that can be returned
    int GetMaxInt();

    // Returns a random boolean value
    bool Boolean();

    // Returns a random integer in the range of [0, MaxInt]
    int Integer();

    // Returns a random real in the range [0,1]
    float Real();

    // Generates a unit length Real2
    Math::Vector2 UnitReal2();

    // Randomly generates a Real2 with its length between min and max
    Math::Vector2 Real2(float minLength, float maxLength);

    // Generates a unit length Real3
    Math::Vector3 UnitReal3();

    // Randomly generates a Real3 with its length between min and max
    Math::Vector3 Real3(float minLength, float maxLength);

    // Random unit length quaternion. This is also a unit quaternion
    Zilch::Quaternion Quaternion();

    // Integer in the range [min, max)
    int RangeInclusiveMax(int min, int max);

    // Integer in the range [min, max]
    int RangeExclusiveMax(int min, int max);

    // Integer in the range [base - variance, base + variance]
    int Variance(int base, int variance);

    // A random Real in the range [min,max]
    float Range(float min, float max);

    // Returns a number in the range [base - variance, base + variance]
    float Variance(float base, float variance);

    // Randomly rolls a number in the range [1, sides]
    uint DieRoll(uint sides);

    // Takes a given probability that we get a true value
    bool Probability(float probOfTrue);

    // Returns true if the coin flips heads
    bool CoinFlip();

    // Random rotation quaternion. This is the same as calling Quaternion()
    Zilch::Quaternion Rotation();

    // Samples a bell curve with standard normal distribution in the range [0,1]
    // This is equivalent to a Gaussian distribution with standard deviation of 1
    float BellCurve();

    // Samples a bell curve with in the range [center - range, center + range]
    // This uses a standard deviation of 1.
    float BellCurve(float center, float range);

    // Samples a bell curve in the range [center - range, center + range] with the
    // given standard deviation. Around 68% will lie within the 1st standard deviation
    float BellCurve(float center, float range, float standardDeviation);

  private:

    // The internal random number generator we use
    Math::Random Generator;
  };
}

// End header protection
#endif
/**************************************************************\
* Author: Trevor Sundberg
* Copyright 2012-2014, DigiPen Institute of Technology
\**************************************************************/

// Include protection
#pragma once
#ifndef ZILCH_HPP
#define ZILCH_HPP

// Includes

namespace Zilch
{
  namespace Debugging
  {
    enum Enum
    {
      UseZilchErrorHandler,
      CustomErrorHandlerOrNoErrors
    };
  }

  // Initializes the shared global memory manager and builds all the static bound libraries
  // Note: No Zilch classes should be created before this occurs
  void ZilchStartup(Debugging::Enum debug);

  // Shuts down the shared global memory manager and releases any static libraries
  // Note: No Zilch classes should be created after this occurs
  void ZilchShutdown();
}

// End header protection
#endif
#pragma once
//Visual studio requires the precompiled header to be included the same for
//all files in the project EVEN when they are located in a different
//relative position. For G++ it needs to be a true path so this
//file redirects to the actual precompiled.
//For G++
//#include "..\Precompiled.hpp"

///////////////////////////////////////////////////////////////////////////////
///
/// \file Block.hpp
/// Declaration of the block memory manger and allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

namespace Memory
{

///Block allocator implements a segmented memory model.
///The block allocator is an array of memory pools of fixed
///sizes. Allocations use a static look up table to find the free list
///their size will fit into.  For each free list size a intrusive singly 
///linked list of free blocks is stored just like in a memory pool.
///The Block allocator is efficient at allocating small objects and helps
///prevent memory fragmentation. The disadvantages is that
///the Block allocator can not allocate large objects 
///(with out falling back on heap allocation)
///and once memory is committed to a block size
///it can not be reclaimed easily.
class Block : public Graph
{
public:
  struct FreeBlock{FreeBlock* NextBlock;};
  Block(StringRange name, Graph* parent);
  ~Block();

  //Allocate an object and call its constructor.
  template<typename type>
  type* AllocateType();

  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);
  void Print(size_t tabs, size_t flags);
  void PushFreeBlock(size_t blockIndex, FreeBlock* block);
  FreeBlock* PopOnFreeList(size_t blockIndex);
  void AllocateBlockPage(size_t blockIndex);
  void CleanUp();
  //Configuration
  static const size_t cBlockCount = 14;
  static const size_t cMaxBlockSize = 640;
  static const size_t cPageSize = 4096;//4K Pages

private:

  //Used to store pages.
  Array<MemPtr> mPageBlocks;

  //Array of FreeLists for each block size.
  FreeBlock* mBlockArray[cBlockCount];

  //Table used to look up block index from allocation size.
  static byte BucketLookUp[cMaxBlockSize+1];
  //Is the allocation table initialized.
  static bool SizeTableInitialized;

  //Size of the block lists.
  static size_t BlockSizes[cBlockCount];

};

template<typename type>
type* Block::AllocateType()
{
  MemPtr memory = Allocate(sizeof(type));
  type* object = new(memory) type();
  return object;
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Pool.hpp
/// Declaration of the memory pool allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{
namespace Memory
{

///A memory pool is an efficient allocator for objects of a fixed size.
///The memory pool allocates memory in pages then divides the page into a 
///intrusively singly linked list of free blocks. Every time an allocation
///is made the next free block is popped of the list. Every time an allocation
///is freed the memory is push back onto the front of the list. When their are 
///no more free blocks new pages are allocated.
class Pool : public Graph
{
public:
  struct FreeBlock{FreeBlock* NextBlock;};
  Pool(StringRange name, Graph* parent, size_t blockSize, size_t blocksPerPage);
  ~Pool();

  template<typename type>
  type* AllocateType();
  template<typename type>
  void DeallocateType(type* instance);
  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);
  void Print(size_t tabs, size_t flags);
  void CleanUp();
private:
  FreeBlock* mNextFreeBlock;
  size_t mBlockSize;
  size_t mBlocksPerPage;
  size_t mPageSize;
  Array<byte*> mPages;
  void PushOnFreeList(MemPtr chunk);
  MemPtr PopOnFreeList();
  void AllocatePage();
};

template<typename type>
type* Pool::AllocateType()
{
  MemPtr memory = Allocate(sizeof(type));
  type* object = new(memory) type();
  return object;
}

template<typename type>
void Pool::DeallocateType(type* instance)
{
  instance->~type();
  Deallocate(instance,sizeof(type));
}

}//namespace Memory
}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Stack.hpp
/// Declaration of the Stack memory allocator.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{
namespace Memory
{

static const bool StackDebug = true;

///The stack allocator works like the program stack. For every allocation the stack
///head is moved forward and for each deallocation it is moved back. 
///It is extremely efficient but allocations must be freed in stack order (LIFO). 
///This makes the stack allocator efficient for temporaries and scratch space 
///that exist only a part of a frame or for permanent allocations that are never
///freed.
class Stack : public Graph
{
public:
  //Entries are used to detect when allocation are not freed
  //in proper stack order.
  struct Entry
  {
    Entry()
    {

    }
    Entry(byte* ptr, size_t size)
      :Ptr(ptr),
      Size(size)
    {

    }

    byte* Ptr;
    size_t Size;
  };

  Stack(StringRange name, Graph* parent, size_t stackSize, size_t maxEntries);
  ~Stack();
  void Print(size_t tabs, size_t flags);
  MemPtr Allocate(size_t numberOfBytes);
  void Deallocate(MemPtr ptr, size_t numberOfBytes);
  void CleanUp();
private:
  size_t mStackIndex;
  byte* mStackHeader;
  size_t mStackSize;
  size_t mMaxEntries;
  size_t mMaxSizeReached;
  PodArray<Entry> mEntries;
};

}//namespace Memory

class StackAllocator : public Memory::StandardMemory
{
public:
  StackAllocator()
    :mStack(NULL)
  {
  }

  StackAllocator(Memory::Stack* manager)
    :mStack(manager)
  {
  }

  MemPtr Allocate(size_t numberOfBytes){return mStack->Allocate(numberOfBytes); };
  void Deallocate(MemPtr ptr, size_t numberOfBytes){mStack->Deallocate(ptr, numberOfBytes);}
  Memory::Stack* mStack;
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Regex.hpp
/// Declaration of the Regex.
///
/// Authors: Trevor Sundberg
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Includes

namespace Zero
{
  // Type-defines
  typedef Array<StringRange> Matches;

  // Forward declaration
  struct RegexPrivateData;

  // The flavor of regular expressions
  DeclareEnum6(RegexFlavor, EcmaScript, PosixBasic, PosixExtended, Awk, Grep, Egrep);

  // How we escape a string (normal means escape everything, extended
  // means escape everything except extended characters such as '\r'...)
  DeclareEnum2(EscapeMode, Normal, Extended);

  class Regex
  {
  public:
    // Default Constructor
    Regex();

    // Constructor
    Regex(StringRange regex, RegexFlavor::Enum flavor = RegexFlavor::EcmaScript, bool caseSensitive = true);
    
    // Copy constructor
    Regex(const Regex& source);

    // Destructor
    ~Regex();

    // Assignment operator
    Regex& operator=(const Regex& source);

    // Search a given string and return matches
    Matches Search(StringRange text);

    // Replace all matches in a given string
    String Replace(StringRange source, StringRange replaceWith);

    // Escape a string so that it can be used directly in a regex, typically for finding exactly that string
    static String Escape(StringRange input, EscapeMode::Enum mode, RegexFlavor::Enum flavor = RegexFlavor::EcmaScript);

    // Validate the regular expression
    static bool Validate(StringRange regex, RegexFlavor::Enum flavor = RegexFlavor::EcmaScript, bool caseSensitive = true);

  private:

  private:

    // Store the private data
    RegexPrivateData* mPrivate;
  };
}
#pragma once
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <ctype.h>
///////////////////////////////////////////////////////////////////////////////
///
/// \file CharacterTraits.hpp
/// 
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

DeclareBitField7(CharacterBits, Graphical, Alpha, Number, WhiteSpace, Lower, Symbol, Control);

int IsSpace(int c);
int IsGraph(int c);
int IsGraphOrSpace(int c);
int IsAlpha(int c);
int IsDigit(int c);
int IsNumber(int c);
int IsAlphaNumeric(int c);
int IsLower(int c);
int IsUpper(int c);
int IsSymbol(int c);
int IsControl(int c);

int GetTraits(int c);

int ToLower(int c);
int ToUpper(int c);

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file ToString.hpp
/// Conversion to and from strings.
///
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

template<typename type>
String ToString(const type& instance)
{
  return instance.ToString();
}

template<typename type>
String ToString(type*const instance)
{
  return instance->ToString();
}

inline String ToString(StringRef instance)
{
  return instance;
}

String ToString(const bool& value);
String ToString(const int& value);
String ToString(const uint& value);
String ToString(const float& value);
String ToString(const double& value);
String ToString(const u64& value);

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file Precompiled.hpp
/// Precompiled header for the math library.
/// 
/// Authors: Benjamin Strukus
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cstddef>

namespace Math
{

}// namespace Math

#pragma once

namespace Math
{

struct BlockVector3
{
  uint GetSize() const;
  void SetSize(uint size);

  Vector3 operator[](uint index) const;
  Vector3& operator[](uint index);

  real& GlobalIndex(uint index);
  
  //Binary Assignment Operators (reals)
  void operator*=(real rhs);

  //Binary Assignment Operators (vectors)
  void operator+=(const BlockVector3& rhs);
  void operator-=(const BlockVector3& rhs);

  real Dot(const BlockVector3& rhs) const;
  void Scale(const BlockVector3& rhs, BlockVector3& out) const; 

  Zero::Array<Vector3> mBlocks;
};

struct BlockMatrix3
{
  uint GetSize() const;
  void SetSize(uint size);

  Matrix3 operator()(uint row, uint col) const;
  Matrix3& operator()(uint row, uint col);

  real& GlobalIndex(uint row, uint col);

  BlockMatrix3 Transposed() const;
  BlockMatrix3 Transform(const BlockMatrix3& rhs) const;
  void Transform(const BlockVector3& rhs, BlockVector3& out) const; 

  typedef Zero::Array<Matrix3> Cells;
  typedef Zero::Array<Cells> Rows;
  Rows mBlocks;
};

struct BlockCgPolicy
{
  real& operator()(BlockMatrix3& A, uint row, uint col)
  {
    return A.GlobalIndex(row,col);
  }

  real& operator()(BlockVector3& v, uint i)
  {
    return v.GlobalIndex(i);
  }

  uint GetDimension(BlockVector3& v)
  {
    return v.GetSize() * 3;
  }

  BlockVector3 Add(const BlockVector3& lhs, const BlockVector3& rhs)
  {
    BlockVector3 result = lhs;
    result += rhs;
    return result;
  }

  BlockVector3 Subtract(const BlockVector3& lhs, const BlockVector3& rhs)
  {
    BlockVector3 result = lhs;
    result -= rhs;
    return result;
  }

  real Dot(const BlockVector3& lhs, const BlockVector3& rhs)
  {
    return lhs.Dot(rhs);
  }

  BlockVector3 Scale(const BlockVector3& lhs, real rhs)
  {
    BlockVector3 result = lhs;
    result *= rhs;
    return result;
  }

  BlockVector3 Transform(const BlockMatrix3& mat, const BlockVector3& vec)
  {
    BlockVector3 result;
    mat.Transform(vec,result);
    return result;
  }

  //v1 * scalar + v2
  //out is assumed to only ever be aliased as v2
  void MultiplyAdd(const BlockVector3& v1, real scalar, BlockVector3& v2, BlockVector3* out)
  {
    uint size = v1.GetSize();
    for(uint i = 0; i < size; ++i)
    {
      (*out)[i] = v2[i] + v1[i] * scalar;
    }
  }

  //-(v1 * scalar - v2) = v2 - v1 * scalar
  //out is assumed to only ever be aliased as v2
  void NegativeMultiplySubtract(const BlockVector3& v1, real scalar, BlockVector3& v2, BlockVector3* out)
  {
    uint size = v1.GetSize();
    for(uint i = 0; i < size; ++i)
    {
      (*out)[i] = v2[i] - v1[i] * scalar;
    }
  }

  //-(mat * v1 - v2) = v2 - mat * v1
  //out is assumed to only ever be aliased as v2
  void NegativeTransformSubtract(const BlockMatrix3& mat, const BlockVector3& v1, BlockVector3& v2, BlockVector3* out)
  {
    uint size = v1.GetSize();
    for(uint i = 0; i < size; ++i)
    {
      Vector3 sum = Vector3::cZero;

      for(uint j = 0; j < size; ++j)
      {
        Matrix3 m = mat(i,j);
        Vector3 v = v1[j];
        sum += Math::Transform(m,v);
      }
      (*out)[i] = v2[i] - sum;
    }
  }
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file Curve.hpp
/// Declaration of the Curve class.
///
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

typedef Zero::Array<Math::Vector3> Vec3Array;

DeclareEnum3(CurveType, Linear, BSpline, CatmulRom);

//------------------------------------------------------------------------ Curve
/// A generic curve object that can switched between different spline types.
struct SplineCurve
{
  SplineCurve();

  void AddControlPoint(Vec3Param controlPoint);
  void RemovePointAtIndex(uint index);
  void AddControlPoints(const Vec3Array& controlPoints);
  void SetControlPoints(const Vec3Array& controlPoints);

  void GetPoints(Vec3Array& results, uint resolution) const;
  /// Bake the curve out using adaptive sampling. The error is the allowed
  /// distance of a point on the curve from the baked approximation.
  void BakeAdaptive(Vec3Array& results, real error) const;

  Vec3Array& GetControlPoints();
  void Clear();

  /// Does the curve loop back in on itself at the end or does it just stop?
  bool GetClosed();
  void SetClosed(bool state);

  /// How the control points are used to generate the curve.
  uint GetCurveType();
  void SetCurveType(uint curveType);

  /// Estimates the distance between a point and the curve using point-to-line
  /// on each line segment generated using the given resolution
  bool DistanceSq(Vec3 point, uint resolution, real& distSq) const;
  
private:
  /// Get the correct set of control points for baking (continuous set or closed set).
  void GetSmoothPoints(Vec3Array& pts) const;
  void MakeContinuous(Vec3Array& points) const;
  void MakeClosed(Vec3Array& points) const;

  template <typename Policy>
  void GetPoints(const Vec3Array& points, Vec3Array& results, uint resolution) const;
  template <typename Policy>
  void GetPoints(const Vec3Array& points, Vec3Array& results, real error) const;

  template <typename Policy>
  Vec3 ComputePoint(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const;

  // Used to store a stack of a point on the curve (and how to compute that point)
  // so that sub-division can be performed at a later time.
  struct PointData
  {
    PointData() {};
    PointData(real t, Vec3Param point)
    {
      T = t;
      Point = point;
    }

    real T;
    Vec3 Point;
  };
  template <typename Policy>
  PointData ComputePointData(real t, Vec3Param a, Vec3Param b, Vec3Param c, Vec3Param d) const;

  //---------------------------------------------------------- B-Spline Policy
  struct BSplinePolicy
  {
    static const Mat4& GetBasis();
    static Vec4 GetParam(real t);
  }; 

  //------------------------------------------------------- Catmull-Rom Policy
  struct CatmullRomPolicy
  {
    static const Mat4& GetBasis();
    static Vec4 GetParam(real t);
  }; 

public:

  Vec3Array ControlPoints;
  bool mClosed;
  uint mCurveType;
};

/// A curve that has been baked out to a set of points and their respective arc-lengths.
/// This table can be used to find a point at a given distance along a curve.
class BakedCurve
{
public:
  struct BakedData
  {
    Vec3 Position;
    real ArcLength;
  };

  /// Bake out the given curve. The error term is the max number of
  /// units that a line segment is allowed to deviate from the curve.
  void Bake(const SplineCurve& curve, real error);
  /// The total number of points this curve was baked out to.
  uint Size() const;
  real GetTotalArcLength() const;
  /// Get one of the baked out points. Used primarily for debug drawing.
  BakedData GetPoint(uint index);
  void SetPoint(uint index, Vec3Param pos);

  /// Finds the point on the curve at the given arc-length distance.
  /// The tangent at this point can optionally be computed.
  Vec3 SampleTable(float distance, Vec3* tangent = NULL) const;

private:
  // Binary search to find the index just below the given arc-length.
  uint SampleLowerBound(real distance) const;

  Zero::Array<BakedData> mArcLengthTable;
};

//----------------------------------------------------------- Piecewise Function
struct PiecewiseFunction
{
  struct ControlPoint;

  /// Constructor.
  PiecewiseFunction();

  /// Clears the entire curve. This will invalidate the baked curve.
  void Clear();

  /// Adds the given control point to the curve. Sorts after insertion.
  /// This will invalidate the baked curve.
  void AddControlPoint(Vec2Param pos, Vec2Param tanIn, Vec2Param tanOut);

  /// Sets all the control points and sorts after.
  /// This will invalidate the baked curve.
  void SetControlPoints(Zero::Array<ControlPoint>& controlPoints);

  /// Samples the curve at the given point. This will bake the curve
  /// if not already baked.
  float Sample(real x);

  /// Bakes the curve to the given array of points.
  void Bake();

  /// Returns whether or not the curve is baked.
  bool IsBaked();

  /// Returns a range of the baked curve.
  Vec3Array::range GetBakedCurve();

  /// Returns whether or not there are any control points in the curve.
  bool empty();

  //-------------------------------------------------------------- Control Point
  struct ControlPoint
  {
    Vec2 Position;
    Vec2 TangentIn;
    Vec2 TangentOut;
  };

  /// The type of curve.
  CurveType::Type mCurveType;

  /// All control points in the curve.
  Zero::Array<ControlPoint> mControlPoints;

  /// The allowed distance of a point on the curve from the baked approximation.
  real mError;

private:
  /// We don't want to have to rebuild the curve every time it is sampled,
  /// so we will bake it out to this array for faster sample time.
  /// Whenever the piecewise function is modified, it will be invalid
  /// until baked again.
  Vec3Array mBakedCurve;
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file DecomposedMatrix4.hpp
/// Declaration of the DecomposedMatrix4 structure.
/// 
/// Authors: Joshua Davis
/// Copyright 2010-2013, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

/// Stores a decomposed matrix 4. This means that shear is lost.
/// This does however allow efficient inverse transforms and
/// extracting of each portion of a transformation.
struct DecomposedMatrix4
{
  DecomposedMatrix4();
  DecomposedMatrix4(Mat4Param transform);

  void Set(Mat4Param transform);

  Vector3 TransformNormal(Vec3Param normal);
  Vector3 InverseTransformNormal(Vec3Param normal);

  /// Transform the surface normal by doing the inverse transpose of the transform.
  Vector3 TransformSurfaceNormal(Vec3Param direction);
  Vector3 InverseTransformSurfaceNormal(Vec3Param direction);

  Vector3 TransformPoint(Vec3Param point);
  Vector3 InverseTransformPoint(Vec3Param point);

  Vector3 Scale;
  Matrix3 Rotation;
  Vector3 Translation;
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file ExtendableMath.hpp
/// 
/// Authors: Joshua Davis
/// Copyright 2014, DigiPen Institute of Technology
///
//////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

//-------------------------------------------------------------------ExtendableVector
struct ExtendableVector
{
  void resize(uint size);

  real& operator[](uint index);
  real operator[](uint index) const;

  uint GetSize() const;

  uint mSize;
  Zero::Array<real> mData;
};

//-------------------------------------------------------------------ExtendableMatrix
struct ExtendableMatrix
{
  void resize(uint sizeX, uint sizeY);

  real& operator()(uint y, uint x);
  real operator()(uint y, uint x) const;

  uint mSizeX;
  uint mSizeY;
  Zero::Array<real> mData;
};

//-------------------------------------------------------------------FixedVector
// A vector who's max size is compile-time but who's
// working size can be changed up to the fixed size.
// Currently used in position correction.
template <typename DataType, size_t FixedSize>
struct FixedVector
{
  void resize(size_t size)
  {
    if(size > FixedSize)
    {
      ErrorIf("Cannot set size greater than the fixed size.");
      size = FixedSize;
    }

    mSize = size;
  }

  DataType& operator[](uint index)
  {
    ErrorIf(index >= mSize, "Access array out of bounds");
    return mData[index];
  }
  DataType operator[](uint index) const
  {
    ErrorIf(index >= mSize, "Access array out of bounds");
    return mData[index];
  }

  size_t GetSize() const
  {
    return mSize;
  }

  size_t mSize;
  DataType mData[FixedSize];
};

//-------------------------------------------------------------------FixedMatrix
template <size_t SizeX, size_t SizeY>
struct FixedMatrix
{
  real& operator()(uint y, uint x)
  {
    ErrorIf(y > SizeY || x > SizeX, "Access matrix out of bounds");
    return mData[x + SizeX * y];
  }
  real operator()(uint y, uint x) const
  {
    ErrorIf(y > SizeY || x > SizeX, "Access matrix out of bounds");
    return mData[x + SizeX * y];
  }

  real mData[SizeX * SizeY];
};

}//namespace Math
///////////////////////////////////////////////////////////////////////////////
///
///  \file Numerical.hpp
///  Contains functions that work on numerical data as functions.
///
///  Authors: Benjamin Strukus
///  Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Math
{

///Solves the quadratic polynomial
///                        a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter.
uint SolveQuadratic(real a0, real a1, real a2, real* roots);

///Solves the cubic polynomial 
///                 a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter.
uint SolveCubic(real a0, real a1, real a2, real a3, real* roots);

///Solves the quartic polynomial 
///             a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0 = 0
///returns the number of real roots found and stores the roots (if any) in the 
///last parameter.
uint SolveQuartic(real a0, real a1, real a2, real a3, real a4, real* roots);

///Evaluates the quadratic polynomial at the given x-value.
///                          a2 * x^2 + a1 * x + a0
real EvaluateQuadratic(real x, real a0, real a1, real a2);

///Evaluates the cubic polynomial at the given x-value.
///                    a3 * x^3 + a2 * x^2 + a1 * x + a0
real EvaluateCubic(real x, real a0, real a1, real a2, real a3);

///Evaluates the quartic polynomial at the given x-value.
///               a4 * x^4 + a3 * x^3 + a2 * x^2 + a1 * x + a0
real EvaluateQuartic(real x, real a0, real a1, real a2, real a3, real a4);

///Evaluates the polynomial at the given x-value.
///             a[count] * x^(count) + ... + a[1] * x + a[0]
real EvaluatePolynomial(real x, real* coefficients, uint coefficientCount);

///

}// namespace Math
///////////////////////////////////////////////////////////////////////////////
///
/// \file PlatformSelector.hpp
/// 
/// Authors: Trevor sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

// Detect the Windows platform
#if defined(_WIN32) || defined(WIN32)
  #define PLATFORM_WINDOWS
  #define PLATFORM_HARDWARE
// Detect all Apple platforms
#elif defined(__APPLE__)
  // This header contains defines that tell us the current platform
  #include <TargetConditionals.h>
  #if TARGET_IPHONE_SIMULATOR
    #define PLATFORM_IPHONE
    #define PLATFORM_VIRTUAL
  #elif TARGET_OS_IPHONE
    #define PLATFORM_IPHONE
    #define PLATFORM_HARDWARE
  #elif TARGET_OS_MAC
    #define PLATFORM_MAC
    #define PLATFORM_POSIX
    #define PLATFORM_HARDWARE
  #else
    #error "Unsupported platform"
  #endif

// Linux, which is a posix platform
#elif defined(__linux) || defined(__linux__)
  #define PLATFORM_LINUX
  #define PLATFORM_POSIX
  #define PLATFORM_HARDWARE

// Unix, which is a posix platform
#elif defined(__unix) || defined(__unix__)
  #define PLATFORM_UNIX
  #define PLATFORM_POSIX
  #define PLATFORM_HARDWARE

// Catch all for other posix compatable platforms
#elif defined(__posix)
  #define PLATFORM_POSIX
  #define PLATFORM_HARDWARE
#endif

// Detect compilers
#if defined(_MSC_VER)
  #define COMPILER_MICROSOFT
#elif defined(__clang__)
  #define COMPILER_CLANG
#elif defined(__GNUC__)
  #define COMPILER_GCC
#elif defined(__llvm__)
  #define COMPILER_LLVM
#endif
///////////////////////////////////////////////////////////////////////////////
///
/// \file DirectoryWatcher.hpp
/// 
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{
class Thread;
class Event;

class DirectoryWatcher
{
public:
  
  enum FileOperation
  {
    Added,
    Removed,
    Modified,
  };

  struct FileOperationInfo
  {
    FileOperation Operation;
    cstr FileName;
  };

  typedef OsInt (*CallbackFunction)(void* callbackInstance, FileOperationInfo& info);

  DirectoryWatcher(cstr directoryToWatch, CallbackFunction callback, void* callbackInstance);
  ~DirectoryWatcher();
  void Shutdown();

  template<typename classType, OsInt (classType::*MemberFunction)(FileOperationInfo& info)>
  static OsInt CallBackCreator(void* objectInstance, FileOperationInfo& info)
  {
    classType* object = (classType*)objectInstance;
    OsInt returnValue = (object->*MemberFunction)(info);
    return returnValue;
  }

private:
  // Note: The directory watcher currently has no private data
  // because it stores everything on the stack of its thread
  char mDirectoryToWatch[File::MaxPath];
  CallbackFunction mCallback;
  void* mCallbackInstance;
  OsInt RunThreadEntryPoint();
  Thread mWorkThread;
  OsEvent mCancelEvent;
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Thread.hpp
/// Declaration of the ExternalLibrary class.
/// 
/// Authors: Trevor Sundberg
/// Copyright 2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{
/// An externally loaded native library (example, a Windows .dll or *nix .so file)
class ExternalLibrary
{
public:
  ExternalLibrary();
  ~ExternalLibrary();

  // Is this a valid library or is it uninitialized?
  bool IsValid();

  // Loads a library in by file path
  void Load(cstr filePath);

  // Unload the library (safe to call more than once)
  void Unload();

  // Read a function out of the external library by name
  void* GetFunctionByName(cstr name);

private:
  OsHandle mHandle;
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file FileSystem.hpp
/// Declaration of the file system functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

DeclareEnum4(FileSystemErrors, 
  FileNotFound, 
  FileNotAccessible,
  FileNotWritable,
  FileLocked
);

extern const char  cDirectorySeparatorChar;
extern const char* cDirectorySeparatorCstr;

/// Intialize the file system
/// Some file systems have startup/shutdown steps that need to be taken.
void InitFileSystem();
void ShutdownFileSystem();

/// Copy a file.
bool CopyFile(StringRef dest, StringRef source);

/// Move a file. Must be folder to folder or file to file.
bool MoveFile(StringRef dest, StringRef source);

/// Delete a file.
bool DeleteFile(StringRef file);

/// Delete an entire directory
bool DeleteDirectory(StringRef directory);

/// Create a directory.
void CreateDirectory(StringRef dest);

/// Create a directory and any parent directories required
void CreateDirectoryAndParents(StringRef directory);

/// -1 Destination is older or does not exist.
///  0 Destination and source are the same.
///  1 Destination is newer.
int CheckFileTime(StringRef dest, StringRef source);

/// Is the dest file older than the source file?
inline bool DestinationIsOlder(StringRef dest, StringRef source)
{
  return CheckFileTime(dest, source) <= 0;
}

/// Update file time to current time.
int SetFileToCurrentTime(StringRef filename);

/// Get the file last modified time.
TimeType GetFileModifiedTime(StringRef filename);

/// Get Size of file zero if not found
u32 GetFileSize(StringRef fileName);

//Does the file exist?
bool FileExists(StringRef filePath);

//Is the file exist and is writable?
bool FileWritable(StringRef filePath);

//Does the directory exist?
bool DirectoryExists(StringRef directoryPath);

//Is this path a directory?
bool IsDirectory(StringRef directoryPath);

/// Special Paths

/// Get the current working directory for this process.
String GetWorkingDirectory();

/// Set the working directory for this process.
void SetWorkingDirectory(String path);

/// Directory for application cache and config files.
String GetUserLocalDirectory();

/// Directory for user modifiable configuration files.
String GetUserDocumentsDirectory();

/// Directory to the application.
String GetApplicationDirectory();

/// Full Path to the application.
String GetApplication();

/// Get directory for temporary files.
String GetTemporaryDirectory();

/// Get an id string for a file. String returned
/// will be unique for every file on the system.
String UniqueFileId(StringRef fullpath);

/// File range for iterating over files in a directory
class FileRange
{
public:
  
  //Path of directory to walk
  FileRange(StringRef path);
  ~FileRange();

  // Range interface
  bool empty();
  cstr front();
  void popFront();

private:
  ZeroDeclarePrivateData(FileRange, 500);
};

}
///////////////////////////////////////////////////////////////////////////////
///
/// \file FpControl.hpp
/// Declaration of the ScopeFpuExceptionsEnabler, ScopeFpuExceptionsDisabler
/// and FpuControlSystem classes.
///
/// Authors: Joshua Davis
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

/// Temporarily changes the fpu exceptions mask so that fpu exceptions
/// will happen. After the current scope of this block, the old
/// exceptions mask will be replaced. Use sparingly as changing the
/// mask is not a cheap operation.
struct ScopeFpuExceptionsEnabler
{
  ScopeFpuExceptionsEnabler();
  ~ScopeFpuExceptionsEnabler();

  unsigned int mOldState;
};

/// Temporarily disables all fpu exception masks. Used primarily
/// before calling out into external programs such as directX
/// or CG.
struct ScopeFpuExceptionsDisabler
{
  ScopeFpuExceptionsDisabler();
  ~ScopeFpuExceptionsDisabler();

  unsigned int mOldState;
};

/// System to store the mask and active flag for floating point exceptions.
struct FpuControlSystem
{
  static uint DefaultMask;
  static bool Active;
};

}//namespace Zero

#define ZFpExceptions 1

#ifdef ZFpExceptions

#define FpuExceptionsEnabler() \
  ScopeFpuExceptionsEnabler __LocalScopedFpuExceptionsEnabler;

#define FpuExceptionsDisabler() \
  ScopeFpuExceptionsDisabler __LocalScopedFpuExceptionsDisabler;

#ifdef _DEBUG
  #define FpuExceptionsEnablerDebug() \
    ScopeFpuExceptionsEnabler __LocalScopedFpuExceptionsEnabler;
#else
    #define FpuExceptionsEnablerDebug() do {} while (0)
#endif

#else

#define FpuExceptionsEnabler() do {} while (0)

#define FpuExceptionsDisabler() do {} while (0)

#define FpuExceptionsEnablerDebug() do {} while (0)

#endif
///////////////////////////////////////////////////////////////////////////////
///
/// \file Process.hpp
/// Declaration of the Process class and support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2012, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

#pragma once

namespace Zero
{

// Simple callback interface for process stdio
class TextStream
{
public:
  virtual void Write(cstr text)=0;
  virtual ~TextStream(){};
};

class TextStreamDebugPrint : public TextStream
{
  virtual void Write(cstr text)
  {
    ZPrintFilter(Filter::DefaultFilter, text);
  }
};

class TextStreamBuffer : public TextStream
{
public:
  StringBuilder buffer;
  String ToString(){return buffer.ToString();}
  void Write(cstr text) override { buffer.Append(text);}
};

class TextStreamNull : public TextStream
{
  void Write(cstr text) override {};
};

}

namespace Zero
{

//---------------------------------------------------------------------- Process
/// Process class used for managing external processes and redirecting their stdio.
/// Used to launch and monitor various external programs, compilers and tools.
class Process
{
public:
  Process();
  ~Process();
  
  // Begin execution of another process. All output from this process 
  // will be passed to the provided console. This call will return immediately.
  uint ExecProcess(cstr debugName, cstr commandLine, 
                   TextStream* stream = NULL, bool showWindow = false);

  // Write to the process std in.
  void WriteToStdIn(cstr text, int size);

  // Close the process handle this does not force the process to exit.
  void Shutdown();

  // Wait for the process to close.
  void WaitForClose();

  // Get the exit code for the process.
  int GetExitCode();

  // Terminate the process (unsafe)
  void Terminate();

private:
  OsInt ReadThreadEntryPoint();
  Thread mReadThread;
  OsEvent mCancelEvent;
  TextStream* mTextStream;
  char mDebugName[cDebugNameMax];
  ZeroDeclarePrivateData(Process, 32);
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file Resolution.hpp
/// Resolution support functions.
/// 
/// Authors: Chris Peters
/// Copyright 2010, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

struct Resolution
{
  Resolution()
    :Width(0), Height(0)
  {}

  Resolution(int w, int h)
    :Width(w), Height(h)
  {}

  bool SameAspect(const Resolution& other)const
  {
    return other.Width * Height == other.Height * Width;
  }

  bool operator==(const Resolution& other) const
  {
    return other.Width == Width &&  other.Height * Height;
  }

  bool operator<(const Resolution& other) const
  {
    if (Width < other.Width)
      return true;
    else
    {
      if (Height < other.Height)
        return true;
      else
        return false;
    }
  }

  String ToString() const
  {
    return String::Format("%d x %d", Width, Height);
  }

  size_t Hash() const
  {
    return Hash64to32Shift( *(u64*)this );
  }

  int Width;
  int Height;
};

const Resolution AspectAny(0,0);
const Resolution Aspect4by3(4,3);
const Resolution Aspect5by4(5,4);
const Resolution Aspect16by9(16,9);
const Resolution Aspect16by10(16,10);
const Resolution Aspects[5] = {AspectAny, Aspect4by3, Aspect5by4, Aspect16by9, Aspect16by10};

inline uint GetAspectIndex(Resolution& toTest)
{
  for(uint i=1;i<5;++i)
  {
    if(Aspects[i].SameAspect(toTest))
      return i;
  }
  return 0;
}

// Return the index of the first resolution that is greater than or
// equal to minWidth and minHeight. Return the first resolution to pass or the last in the list
inline int FindMinResolution(Array<Resolution>& resolutions, int minWidth, int minHeight)
{
  for(uint i=0;i<resolutions.size();++i)
  {
    Resolution r = resolutions[i];
    if(r.Width >= minWidth && r.Height >= minHeight)
      return (int)i;
  }
  return (int)(resolutions.size()-1);
}

/// Get the current resolution of the desktop.
Resolution GetDesktopResolution();

/// Enumerate all Resolutions valid for the display adapter with the given bit depth
/// and aspect ratio
/// bitDepth zero for any bit depth
/// resolution any resolution with the same aspect ratio (0,0) will return all.
void Enumerate(Array<Resolution>& resolutions, uint bitDepth, Resolution aspect);

}

///////////////////////////////////////////////////////////////////////////////
///
/// \file Timer.hpp
/// Declaration of the Os High precision Timer class.
/// 
/// Authors: Chris Peters
/// Copyright 2010-2011, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

/// High precision timer class.
class Timer
{
public:
  typedef unsigned long long TickType;
  //Constructor
  Timer();
  ~Timer();
  //Reset the Time to Zero
  void Reset();
  //Update the clock
  void Update();
  //Get the time from in  seconds from the last reset.
  double Time() const;
  //Gets the floating point time between the last update and the update before it.
  double TimeDelta() const;
  //Update and get time since last reset.
  double UpdateAndGetTime();  

  //Gets the floating point time from the last update.
  double TimeNoUpdate() const;
  //Get Tick time
  TickType GetTickTime() const;
  //Get the time in seconds from a tick count;
  double TicksToSeconds(TickType ticks) const;
private:
  ZeroDeclarePrivateData(Timer, 50);
};

}//namespace Zero
///////////////////////////////////////////////////////////////////////////////
///
/// \file CrashHandler.hpp
/// Declaration of the CrashHandler class.
///
/// Authors: Trevor Sundberg, Joshua Davis
/// Copyright 2010-2014, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////
#pragma once

namespace Zero
{

class Engine;

// For debugging, this is so the crash handler can be called within visual studio.
// This can't know about the engine though, so it has to take a callback that calls run on the engine...
typedef void (*RunEngineFunction)(void* engine);
void RunEngine(RunEngineFunction runFn, void* engine);

// Wraps parameters being passed to the crash handler.
// Maybe change this to some interface type?
class CrashHandlerParameters
{
public:
  void AddParameter(StringRange name, StringRange value);

  String GetParameterString();

private:
  StringBuilder mParameters;
};

// Denotes a memory range that is used to insert extra memory into a crash dump.
struct MemoryRange
{
  byte* Begin;
  size_t Length;
};

// Startup information needed by the crash handler to find certain files.
struct CrashInfo
{
  CrashInfo()
  {
    mDumpName = "ZeroDump.dmp";
    mLogName = "ZeroLog.txt";
    mStackName = "ZeroStack.txt";
    mModuleName = "ZeroEditor";
    mStripModules = false;
  }

  // The names of the files to open/send.
  // In zero these have a date/time-stamp which is set in the CrashStartCallback.
  String mDumpName;
  String mLogName;
  String mStackName;

  // Do we strip modules? If so we include ntdll and whatever is in mModuleName.
  // Make sure to set mModuleName to the name of your program if you set mStripModules to true!
  bool mStripModules;
  String mModuleName;
};

struct CrashHandler
{
  // Enable the crash handler to start catching hardware exceptions. When a crash happens,
  // mRunCrashHandlerCallback will be called to control all of the crash handler logic.
  static void Enable();

  typedef void (*RunCrashHandlerCallback)(void* crashData, bool doRescueCall, void* userData);
  // Called when a crash happens. This function controls all of the behavior of the crash handler,
  // including making the minidump and sending off the crash information.
  static void SetRunCrashHandlerCallback(RunCrashHandlerCallback callback, void* userData);

  typedef void (*CrashStartCallback)(CrashInfo&, void* userData);
  // The crash start callback is used primarily to get the dump/log/stack file name.
  // Any other initial setup for the crash handler can also be performed here.
  static void SetCrashStartCallback(CrashStartCallback callback, void* userData);

  typedef void (*PreMemoryDumpCallback)(void* userData);
  // Called before the memory dump is run. This allows for any setup before the CustomMemoryCallback is called.
  static void SetPreMemoryDumpCallback(PreMemoryDumpCallback callback, void* userData);

  typedef bool (*CustomMemoryCallback)(MemoryRange& memoryRange, void* userData);
  // Used to inject a range of memory manually into the crash dump.
  // This is a re-entrant call that will be continually called until false is returned.
  // Used currently to put zilch op-code into the dump for debugging.
  // Can be used for any bit of memory used to make debugging easier (Strings?).
  static void SetCustomMemoryCallback(CustomMemoryCallback callback, void* userData);

  typedef void (*LoggingCallback)(CrashHandlerParameters& params, CrashInfo& info, void* userData);
  // Perform any logging before the crash report is sent.
  // This may need to flush any log files as well as add the log file's name to the parameters.
  static void SetLoggingCallback(LoggingCallback callback, void* userData);

  typedef void (*SendCrashReportCallback)(CrashHandlerParameters& params, void* userData);
  // Send the crash report out somehow. The params should contain all
  // of the files/parameters to properly invoke the crash reporter.
  static void SetSendCrashReportCallback(SendCrashReportCallback callback, void* userData);

  typedef void (*FinalRescueCall)(void* userData);
  // The rescue call happens after the crash report is sent so we can attempt to
  // rescue any user settings/data (such as modified levels or files).
  static void SetupRescueCallback(FinalRescueCall rescueCall, void* userData);

  // These functions invoke the various callbacks while wrapping each
  // call in the platform specific __try __except exceptions handlers for safety.
  static void InvokeCrashStartCallback(CrashInfo& info);
  static void InvokePreMemoryDumpCallback();
  static void WriteMiniDump(CrashHandlerParameters& params, void* crashData, CrashInfo& info);
  static void InvokeWriteCallstack(CrashHandlerParameters& params, void* crashData, CrashInfo& info);
  static void InvokeLoggingCallback(CrashHandlerParameters& params, CrashInfo& info);
  static void InvokeRescueCallback();
  static void InvokeSendCrashReport(CrashHandlerParameters& params);

  // Used to signal that a fatal error has happened and send out a crash report.
  // No minidump will be generated as there was no hardware exception,
  // but stack and log information will be sent. Also doesn't invoke the rescue callback.
  static void FatalError(int errorCode);
  
  // The default logic for the crash handler.
  static void DefaultRunCrashHandlerCallback(void* crashData, bool doRescueCall, void* userData);
  static void SetRestartCommandLine(StringRange commandLine);
  static void RestartOnCrash(bool state);

  static RunCrashHandlerCallback mRunCrashHandlerCallback;
  static void* mRunCrashHandlerUserData;
  static CrashStartCallback mCrashStartCallback;
  static void* mCrashStartUserData;
  static PreMemoryDumpCallback mPreMemoryDumpCallback;
  static void* mPreMemoryDumpUserData;
  static CustomMemoryCallback mCustomMemoryCallback;
  static void* mCustomMemoryUserData;
  static LoggingCallback mLoggingCallback;
  static void* mLoggingUserData;
  static SendCrashReportCallback mSendCrashReportCallback;
  static void* mSendCrashReportUserData;
  static FinalRescueCall mRescueCallback;
  static void* mRescueUserData;

  // Do we auto restart the program instead of sending a crash report?
  static bool mAutoRestart;
  // The command line to use to restart ourself.
  static String mRestartCommandLine;
};

}//namespace Zero
